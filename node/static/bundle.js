/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _argon = __webpack_require__(1);

	var Argon = _interopRequireWildcard(_argon);

	var _three = __webpack_require__(5);

	var THREE = _interopRequireWildcard(_three);

	var _navigo = __webpack_require__(6);

	var _navigo2 = _interopRequireDefault(_navigo);

	var _index = __webpack_require__(7);

	var _CSS3DArgon = __webpack_require__(520);

	var _argon2 = __webpack_require__(521);

	var _utilities = __webpack_require__(189);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function main() {
	    // Used by the Navigo router library
	    var BASE_URL = 'http://alberta.livingarchives.dev';
	    // Application Router
	    var Router = new _navigo2.default(BASE_URL);

	    // Main state of our application (mutable)
	    var state = {
	        router: Router,
	        navigate: function navigate(path) {
	            return Router.navigate('' + window.location.origin + path, true);
	        },
	        documentRootNode: document.documentElement,
	        reactMountNode: document.getElementById('mount'),
	        argonMountNode: document.getElementById('argon'),
	        app: Argon.init(),
	        scene: new THREE.Scene(),
	        camera: new THREE.PerspectiveCamera(),
	        userLocation: new THREE.Object3D(),
	        renderer: new THREE.WebGLRenderer({
	            alpha: true,
	            logarithimDepthBuffer: true
	        }),
	        cssRenderer: new _CSS3DArgon.CSS3DArgonRenderer(),
	        hud: new _CSS3DArgon.CSS3DArgonHUD(),
	        locations: [],
	        prevRoute: '',
	        userPosition: {},
	        userData: {}
	    };

	    // Initialize basic argon setup
	    state = (0, _argon2.setupArgon)(state);
	    // Fetch location + user data and store it in the cache
	    (0, _utilities.setupLocationData)(state);
	    (0, _utilities.setupUserData)(state);

	    // Iterate through all routes and their urls,
	    // add a new route for each of these urls
	    _index.routes.forEach(function (r) {
	        r.urls.forEach(function (url) {
	            return Router.on(url, r.route(state), r.hooks(state));
	        });
	    });

	    // Resolve the current url
	    Router.resolve();
	}

	main();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, process) {!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!="function"&&__webpack_require__(3).resolve&&"undefined"!=typeof process&&__webpack_require__(3),I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

	(["1"], [], false, function($__System) {
	var _dereq_ = this.require, exports = this.exports, module = this.module;
	!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(u),t=(r[1].split(",")[n]||"require").replace(s,""),i=p[t]||(p[t]=new RegExp(a+t+f,"g"));i.lastIndex=0;for(var o,c=[];o=i.exec(e);)c.push(o[2]||o[3]);return c}function r(e,n,t,o){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var l=i.get(e);return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var a=[],f=0;f<e.length;f++)a.push(i["import"](e[f],o));Promise.all(a).then(function(e){n&&n.apply(null,e)},t)}function t(t,l,a){"string"!=typeof t&&(a=l,l=t,t=null),l instanceof Array||(a=l,l=["require","exports","module"].splice(0,a.length)),"function"!=typeof a&&(a=function(e){return function(){return e}}(a)),void 0===l[l.length-1]&&l.pop();var f,u,s;-1!=(f=o.call(l,"require"))&&(l.splice(f,1),t||(l=l.concat(n(a.toString(),f)))),-1!=(u=o.call(l,"exports"))&&l.splice(u,1),-1!=(s=o.call(l,"module"))&&l.splice(s,1);var p={name:t,deps:l,execute:function(n,t,o){for(var p=[],c=0;c<l.length;c++)p.push(n(l[c]));o.uri=o.id,o.config=function(){},-1!=s&&p.splice(s,0,o),-1!=u&&p.splice(u,0,t),-1!=f&&p.splice(f,0,function(e,t,l){return"string"==typeof e&&"function"!=typeof t?n(e):r.call(i,e,t,l,o.id)});var d=a.apply(-1==u?e:t,p);return"undefined"==typeof d&&o&&(d=o.exports),"undefined"!=typeof d?d:void 0}};if(t)c.anonDefine||c.isBundle?c.anonDefine&&c.anonDefine.name&&(c.anonDefine=null):c.anonDefine=p,c.isBundle=!0,i.registerDynamic(p.name,p.deps,!1,p.execute);else{if(c.anonDefine&&!c.anonDefine.name)throw new Error("Multiple anonymous defines in module "+t);c.anonDefine=p}}var i=$__System,o=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,a="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",u=/\(([^\)]*)\)/,s=/^\s+|\s+$/g,p={};t.amd={};var c={isBundle:!1,anonDefine:null};i.amdDefine=t,i.amdRequire=r}("undefined"!=typeof self?self:global);
	(function() {
	var define = $__System.amdDefine;
	define("2", ["exports", "3"], function(exports, _aureliaPal) {
	  'use strict';
	  Number.isNaN = Number.isNaN || function(value) {
	    return value !== value;
	  };
	  Number.isFinite = Number.isFinite || function(value) {
	    return typeof value === "number" && isFinite(value);
	  };
	  if (!String.prototype.endsWith) {
	    String.prototype.endsWith = function(searchString, position) {
	      var subjectString = this.toString();
	      if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
	        position = subjectString.length;
	      }
	      position -= searchString.length;
	      var lastIndex = subjectString.indexOf(searchString, position);
	      return lastIndex !== -1 && lastIndex === position;
	    };
	  }
	  if (!String.prototype.startsWith) {
	    String.prototype.startsWith = function(searchString, position) {
	      position = position || 0;
	      return this.substr(position, searchString.length) === searchString;
	    };
	  }
	  if (!Array.from) {
	    Array.from = (function() {
	      var toStr = Object.prototype.toString;
	      var isCallable = function isCallable(fn) {
	        return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
	      };
	      var toInteger = function toInteger(value) {
	        var number = Number(value);
	        if (isNaN(number)) {
	          return 0;
	        }
	        if (number === 0 || !isFinite(number)) {
	          return number;
	        }
	        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
	      };
	      var maxSafeInteger = Math.pow(2, 53) - 1;
	      var toLength = function toLength(value) {
	        var len = toInteger(value);
	        return Math.min(Math.max(len, 0), maxSafeInteger);
	      };
	      return function from(arrayLike) {
	        var C = this;
	        var items = Object(arrayLike);
	        if (arrayLike == null) {
	          throw new TypeError("Array.from requires an array-like object - not null or undefined");
	        }
	        var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
	        var T;
	        if (typeof mapFn !== 'undefined') {
	          if (!isCallable(mapFn)) {
	            throw new TypeError('Array.from: when provided, the second argument must be a function');
	          }
	          if (arguments.length > 2) {
	            T = arguments[2];
	          }
	        }
	        var len = toLength(items.length);
	        var A = isCallable(C) ? Object(new C(len)) : new Array(len);
	        var k = 0;
	        var kValue;
	        while (k < len) {
	          kValue = items[k];
	          if (mapFn) {
	            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
	          } else {
	            A[k] = kValue;
	          }
	          k += 1;
	        }
	        A.length = len;
	        return A;
	      };
	    })();
	  }
	  if (!Array.prototype.find) {
	    Array.prototype.find = function(predicate) {
	      if (this === null) {
	        throw new TypeError('Array.prototype.find called on null or undefined');
	      }
	      if (typeof predicate !== 'function') {
	        throw new TypeError('predicate must be a function');
	      }
	      var list = Object(this);
	      var length = list.length >>> 0;
	      var thisArg = arguments[1];
	      var value;
	      for (var i = 0; i < length; i++) {
	        value = list[i];
	        if (predicate.call(thisArg, value, i, list)) {
	          return value;
	        }
	      }
	      return undefined;
	    };
	  }
	  if (!Array.prototype.findIndex) {
	    Array.prototype.findIndex = function(predicate) {
	      if (this === null) {
	        throw new TypeError('Array.prototype.findIndex called on null or undefined');
	      }
	      if (typeof predicate !== 'function') {
	        throw new TypeError('predicate must be a function');
	      }
	      var list = Object(this);
	      var length = list.length >>> 0;
	      var thisArg = arguments[1];
	      var value;
	      for (var i = 0; i < length; i++) {
	        value = list[i];
	        if (predicate.call(thisArg, value, i, list)) {
	          return i;
	        }
	      }
	      return -1;
	    };
	  }
	  if (!Array.prototype.includes) {
	    Array.prototype.includes = function(searchElement) {
	      var O = Object(this);
	      var len = parseInt(O.length) || 0;
	      if (len === 0) {
	        return false;
	      }
	      var n = parseInt(arguments[1]) || 0;
	      var k;
	      if (n >= 0) {
	        k = n;
	      } else {
	        k = len + n;
	        if (k < 0) {
	          k = 0;
	        }
	      }
	      var currentElement;
	      while (k < len) {
	        currentElement = O[k];
	        if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
	          return true;
	        }
	        k++;
	      }
	      return false;
	    };
	  }
	  if (typeof Object.assign !== 'function') {
	    Object.assign = function(target) {
	      if (target === undefined || target === null) {
	        throw new TypeError('Cannot convert undefined or null to object');
	      }
	      var output = Object(target);
	      for (var index = 1; index < arguments.length; index++) {
	        var source = arguments[index];
	        if (source !== undefined && source !== null) {
	          for (var nextKey in source) {
	            if (source.hasOwnProperty(nextKey)) {
	              output[nextKey] = source[nextKey];
	            }
	          }
	        }
	      }
	      return output;
	    };
	  }
	  (function(global) {
	    var i = undefined;
	    var defineProperty = Object.defineProperty;
	    var is = function is(a, b) {
	      return a === b || a !== a && b !== b;
	    };
	    if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {
	      global.Map = createCollection({
	        'delete': sharedDelete,
	        has: mapHas,
	        get: sharedGet,
	        set: sharedSet,
	        keys: sharedKeys,
	        values: sharedValues,
	        entries: mapEntries,
	        forEach: sharedForEach,
	        clear: sharedClear
	      });
	    }
	    if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {
	      global.Set = createCollection({
	        has: setHas,
	        add: sharedAdd,
	        'delete': sharedDelete,
	        clear: sharedClear,
	        keys: sharedValues,
	        values: sharedValues,
	        entries: setEntries,
	        forEach: sharedForEach
	      });
	    }
	    function createCollection(proto, objectOnly) {
	      function Collection(a) {
	        if (!this || this.constructor !== Collection)
	          return new Collection(a);
	        this._keys = [];
	        this._values = [];
	        this._itp = [];
	        this.objectOnly = objectOnly;
	        if (a)
	          init.call(this, a);
	      }
	      if (!objectOnly) {
	        defineProperty(proto, 'size', {get: sharedSize});
	      }
	      proto.constructor = Collection;
	      Collection.prototype = proto;
	      return Collection;
	    }
	    function init(a) {
	      var i;
	      if (this.add)
	        a.forEach(this.add, this);
	      else
	        a.forEach(function(a) {
	          this.set(a[0], a[1]);
	        }, this);
	    }
	    function sharedDelete(key) {
	      if (this.has(key)) {
	        this._keys.splice(i, 1);
	        this._values.splice(i, 1);
	        this._itp.forEach(function(p) {
	          if (i < p[0])
	            p[0]--;
	        });
	      }
	      return -1 < i;
	    }
	    ;
	    function sharedGet(key) {
	      return this.has(key) ? this._values[i] : undefined;
	    }
	    function has(list, key) {
	      if (this.objectOnly && key !== Object(key))
	        throw new TypeError("Invalid value used as weak collection key");
	      if (key != key || key === 0)
	        for (i = list.length; i-- && !is(list[i], key); ) {}
	      else
	        i = list.indexOf(key);
	      return -1 < i;
	    }
	    function setHas(value) {
	      return has.call(this, this._values, value);
	    }
	    function mapHas(value) {
	      return has.call(this, this._keys, value);
	    }
	    function sharedSet(key, value) {
	      this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
	      return this;
	    }
	    function sharedAdd(value) {
	      if (!this.has(value))
	        this._values.push(value);
	      return this;
	    }
	    function sharedClear() {
	      (this._keys || 0).length = this._values.length = 0;
	    }
	    function sharedKeys() {
	      return sharedIterator(this._itp, this._keys);
	    }
	    function sharedValues() {
	      return sharedIterator(this._itp, this._values);
	    }
	    function mapEntries() {
	      return sharedIterator(this._itp, this._keys, this._values);
	    }
	    function setEntries() {
	      return sharedIterator(this._itp, this._values, this._values);
	    }
	    function sharedIterator(itp, array, array2) {
	      var p = [0],
	          done = false;
	      itp.push(p);
	      return {next: function next() {
	          var v,
	              k = p[0];
	          if (!done && k < array.length) {
	            v = array2 ? [array[k], array2[k]] : array[k];
	            p[0]++;
	          } else {
	            done = true;
	            itp.splice(itp.indexOf(p), 1);
	          }
	          return {
	            done: done,
	            value: v
	          };
	        }};
	    }
	    function sharedSize() {
	      return this._values.length;
	    }
	    function sharedForEach(callback, context) {
	      var it = this.entries();
	      for (; ; ) {
	        var r = it.next();
	        if (r.done)
	          break;
	        callback.call(context, r.value[1], r.value[0], this);
	      }
	    }
	  })(_aureliaPal.PLATFORM.global);
	  var emptyMetadata = Object.freeze({});
	  var metadataContainerKey = '__metadata__';
	  var bind = Function.prototype.bind;
	  if (typeof _aureliaPal.PLATFORM.global.Reflect === 'undefined') {
	    _aureliaPal.PLATFORM.global.Reflect = {};
	  }
	  if (typeof Reflect.getOwnMetadata !== 'function') {
	    Reflect.getOwnMetadata = function(metadataKey, target, targetKey) {
	      return ((target[metadataContainerKey] || emptyMetadata)[targetKey] || emptyMetadata)[metadataKey];
	    };
	  }
	  if (typeof Reflect.defineMetadata !== 'function') {
	    Reflect.defineMetadata = function(metadataKey, metadataValue, target, targetKey) {
	      var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};
	      var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});
	      targetContainer[metadataKey] = metadataValue;
	    };
	  }
	  if (typeof Reflect.metadata !== 'function') {
	    Reflect.metadata = function(metadataKey, metadataValue) {
	      return function(target, targetKey) {
	        Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
	      };
	    };
	  }
	  if (typeof Reflect.construct !== 'function') {
	    Reflect.construct = function(Target, args) {
	      if (args) {
	        switch (args.length) {
	          case 0:
	            return new Target();
	          case 1:
	            return new Target(args[0]);
	          case 2:
	            return new Target(args[0], args[1]);
	          case 3:
	            return new Target(args[0], args[1], args[2]);
	          case 4:
	            return new Target(args[0], args[1], args[2], args[3]);
	        }
	      }
	      var a = [null];
	      a.push.apply(a, args);
	      return new (bind.apply(Target, a))();
	    };
	  }
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	;
	(function(root) {
	  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	  var freeModule = typeof module == 'object' && module && !module.nodeType && module;
	  var freeGlobal = typeof global == 'object' && global;
	  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
	    root = freeGlobal;
	  }
	  var punycode,
	      maxInt = 2147483647,
	      base = 36,
	      tMin = 1,
	      tMax = 26,
	      skew = 38,
	      damp = 700,
	      initialBias = 72,
	      initialN = 128,
	      delimiter = '-',
	      regexPunycode = /^xn--/,
	      regexNonASCII = /[^\x20-\x7E]/,
	      regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	      errors = {
	        'overflow': 'Overflow: input needs wider integers to process',
	        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	        'invalid-input': 'Invalid input'
	      },
	      baseMinusTMin = base - tMin,
	      floor = Math.floor,
	      stringFromCharCode = String.fromCharCode,
	      key;
	  function error(type) {
	    throw new RangeError(errors[type]);
	  }
	  function map(array, fn) {
	    var length = array.length;
	    var result = [];
	    while (length--) {
	      result[length] = fn(array[length]);
	    }
	    return result;
	  }
	  function mapDomain(string, fn) {
	    var parts = string.split('@');
	    var result = '';
	    if (parts.length > 1) {
	      result = parts[0] + '@';
	      string = parts[1];
	    }
	    string = string.replace(regexSeparators, '\x2E');
	    var labels = string.split('.');
	    var encoded = map(labels, fn).join('.');
	    return result + encoded;
	  }
	  function ucs2decode(string) {
	    var output = [],
	        counter = 0,
	        length = string.length,
	        value,
	        extra;
	    while (counter < length) {
	      value = string.charCodeAt(counter++);
	      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	        extra = string.charCodeAt(counter++);
	        if ((extra & 0xFC00) == 0xDC00) {
	          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	        } else {
	          output.push(value);
	          counter--;
	        }
	      } else {
	        output.push(value);
	      }
	    }
	    return output;
	  }
	  function ucs2encode(array) {
	    return map(array, function(value) {
	      var output = '';
	      if (value > 0xFFFF) {
	        value -= 0x10000;
	        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
	        value = 0xDC00 | value & 0x3FF;
	      }
	      output += stringFromCharCode(value);
	      return output;
	    }).join('');
	  }
	  function basicToDigit(codePoint) {
	    if (codePoint - 48 < 10) {
	      return codePoint - 22;
	    }
	    if (codePoint - 65 < 26) {
	      return codePoint - 65;
	    }
	    if (codePoint - 97 < 26) {
	      return codePoint - 97;
	    }
	    return base;
	  }
	  function digitToBasic(digit, flag) {
	    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	  }
	  function adapt(delta, numPoints, firstTime) {
	    var k = 0;
	    delta = firstTime ? floor(delta / damp) : delta >> 1;
	    delta += floor(delta / numPoints);
	    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
	      delta = floor(delta / baseMinusTMin);
	    }
	    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	  }
	  function decode(input) {
	    var output = [],
	        inputLength = input.length,
	        out,
	        i = 0,
	        n = initialN,
	        bias = initialBias,
	        basic,
	        j,
	        index,
	        oldi,
	        w,
	        k,
	        digit,
	        t,
	        baseMinusT;
	    basic = input.lastIndexOf(delimiter);
	    if (basic < 0) {
	      basic = 0;
	    }
	    for (j = 0; j < basic; ++j) {
	      if (input.charCodeAt(j) >= 0x80) {
	        error('not-basic');
	      }
	      output.push(input.charCodeAt(j));
	    }
	    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
	      for (oldi = i, w = 1, k = base; ; k += base) {
	        if (index >= inputLength) {
	          error('invalid-input');
	        }
	        digit = basicToDigit(input.charCodeAt(index++));
	        if (digit >= base || digit > floor((maxInt - i) / w)) {
	          error('overflow');
	        }
	        i += digit * w;
	        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	        if (digit < t) {
	          break;
	        }
	        baseMinusT = base - t;
	        if (w > floor(maxInt / baseMinusT)) {
	          error('overflow');
	        }
	        w *= baseMinusT;
	      }
	      out = output.length + 1;
	      bias = adapt(i - oldi, out, oldi == 0);
	      if (floor(i / out) > maxInt - n) {
	        error('overflow');
	      }
	      n += floor(i / out);
	      i %= out;
	      output.splice(i++, 0, n);
	    }
	    return ucs2encode(output);
	  }
	  function encode(input) {
	    var n,
	        delta,
	        handledCPCount,
	        basicLength,
	        bias,
	        j,
	        m,
	        q,
	        k,
	        t,
	        currentValue,
	        output = [],
	        inputLength,
	        handledCPCountPlusOne,
	        baseMinusT,
	        qMinusT;
	    input = ucs2decode(input);
	    inputLength = input.length;
	    n = initialN;
	    delta = 0;
	    bias = initialBias;
	    for (j = 0; j < inputLength; ++j) {
	      currentValue = input[j];
	      if (currentValue < 0x80) {
	        output.push(stringFromCharCode(currentValue));
	      }
	    }
	    handledCPCount = basicLength = output.length;
	    if (basicLength) {
	      output.push(delimiter);
	    }
	    while (handledCPCount < inputLength) {
	      for (m = maxInt, j = 0; j < inputLength; ++j) {
	        currentValue = input[j];
	        if (currentValue >= n && currentValue < m) {
	          m = currentValue;
	        }
	      }
	      handledCPCountPlusOne = handledCPCount + 1;
	      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
	        error('overflow');
	      }
	      delta += (m - n) * handledCPCountPlusOne;
	      n = m;
	      for (j = 0; j < inputLength; ++j) {
	        currentValue = input[j];
	        if (currentValue < n && ++delta > maxInt) {
	          error('overflow');
	        }
	        if (currentValue == n) {
	          for (q = delta, k = base; ; k += base) {
	            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	            if (q < t) {
	              break;
	            }
	            qMinusT = q - t;
	            baseMinusT = base - t;
	            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
	            q = floor(qMinusT / baseMinusT);
	          }
	          output.push(stringFromCharCode(digitToBasic(q, 0)));
	          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	          delta = 0;
	          ++handledCPCount;
	        }
	      }
	      ++delta;
	      ++n;
	    }
	    return output.join('');
	  }
	  function toUnicode(input) {
	    return mapDomain(input, function(string) {
	      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	    });
	  }
	  function toASCII(input) {
	    return mapDomain(input, function(string) {
	      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	    });
	  }
	  punycode = {
	    'version': '1.3.2',
	    'ucs2': {
	      'decode': ucs2decode,
	      'encode': ucs2encode
	    },
	    'decode': decode,
	    'encode': encode,
	    'toASCII': toASCII,
	    'toUnicode': toUnicode
	  };
	  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
	    define("4", [], function() {
	      return punycode;
	    }) && define("punycode", ["4"], function(m) {
	      return m;
	    });
	  } else if (freeExports && freeModule) {
	    if (module.exports == freeExports) {
	      freeModule.exports = punycode;
	    } else {
	      for (key in punycode) {
	        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
	      }
	    }
	  } else {
	    root.punycode = punycode;
	  }
	}(this));

	})();
	(function() {
	var define = $__System.amdDefine;
	(function(root, factory) {
	  'use strict';
	  if (typeof exports === 'object') {
	    module.exports = factory();
	  } else if (typeof define === 'function' && define.amd) {
	    define("5", [], factory);
	  } else {
	    root.IPv6 = factory(root);
	  }
	}(this, function(root) {
	  'use strict';
	  var _IPv6 = root && root.IPv6;
	  function bestPresentation(address) {
	    var _address = address.toLowerCase();
	    var segments = _address.split(':');
	    var length = segments.length;
	    var total = 8;
	    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
	      segments.shift();
	      segments.shift();
	    } else if (segments[0] === '' && segments[1] === '') {
	      segments.shift();
	    } else if (segments[length - 1] === '' && segments[length - 2] === '') {
	      segments.pop();
	    }
	    length = segments.length;
	    if (segments[length - 1].indexOf('.') !== -1) {
	      total = 7;
	    }
	    var pos;
	    for (pos = 0; pos < length; pos++) {
	      if (segments[pos] === '') {
	        break;
	      }
	    }
	    if (pos < total) {
	      segments.splice(pos, 1, '0000');
	      while (segments.length < total) {
	        segments.splice(pos, 0, '0000');
	      }
	    }
	    var _segments;
	    for (var i = 0; i < total; i++) {
	      _segments = segments[i].split('');
	      for (var j = 0; j < 3; j++) {
	        if (_segments[0] === '0' && _segments.length > 1) {
	          _segments.splice(0, 1);
	        } else {
	          break;
	        }
	      }
	      segments[i] = _segments.join('');
	    }
	    var best = -1;
	    var _best = 0;
	    var _current = 0;
	    var current = -1;
	    var inzeroes = false;
	    for (i = 0; i < total; i++) {
	      if (inzeroes) {
	        if (segments[i] === '0') {
	          _current += 1;
	        } else {
	          inzeroes = false;
	          if (_current > _best) {
	            best = current;
	            _best = _current;
	          }
	        }
	      } else {
	        if (segments[i] === '0') {
	          inzeroes = true;
	          current = i;
	          _current = 1;
	        }
	      }
	    }
	    if (_current > _best) {
	      best = current;
	      _best = _current;
	    }
	    if (_best > 1) {
	      segments.splice(best, _best, '');
	    }
	    length = segments.length;
	    var result = '';
	    if (segments[0] === '') {
	      result = ':';
	    }
	    for (i = 0; i < length; i++) {
	      result += segments[i];
	      if (i === length - 1) {
	        break;
	      }
	      result += ':';
	    }
	    if (segments[length - 1] === '') {
	      result += ':';
	    }
	    return result;
	  }
	  function noConflict() {
	    if (root.IPv6 === this) {
	      root.IPv6 = _IPv6;
	    }
	    return this;
	  }
	  return {
	    best: bestPresentation,
	    noConflict: noConflict
	  };
	}));

	})();
	(function() {
	var define = $__System.amdDefine;
	(function(root, factory) {
	  'use strict';
	  if (typeof exports === 'object') {
	    module.exports = factory();
	  } else if (typeof define === 'function' && define.amd) {
	    define("6", [], factory);
	  } else {
	    root.SecondLevelDomains = factory(root);
	  }
	}(this, function(root) {
	  'use strict';
	  var _SecondLevelDomains = root && root.SecondLevelDomains;
	  var SLD = {
	    list: {
	      'ac': ' com gov mil net org ',
	      'ae': ' ac co gov mil name net org pro sch ',
	      'af': ' com edu gov net org ',
	      'al': ' com edu gov mil net org ',
	      'ao': ' co ed gv it og pb ',
	      'ar': ' com edu gob gov int mil net org tur ',
	      'at': ' ac co gv or ',
	      'au': ' asn com csiro edu gov id net org ',
	      'ba': ' co com edu gov mil net org rs unbi unmo unsa untz unze ',
	      'bb': ' biz co com edu gov info net org store tv ',
	      'bh': ' biz cc com edu gov info net org ',
	      'bn': ' com edu gov net org ',
	      'bo': ' com edu gob gov int mil net org tv ',
	      'br': ' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
	      'bs': ' com edu gov net org ',
	      'bz': ' du et om ov rg ',
	      'ca': ' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
	      'ck': ' biz co edu gen gov info net org ',
	      'cn': ' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
	      'co': ' com edu gov mil net nom org ',
	      'cr': ' ac c co ed fi go or sa ',
	      'cy': ' ac biz com ekloges gov ltd name net org parliament press pro tm ',
	      'do': ' art com edu gob gov mil net org sld web ',
	      'dz': ' art asso com edu gov net org pol ',
	      'ec': ' com edu fin gov info med mil net org pro ',
	      'eg': ' com edu eun gov mil name net org sci ',
	      'er': ' com edu gov ind mil net org rochest w ',
	      'es': ' com edu gob nom org ',
	      'et': ' biz com edu gov info name net org ',
	      'fj': ' ac biz com info mil name net org pro ',
	      'fk': ' ac co gov net nom org ',
	      'fr': ' asso com f gouv nom prd presse tm ',
	      'gg': ' co net org ',
	      'gh': ' com edu gov mil org ',
	      'gn': ' ac com gov net org ',
	      'gr': ' com edu gov mil net org ',
	      'gt': ' com edu gob ind mil net org ',
	      'gu': ' com edu gov net org ',
	      'hk': ' com edu gov idv net org ',
	      'hu': ' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
	      'id': ' ac co go mil net or sch web ',
	      'il': ' ac co gov idf k12 muni net org ',
	      'in': ' ac co edu ernet firm gen gov i ind mil net nic org res ',
	      'iq': ' com edu gov i mil net org ',
	      'ir': ' ac co dnssec gov i id net org sch ',
	      'it': ' edu gov ',
	      'je': ' co net org ',
	      'jo': ' com edu gov mil name net org sch ',
	      'jp': ' ac ad co ed go gr lg ne or ',
	      'ke': ' ac co go info me mobi ne or sc ',
	      'kh': ' com edu gov mil net org per ',
	      'ki': ' biz com de edu gov info mob net org tel ',
	      'km': ' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
	      'kn': ' edu gov net org ',
	      'kr': ' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
	      'kw': ' com edu gov net org ',
	      'ky': ' com edu gov net org ',
	      'kz': ' com edu gov mil net org ',
	      'lb': ' com edu gov net org ',
	      'lk': ' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
	      'lr': ' com edu gov net org ',
	      'lv': ' asn com conf edu gov id mil net org ',
	      'ly': ' com edu gov id med net org plc sch ',
	      'ma': ' ac co gov m net org press ',
	      'mc': ' asso tm ',
	      'me': ' ac co edu gov its net org priv ',
	      'mg': ' com edu gov mil nom org prd tm ',
	      'mk': ' com edu gov inf name net org pro ',
	      'ml': ' com edu gov net org presse ',
	      'mn': ' edu gov org ',
	      'mo': ' com edu gov net org ',
	      'mt': ' com edu gov net org ',
	      'mv': ' aero biz com coop edu gov info int mil museum name net org pro ',
	      'mw': ' ac co com coop edu gov int museum net org ',
	      'mx': ' com edu gob net org ',
	      'my': ' com edu gov mil name net org sch ',
	      'nf': ' arts com firm info net other per rec store web ',
	      'ng': ' biz com edu gov mil mobi name net org sch ',
	      'ni': ' ac co com edu gob mil net nom org ',
	      'np': ' com edu gov mil net org ',
	      'nr': ' biz com edu gov info net org ',
	      'om': ' ac biz co com edu gov med mil museum net org pro sch ',
	      'pe': ' com edu gob mil net nom org sld ',
	      'ph': ' com edu gov i mil net ngo org ',
	      'pk': ' biz com edu fam gob gok gon gop gos gov net org web ',
	      'pl': ' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
	      'pr': ' ac biz com edu est gov info isla name net org pro prof ',
	      'ps': ' com edu gov net org plo sec ',
	      'pw': ' belau co ed go ne or ',
	      'ro': ' arts com firm info nom nt org rec store tm www ',
	      'rs': ' ac co edu gov in org ',
	      'sb': ' com edu gov net org ',
	      'sc': ' com edu gov net org ',
	      'sh': ' co com edu gov net nom org ',
	      'sl': ' com edu gov net org ',
	      'st': ' co com consulado edu embaixada gov mil net org principe saotome store ',
	      'sv': ' com edu gob org red ',
	      'sz': ' ac co org ',
	      'tr': ' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
	      'tt': ' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
	      'tw': ' club com ebiz edu game gov idv mil net org ',
	      'mu': ' ac co com gov net or org ',
	      'mz': ' ac co edu gov org ',
	      'na': ' co com ',
	      'nz': ' ac co cri geek gen govt health iwi maori mil net org parliament school ',
	      'pa': ' abo ac com edu gob ing med net nom org sld ',
	      'pt': ' com edu gov int net nome org publ ',
	      'py': ' com edu gov mil net org ',
	      'qa': ' com edu gov mil net org ',
	      're': ' asso com nom ',
	      'ru': ' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
	      'rw': ' ac co com edu gouv gov int mil net ',
	      'sa': ' com edu gov med net org pub sch ',
	      'sd': ' com edu gov info med net org tv ',
	      'se': ' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
	      'sg': ' com edu gov idn net org per ',
	      'sn': ' art com edu gouv org perso univ ',
	      'sy': ' com edu gov mil net news org ',
	      'th': ' ac co go in mi net or ',
	      'tj': ' ac biz co com edu go gov info int mil name net nic org test web ',
	      'tn': ' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
	      'tz': ' ac co go ne or ',
	      'ua': ' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
	      'ug': ' ac co go ne or org sc ',
	      'uk': ' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
	      'us': ' dni fed isa kids nsn ',
	      'uy': ' com edu gub mil net org ',
	      've': ' co com edu gob info mil net org web ',
	      'vi': ' co com k12 net org ',
	      'vn': ' ac biz com edu gov health info int name net org pro ',
	      'ye': ' co com gov ltd me net org plc ',
	      'yu': ' ac co edu gov org ',
	      'za': ' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
	      'zm': ' ac co com edu gov net org sch '
	    },
	    has: function(domain) {
	      var tldOffset = domain.lastIndexOf('.');
	      if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
	        return false;
	      }
	      var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
	      if (sldOffset <= 0 || sldOffset >= (tldOffset - 1)) {
	        return false;
	      }
	      var sldList = SLD.list[domain.slice(tldOffset + 1)];
	      if (!sldList) {
	        return false;
	      }
	      return sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') >= 0;
	    },
	    is: function(domain) {
	      var tldOffset = domain.lastIndexOf('.');
	      if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
	        return false;
	      }
	      var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
	      if (sldOffset >= 0) {
	        return false;
	      }
	      var sldList = SLD.list[domain.slice(tldOffset + 1)];
	      if (!sldList) {
	        return false;
	      }
	      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
	    },
	    get: function(domain) {
	      var tldOffset = domain.lastIndexOf('.');
	      if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
	        return null;
	      }
	      var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
	      if (sldOffset <= 0 || sldOffset >= (tldOffset - 1)) {
	        return null;
	      }
	      var sldList = SLD.list[domain.slice(tldOffset + 1)];
	      if (!sldList) {
	        return null;
	      }
	      if (sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') < 0) {
	        return null;
	      }
	      return domain.slice(sldOffset + 1);
	    },
	    noConflict: function() {
	      if (root.SecondLevelDomains === this) {
	        root.SecondLevelDomains = _SecondLevelDomains;
	      }
	      return this;
	    }
	  };
	  return SLD;
	}));

	})();
	(function() {
	var define = $__System.amdDefine;
	(function(root, factory) {
	  'use strict';
	  if (typeof exports === 'object') {
	    module.exports = factory(_dereq_('./punycode'), _dereq_('./IPv6'), _dereq_('./SecondLevelDomains'));
	  } else if (typeof define === 'function' && define.amd) {
	    define("7", ["4", "5", "6"], factory);
	  } else {
	    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
	  }
	}(this, function(punycode, IPv6, SLD, root) {
	  'use strict';
	  var _URI = root && root.URI;
	  function URI(url, base) {
	    var _urlSupplied = arguments.length >= 1;
	    var _baseSupplied = arguments.length >= 2;
	    if (!(this instanceof URI)) {
	      if (_urlSupplied) {
	        if (_baseSupplied) {
	          return new URI(url, base);
	        }
	        return new URI(url);
	      }
	      return new URI();
	    }
	    if (url === undefined) {
	      if (_urlSupplied) {
	        throw new TypeError('undefined is not a valid argument for URI');
	      }
	      if (typeof location !== 'undefined') {
	        url = location.href + '';
	      } else {
	        url = '';
	      }
	    }
	    this.href(url);
	    if (base !== undefined) {
	      return this.absoluteTo(base);
	    }
	    return this;
	  }
	  URI.version = '1.18.1';
	  var p = URI.prototype;
	  var hasOwn = Object.prototype.hasOwnProperty;
	  function escapeRegEx(string) {
	    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
	  }
	  function getType(value) {
	    if (value === undefined) {
	      return 'Undefined';
	    }
	    return String(Object.prototype.toString.call(value)).slice(8, -1);
	  }
	  function isArray(obj) {
	    return getType(obj) === 'Array';
	  }
	  function filterArrayValues(data, value) {
	    var lookup = {};
	    var i,
	        length;
	    if (getType(value) === 'RegExp') {
	      lookup = null;
	    } else if (isArray(value)) {
	      for (i = 0, length = value.length; i < length; i++) {
	        lookup[value[i]] = true;
	      }
	    } else {
	      lookup[value] = true;
	    }
	    for (i = 0, length = data.length; i < length; i++) {
	      var _match = lookup && lookup[data[i]] !== undefined || !lookup && value.test(data[i]);
	      if (_match) {
	        data.splice(i, 1);
	        length--;
	        i--;
	      }
	    }
	    return data;
	  }
	  function arrayContains(list, value) {
	    var i,
	        length;
	    if (isArray(value)) {
	      for (i = 0, length = value.length; i < length; i++) {
	        if (!arrayContains(list, value[i])) {
	          return false;
	        }
	      }
	      return true;
	    }
	    var _type = getType(value);
	    for (i = 0, length = list.length; i < length; i++) {
	      if (_type === 'RegExp') {
	        if (typeof list[i] === 'string' && list[i].match(value)) {
	          return true;
	        }
	      } else if (list[i] === value) {
	        return true;
	      }
	    }
	    return false;
	  }
	  function arraysEqual(one, two) {
	    if (!isArray(one) || !isArray(two)) {
	      return false;
	    }
	    if (one.length !== two.length) {
	      return false;
	    }
	    one.sort();
	    two.sort();
	    for (var i = 0,
	        l = one.length; i < l; i++) {
	      if (one[i] !== two[i]) {
	        return false;
	      }
	    }
	    return true;
	  }
	  function trimSlashes(text) {
	    var trim_expression = /^\/+|\/+$/g;
	    return text.replace(trim_expression, '');
	  }
	  URI._parts = function() {
	    return {
	      protocol: null,
	      username: null,
	      password: null,
	      hostname: null,
	      urn: null,
	      port: null,
	      path: null,
	      query: null,
	      fragment: null,
	      duplicateQueryParameters: URI.duplicateQueryParameters,
	      escapeQuerySpace: URI.escapeQuerySpace
	    };
	  };
	  URI.duplicateQueryParameters = false;
	  URI.escapeQuerySpace = true;
	  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
	  URI.idn_expression = /[^a-z0-9\.-]/i;
	  URI.punycode_expression = /(xn--)/i;
	  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
	  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
	  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
	  URI.findUri = {
	    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
	    end: /[\s\r\n]|$/,
	    trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/
	  };
	  URI.defaultPorts = {
	    http: '80',
	    https: '443',
	    ftp: '21',
	    gopher: '70',
	    ws: '80',
	    wss: '443'
	  };
	  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
	  URI.domAttributes = {
	    'a': 'href',
	    'blockquote': 'cite',
	    'link': 'href',
	    'base': 'href',
	    'script': 'src',
	    'form': 'action',
	    'img': 'src',
	    'area': 'href',
	    'iframe': 'src',
	    'embed': 'src',
	    'source': 'src',
	    'track': 'src',
	    'input': 'src',
	    'audio': 'src',
	    'video': 'src'
	  };
	  URI.getDomAttribute = function(node) {
	    if (!node || !node.nodeName) {
	      return undefined;
	    }
	    var nodeName = node.nodeName.toLowerCase();
	    if (nodeName === 'input' && node.type !== 'image') {
	      return undefined;
	    }
	    return URI.domAttributes[nodeName];
	  };
	  function escapeForDumbFirefox36(value) {
	    return escape(value);
	  }
	  function strictEncodeURIComponent(string) {
	    return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, '%2A');
	  }
	  URI.encode = strictEncodeURIComponent;
	  URI.decode = decodeURIComponent;
	  URI.iso8859 = function() {
	    URI.encode = escape;
	    URI.decode = unescape;
	  };
	  URI.unicode = function() {
	    URI.encode = strictEncodeURIComponent;
	    URI.decode = decodeURIComponent;
	  };
	  URI.characters = {
	    pathname: {
	      encode: {
	        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
	        map: {
	          '%24': '$',
	          '%26': '&',
	          '%2B': '+',
	          '%2C': ',',
	          '%3B': ';',
	          '%3D': '=',
	          '%3A': ':',
	          '%40': '@'
	        }
	      },
	      decode: {
	        expression: /[\/\?#]/g,
	        map: {
	          '/': '%2F',
	          '?': '%3F',
	          '#': '%23'
	        }
	      }
	    },
	    reserved: {encode: {
	        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
	        map: {
	          '%3A': ':',
	          '%2F': '/',
	          '%3F': '?',
	          '%23': '#',
	          '%5B': '[',
	          '%5D': ']',
	          '%40': '@',
	          '%21': '!',
	          '%24': '$',
	          '%26': '&',
	          '%27': '\'',
	          '%28': '(',
	          '%29': ')',
	          '%2A': '*',
	          '%2B': '+',
	          '%2C': ',',
	          '%3B': ';',
	          '%3D': '='
	        }
	      }},
	    urnpath: {
	      encode: {
	        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
	        map: {
	          '%21': '!',
	          '%24': '$',
	          '%27': '\'',
	          '%28': '(',
	          '%29': ')',
	          '%2A': '*',
	          '%2B': '+',
	          '%2C': ',',
	          '%3B': ';',
	          '%3D': '=',
	          '%40': '@'
	        }
	      },
	      decode: {
	        expression: /[\/\?#:]/g,
	        map: {
	          '/': '%2F',
	          '?': '%3F',
	          '#': '%23',
	          ':': '%3A'
	        }
	      }
	    }
	  };
	  URI.encodeQuery = function(string, escapeQuerySpace) {
	    var escaped = URI.encode(string + '');
	    if (escapeQuerySpace === undefined) {
	      escapeQuerySpace = URI.escapeQuerySpace;
	    }
	    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
	  };
	  URI.decodeQuery = function(string, escapeQuerySpace) {
	    string += '';
	    if (escapeQuerySpace === undefined) {
	      escapeQuerySpace = URI.escapeQuerySpace;
	    }
	    try {
	      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
	    } catch (e) {
	      return string;
	    }
	  };
	  var _parts = {
	    'encode': 'encode',
	    'decode': 'decode'
	  };
	  var _part;
	  var generateAccessor = function(_group, _part) {
	    return function(string) {
	      try {
	        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
	          return URI.characters[_group][_part].map[c];
	        });
	      } catch (e) {
	        return string;
	      }
	    };
	  };
	  for (_part in _parts) {
	    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
	    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
	  }
	  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
	    return function(string) {
	      var actualCodingFunc;
	      if (!_innerCodingFuncName) {
	        actualCodingFunc = URI[_codingFuncName];
	      } else {
	        actualCodingFunc = function(string) {
	          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
	        };
	      }
	      var segments = (string + '').split(_sep);
	      for (var i = 0,
	          length = segments.length; i < length; i++) {
	        segments[i] = actualCodingFunc(segments[i]);
	      }
	      return segments.join(_sep);
	    };
	  };
	  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
	  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
	  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
	  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');
	  URI.encodeReserved = generateAccessor('reserved', 'encode');
	  URI.parse = function(string, parts) {
	    var pos;
	    if (!parts) {
	      parts = {};
	    }
	    pos = string.indexOf('#');
	    if (pos > -1) {
	      parts.fragment = string.substring(pos + 1) || null;
	      string = string.substring(0, pos);
	    }
	    pos = string.indexOf('?');
	    if (pos > -1) {
	      parts.query = string.substring(pos + 1) || null;
	      string = string.substring(0, pos);
	    }
	    if (string.substring(0, 2) === '//') {
	      parts.protocol = null;
	      string = string.substring(2);
	      string = URI.parseAuthority(string, parts);
	    } else {
	      pos = string.indexOf(':');
	      if (pos > -1) {
	        parts.protocol = string.substring(0, pos) || null;
	        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
	          parts.protocol = undefined;
	        } else if (string.substring(pos + 1, pos + 3) === '//') {
	          string = string.substring(pos + 3);
	          string = URI.parseAuthority(string, parts);
	        } else {
	          string = string.substring(pos + 1);
	          parts.urn = true;
	        }
	      }
	    }
	    parts.path = string;
	    return parts;
	  };
	  URI.parseHost = function(string, parts) {
	    string = string.replace(/\\/g, '/');
	    var pos = string.indexOf('/');
	    var bracketPos;
	    var t;
	    if (pos === -1) {
	      pos = string.length;
	    }
	    if (string.charAt(0) === '[') {
	      bracketPos = string.indexOf(']');
	      parts.hostname = string.substring(1, bracketPos) || null;
	      parts.port = string.substring(bracketPos + 2, pos) || null;
	      if (parts.port === '/') {
	        parts.port = null;
	      }
	    } else {
	      var firstColon = string.indexOf(':');
	      var firstSlash = string.indexOf('/');
	      var nextColon = string.indexOf(':', firstColon + 1);
	      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
	        parts.hostname = string.substring(0, pos) || null;
	        parts.port = null;
	      } else {
	        t = string.substring(0, pos).split(':');
	        parts.hostname = t[0] || null;
	        parts.port = t[1] || null;
	      }
	    }
	    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
	      pos++;
	      string = '/' + string;
	    }
	    return string.substring(pos) || '/';
	  };
	  URI.parseAuthority = function(string, parts) {
	    string = URI.parseUserinfo(string, parts);
	    return URI.parseHost(string, parts);
	  };
	  URI.parseUserinfo = function(string, parts) {
	    var firstSlash = string.indexOf('/');
	    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
	    var t;
	    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
	      t = string.substring(0, pos).split(':');
	      parts.username = t[0] ? URI.decode(t[0]) : null;
	      t.shift();
	      parts.password = t[0] ? URI.decode(t.join(':')) : null;
	      string = string.substring(pos + 1);
	    } else {
	      parts.username = null;
	      parts.password = null;
	    }
	    return string;
	  };
	  URI.parseQuery = function(string, escapeQuerySpace) {
	    if (!string) {
	      return {};
	    }
	    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');
	    if (!string) {
	      return {};
	    }
	    var items = {};
	    var splits = string.split('&');
	    var length = splits.length;
	    var v,
	        name,
	        value;
	    for (var i = 0; i < length; i++) {
	      v = splits[i].split('=');
	      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
	      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;
	      if (hasOwn.call(items, name)) {
	        if (typeof items[name] === 'string' || items[name] === null) {
	          items[name] = [items[name]];
	        }
	        items[name].push(value);
	      } else {
	        items[name] = value;
	      }
	    }
	    return items;
	  };
	  URI.build = function(parts) {
	    var t = '';
	    if (parts.protocol) {
	      t += parts.protocol + ':';
	    }
	    if (!parts.urn && (t || parts.hostname)) {
	      t += '//';
	    }
	    t += (URI.buildAuthority(parts) || '');
	    if (typeof parts.path === 'string') {
	      if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
	        t += '/';
	      }
	      t += parts.path;
	    }
	    if (typeof parts.query === 'string' && parts.query) {
	      t += '?' + parts.query;
	    }
	    if (typeof parts.fragment === 'string' && parts.fragment) {
	      t += '#' + parts.fragment;
	    }
	    return t;
	  };
	  URI.buildHost = function(parts) {
	    var t = '';
	    if (!parts.hostname) {
	      return '';
	    } else if (URI.ip6_expression.test(parts.hostname)) {
	      t += '[' + parts.hostname + ']';
	    } else {
	      t += parts.hostname;
	    }
	    if (parts.port) {
	      t += ':' + parts.port;
	    }
	    return t;
	  };
	  URI.buildAuthority = function(parts) {
	    return URI.buildUserinfo(parts) + URI.buildHost(parts);
	  };
	  URI.buildUserinfo = function(parts) {
	    var t = '';
	    if (parts.username) {
	      t += URI.encode(parts.username);
	    }
	    if (parts.password) {
	      t += ':' + URI.encode(parts.password);
	    }
	    if (t) {
	      t += '@';
	    }
	    return t;
	  };
	  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
	    var t = '';
	    var unique,
	        key,
	        i,
	        length;
	    for (key in data) {
	      if (hasOwn.call(data, key) && key) {
	        if (isArray(data[key])) {
	          unique = {};
	          for (i = 0, length = data[key].length; i < length; i++) {
	            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
	              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
	              if (duplicateQueryParameters !== true) {
	                unique[data[key][i] + ''] = true;
	              }
	            }
	          }
	        } else if (data[key] !== undefined) {
	          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
	        }
	      }
	    }
	    return t.substring(1);
	  };
	  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
	    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
	  };
	  URI.addQuery = function(data, name, value) {
	    if (typeof name === 'object') {
	      for (var key in name) {
	        if (hasOwn.call(name, key)) {
	          URI.addQuery(data, key, name[key]);
	        }
	      }
	    } else if (typeof name === 'string') {
	      if (data[name] === undefined) {
	        data[name] = value;
	        return;
	      } else if (typeof data[name] === 'string') {
	        data[name] = [data[name]];
	      }
	      if (!isArray(value)) {
	        value = [value];
	      }
	      data[name] = (data[name] || []).concat(value);
	    } else {
	      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
	    }
	  };
	  URI.removeQuery = function(data, name, value) {
	    var i,
	        length,
	        key;
	    if (isArray(name)) {
	      for (i = 0, length = name.length; i < length; i++) {
	        data[name[i]] = undefined;
	      }
	    } else if (getType(name) === 'RegExp') {
	      for (key in data) {
	        if (name.test(key)) {
	          data[key] = undefined;
	        }
	      }
	    } else if (typeof name === 'object') {
	      for (key in name) {
	        if (hasOwn.call(name, key)) {
	          URI.removeQuery(data, key, name[key]);
	        }
	      }
	    } else if (typeof name === 'string') {
	      if (value !== undefined) {
	        if (getType(value) === 'RegExp') {
	          if (!isArray(data[name]) && value.test(data[name])) {
	            data[name] = undefined;
	          } else {
	            data[name] = filterArrayValues(data[name], value);
	          }
	        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
	          data[name] = undefined;
	        } else if (isArray(data[name])) {
	          data[name] = filterArrayValues(data[name], value);
	        }
	      } else {
	        data[name] = undefined;
	      }
	    } else {
	      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
	    }
	  };
	  URI.hasQuery = function(data, name, value, withinArray) {
	    switch (getType(name)) {
	      case 'String':
	        break;
	      case 'RegExp':
	        for (var key in data) {
	          if (hasOwn.call(data, key)) {
	            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
	              return true;
	            }
	          }
	        }
	        return false;
	      case 'Object':
	        for (var _key in name) {
	          if (hasOwn.call(name, _key)) {
	            if (!URI.hasQuery(data, _key, name[_key])) {
	              return false;
	            }
	          }
	        }
	        return true;
	      default:
	        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');
	    }
	    switch (getType(value)) {
	      case 'Undefined':
	        return name in data;
	      case 'Boolean':
	        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
	        return value === _booly;
	      case 'Function':
	        return !!value(data[name], name, data);
	      case 'Array':
	        if (!isArray(data[name])) {
	          return false;
	        }
	        var op = withinArray ? arrayContains : arraysEqual;
	        return op(data[name], value);
	      case 'RegExp':
	        if (!isArray(data[name])) {
	          return Boolean(data[name] && data[name].match(value));
	        }
	        if (!withinArray) {
	          return false;
	        }
	        return arrayContains(data[name], value);
	      case 'Number':
	        value = String(value);
	      case 'String':
	        if (!isArray(data[name])) {
	          return data[name] === value;
	        }
	        if (!withinArray) {
	          return false;
	        }
	        return arrayContains(data[name], value);
	      default:
	        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
	    }
	  };
	  URI.joinPaths = function() {
	    var input = [];
	    var segments = [];
	    var nonEmptySegments = 0;
	    for (var i = 0; i < arguments.length; i++) {
	      var url = new URI(arguments[i]);
	      input.push(url);
	      var _segments = url.segment();
	      for (var s = 0; s < _segments.length; s++) {
	        if (typeof _segments[s] === 'string') {
	          segments.push(_segments[s]);
	        }
	        if (_segments[s]) {
	          nonEmptySegments++;
	        }
	      }
	    }
	    if (!segments.length || !nonEmptySegments) {
	      return new URI('');
	    }
	    var uri = new URI('').segment(segments);
	    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {
	      uri.path('/' + uri.path());
	    }
	    return uri.normalize();
	  };
	  URI.commonPath = function(one, two) {
	    var length = Math.min(one.length, two.length);
	    var pos;
	    for (pos = 0; pos < length; pos++) {
	      if (one.charAt(pos) !== two.charAt(pos)) {
	        pos--;
	        break;
	      }
	    }
	    if (pos < 1) {
	      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
	    }
	    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
	      pos = one.substring(0, pos).lastIndexOf('/');
	    }
	    return one.substring(0, pos + 1);
	  };
	  URI.withinString = function(string, callback, options) {
	    options || (options = {});
	    var _start = options.start || URI.findUri.start;
	    var _end = options.end || URI.findUri.end;
	    var _trim = options.trim || URI.findUri.trim;
	    var _attributeOpen = /[a-z0-9-]=["']?$/i;
	    _start.lastIndex = 0;
	    while (true) {
	      var match = _start.exec(string);
	      if (!match) {
	        break;
	      }
	      var start = match.index;
	      if (options.ignoreHtml) {
	        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
	        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
	          continue;
	        }
	      }
	      var end = start + string.slice(start).search(_end);
	      var slice = string.slice(start, end).replace(_trim, '');
	      if (options.ignore && options.ignore.test(slice)) {
	        continue;
	      }
	      end = start + slice.length;
	      var result = callback(slice, start, end, string);
	      string = string.slice(0, start) + result + string.slice(end);
	      _start.lastIndex = start + result.length;
	    }
	    _start.lastIndex = 0;
	    return string;
	  };
	  URI.ensureValidHostname = function(v) {
	    if (v.match(URI.invalid_hostname_characters)) {
	      if (!punycode) {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
	      }
	      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
	      }
	    }
	  };
	  URI.noConflict = function(removeAll) {
	    if (removeAll) {
	      var unconflicted = {URI: this.noConflict()};
	      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
	        unconflicted.URITemplate = root.URITemplate.noConflict();
	      }
	      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
	        unconflicted.IPv6 = root.IPv6.noConflict();
	      }
	      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
	        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
	      }
	      return unconflicted;
	    } else if (root.URI === this) {
	      root.URI = _URI;
	    }
	    return this;
	  };
	  p.build = function(deferBuild) {
	    if (deferBuild === true) {
	      this._deferred_build = true;
	    } else if (deferBuild === undefined || this._deferred_build) {
	      this._string = URI.build(this._parts);
	      this._deferred_build = false;
	    }
	    return this;
	  };
	  p.clone = function() {
	    return new URI(this);
	  };
	  p.valueOf = p.toString = function() {
	    return this.build(false)._string;
	  };
	  function generateSimpleAccessor(_part) {
	    return function(v, build) {
	      if (v === undefined) {
	        return this._parts[_part] || '';
	      } else {
	        this._parts[_part] = v || null;
	        this.build(!build);
	        return this;
	      }
	    };
	  }
	  function generatePrefixAccessor(_part, _key) {
	    return function(v, build) {
	      if (v === undefined) {
	        return this._parts[_part] || '';
	      } else {
	        if (v !== null) {
	          v = v + '';
	          if (v.charAt(0) === _key) {
	            v = v.substring(1);
	          }
	        }
	        this._parts[_part] = v;
	        this.build(!build);
	        return this;
	      }
	    };
	  }
	  p.protocol = generateSimpleAccessor('protocol');
	  p.username = generateSimpleAccessor('username');
	  p.password = generateSimpleAccessor('password');
	  p.hostname = generateSimpleAccessor('hostname');
	  p.port = generateSimpleAccessor('port');
	  p.query = generatePrefixAccessor('query', '?');
	  p.fragment = generatePrefixAccessor('fragment', '#');
	  p.search = function(v, build) {
	    var t = this.query(v, build);
	    return typeof t === 'string' && t.length ? ('?' + t) : t;
	  };
	  p.hash = function(v, build) {
	    var t = this.fragment(v, build);
	    return typeof t === 'string' && t.length ? ('#' + t) : t;
	  };
	  p.pathname = function(v, build) {
	    if (v === undefined || v === true) {
	      var res = this._parts.path || (this._parts.hostname ? '/' : '');
	      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
	    } else {
	      if (this._parts.urn) {
	        this._parts.path = v ? URI.recodeUrnPath(v) : '';
	      } else {
	        this._parts.path = v ? URI.recodePath(v) : '/';
	      }
	      this.build(!build);
	      return this;
	    }
	  };
	  p.path = p.pathname;
	  p.href = function(href, build) {
	    var key;
	    if (href === undefined) {
	      return this.toString();
	    }
	    this._string = '';
	    this._parts = URI._parts();
	    var _URI = href instanceof URI;
	    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
	    if (href.nodeName) {
	      var attribute = URI.getDomAttribute(href);
	      href = href[attribute] || '';
	      _object = false;
	    }
	    if (!_URI && _object && href.pathname !== undefined) {
	      href = href.toString();
	    }
	    if (typeof href === 'string' || href instanceof String) {
	      this._parts = URI.parse(String(href), this._parts);
	    } else if (_URI || _object) {
	      var src = _URI ? href._parts : href;
	      for (key in src) {
	        if (hasOwn.call(this._parts, key)) {
	          this._parts[key] = src[key];
	        }
	      }
	    } else {
	      throw new TypeError('invalid input');
	    }
	    this.build(!build);
	    return this;
	  };
	  p.is = function(what) {
	    var ip = false;
	    var ip4 = false;
	    var ip6 = false;
	    var name = false;
	    var sld = false;
	    var idn = false;
	    var punycode = false;
	    var relative = !this._parts.urn;
	    if (this._parts.hostname) {
	      relative = false;
	      ip4 = URI.ip4_expression.test(this._parts.hostname);
	      ip6 = URI.ip6_expression.test(this._parts.hostname);
	      ip = ip4 || ip6;
	      name = !ip;
	      sld = name && SLD && SLD.has(this._parts.hostname);
	      idn = name && URI.idn_expression.test(this._parts.hostname);
	      punycode = name && URI.punycode_expression.test(this._parts.hostname);
	    }
	    switch (what.toLowerCase()) {
	      case 'relative':
	        return relative;
	      case 'absolute':
	        return !relative;
	      case 'domain':
	      case 'name':
	        return name;
	      case 'sld':
	        return sld;
	      case 'ip':
	        return ip;
	      case 'ip4':
	      case 'ipv4':
	      case 'inet4':
	        return ip4;
	      case 'ip6':
	      case 'ipv6':
	      case 'inet6':
	        return ip6;
	      case 'idn':
	        return idn;
	      case 'url':
	        return !this._parts.urn;
	      case 'urn':
	        return !!this._parts.urn;
	      case 'punycode':
	        return punycode;
	    }
	    return null;
	  };
	  var _protocol = p.protocol;
	  var _port = p.port;
	  var _hostname = p.hostname;
	  p.protocol = function(v, build) {
	    if (v !== undefined) {
	      if (v) {
	        v = v.replace(/:(\/\/)?$/, '');
	        if (!v.match(URI.protocol_expression)) {
	          throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
	        }
	      }
	    }
	    return _protocol.call(this, v, build);
	  };
	  p.scheme = p.protocol;
	  p.port = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v !== undefined) {
	      if (v === 0) {
	        v = null;
	      }
	      if (v) {
	        v += '';
	        if (v.charAt(0) === ':') {
	          v = v.substring(1);
	        }
	        if (v.match(/[^0-9]/)) {
	          throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
	        }
	      }
	    }
	    return _port.call(this, v, build);
	  };
	  p.hostname = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v !== undefined) {
	      var x = {};
	      var res = URI.parseHost(v, x);
	      if (res !== '/') {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
	      }
	      v = x.hostname;
	    }
	    return _hostname.call(this, v, build);
	  };
	  p.origin = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v === undefined) {
	      var protocol = this.protocol();
	      var authority = this.authority();
	      if (!authority) {
	        return '';
	      }
	      return (protocol ? protocol + '://' : '') + this.authority();
	    } else {
	      var origin = URI(v);
	      this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
	      return this;
	    }
	  };
	  p.host = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v === undefined) {
	      return this._parts.hostname ? URI.buildHost(this._parts) : '';
	    } else {
	      var res = URI.parseHost(v, this._parts);
	      if (res !== '/') {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
	      }
	      this.build(!build);
	      return this;
	    }
	  };
	  p.authority = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v === undefined) {
	      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
	    } else {
	      var res = URI.parseAuthority(v, this._parts);
	      if (res !== '/') {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
	      }
	      this.build(!build);
	      return this;
	    }
	  };
	  p.userinfo = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v === undefined) {
	      var t = URI.buildUserinfo(this._parts);
	      return t ? t.substring(0, t.length - 1) : t;
	    } else {
	      if (v[v.length - 1] !== '@') {
	        v += '@';
	      }
	      URI.parseUserinfo(v, this._parts);
	      this.build(!build);
	      return this;
	    }
	  };
	  p.resource = function(v, build) {
	    var parts;
	    if (v === undefined) {
	      return this.path() + this.search() + this.hash();
	    }
	    parts = URI.parse(v);
	    this._parts.path = parts.path;
	    this._parts.query = parts.query;
	    this._parts.fragment = parts.fragment;
	    this.build(!build);
	    return this;
	  };
	  p.subdomain = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v === undefined) {
	      if (!this._parts.hostname || this.is('IP')) {
	        return '';
	      }
	      var end = this._parts.hostname.length - this.domain().length - 1;
	      return this._parts.hostname.substring(0, end) || '';
	    } else {
	      var e = this._parts.hostname.length - this.domain().length;
	      var sub = this._parts.hostname.substring(0, e);
	      var replace = new RegExp('^' + escapeRegEx(sub));
	      if (v && v.charAt(v.length - 1) !== '.') {
	        v += '.';
	      }
	      if (v) {
	        URI.ensureValidHostname(v);
	      }
	      this._parts.hostname = this._parts.hostname.replace(replace, v);
	      this.build(!build);
	      return this;
	    }
	  };
	  p.domain = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (typeof v === 'boolean') {
	      build = v;
	      v = undefined;
	    }
	    if (v === undefined) {
	      if (!this._parts.hostname || this.is('IP')) {
	        return '';
	      }
	      var t = this._parts.hostname.match(/\./g);
	      if (t && t.length < 2) {
	        return this._parts.hostname;
	      }
	      var end = this._parts.hostname.length - this.tld(build).length - 1;
	      end = this._parts.hostname.lastIndexOf('.', end - 1) + 1;
	      return this._parts.hostname.substring(end) || '';
	    } else {
	      if (!v) {
	        throw new TypeError('cannot set domain empty');
	      }
	      URI.ensureValidHostname(v);
	      if (!this._parts.hostname || this.is('IP')) {
	        this._parts.hostname = v;
	      } else {
	        var replace = new RegExp(escapeRegEx(this.domain()) + '$');
	        this._parts.hostname = this._parts.hostname.replace(replace, v);
	      }
	      this.build(!build);
	      return this;
	    }
	  };
	  p.tld = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (typeof v === 'boolean') {
	      build = v;
	      v = undefined;
	    }
	    if (v === undefined) {
	      if (!this._parts.hostname || this.is('IP')) {
	        return '';
	      }
	      var pos = this._parts.hostname.lastIndexOf('.');
	      var tld = this._parts.hostname.substring(pos + 1);
	      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
	        return SLD.get(this._parts.hostname) || tld;
	      }
	      return tld;
	    } else {
	      var replace;
	      if (!v) {
	        throw new TypeError('cannot set TLD empty');
	      } else if (v.match(/[^a-zA-Z0-9-]/)) {
	        if (SLD && SLD.is(v)) {
	          replace = new RegExp(escapeRegEx(this.tld()) + '$');
	          this._parts.hostname = this._parts.hostname.replace(replace, v);
	        } else {
	          throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
	        }
	      } else if (!this._parts.hostname || this.is('IP')) {
	        throw new ReferenceError('cannot set TLD on non-domain host');
	      } else {
	        replace = new RegExp(escapeRegEx(this.tld()) + '$');
	        this._parts.hostname = this._parts.hostname.replace(replace, v);
	      }
	      this.build(!build);
	      return this;
	    }
	  };
	  p.directory = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v === undefined || v === true) {
	      if (!this._parts.path && !this._parts.hostname) {
	        return '';
	      }
	      if (this._parts.path === '/') {
	        return '/';
	      }
	      var end = this._parts.path.length - this.filename().length - 1;
	      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');
	      return v ? URI.decodePath(res) : res;
	    } else {
	      var e = this._parts.path.length - this.filename().length;
	      var directory = this._parts.path.substring(0, e);
	      var replace = new RegExp('^' + escapeRegEx(directory));
	      if (!this.is('relative')) {
	        if (!v) {
	          v = '/';
	        }
	        if (v.charAt(0) !== '/') {
	          v = '/' + v;
	        }
	      }
	      if (v && v.charAt(v.length - 1) !== '/') {
	        v += '/';
	      }
	      v = URI.recodePath(v);
	      this._parts.path = this._parts.path.replace(replace, v);
	      this.build(!build);
	      return this;
	    }
	  };
	  p.filename = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v === undefined || v === true) {
	      if (!this._parts.path || this._parts.path === '/') {
	        return '';
	      }
	      var pos = this._parts.path.lastIndexOf('/');
	      var res = this._parts.path.substring(pos + 1);
	      return v ? URI.decodePathSegment(res) : res;
	    } else {
	      var mutatedDirectory = false;
	      if (v.charAt(0) === '/') {
	        v = v.substring(1);
	      }
	      if (v.match(/\.?\//)) {
	        mutatedDirectory = true;
	      }
	      var replace = new RegExp(escapeRegEx(this.filename()) + '$');
	      v = URI.recodePath(v);
	      this._parts.path = this._parts.path.replace(replace, v);
	      if (mutatedDirectory) {
	        this.normalizePath(build);
	      } else {
	        this.build(!build);
	      }
	      return this;
	    }
	  };
	  p.suffix = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	    if (v === undefined || v === true) {
	      if (!this._parts.path || this._parts.path === '/') {
	        return '';
	      }
	      var filename = this.filename();
	      var pos = filename.lastIndexOf('.');
	      var s,
	          res;
	      if (pos === -1) {
	        return '';
	      }
	      s = filename.substring(pos + 1);
	      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
	      return v ? URI.decodePathSegment(res) : res;
	    } else {
	      if (v.charAt(0) === '.') {
	        v = v.substring(1);
	      }
	      var suffix = this.suffix();
	      var replace;
	      if (!suffix) {
	        if (!v) {
	          return this;
	        }
	        this._parts.path += '.' + URI.recodePath(v);
	      } else if (!v) {
	        replace = new RegExp(escapeRegEx('.' + suffix) + '$');
	      } else {
	        replace = new RegExp(escapeRegEx(suffix) + '$');
	      }
	      if (replace) {
	        v = URI.recodePath(v);
	        this._parts.path = this._parts.path.replace(replace, v);
	      }
	      this.build(!build);
	      return this;
	    }
	  };
	  p.segment = function(segment, v, build) {
	    var separator = this._parts.urn ? ':' : '/';
	    var path = this.path();
	    var absolute = path.substring(0, 1) === '/';
	    var segments = path.split(separator);
	    if (segment !== undefined && typeof segment !== 'number') {
	      build = v;
	      v = segment;
	      segment = undefined;
	    }
	    if (segment !== undefined && typeof segment !== 'number') {
	      throw new Error('Bad segment "' + segment + '", must be 0-based integer');
	    }
	    if (absolute) {
	      segments.shift();
	    }
	    if (segment < 0) {
	      segment = Math.max(segments.length + segment, 0);
	    }
	    if (v === undefined) {
	      return segment === undefined ? segments : segments[segment];
	    } else if (segment === null || segments[segment] === undefined) {
	      if (isArray(v)) {
	        segments = [];
	        for (var i = 0,
	            l = v.length; i < l; i++) {
	          if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
	            continue;
	          }
	          if (segments.length && !segments[segments.length - 1].length) {
	            segments.pop();
	          }
	          segments.push(trimSlashes(v[i]));
	        }
	      } else if (v || typeof v === 'string') {
	        v = trimSlashes(v);
	        if (segments[segments.length - 1] === '') {
	          segments[segments.length - 1] = v;
	        } else {
	          segments.push(v);
	        }
	      }
	    } else {
	      if (v) {
	        segments[segment] = trimSlashes(v);
	      } else {
	        segments.splice(segment, 1);
	      }
	    }
	    if (absolute) {
	      segments.unshift('');
	    }
	    return this.path(segments.join(separator), build);
	  };
	  p.segmentCoded = function(segment, v, build) {
	    var segments,
	        i,
	        l;
	    if (typeof segment !== 'number') {
	      build = v;
	      v = segment;
	      segment = undefined;
	    }
	    if (v === undefined) {
	      segments = this.segment(segment, v, build);
	      if (!isArray(segments)) {
	        segments = segments !== undefined ? URI.decode(segments) : undefined;
	      } else {
	        for (i = 0, l = segments.length; i < l; i++) {
	          segments[i] = URI.decode(segments[i]);
	        }
	      }
	      return segments;
	    }
	    if (!isArray(v)) {
	      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
	    } else {
	      for (i = 0, l = v.length; i < l; i++) {
	        v[i] = URI.encode(v[i]);
	      }
	    }
	    return this.segment(segment, v, build);
	  };
	  var q = p.query;
	  p.query = function(v, build) {
	    if (v === true) {
	      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    } else if (typeof v === 'function') {
	      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	      var result = v.call(this, data);
	      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	      this.build(!build);
	      return this;
	    } else if (v !== undefined && typeof v !== 'string') {
	      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	      this.build(!build);
	      return this;
	    } else {
	      return q.call(this, v, build);
	    }
	  };
	  p.setQuery = function(name, value, build) {
	    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    if (typeof name === 'string' || name instanceof String) {
	      data[name] = value !== undefined ? value : null;
	    } else if (typeof name === 'object') {
	      for (var key in name) {
	        if (hasOwn.call(name, key)) {
	          data[key] = name[key];
	        }
	      }
	    } else {
	      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
	    }
	    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	    if (typeof name !== 'string') {
	      build = value;
	    }
	    this.build(!build);
	    return this;
	  };
	  p.addQuery = function(name, value, build) {
	    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    URI.addQuery(data, name, value === undefined ? null : value);
	    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	    if (typeof name !== 'string') {
	      build = value;
	    }
	    this.build(!build);
	    return this;
	  };
	  p.removeQuery = function(name, value, build) {
	    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    URI.removeQuery(data, name, value);
	    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	    if (typeof name !== 'string') {
	      build = value;
	    }
	    this.build(!build);
	    return this;
	  };
	  p.hasQuery = function(name, value, withinArray) {
	    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    return URI.hasQuery(data, name, value, withinArray);
	  };
	  p.setSearch = p.setQuery;
	  p.addSearch = p.addQuery;
	  p.removeSearch = p.removeQuery;
	  p.hasSearch = p.hasQuery;
	  p.normalize = function() {
	    if (this._parts.urn) {
	      return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
	    }
	    return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
	  };
	  p.normalizeProtocol = function(build) {
	    if (typeof this._parts.protocol === 'string') {
	      this._parts.protocol = this._parts.protocol.toLowerCase();
	      this.build(!build);
	    }
	    return this;
	  };
	  p.normalizeHostname = function(build) {
	    if (this._parts.hostname) {
	      if (this.is('IDN') && punycode) {
	        this._parts.hostname = punycode.toASCII(this._parts.hostname);
	      } else if (this.is('IPv6') && IPv6) {
	        this._parts.hostname = IPv6.best(this._parts.hostname);
	      }
	      this._parts.hostname = this._parts.hostname.toLowerCase();
	      this.build(!build);
	    }
	    return this;
	  };
	  p.normalizePort = function(build) {
	    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
	      this._parts.port = null;
	      this.build(!build);
	    }
	    return this;
	  };
	  p.normalizePath = function(build) {
	    var _path = this._parts.path;
	    if (!_path) {
	      return this;
	    }
	    if (this._parts.urn) {
	      this._parts.path = URI.recodeUrnPath(this._parts.path);
	      this.build(!build);
	      return this;
	    }
	    if (this._parts.path === '/') {
	      return this;
	    }
	    _path = URI.recodePath(_path);
	    var _was_relative;
	    var _leadingParents = '';
	    var _parent,
	        _pos;
	    if (_path.charAt(0) !== '/') {
	      _was_relative = true;
	      _path = '/' + _path;
	    }
	    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
	      _path += '/';
	    }
	    _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, '/').replace(/\/{2,}/g, '/');
	    if (_was_relative) {
	      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
	      if (_leadingParents) {
	        _leadingParents = _leadingParents[0];
	      }
	    }
	    while (true) {
	      _parent = _path.search(/\/\.\.(\/|$)/);
	      if (_parent === -1) {
	        break;
	      } else if (_parent === 0) {
	        _path = _path.substring(3);
	        continue;
	      }
	      _pos = _path.substring(0, _parent).lastIndexOf('/');
	      if (_pos === -1) {
	        _pos = _parent;
	      }
	      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
	    }
	    if (_was_relative && this.is('relative')) {
	      _path = _leadingParents + _path.substring(1);
	    }
	    this._parts.path = _path;
	    this.build(!build);
	    return this;
	  };
	  p.normalizePathname = p.normalizePath;
	  p.normalizeQuery = function(build) {
	    if (typeof this._parts.query === 'string') {
	      if (!this._parts.query.length) {
	        this._parts.query = null;
	      } else {
	        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
	      }
	      this.build(!build);
	    }
	    return this;
	  };
	  p.normalizeFragment = function(build) {
	    if (!this._parts.fragment) {
	      this._parts.fragment = null;
	      this.build(!build);
	    }
	    return this;
	  };
	  p.normalizeSearch = p.normalizeQuery;
	  p.normalizeHash = p.normalizeFragment;
	  p.iso8859 = function() {
	    var e = URI.encode;
	    var d = URI.decode;
	    URI.encode = escape;
	    URI.decode = decodeURIComponent;
	    try {
	      this.normalize();
	    } finally {
	      URI.encode = e;
	      URI.decode = d;
	    }
	    return this;
	  };
	  p.unicode = function() {
	    var e = URI.encode;
	    var d = URI.decode;
	    URI.encode = strictEncodeURIComponent;
	    URI.decode = unescape;
	    try {
	      this.normalize();
	    } finally {
	      URI.encode = e;
	      URI.decode = d;
	    }
	    return this;
	  };
	  p.readable = function() {
	    var uri = this.clone();
	    uri.username('').password('').normalize();
	    var t = '';
	    if (uri._parts.protocol) {
	      t += uri._parts.protocol + '://';
	    }
	    if (uri._parts.hostname) {
	      if (uri.is('punycode') && punycode) {
	        t += punycode.toUnicode(uri._parts.hostname);
	        if (uri._parts.port) {
	          t += ':' + uri._parts.port;
	        }
	      } else {
	        t += uri.host();
	      }
	    }
	    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
	      t += '/';
	    }
	    t += uri.path(true);
	    if (uri._parts.query) {
	      var q = '';
	      for (var i = 0,
	          qp = uri._parts.query.split('&'),
	          l = qp.length; i < l; i++) {
	        var kv = (qp[i] || '').split('=');
	        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, '%26');
	        if (kv[1] !== undefined) {
	          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, '%26');
	        }
	      }
	      t += '?' + q.substring(1);
	    }
	    t += URI.decodeQuery(uri.hash(), true);
	    return t;
	  };
	  p.absoluteTo = function(base) {
	    var resolved = this.clone();
	    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
	    var basedir,
	        i,
	        p;
	    if (this._parts.urn) {
	      throw new Error('URNs do not have any generally defined hierarchical components');
	    }
	    if (!(base instanceof URI)) {
	      base = new URI(base);
	    }
	    if (!resolved._parts.protocol) {
	      resolved._parts.protocol = base._parts.protocol;
	    }
	    if (this._parts.hostname) {
	      return resolved;
	    }
	    for (i = 0; (p = properties[i]); i++) {
	      resolved._parts[p] = base._parts[p];
	    }
	    if (!resolved._parts.path) {
	      resolved._parts.path = base._parts.path;
	      if (!resolved._parts.query) {
	        resolved._parts.query = base._parts.query;
	      }
	    } else if (resolved._parts.path.substring(-2) === '..') {
	      resolved._parts.path += '/';
	    }
	    if (resolved.path().charAt(0) !== '/') {
	      basedir = base.directory();
	      basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
	      resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
	      resolved.normalizePath();
	    }
	    resolved.build();
	    return resolved;
	  };
	  p.relativeTo = function(base) {
	    var relative = this.clone().normalize();
	    var relativeParts,
	        baseParts,
	        common,
	        relativePath,
	        basePath;
	    if (relative._parts.urn) {
	      throw new Error('URNs do not have any generally defined hierarchical components');
	    }
	    base = new URI(base).normalize();
	    relativeParts = relative._parts;
	    baseParts = base._parts;
	    relativePath = relative.path();
	    basePath = base.path();
	    if (relativePath.charAt(0) !== '/') {
	      throw new Error('URI is already relative');
	    }
	    if (basePath.charAt(0) !== '/') {
	      throw new Error('Cannot calculate a URI relative to another relative URI');
	    }
	    if (relativeParts.protocol === baseParts.protocol) {
	      relativeParts.protocol = null;
	    }
	    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
	      return relative.build();
	    }
	    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
	      return relative.build();
	    }
	    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
	      relativeParts.hostname = null;
	      relativeParts.port = null;
	    } else {
	      return relative.build();
	    }
	    if (relativePath === basePath) {
	      relativeParts.path = '';
	      return relative.build();
	    }
	    common = URI.commonPath(relativePath, basePath);
	    if (!common) {
	      return relative.build();
	    }
	    var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, '').replace(/.*?\//g, '../');
	    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';
	    return relative.build();
	  };
	  p.equals = function(uri) {
	    var one = this.clone();
	    var two = new URI(uri);
	    var one_map = {};
	    var two_map = {};
	    var checked = {};
	    var one_query,
	        two_query,
	        key;
	    one.normalize();
	    two.normalize();
	    if (one.toString() === two.toString()) {
	      return true;
	    }
	    one_query = one.query();
	    two_query = two.query();
	    one.query('');
	    two.query('');
	    if (one.toString() !== two.toString()) {
	      return false;
	    }
	    if (one_query.length !== two_query.length) {
	      return false;
	    }
	    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
	    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
	    for (key in one_map) {
	      if (hasOwn.call(one_map, key)) {
	        if (!isArray(one_map[key])) {
	          if (one_map[key] !== two_map[key]) {
	            return false;
	          }
	        } else if (!arraysEqual(one_map[key], two_map[key])) {
	          return false;
	        }
	        checked[key] = true;
	      }
	    }
	    for (key in two_map) {
	      if (hasOwn.call(two_map, key)) {
	        if (!checked[key]) {
	          return false;
	        }
	      }
	    }
	    return true;
	  };
	  p.duplicateQueryParameters = function(v) {
	    this._parts.duplicateQueryParameters = !!v;
	    return this;
	  };
	  p.escapeQuerySpace = function(v) {
	    this._parts.escapeQuerySpace = !!v;
	    return this;
	  };
	  return URI;
	}));

	})();
	$__System.registerDynamic("8", [], true, function($__require, exports, module) {
	  ;
	  var define,
	      global = this || self,
	      GLOBAL = global;
	  (function(define, undefined) {
	    define(function() {
	      'use strict';
	      var impl = {};
	      impl.mobileDetectRules = {
	        "phones": {
	          "iPhone": "\\biPhone\\b|\\biPod\\b",
	          "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+",
	          "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m",
	          "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
	          "Dell": "Dell.*Streak|Dell.*Aero|Dell.*Venue|DELL.*Venue Pro|Dell Flash|Dell Smoke|Dell Mini 3iX|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
	          "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b",
	          "Samsung": "Samsung|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350",
	          "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323)",
	          "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
	          "Asus": "Asus.*Galaxy|PadFone.*Mobile",
	          "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
	          "Palm": "PalmSource|Palm",
	          "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
	          "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
	          "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
	          "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
	          "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
	          "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
	          "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
	          "Alcatel": "Alcatel",
	          "Nintendo": "Nintendo 3DS",
	          "Amoi": "Amoi",
	          "INQ": "INQ",
	          "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
	        },
	        "tablets": {
	          "iPad": "iPad|iPad.*Mobile",
	          "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
	          "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561",
	          "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI)\\b",
	          "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
	          "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
	          "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K017 |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C",
	          "BlackBerryTablet": "PlayBook|RIM Tablet",
	          "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
	          "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
	          "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
	          "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b",
	          "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
	          "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
	          "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
	          "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
	          "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)",
	          "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
	          "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
	          "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
	          "ArnovaTablet": "AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
	          "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
	          "IRUTablet": "M702pro",
	          "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
	          "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
	          "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
	          "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
	          "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
	          "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP612|SOT31",
	          "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
	          "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
	          "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
	          "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
	          "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
	          "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
	          "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
	          "FlyTablet": "IQ310|Fly Vision",
	          "bqTablet": "Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris E10)|Maxwell.*Lite|Maxwell.*Plus",
	          "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim",
	          "NecTablet": "\\bN-06D|\\bN-08D",
	          "PantechTablet": "Pantech.*P4100",
	          "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
	          "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
	          "ZyncTablet": "z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900",
	          "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
	          "NabiTablet": "Android.*\\bNabi",
	          "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
	          "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
	          "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
	          "PlaystationTablet": "Playstation.*(Portable|Vita)",
	          "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
	          "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
	          "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
	          "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
	          "GalapadTablet": "Android.*\\bG1\\b",
	          "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
	          "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
	          "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
	          "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
	          "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
	          "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
	          "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
	          "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
	          "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)",
	          "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
	          "DPSTablet": "DPS Dream 9|DPS Dual 7",
	          "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
	          "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
	          "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
	          "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
	          "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
	          "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
	          "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
	          "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
	          "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
	          "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7",
	          "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
	          "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
	          "iMobileTablet": "i-mobile i-note",
	          "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
	          "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
	          "AMPETablet": "Android.* A78 ",
	          "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
	          "TecnoTablet": "TECNO P9",
	          "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
	          "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
	          "FX2Tablet": "FX2 PAD7|FX2 PAD10",
	          "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
	          "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
	          "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
	          "CaptivaTablet": "CAPTIVA PAD",
	          "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
	          "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
	          "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+",
	          "JaytechTablet": "TPC-PA762",
	          "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
	          "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
	          "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
	          "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
	          "AocTablet": "MW0811|MW0812|MW0922|MTK8382",
	          "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
	          "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
	          "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
	          "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
	          "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
	          "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
	          "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
	          "UbislateTablet": "UbiSlate[\\s]?7C",
	          "PocketBookTablet": "Pocketbook",
	          "Hudl": "Hudl HT7S3|Hudl 2",
	          "TelstraTablet": "T-Hub2",
	          "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bJolla\\b|\\bTP750\\b"
	        },
	        "oss": {
	          "AndroidOS": "Android",
	          "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
	          "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
	          "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
	          "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;",
	          "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
	          "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad",
	          "MeeGoOS": "MeeGo",
	          "MaemoOS": "Maemo",
	          "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
	          "webOS": "webOS|hpwOS",
	          "badaOS": "\\bBada\\b",
	          "BREWOS": "BREW"
	        },
	        "uas": {
	          "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
	          "Dolfin": "\\bDolfin\\b",
	          "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+|Coast\/[0-9.]+",
	          "Skyfire": "Skyfire",
	          "IE": "IEMobile|MSIEMobile",
	          "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile",
	          "Bolt": "bolt",
	          "TeaShark": "teashark",
	          "Blazer": "Blazer",
	          "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
	          "Tizen": "Tizen",
	          "UCBrowser": "UC.*Browser|UCWEB",
	          "baiduboxapp": "baiduboxapp",
	          "baidubrowser": "baidubrowser",
	          "DiigoBrowser": "DiigoBrowser",
	          "Puffin": "Puffin",
	          "Mercury": "\\bMercury\\b",
	          "ObigoBrowser": "Obigo",
	          "NetFront": "NF-Browser",
	          "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger"
	        },
	        "props": {
	          "Mobile": "Mobile\/[VER]",
	          "Build": "Build\/[VER]",
	          "Version": "Version\/[VER]",
	          "VendorID": "VendorID\/[VER]",
	          "iPad": "iPad.*CPU[a-z ]+[VER]",
	          "iPhone": "iPhone.*CPU[a-z ]+[VER]",
	          "iPod": "iPod.*CPU[a-z ]+[VER]",
	          "Kindle": "Kindle\/[VER]",
	          "Chrome": ["Chrome\/[VER]", "CriOS\/[VER]", "CrMo\/[VER]"],
	          "Coast": ["Coast\/[VER]"],
	          "Dolfin": "Dolfin\/[VER]",
	          "Firefox": "Firefox\/[VER]",
	          "Fennec": "Fennec\/[VER]",
	          "IE": ["IEMobile\/[VER];", "IEMobile [VER]", "MSIE [VER];", "Trident\/[0-9.]+;.*rv:[VER]"],
	          "NetFront": "NetFront\/[VER]",
	          "NokiaBrowser": "NokiaBrowser\/[VER]",
	          "Opera": [" OPR\/[VER]", "Opera Mini\/[VER]", "Version\/[VER]"],
	          "Opera Mini": "Opera Mini\/[VER]",
	          "Opera Mobi": "Version\/[VER]",
	          "UC Browser": "UC Browser[VER]",
	          "MQQBrowser": "MQQBrowser\/[VER]",
	          "MicroMessenger": "MicroMessenger\/[VER]",
	          "baiduboxapp": "baiduboxapp\/[VER]",
	          "baidubrowser": "baidubrowser\/[VER]",
	          "Iron": "Iron\/[VER]",
	          "Safari": ["Version\/[VER]", "Safari\/[VER]"],
	          "Skyfire": "Skyfire\/[VER]",
	          "Tizen": "Tizen\/[VER]",
	          "Webkit": "webkit[ \/][VER]",
	          "Gecko": "Gecko\/[VER]",
	          "Trident": "Trident\/[VER]",
	          "Presto": "Presto\/[VER]",
	          "iOS": " \\bi?OS\\b [VER][ ;]{1}",
	          "Android": "Android [VER]",
	          "BlackBerry": ["BlackBerry[\\w]+\/[VER]", "BlackBerry.*Version\/[VER]", "Version\/[VER]"],
	          "BREW": "BREW [VER]",
	          "Java": "Java\/[VER]",
	          "Windows Phone OS": ["Windows Phone OS [VER]", "Windows Phone [VER]"],
	          "Windows Phone": "Windows Phone [VER]",
	          "Windows CE": "Windows CE\/[VER]",
	          "Windows NT": "Windows NT [VER]",
	          "Symbian": ["SymbianOS\/[VER]", "Symbian\/[VER]"],
	          "webOS": ["webOS\/[VER]", "hpwOS\/[VER];"]
	        },
	        "utils": {
	          "Bot": "Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom",
	          "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
	          "DesktopMode": "WPDesktop",
	          "TV": "SonyDTV|HbbTV",
	          "WebKit": "(webkit)[ \/]([\\w.]+)",
	          "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|PLAYSTATION|Xbox)\\b",
	          "Watch": "SM-V700"
	        }
	      };
	      impl.detectMobileBrowsers = {
	        fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
	        shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
	        tabletPattern: /android|ipad|playbook|silk/i
	      };
	      var hasOwnProp = Object.prototype.hasOwnProperty,
	          isArray;
	      impl.FALLBACK_PHONE = 'UnknownPhone';
	      impl.FALLBACK_TABLET = 'UnknownTablet';
	      impl.FALLBACK_MOBILE = 'UnknownMobile';
	      isArray = ('isArray' in Array) ? Array.isArray : function(value) {
	        return Object.prototype.toString.call(value) === '[object Array]';
	      };
	      function equalIC(a, b) {
	        return a != null && b != null && a.toLowerCase() === b.toLowerCase();
	      }
	      function containsIC(array, value) {
	        var valueLC,
	            i,
	            len = array.length;
	        if (!len || !value) {
	          return false;
	        }
	        valueLC = value.toLowerCase();
	        for (i = 0; i < len; ++i) {
	          if (valueLC === array[i].toLowerCase()) {
	            return true;
	          }
	        }
	        return false;
	      }
	      function convertPropsToRegExp(object) {
	        for (var key in object) {
	          if (hasOwnProp.call(object, key)) {
	            object[key] = new RegExp(object[key], 'i');
	          }
	        }
	      }
	      (function init() {
	        var key,
	            values,
	            value,
	            i,
	            len,
	            verPos,
	            mobileDetectRules = impl.mobileDetectRules;
	        for (key in mobileDetectRules.props) {
	          if (hasOwnProp.call(mobileDetectRules.props, key)) {
	            values = mobileDetectRules.props[key];
	            if (!isArray(values)) {
	              values = [values];
	            }
	            len = values.length;
	            for (i = 0; i < len; ++i) {
	              value = values[i];
	              verPos = value.indexOf('[VER]');
	              if (verPos >= 0) {
	                value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
	              }
	              values[i] = new RegExp(value, 'i');
	            }
	            mobileDetectRules.props[key] = values;
	          }
	        }
	        convertPropsToRegExp(mobileDetectRules.oss);
	        convertPropsToRegExp(mobileDetectRules.phones);
	        convertPropsToRegExp(mobileDetectRules.tablets);
	        convertPropsToRegExp(mobileDetectRules.uas);
	        convertPropsToRegExp(mobileDetectRules.utils);
	        mobileDetectRules.oss0 = {
	          WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
	          WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
	        };
	      }());
	      impl.findMatch = function(rules, userAgent) {
	        for (var key in rules) {
	          if (hasOwnProp.call(rules, key)) {
	            if (rules[key].test(userAgent)) {
	              return key;
	            }
	          }
	        }
	        return null;
	      };
	      impl.findMatches = function(rules, userAgent) {
	        var result = [];
	        for (var key in rules) {
	          if (hasOwnProp.call(rules, key)) {
	            if (rules[key].test(userAgent)) {
	              result.push(key);
	            }
	          }
	        }
	        return result;
	      };
	      impl.getVersionStr = function(propertyName, userAgent) {
	        var props = impl.mobileDetectRules.props,
	            patterns,
	            i,
	            len,
	            match;
	        if (hasOwnProp.call(props, propertyName)) {
	          patterns = props[propertyName];
	          len = patterns.length;
	          for (i = 0; i < len; ++i) {
	            match = patterns[i].exec(userAgent);
	            if (match !== null) {
	              return match[1];
	            }
	          }
	        }
	        return null;
	      };
	      impl.getVersion = function(propertyName, userAgent) {
	        var version = impl.getVersionStr(propertyName, userAgent);
	        return version ? impl.prepareVersionNo(version) : NaN;
	      };
	      impl.prepareVersionNo = function(version) {
	        var numbers;
	        numbers = version.split(/[a-z._ \/\-]/i);
	        if (numbers.length === 1) {
	          version = numbers[0];
	        }
	        if (numbers.length > 1) {
	          version = numbers[0] + '.';
	          numbers.shift();
	          version += numbers.join('');
	        }
	        return Number(version);
	      };
	      impl.isMobileFallback = function(userAgent) {
	        return impl.detectMobileBrowsers.fullPattern.test(userAgent) || impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0, 4));
	      };
	      impl.isTabletFallback = function(userAgent) {
	        return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
	      };
	      impl.prepareDetectionCache = function(cache, userAgent, maxPhoneWidth) {
	        if (cache.mobile !== undefined) {
	          return;
	        }
	        var phone,
	            tablet,
	            phoneSized;
	        tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
	        if (tablet) {
	          cache.mobile = cache.tablet = tablet;
	          cache.phone = null;
	          return;
	        }
	        phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
	        if (phone) {
	          cache.mobile = cache.phone = phone;
	          cache.tablet = null;
	          return;
	        }
	        if (impl.isMobileFallback(userAgent)) {
	          phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
	          if (phoneSized === undefined) {
	            cache.mobile = impl.FALLBACK_MOBILE;
	            cache.tablet = cache.phone = null;
	          } else if (phoneSized) {
	            cache.mobile = cache.phone = impl.FALLBACK_PHONE;
	            cache.tablet = null;
	          } else {
	            cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
	            cache.phone = null;
	          }
	        } else if (impl.isTabletFallback(userAgent)) {
	          cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
	          cache.phone = null;
	        } else {
	          cache.mobile = cache.tablet = cache.phone = null;
	        }
	      };
	      impl.mobileGrade = function(t) {
	        var $isMobile = t.mobile() !== null;
	        if (t.os('iOS') && t.version('iPad') >= 4.3 || t.os('iOS') && t.version('iPhone') >= 3.1 || t.os('iOS') && t.version('iPod') >= 3.1 || (t.version('Android') > 2.1 && t.is('Webkit')) || t.version('Windows Phone OS') >= 7.0 || t.is('BlackBerry') && t.version('BlackBerry') >= 6.0 || t.match('Playbook.*Tablet') || (t.version('webOS') >= 1.4 && t.match('Palm|Pre|Pixi')) || t.match('hp.*TouchPad') || (t.is('Firefox') && t.version('Firefox') >= 12) || (t.is('Chrome') && t.is('AndroidOS') && t.version('Android') >= 4.0) || (t.is('Skyfire') && t.version('Skyfire') >= 4.1 && t.is('AndroidOS') && t.version('Android') >= 2.3) || (t.is('Opera') && t.version('Opera Mobi') > 11 && t.is('AndroidOS')) || t.is('MeeGoOS') || t.is('Tizen') || t.is('Dolfin') && t.version('Bada') >= 2.0 || ((t.is('UC Browser') || t.is('Dolfin')) && t.version('Android') >= 2.3) || (t.match('Kindle Fire') || t.is('Kindle') && t.version('Kindle') >= 3.0) || t.is('AndroidOS') && t.is('NookTablet') || t.version('Chrome') >= 11 && !$isMobile || t.version('Safari') >= 5.0 && !$isMobile || t.version('Firefox') >= 4.0 && !$isMobile || t.version('MSIE') >= 7.0 && !$isMobile || t.version('Opera') >= 10 && !$isMobile) {
	          return 'A';
	        }
	        if (t.os('iOS') && t.version('iPad') < 4.3 || t.os('iOS') && t.version('iPhone') < 3.1 || t.os('iOS') && t.version('iPod') < 3.1 || t.is('Blackberry') && t.version('BlackBerry') >= 5 && t.version('BlackBerry') < 6 || (t.version('Opera Mini') >= 5.0 && t.version('Opera Mini') <= 6.5 && (t.version('Android') >= 2.3 || t.is('iOS'))) || t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') || t.version('Opera Mobi') >= 11 && t.is('SymbianOS')) {
	          return 'B';
	        }
	        if (t.version('BlackBerry') < 5.0 || t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile') <= 5.2) {
	          return 'C';
	        }
	        return 'C';
	      };
	      impl.detectOS = function(ua) {
	        return impl.findMatch(impl.mobileDetectRules.oss0, ua) || impl.findMatch(impl.mobileDetectRules.oss, ua);
	      };
	      impl.getDeviceSmallerSide = function() {
	        return window.screen.width < window.screen.height ? window.screen.width : window.screen.height;
	      };
	      function MobileDetect(userAgent, maxPhoneWidth) {
	        this.ua = userAgent || '';
	        this._cache = {};
	        this.maxPhoneWidth = maxPhoneWidth || 600;
	      }
	      MobileDetect.prototype = {
	        constructor: MobileDetect,
	        mobile: function() {
	          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
	          return this._cache.mobile;
	        },
	        phone: function() {
	          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
	          return this._cache.phone;
	        },
	        tablet: function() {
	          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
	          return this._cache.tablet;
	        },
	        userAgent: function() {
	          if (this._cache.userAgent === undefined) {
	            this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
	          }
	          return this._cache.userAgent;
	        },
	        userAgents: function() {
	          if (this._cache.userAgents === undefined) {
	            this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
	          }
	          return this._cache.userAgents;
	        },
	        os: function() {
	          if (this._cache.os === undefined) {
	            this._cache.os = impl.detectOS(this.ua);
	          }
	          return this._cache.os;
	        },
	        version: function(key) {
	          return impl.getVersion(key, this.ua);
	        },
	        versionStr: function(key) {
	          return impl.getVersionStr(key, this.ua);
	        },
	        is: function(key) {
	          return containsIC(this.userAgents(), key) || equalIC(key, this.os()) || equalIC(key, this.phone()) || equalIC(key, this.tablet()) || containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
	        },
	        match: function(pattern) {
	          if (!(pattern instanceof RegExp)) {
	            pattern = new RegExp(pattern, 'i');
	          }
	          return pattern.test(this.ua);
	        },
	        isPhoneSized: function(maxPhoneWidth) {
	          return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
	        },
	        mobileGrade: function() {
	          if (this._cache.grade === undefined) {
	            this._cache.grade = impl.mobileGrade(this);
	          }
	          return this._cache.grade;
	        }
	      };
	      if (typeof window !== 'undefined' && window.screen) {
	        MobileDetect.isPhoneSized = function(maxPhoneWidth) {
	          return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
	        };
	      } else {
	        MobileDetect.isPhoneSized = function() {};
	      }
	      MobileDetect._impl = impl;
	      return MobileDetect;
	    });
	  })((function(undefined) {
	    if (typeof module !== 'undefined' && module.exports) {
	      return function(factory) {
	        module.exports = factory();
	      };
	    } else if (typeof define === 'function' && define.amd) {
	      return define;
	    } else if (typeof window !== 'undefined') {
	      return function(factory) {
	        window.MobileDetect = factory();
	      };
	    } else {
	      throw new Error('unknown environment');
	    }
	  })());
	  return module.exports;
	});

	$__System.register('9', ['c', 'a', 'b', '8'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, cesium_imports_1, context_2, mobile_detect_1;
	    var DeviceService;
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (cesium_imports_1_1) {
	            cesium_imports_1 = cesium_imports_1_1;
	        }, function (context_2_1) {
	            context_2 = context_2_1;
	        }, function (mobile_detect_1_1) {
	            mobile_detect_1 = mobile_detect_1_1;
	        }],
	        execute: function () {
	            /**
	            * Provides pose state for the device.
	            */
	            DeviceService = function () {
	                /**
	                * Initialize the DeviceService
	                */
	                function DeviceService(context) {
	                    this.locationUpdatesEnabled = true;
	                    this.orientationUpdatesEnabled = true;
	                    /**
	                     * An ENU coordinate frame centered at the gps location reported by this device
	                     */
	                    this.geolocationEntity = new cesium_imports_1.Entity({ id: 'ar.device.geolocation', name: 'Device Geolocation' });
	                    /**
	                     * A frame which represents the orientation of this device relative to it's ENU coordinate frame (geolocationEntity)
	                     */
	                    this.orientationEntity = new cesium_imports_1.Entity({ id: 'ar.device.orientation', name: 'Device Orientation' });
	                    /**
	                     * A frame which represents the pose of this device
	                     */
	                    this.entity = new cesium_imports_1.Entity({ id: 'ar.device', name: 'Device' });
	                    /**
	                     * A frame which describes the pose of the display relative to this device
	                     */
	                    this.displayEntity = new cesium_imports_1.Entity({
	                        id: 'ar.device.display',
	                        name: 'Device Display',
	                        position: new cesium_imports_1.ConstantPositionProperty(cesium_imports_1.Cartesian3.ZERO, this.entity),
	                        orientation: new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.IDENTITY)
	                    });
	                    this._scratchCartesian = new cesium_imports_1.Cartesian3();
	                    this._scratchQuaternion1 = new cesium_imports_1.Quaternion();
	                    this._scratchQuaternion2 = new cesium_imports_1.Quaternion();
	                    this._x90Rot = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_X, cesium_imports_1.CesiumMath.PI_OVER_TWO);
	                    this._headingDrift = 0;
	                    context.wellKnownReferenceFrames.add(this.geolocationEntity);
	                    context.wellKnownReferenceFrames.add(this.orientationEntity);
	                    context.wellKnownReferenceFrames.add(this.entity);
	                    context.wellKnownReferenceFrames.add(this.displayEntity);
	                    if (typeof navigator !== 'undefined') {
	                        this._mobileDetect = new mobile_detect_1.default(navigator.userAgent);
	                    }
	                }
	                DeviceService.prototype.onIdle = function () {
	                    if (typeof navigator === 'undefined') return;
	                    if (cesium_imports_1.defined(this._geolocationWatchId)) {
	                        navigator.geolocation.clearWatch(this._geolocationWatchId);
	                        this._geolocationWatchId = undefined;
	                    }
	                    if (cesium_imports_1.defined(this._deviceorientationListener)) {
	                        window.removeEventListener('deviceorientation', this._deviceorientationListener);
	                        this._deviceorientationListener = undefined;
	                        this._alphaOffset = undefined;
	                    }
	                };
	                DeviceService.prototype.onUpdate = function () {
	                    var _this = this;
	                    if (typeof navigator !== 'undefined') {
	                        var interfaceOrientationProperty = this.displayEntity.orientation;
	                        var interfaceOrientation = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_Z, (-window.orientation || 0) * cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE, this._scratchQuaternion1);
	                        if (this._mobileDetect && !this._mobileDetect.mobile()) {
	                            // for laptops, rotate device orientation by 90° around +X so that it 
	                            // corresponds to an upright display rather than the integrated keyboard
	                            interfaceOrientation = cesium_imports_1.Quaternion.multiply(this._x90Rot, interfaceOrientation, interfaceOrientation);
	                        }
	                        interfaceOrientationProperty.setValue(interfaceOrientation);
	                        if (!cesium_imports_1.defined(this._geolocationWatchId) && this.locationUpdatesEnabled) {
	                            this._geolocationWatchId = navigator.geolocation.watchPosition(function (pos) {
	                                if (_this.geolocationEntity.position instanceof cesium_imports_1.SampledPositionProperty === false) {
	                                    var sampledPostionProperty = new cesium_imports_1.SampledPositionProperty(cesium_imports_1.ReferenceFrame.FIXED);
	                                    sampledPostionProperty.forwardExtrapolationType = cesium_imports_1.ExtrapolationType.HOLD;
	                                    sampledPostionProperty.backwardExtrapolationType = cesium_imports_1.ExtrapolationType.HOLD;
	                                    sampledPostionProperty.maxNumSamples = 10;
	                                    _this.geolocationEntity.position = sampledPostionProperty;
	                                }
	                                var positionTime = cesium_imports_1.JulianDate.fromDate(new Date(pos.timestamp));
	                                var positionECEF = cesium_imports_1.Cartesian3.fromDegrees(pos.coords.longitude, pos.coords.latitude, pos.coords.altitude || 0, undefined, _this._scratchCartesian);
	                                _this.geolocationEntity.position.addSample(positionTime, positionECEF);
	                                if (_this.geolocationEntity.orientation instanceof cesium_imports_1.ConstantProperty === false) {
	                                    _this.geolocationEntity.orientation = new cesium_imports_1.ConstantProperty();
	                                }
	                                var enuOrientation = cesium_imports_1.Transforms.headingPitchRollQuaternion(positionECEF, 0, 0, 0, undefined, _this._scratchQuaternion1);
	                                _this.geolocationEntity.orientation.setValue(enuOrientation);
	                            }, function (error) {
	                                console.error(error);
	                            }, {
	                                enableHighAccuracy: true
	                            });
	                        } else if (cesium_imports_1.defined(this._geolocationWatchId) && !this.locationUpdatesEnabled) {
	                            navigator.geolocation.clearWatch(this._geolocationWatchId);
	                            this._geolocationWatchId = undefined;
	                        }
	                        if (!cesium_imports_1.defined(this._deviceorientationListener) && this.orientationUpdatesEnabled) {
	                            this._deviceorientationListener = function (e) {
	                                var alphaDegrees = e.alpha;
	                                if (!cesium_imports_1.defined(alphaDegrees)) {
	                                    return;
	                                }
	                                if (e.absolute) {
	                                    _this._alphaOffset = 0;
	                                }
	                                var webkitCompassHeading = e['webkitCompassHeading'];
	                                var webkitCompassAccuracy = +e['webkitCompassAccuracy'];
	                                // when the phone is almost updside down, webkit flips the compass heading 
	                                // (not documented anywhere, annoyingly)
	                                // if (e.beta >= 130 || e.beta <= -130) webkitCompassHeading = undefined;
	                                if ((!cesium_imports_1.defined(_this._alphaOffset) || Math.abs(_this._headingDrift) > 5) && cesium_imports_1.defined(webkitCompassHeading) && webkitCompassAccuracy >= 0 && webkitCompassAccuracy < 50 && webkitCompassHeading >= 0) {
	                                    if (!cesium_imports_1.defined(_this._alphaOffset)) {
	                                        _this._alphaOffset = -webkitCompassHeading;
	                                    } else {
	                                        _this._alphaOffset -= _this._headingDrift;
	                                    }
	                                }
	                                var alphaOffset = _this._alphaOffset || -webkitCompassHeading || 0;
	                                // TODO: deal with various browser quirks :\
	                                // https://mobiforge.com/design-development/html5-mobile-web-device-orientation-events
	                                var alpha = cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE * (e.alpha + alphaOffset);
	                                var beta = cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE * e.beta;
	                                var gamma = cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE * e.gamma;
	                                var alphaQuat = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_Z, alpha, _this._scratchQuaternion1);
	                                var betaQuat = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_X, beta, _this._scratchQuaternion2);
	                                var alphaBetaQuat = cesium_imports_1.Quaternion.multiply(alphaQuat, betaQuat, _this._scratchQuaternion1);
	                                var gammaQuat = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_Y, gamma, _this._scratchQuaternion2);
	                                var alphaBetaGammaQuat = cesium_imports_1.Quaternion.multiply(alphaBetaQuat, gammaQuat, alphaBetaQuat);
	                                // update orientationEntity
	                                if (_this.orientationEntity.position instanceof cesium_imports_1.ConstantPositionProperty == false) {
	                                    _this.orientationEntity.position = new cesium_imports_1.ConstantPositionProperty(cesium_imports_1.Cartesian3.ZERO, _this.geolocationEntity);
	                                }
	                                if (_this.orientationEntity.orientation instanceof cesium_imports_1.ConstantProperty == false) {
	                                    _this.orientationEntity.orientation = new cesium_imports_1.ConstantProperty();
	                                }
	                                _this.orientationEntity.orientation.setValue(alphaBetaGammaQuat);
	                                // make sure the device entity has a defined pose relative to the device orientation entity
	                                if (_this.entity.position instanceof cesium_imports_1.ConstantPositionProperty == false) {
	                                    _this.entity.position = new cesium_imports_1.ConstantPositionProperty(cesium_imports_1.Cartesian3.ZERO, _this.orientationEntity);
	                                }
	                                if (_this.entity.orientation instanceof cesium_imports_1.ConstantProperty == false) {
	                                    _this.entity.orientation = new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.IDENTITY);
	                                }
	                                // TODO: fix heading drift calculation (heading should match webkitCompassHeading)
	                                // if (defined(webkitCompassHeading)) {
	                                //     const q = alphaBetaGammaQuat//utils.getEntityOrientationInReferenceFrame(this.interfaceEntity, JulianDate.now(), this.locationEntity, this._scratchQuaternion1);
	                                //     var heading = -Math.atan2(2*(q.w*q.z + q.x*q.y), 1 - 2*(q.y*q.y + q.z*q.z));
	                                //     if (heading < 0) heading += 2*Math.PI;
	                                //     const {swing,twist} = swingTwistDecomposition(alphaBetaGammaQuat, Cartesian3.UNIT_Z);
	                                //     const twistAngle = 2 * Math.acos(twist.w);
	                                //     console.log(twist.w + ' ' + twistAngle * CesiumMath.DEGREES_PER_RADIAN + '\n' + webkitCompassHeading);
	                                //     // this._headingDrift = webkitCompassHeading - heading * CesiumMath.DEGREES_PER_RADIAN;
	                                // }
	                            };
	                            window.addEventListener('deviceorientation', this._deviceorientationListener);
	                        } else if (cesium_imports_1.defined(this._deviceorientationListener) && !this.orientationUpdatesEnabled) {
	                            window.removeEventListener('deviceorientation', this._deviceorientationListener);
	                            this._deviceorientationListener = undefined;
	                        }
	                    }
	                };
	                /**
	                * Update the pose with latest sensor data
	                */
	                DeviceService.prototype.update = function () {
	                    var _this = this;
	                    if (cesium_imports_1.defined(this._idleTimeoutId)) clearTimeout(this._idleTimeoutId);
	                    this._idleTimeoutId = setTimeout(function () {
	                        _this.onIdle();
	                    }, 2000);
	                    this.onUpdate();
	                };
	                DeviceService = __decorate([aurelia_dependency_injection_1.inject(context_2.ContextService)], DeviceService);
	                return DeviceService;
	            }();
	            exports_1("DeviceService", DeviceService);
	        }
	    };
	});
	$__System.register('d', ['a'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var cesium_imports_1;
	    var TimerService, lastTime;
	    function requestAnimationFramePoly(callback) {
	        var currTime = Date.now();
	        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	        var id = setTimeout(function () {
	            callback(currTime + timeToCall);
	        }, timeToCall);
	        lastTime = currTime + timeToCall;
	        return id;
	    }
	    return {
	        setters: [function (cesium_imports_1_1) {
	            cesium_imports_1 = cesium_imports_1_1;
	        }],
	        execute: function () {
	            /**
	             * Provides timer service
	             */
	            TimerService = function () {
	                function TimerService() {
	                    this.frameNumbers = new WeakMap();
	                }
	                /**
	                 * Request that the callback function be called for the next frame.
	                 *
	                 * @param callback function
	                 */
	                TimerService.prototype.requestFrame = function (callback) {
	                    var _this = this;
	                    if (typeof requestAnimationFrame !== 'undefined' && typeof performance !== 'undefined') {
	                        this.navigationStartDate = this.navigationStartDate || cesium_imports_1.JulianDate.fromDate(new Date(performance.timing.navigationStart));
	                        requestAnimationFrame(function (time) {
	                            var frameTime = cesium_imports_1.JulianDate.addSeconds(_this.navigationStartDate, time / 1000, new cesium_imports_1.JulianDate(0, 0));
	                            callback(frameTime, _this.getNextFrameNumber(callback));
	                        });
	                    } else {
	                        requestAnimationFramePoly(function (time) {
	                            var frameTime = cesium_imports_1.JulianDate.fromDate(new Date(time));
	                            callback(frameTime, _this.getNextFrameNumber(callback));
	                        });
	                    }
	                };
	                TimerService.prototype.getNextFrameNumber = function (callback) {
	                    var frameNumber = this.frameNumbers.get(callback) || 0;
	                    this.frameNumbers.set(callback, frameNumber + 1);
	                    return frameNumber;
	                };
	                return TimerService;
	            }();
	            exports_1("TimerService", TimerService);
	            lastTime = 0;
	        }
	    };
	});
	$__System.register('e', ['c', 'f', '10', '9', 'd', '11', '12'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __extends = this && this.__extends || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, common_1, session_1, device_1, timer_1, reality_1, utils_1;
	    var EmptyRealityLoader;
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (common_1_1) {
	            common_1 = common_1_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	        }, function (device_1_1) {
	            device_1 = device_1_1;
	        }, function (timer_1_1) {
	            timer_1 = timer_1_1;
	        }, function (reality_1_1) {
	            reality_1 = reality_1_1;
	        }, function (utils_1_1) {
	            utils_1 = utils_1_1;
	        }],
	        execute: function () {
	            EmptyRealityLoader = function (_super) {
	                __extends(EmptyRealityLoader, _super);
	                function EmptyRealityLoader(sessionService, deviceService, timer) {
	                    _super.call(this);
	                    this.sessionService = sessionService;
	                    this.deviceService = deviceService;
	                    this.timer = timer;
	                    this.type = 'empty';
	                }
	                EmptyRealityLoader.prototype.load = function (reality, callback) {
	                    var _this = this;
	                    var realitySession = this.sessionService.addManagedSessionPort(reality.uri);
	                    var remoteRealitySession = this.sessionService.createSessionPort();
	                    var doUpdate = true;
	                    remoteRealitySession.on['ar.context.update'] = function () {};
	                    remoteRealitySession.connectEvent.addEventListener(function () {
	                        var update = function (time, index) {
	                            if (doUpdate) {
	                                _this.deviceService.update();
	                                var frameState = {
	                                    time: time,
	                                    index: index,
	                                    eye: {
	                                        pose: utils_1.getSerializedEntityPose(_this.deviceService.displayEntity, time)
	                                    }
	                                };
	                                remoteRealitySession.send('ar.reality.frameState', frameState);
	                                _this.timer.requestFrame(update);
	                            }
	                        };
	                        _this.timer.requestFrame(update);
	                    });
	                    remoteRealitySession.closeEvent.addEventListener(function () {
	                        doUpdate = false;
	                    });
	                    callback(realitySession);
	                    // Only connect after the caller is able to attach connectEvent handlers
	                    var messageChannel = this.sessionService.createSynchronousMessageChannel();
	                    realitySession.open(messageChannel.port1, this.sessionService.configuration);
	                    remoteRealitySession.open(messageChannel.port2, { role: common_1.Role.REALITY_VIEW });
	                };
	                EmptyRealityLoader = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, device_1.DeviceService, timer_1.TimerService)], EmptyRealityLoader);
	                return EmptyRealityLoader;
	            }(reality_1.RealityLoader);
	            exports_1("EmptyRealityLoader", EmptyRealityLoader);
	        }
	    };
	});
	$__System.register('13', ['c', '14', '10', '12'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __extends = this && this.__extends || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, focus_1, session_1, utils_1;
	    var VuforiaInitResult, VuforiaHint, VuforiaServiceDelegateBase, VuforiaServiceDelegate, VuforiaService, VuforiaAPI, VuforiaTracker, VuforiaObjectTracker, VuforiaDataSet;
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (focus_1_1) {
	            focus_1 = focus_1_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	        }, function (utils_1_1) {
	            utils_1 = utils_1_1;
	        }],
	        execute: function () {
	            /**
	             * The set of possible error codes that can be returned from vuforia's
	             * initialization function.
	             */
	            (function (VuforiaInitResult) {
	                VuforiaInitResult[VuforiaInitResult["SUCCESS"] = 100] = "SUCCESS";
	                /** Error during initialization. */
	                VuforiaInitResult[VuforiaInitResult["INIT_ERROR"] = -1] = "INIT_ERROR";
	                /** The device is not supported. */
	                VuforiaInitResult[VuforiaInitResult["INIT_DEVICE_NOT_SUPPORTED"] = -2] = "INIT_DEVICE_NOT_SUPPORTED";
	                /** Cannot access the camera. */
	                VuforiaInitResult[VuforiaInitResult["INIT_NO_CAMERA_ACCESS"] = -3] = "INIT_NO_CAMERA_ACCESS";
	                /** License key is missing. */
	                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_MISSING_KEY"] = -4] = "INIT_LICENSE_ERROR_MISSING_KEY";
	                /** Invalid license key passed to SDK. */
	                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_INVALID_KEY"] = -5] = "INIT_LICENSE_ERROR_INVALID_KEY";
	                /** Unable to verify license key due to network (Permanent error). */
	                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_NO_NETWORK_PERMANENT"] = -6] = "INIT_LICENSE_ERROR_NO_NETWORK_PERMANENT";
	                /** Unable to verify license key due to network (Transient error). */
	                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_NO_NETWORK_TRANSIENT"] = -7] = "INIT_LICENSE_ERROR_NO_NETWORK_TRANSIENT";
	                /** Provided key is no longer valid. */
	                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_CANCELED_KEY"] = -8] = "INIT_LICENSE_ERROR_CANCELED_KEY";
	                /** Provided key is not valid for this product. */
	                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_PRODUCT_TYPE_MISMATCH"] = -9] = "INIT_LICENSE_ERROR_PRODUCT_TYPE_MISMATCH";
	                /** Dependent external device not detected/plugged in. */
	                VuforiaInitResult[VuforiaInitResult["INIT_EXTERNAL_DEVICE_NOT_DETECTED"] = -10] = "INIT_EXTERNAL_DEVICE_NOT_DETECTED";
	            })(VuforiaInitResult || (VuforiaInitResult = {}));
	            exports_1("VuforiaInitResult", VuforiaInitResult);
	            (function (VuforiaHint) {
	                VuforiaHint[VuforiaHint["MaxSimultaneousImageTargets"] = 0] = "MaxSimultaneousImageTargets";
	                VuforiaHint[VuforiaHint["MaxSimultaneousObjectTargets"] = 1] = "MaxSimultaneousObjectTargets";
	                VuforiaHint[VuforiaHint["DelayedLoadingObjectDatasets"] = 2] = "DelayedLoadingObjectDatasets";
	            })(VuforiaHint || (VuforiaHint = {}));
	            exports_1("VuforiaHint", VuforiaHint);
	            /**
	             * An abstract class representing the Vuforia API.
	             */
	            VuforiaServiceDelegateBase = function () {
	                function VuforiaServiceDelegateBase() {
	                    this.stateUpdateEvent = new utils_1.Event();
	                }
	                return VuforiaServiceDelegateBase;
	            }();
	            exports_1("VuforiaServiceDelegateBase", VuforiaServiceDelegateBase);
	            /**
	             * An no-op implementation of VuforiaServiceDelegate.
	             */
	            VuforiaServiceDelegate = function (_super) {
	                __extends(VuforiaServiceDelegate, _super);
	                function VuforiaServiceDelegate() {
	                    _super.apply(this, arguments);
	                }
	                VuforiaServiceDelegate.prototype.isAvailable = function () {
	                    return false;
	                };
	                VuforiaServiceDelegate.prototype.setHint = function (hint, value) {
	                    return true;
	                };
	                VuforiaServiceDelegate.prototype.decryptLicenseKey = function (encryptedLicenseData, session) {
	                    return Promise.resolve(undefined);
	                };
	                VuforiaServiceDelegate.prototype.init = function (options) {
	                    return Promise.resolve(VuforiaInitResult.SUCCESS);
	                };
	                VuforiaServiceDelegate.prototype.deinit = function () {};
	                VuforiaServiceDelegate.prototype.cameraDeviceInitAndStart = function () {
	                    return true;
	                };
	                VuforiaServiceDelegate.prototype.cameraDeviceSetFlashTorchMode = function (on) {
	                    return true;
	                };
	                VuforiaServiceDelegate.prototype.objectTrackerInit = function () {
	                    return true;
	                };
	                VuforiaServiceDelegate.prototype.objectTrackerCreateDataSet = function (url) {
	                    return '';
	                };
	                VuforiaServiceDelegate.prototype.objectTrackerDestroyDataSet = function (id) {
	                    return true;
	                };
	                VuforiaServiceDelegate.prototype.objectTrackerActivateDataSet = function (id) {
	                    return true;
	                };
	                VuforiaServiceDelegate.prototype.objectTrackerDeactivateDataSet = function (id) {
	                    return true;
	                };
	                VuforiaServiceDelegate.prototype.dataSetFetch = function (id) {
	                    return Promise.resolve(undefined);
	                };
	                VuforiaServiceDelegate.prototype.dataSetLoad = function (id) {
	                    return Promise.resolve();
	                };
	                return VuforiaServiceDelegate;
	            }(VuforiaServiceDelegateBase);
	            exports_1("VuforiaServiceDelegate", VuforiaServiceDelegate);
	            /**
	             * Mediates requests to the Vuforia API. Handles the following requests:
	             * // TODO
	             */
	            VuforiaService = function () {
	                function VuforiaService(sessionService, focusService, delegate) {
	                    var _this = this;
	                    this.sessionService = sessionService;
	                    this.focusService = focusService;
	                    this.delegate = delegate;
	                    this._sessionSwitcherCommandQueue = new utils_1.CommandQueue();
	                    this._sessionCommandQueue = new WeakMap();
	                    this._sessionInitOptions = new WeakMap();
	                    this._sessionInitPromise = new WeakMap();
	                    this._sessionIsInitialized = new WeakMap();
	                    this._sessionCreatedDataSets = new WeakMap();
	                    this._sessionActivatedDataSets = new WeakMap();
	                    if (sessionService.isRealityManager) {
	                        this._sessionSwitcherCommandQueue.errorEvent.addEventListener(function (err) {
	                            _this.sessionService.errorEvent.raiseEvent(err);
	                        });
	                        sessionService.connectEvent.addEventListener(function (session) {
	                            var commandQueue = new utils_1.CommandQueue();
	                            commandQueue.errorEvent.addEventListener(function (err) {
	                                _this.sessionService.errorEvent.raiseEvent(err);
	                                session.sendError(err);
	                            });
	                            _this._sessionCommandQueue.set(session, commandQueue);
	                            var createdDataSets = new Set();
	                            _this._sessionCreatedDataSets.set(session, createdDataSets);
	                            var activatedDataSets = new Set();
	                            _this._sessionActivatedDataSets.set(session, activatedDataSets);
	                            session.on['ar.vuforia.isAvailable'] = function () {
	                                return Promise.resolve({ available: delegate.isAvailable() });
	                            };
	                            session.on['ar.vuforia.init'] = function (options) {
	                                if (!delegate.isAvailable()) throw new Error("Vuforia is not supported");
	                                if (_this._sessionIsInitialized.get(session)) throw new Error("Vuforia has already been initialized");
	                                if (!options.key && !options.encryptedLicenseData) throw new Error("Expected `encryptedLicenseData` field. You can encrypt your Vuforia license key at http://docs.argonjs.io/start/vuforia-pgp-encryptor");
	                                var keyPromise = options.key ? Promise.resolve(options.key) : delegate.decryptLicenseKey(options.encryptedLicenseData, session);
	                                return keyPromise.then(function (key) {
	                                    _this._sessionInitOptions.set(session, {
	                                        key: key
	                                    });
	                                    var result = commandQueue.push(function () {
	                                        return _this._init(session).then(function () {
	                                            _this._sessionIsInitialized.set(session, true);
	                                        });
	                                    }, _this._controllingSession === session);
	                                    if (_this.focusService.getSession() === session) {
	                                        _this._setControllingSession(session);
	                                    }
	                                    _this._sessionInitPromise.set(session, result);
	                                    return result;
	                                });
	                            };
	                            session.on['ar.vuforia.objectTrackerCreateDataSet'] = function (_a) {
	                                var url = _a.url;
	                                return commandQueue.push(function () {
	                                    var id = delegate.objectTrackerCreateDataSet(url);
	                                    if (id) {
	                                        createdDataSets.add(id);
	                                        return Promise.resolve({ id: id });
	                                    }
	                                    throw new Error('Unable to create DataSet');
	                                }, _this._controllingSession === session);
	                            };
	                            session.on['ar.vuforia.objectTrackerActivateDataSet'] = function (_a) {
	                                var id = _a.id;
	                                return commandQueue.push(function () {
	                                    if (delegate.objectTrackerActivateDataSet(id)) {
	                                        activatedDataSets.add(id);
	                                        session.send('ar.vuforia.objectTrackerActivateDataSetEvent', { id: id });
	                                        return;
	                                    }
	                                    throw new Error("Unable to activate DataSet (" + id + ")");
	                                }, _this._controllingSession === session);
	                            };
	                            session.on['ar.vuforia.objectTrackerDeactivateDataSet'] = function (_a) {
	                                var id = _a.id;
	                                return commandQueue.push(function () {
	                                    if (delegate.objectTrackerDeactivateDataSet(id)) {
	                                        activatedDataSets.delete(id);
	                                        session.send('ar.vuforia.objectTrackerDeactivateDataSetEvent', { id: id });
	                                        return;
	                                    }
	                                    throw new Error("Unable to deactivate DataSet (" + id + ")");
	                                }, _this._controllingSession === session);
	                            };
	                            session.on['ar.vuforia.dataSetFetch'] = function (_a) {
	                                var id = _a.id;
	                                return commandQueue.push(function () {
	                                    return delegate.dataSetFetch(id);
	                                }, _this._controllingSession === session);
	                            };
	                            session.on['ar.vuforia.dataSetLoad'] = function (_a) {
	                                var id = _a.id;
	                                return commandQueue.push(function () {
	                                    return delegate.dataSetLoad(id);
	                                }, _this._controllingSession === session);
	                            };
	                            session.closeEvent.addEventListener(function () {
	                                if (_this._controllingSession === session) {
	                                    commandQueue.clear();
	                                    commandQueue.push(function () {
	                                        _this._cleanupSession(session);
	                                        setTimeout(function () {
	                                            _this._ensureActiveSession();
	                                        }, 2000);
	                                    }, true);
	                                } else {
	                                    _this._cleanupSession(session);
	                                }
	                            });
	                        });
	                        focusService.sessionFocusEvent.addEventListener(function (_a) {
	                            var current = _a.current;
	                            if (current && _this._sessionInitOptions.get(current)) {
	                                _this._setControllingSession(current);
	                            }
	                        });
	                    }
	                }
	                ;
	                VuforiaService.prototype.isAvailable = function () {
	                    return this.sessionService.manager.request('ar.vuforia.isAvailable').then(function (message) {
	                        return message.available;
	                    });
	                };
	                /**
	                 * Initialize vuforia with an unecrypted key. Manager-only, unless the "force" (flag) is used.
	                 * It's a bad idea to publish your private vuforia key on the internet.
	                 */
	                VuforiaService.prototype.initWithUnencryptedKey = function (options, force) {
	                    var _this = this;
	                    if (!force) this.sessionService.ensureIsRealityManager();
	                    return this.sessionService.manager.request('ar.vuforia.init', options).then(function () {
	                        return new VuforiaAPI(_this.sessionService.manager);
	                    });
	                };
	                /**
	                 * Initialize vuforia using an encrypted license key.
	                 * You can encrypt your license key at http://docs.argonjs.io/start/vuforia-pgp-encryptor
	                 */
	                VuforiaService.prototype.init = function (options) {
	                    var _this = this;
	                    if (!options.encryptedLicenseData || typeof options.encryptedLicenseData !== 'string') throw new Error('options.encryptedLicenseData is required.');
	                    return this.sessionService.manager.request('ar.vuforia.init', options).then(function () {
	                        return new VuforiaAPI(_this.sessionService.manager);
	                    });
	                };
	                VuforiaService.prototype._ensureActiveSession = function () {
	                    console.log("VuforiaService: Ensuring an active session is in control.");
	                    if (this._controllingSession && this._controllingSession.isConnected) return;
	                    this._selectControllingSession();
	                };
	                VuforiaService.prototype._selectControllingSession = function () {
	                    var focusSession = this.focusService.getSession();
	                    if (focusSession && this._sessionInitOptions.get(focusSession)) {
	                        this._setControllingSession(focusSession);
	                        return;
	                    }
	                    for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
	                        var session = _a[_i];
	                        if (this._sessionInitOptions.get(session)) {
	                            this._setControllingSession(session);
	                            return;
	                        }
	                    }
	                    if (this._sessionInitOptions.get(this.sessionService.manager)) this._setControllingSession(this.sessionService.manager);
	                };
	                VuforiaService.prototype._setControllingSession = function (session) {
	                    var _this = this;
	                    if (this._controllingSession === session) return;
	                    console.log("VuforiaService: Setting controlling session to " + session.uri);
	                    this._sessionSwitcherCommandQueue.clear();
	                    this._sessionSwitcherCommandQueue.push(function () {
	                        return _this._pauseSession().then(function () {
	                            return _this._resumeSession(session);
	                        });
	                    }, true);
	                };
	                VuforiaService.prototype._resumeSession = function (session) {
	                    if (this._controllingSession) throw new Error('Attempted to resume a session while a session is still in control');
	                    if (session) console.log("VuforiaService: Resuming session " + session.uri);
	                    var initOptions = this._sessionInitOptions.get(session);
	                    if (!initOptions) {
	                        throw new Error('Attempted to resume a session without initialization options');
	                    }
	                    this._controllingSession = session;
	                    var commandQueue = this._sessionCommandQueue.get(session);
	                    if (this._sessionIsInitialized.get(session)) {
	                        return this._init(session).then(function () {
	                            commandQueue.execute();
	                        }).catch(function (err) {
	                            session.sendError(err);
	                        });
	                    } else {
	                        commandQueue.execute();
	                        return this._sessionInitPromise.get(session);
	                    }
	                };
	                VuforiaService.prototype._pauseSession = function () {
	                    var _this = this;
	                    var session = this._controllingSession;
	                    if (!session) return Promise.resolve(undefined);
	                    console.log("VuforiaService: Pausing session " + session.uri);
	                    var commandQueue = this._sessionCommandQueue.get(session);
	                    return commandQueue.push(function () {
	                        commandQueue.pause();
	                        _this._controllingSession = undefined;
	                        return _this._deinit(session);
	                    }, true);
	                };
	                VuforiaService.prototype._cleanupSession = function (session) {
	                    var _this = this;
	                    if (!this._sessionInitOptions.has(session)) return;
	                    // delete session init options
	                    this._sessionInitOptions.delete(session);
	                    var createdDataSets = this._sessionCreatedDataSets.get(session);
	                    // Deactivate session datasets / trackables
	                    console.log('VuforiaService: Deactivating datasets for session ' + session.uri);
	                    this._sessionActivatedDataSets.get(session).forEach(function (id) {
	                        _this.delegate.objectTrackerDeactivateDataSet(id);
	                    });
	                    this._sessionActivatedDataSets.delete(session);
	                    // destroy session objects                   
	                    console.log('VuforiaService: Destroying objects for session ' + session.uri);
	                    createdDataSets.forEach(function (id) {
	                        _this.delegate.objectTrackerDestroyDataSet(id);
	                    });
	                    this._sessionCreatedDataSets.delete(session);
	                };
	                VuforiaService.prototype._init = function (session) {
	                    var _this = this;
	                    console.log("Attempting to initialize vuforia for " + session.uri);
	                    var options = this._sessionInitOptions.get(session);
	                    return this.delegate.init(options).then(function (initResult) {
	                        if (initResult !== VuforiaInitResult.SUCCESS) {
	                            throw new Error("Vuforia init failed: " + VuforiaInitResult[initResult]);
	                        }
	                        // must initialize trackers before initializing the camera device
	                        if (!_this.delegate.objectTrackerInit()) {
	                            throw new Error("Vuforia init failed: Unable to initialize ObjectTracker");
	                        }
	                        // restore active datasets & trackables
	                        var success = true;
	                        _this._sessionActivatedDataSets.get(session).forEach(function (id) {
	                            success = success && _this.delegate.objectTrackerActivateDataSet(id);
	                            if (success) {
	                                session.send('ar.vuforia.objectTrackerActivateDataSetEvent', { id: id });
	                            }
	                        });
	                        if (!success) {
	                            throw new Error("Vuforia init failed: Unable to restore active datasets");
	                        }
	                        // todo: also activate datasets / trackables created by other sessions
	                        // (if this fails, then vuforia has probably started forbidding datasets created 
	                        // by one developer account to work while using a license key from a different
	                        // developer account, so no need to return a rejected promise in that case)
	                        if (!_this.delegate.cameraDeviceInitAndStart()) {
	                            throw new Error("Vuforia init failed: Unable to complete initialization");
	                        }
	                        console.log("Vuforia init success");
	                    }).catch(function (err) {
	                        console.log("Vuforia init fail: " + err.message);
	                        _this._sessionInitOptions.delete(session);
	                        _this._sessionIsInitialized.set(session, false);
	                        _this._deinit(session);
	                        _this._ensureActiveSession();
	                        throw err;
	                    });
	                };
	                VuforiaService.prototype._deinit = function (session) {
	                    // Deactivate any activated datasets, stop trackers, and deinit. 
	                    // Don't actually destroy created resources so we can use them to restore state. 
	                    var _this = this;
	                    var activatedDataSets = this._sessionActivatedDataSets.get(session);
	                    if (activatedDataSets) {
	                        activatedDataSets.forEach(function (id) {
	                            _this.delegate.objectTrackerDeactivateDataSet(id);
	                            session.send('ar.vuforia.objectTrackerDeactivateDataSetEvent', { id: id });
	                        });
	                    }
	                    // right now the delegate.deinit() call deinitiailizes trackers and camera device for us. 
	                    // May want to move here instead?
	                    // const errors:Array<string> = [];
	                    // if (!this.delegate.objectTrackerDeinit()) {
	                    //     errors.push("Unable to deinitialize ObjectTracker");
	                    // } 
	                    // if (!this.delegate.cameraDeviceDeinit()) {
	                    //     errors.push("Unable to deinitialize CameraDevice");
	                    // }
	                    this.delegate.deinit();
	                    // if (errors.length > 0) {
	                    //     throw new Error(errors.join('\n'));
	                    // }
	                };
	                VuforiaService = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, focus_1.FocusService, VuforiaServiceDelegate)], VuforiaService);
	                return VuforiaService;
	            }();
	            exports_1("VuforiaService", VuforiaService);
	            VuforiaAPI = function () {
	                function VuforiaAPI(manager) {
	                    this.objectTracker = new VuforiaObjectTracker(manager);
	                }
	                return VuforiaAPI;
	            }();
	            exports_1("VuforiaAPI", VuforiaAPI);
	            VuforiaTracker = function () {
	                function VuforiaTracker() {}
	                return VuforiaTracker;
	            }();
	            exports_1("VuforiaTracker", VuforiaTracker);
	            /**
	             * Vuforia Object Tracker
	             */
	            VuforiaObjectTracker = function (_super) {
	                __extends(VuforiaObjectTracker, _super);
	                function VuforiaObjectTracker(manager) {
	                    var _this = this;
	                    _super.call(this);
	                    this.manager = manager;
	                    this._dataSetMap = new Map();
	                    this.dataSetActivateEvent = new utils_1.Event();
	                    this.dataSetDeactivateEvent = new utils_1.Event();
	                    manager.on['ar.vuforia.objectTrackerActivateDataSetEvent'] = function (_a) {
	                        var id = _a.id;
	                        var dataSet = _this._dataSetMap.get(id);
	                        dataSet._onActivate();
	                        _this.dataSetActivateEvent.raiseEvent(dataSet);
	                    };
	                    manager.on['ar.vuforia.objectTrackerDeactivateDataSetEvent'] = function (_a) {
	                        var id = _a.id;
	                        var dataSet = _this._dataSetMap.get(id);
	                        dataSet._onDeactivate();
	                        _this.dataSetDeactivateEvent.raiseEvent(dataSet);
	                    };
	                }
	                VuforiaObjectTracker.prototype.createDataSet = function (url) {
	                    var _this = this;
	                    if (url && window.document) {
	                        url = utils_1.resolveURL(url);
	                    }
	                    return this.manager.request('ar.vuforia.objectTrackerCreateDataSet', { url: url }).then(function (message) {
	                        var dataSet = new VuforiaDataSet(message.id, _this.manager);
	                        _this._dataSetMap.set(message.id, dataSet);
	                        return dataSet;
	                    });
	                };
	                VuforiaObjectTracker.prototype.activateDataSet = function (dataSet) {
	                    return this.manager.request('ar.vuforia.objectTrackerActivateDataSet', { id: dataSet.id });
	                };
	                VuforiaObjectTracker.prototype.deactivateDataSet = function (dataSet) {
	                    return this.manager.request('ar.vuforia.objectTrackerDeactivateDataSet', { id: dataSet.id });
	                };
	                return VuforiaObjectTracker;
	            }(VuforiaTracker);
	            exports_1("VuforiaObjectTracker", VuforiaObjectTracker);
	            /**
	             * A vuforia data set. TODO
	             */
	            VuforiaDataSet = function () {
	                function VuforiaDataSet(id, manager) {
	                    this.id = id;
	                    this.manager = manager;
	                    this._isActive = false;
	                }
	                VuforiaDataSet.prototype._onActivate = function () {
	                    this._isActive = true;
	                };
	                VuforiaDataSet.prototype._onDeactivate = function () {
	                    this._isActive = false;
	                };
	                VuforiaDataSet.prototype.fetch = function () {
	                    return this.manager.request('ar.vuforia.dataSetFetch', { id: this.id }).then(function () {});
	                };
	                VuforiaDataSet.prototype.load = function () {
	                    var _this = this;
	                    return this.manager.request('ar.vuforia.dataSetLoad', { id: this.id }).then(function (trackables) {
	                        _this._trackables = trackables;
	                        return trackables;
	                    });
	                };
	                VuforiaDataSet.prototype.isActive = function () {
	                    return this._isActive;
	                };
	                VuforiaDataSet.prototype.getTrackables = function () {
	                    return this._trackables;
	                };
	                return VuforiaDataSet;
	            }();
	            exports_1("VuforiaDataSet", VuforiaDataSet);
	        }
	    };
	});
	$__System.register('15', ['c', 'f', '10', '11', '13'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __extends = this && this.__extends || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, common_1, session_1, reality_1, vuforia_1;
	    var LiveVideoRealityLoader;
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (common_1_1) {
	            common_1 = common_1_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	        }, function (reality_1_1) {
	            reality_1 = reality_1_1;
	        }, function (vuforia_1_1) {
	            vuforia_1 = vuforia_1_1;
	        }],
	        execute: function () {
	            LiveVideoRealityLoader = function (_super) {
	                __extends(LiveVideoRealityLoader, _super);
	                function LiveVideoRealityLoader(sessionService, vuforiaDelegate) {
	                    _super.call(this);
	                    this.sessionService = sessionService;
	                    this.vuforiaDelegate = vuforiaDelegate;
	                    this.type = 'live-video';
	                }
	                LiveVideoRealityLoader.prototype.load = function (reality, callback) {
	                    var _this = this;
	                    var realitySession = this.sessionService.addManagedSessionPort(reality.uri);
	                    var remoteRealitySession = this.sessionService.createSessionPort();
	                    remoteRealitySession.on['ar.context.update'] = function () {};
	                    remoteRealitySession.connectEvent.addEventListener(function () {
	                        var remove = _this.vuforiaDelegate.stateUpdateEvent.addEventListener(function (frameState) {
	                            remoteRealitySession.send('ar.reality.frameState', frameState);
	                        });
	                        _this.vuforiaDelegate.videoEnabled = true;
	                        _this.vuforiaDelegate.trackingEnabled = true;
	                        remoteRealitySession.closeEvent.addEventListener(function () {
	                            remove();
	                            _this.vuforiaDelegate.videoEnabled = false;
	                            _this.vuforiaDelegate.trackingEnabled = false;
	                        });
	                    });
	                    callback(realitySession);
	                    // Only connect after the caller is able to attach connectEvent handlers
	                    var messageChannel = this.sessionService.createSynchronousMessageChannel();
	                    realitySession.open(messageChannel.port1, this.sessionService.configuration);
	                    remoteRealitySession.open(messageChannel.port2, { role: common_1.Role.REALITY_VIEW });
	                };
	                LiveVideoRealityLoader = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, vuforia_1.VuforiaServiceDelegate)], LiveVideoRealityLoader);
	                return LiveVideoRealityLoader;
	            }(reality_1.RealityLoader);
	            exports_1("LiveVideoRealityLoader", LiveVideoRealityLoader);
	        }
	    };
	});
	$__System.register('b', ['c', 'a', '10', '11', '12'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, cesium_imports_1, session_1, reality_1, utils_1;
	    var PoseStatus, scratchCartesian3, scratchQuaternion, scratchOriginCartesian3, ContextService;
	    function _stringFromReferenceFrame(referenceFrame) {
	        var rf = referenceFrame;
	        return cesium_imports_1.defined(rf.id) ? rf.id : '' + rf;
	    }
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (cesium_imports_1_1) {
	            cesium_imports_1 = cesium_imports_1_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	        }, function (reality_1_1) {
	            reality_1 = reality_1_1;
	        }, function (utils_1_1) {
	            utils_1 = utils_1_1;
	        }],
	        execute: function () {
	            /**
	            * A bitmask that provides metadata about the pose of an EntityPose.
	            *   KNOWN - the pose of the entity state is defined.
	            *   KNOWN & FOUND - the pose was undefined when the entity state was last queried, and is now defined.
	            *   LOST - the pose was defined when the entity state was last queried, and is now undefined
	            */
	            (function (PoseStatus) {
	                PoseStatus[PoseStatus["KNOWN"] = 1] = "KNOWN";
	                PoseStatus[PoseStatus["FOUND"] = 2] = "FOUND";
	                PoseStatus[PoseStatus["LOST"] = 4] = "LOST";
	            })(PoseStatus || (PoseStatus = {}));
	            exports_1("PoseStatus", PoseStatus);
	            scratchCartesian3 = new cesium_imports_1.Cartesian3(0, 0);
	            scratchQuaternion = new cesium_imports_1.Quaternion(0, 0);
	            scratchOriginCartesian3 = new cesium_imports_1.Cartesian3(0, 0);
	            /**
	             * Provides a means of querying the current state of reality.
	             *
	             * This class adds the following message handlers to any sessions
	             * managed by the session service:
	             *
	             *  * `ar.context.subscribe` - Subscribes the session to updates from an
	             *    entity with the provided id.
	             *    * Parameters:
	             *      * id: string - The id of an entity the session wishes to recieve
	             *        updates on.
	             *
	             * This service sends the following messages to managed sessions
	             *
	             *  * `ar.context.update` - Indicates to this context that the session wants
	             *    to be focused on.
	             */
	            ContextService = function () {
	                function ContextService(sessionService, realityService) {
	                    var _this = this;
	                    this.sessionService = sessionService;
	                    this.realityService = realityService;
	                    /**
	                     * An event that is raised when all remotely managed entities are are up-to-date for
	                     * the current frame. It is suggested that all modifications to locally managed entities
	                     * should occur within this event.
	                     */
	                    this.updateEvent = new utils_1.Event();
	                    /**
	                     * An event that is raised when it is an approriate time to render graphics.
	                     * This event fires after the update event.
	                     */
	                    this.renderEvent = new utils_1.Event();
	                    /**
	                     * The set of entities representing well-known reference frames.
	                     * These are assumed to be readily available to applications.
	                     */
	                    this.wellKnownReferenceFrames = new cesium_imports_1.EntityCollection();
	                    /**
	                     * The set of subscribed entities.
	                     */
	                    this.subscribedEntities = new cesium_imports_1.EntityCollection();
	                    /**
	                     * The set of entities that this session is aware of.
	                     */
	                    this.entities = new cesium_imports_1.CompositeEntityCollection();
	                    /**
	                     * An event that fires when the local origin changes.
	                     */
	                    this.localOriginChangeEvent = new utils_1.Event();
	                    /**
	                     * An entity representing the location and orientation of the user.
	                     */
	                    this.user = new cesium_imports_1.Entity({
	                        id: 'ar.user',
	                        name: 'user',
	                        position: new cesium_imports_1.ConstantPositionProperty(undefined, cesium_imports_1.ReferenceFrame.FIXED),
	                        orientation: new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.IDENTITY)
	                    });
	                    /**
	                     * An entity positioned near the user, aligned with the local East-North-Up
	                     * coordinate system.
	                     */
	                    this.localOriginEastNorthUp = new cesium_imports_1.Entity({
	                        id: 'ar.localENU',
	                        name: 'localOriginENU',
	                        position: new cesium_imports_1.ConstantPositionProperty(undefined, cesium_imports_1.ReferenceFrame.FIXED),
	                        orientation: new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.IDENTITY)
	                    });
	                    /**
	                     * An entity positioned near the user, aligned with the East-Up-South
	                     * coordinate system. This useful for converting to the Y-Up convention
	                     * used in some libraries, such as three.js.
	                     */
	                    this.localOriginEastUpSouth = new cesium_imports_1.Entity({
	                        id: 'ar.localEUS',
	                        name: 'localOriginEUS',
	                        position: new cesium_imports_1.ConstantPositionProperty(cesium_imports_1.Cartesian3.ZERO, this.localOriginEastNorthUp),
	                        orientation: new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_X, Math.PI / 2))
	                    });
	                    /**
	                     * This value caps the deltaTime for each frame
	                     */
	                    this.maxDeltaTime = 1 / 3 * 1000;
	                    this._frame = {
	                        time: new cesium_imports_1.JulianDate(0, 0),
	                        systemTime: 0,
	                        deltaTime: 0
	                    };
	                    // The default origin to use when calling `getEntityPose`.
	                    this._defaultReferenceFrame = this.localOriginEastNorthUp;
	                    this._entityPoseCache = {};
	                    this._entityPoseMap = new Map();
	                    this._subscribedEntities = new WeakMap();
	                    this._updatingEntities = new Set();
	                    this._knownEntities = new Set();
	                    this.entities.addCollection(this.wellKnownReferenceFrames);
	                    this.entities.addCollection(this.subscribedEntities);
	                    this.subscribedEntities.add(this.user);
	                    if (this.sessionService.isRealityManager) {
	                        this.realityService.frameEvent.addEventListener(function (state) {
	                            _this._update(state);
	                        });
	                        this.sessionService.connectEvent.addEventListener(function (session) {
	                            _this._subscribedEntities.set(session, new Set());
	                            session.on['ar.context.subscribe'] = function (_a) {
	                                var id = _a.id;
	                                var subscriptions = _this._subscribedEntities.get(session);
	                                if (subscriptions) subscriptions.add(id);
	                            };
	                        });
	                    } else {
	                        this.sessionService.manager.on['ar.context.update'] = function (state) {
	                            _this._update(state);
	                        };
	                    }
	                }
	                Object.defineProperty(ContextService.prototype, "frame", {
	                    /**
	                     * The current frame
	                     */
	                    get: function () {
	                        if (!cesium_imports_1.defined(this.serializedFrameState)) throw new Error('A frame state has not yet been received');
	                        return this._frame;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ContextService.prototype, "serializedFrameState", {
	                    /**
	                     * The serialized frame state for this frame
	                     */
	                    get: function () {
	                        return this._serializedState;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Get the current time
	                 */
	                ContextService.prototype.getTime = function () {
	                    return this.frame.time;
	                };
	                /**
	                 * Set the default reference frame for `getCurrentEntityState`.
	                 */
	                ContextService.prototype.setDefaultReferenceFrame = function (origin) {
	                    this._defaultReferenceFrame = origin;
	                };
	                /**
	                 * Get the default reference frame to use when calling `getEntityPose`.
	                 * By default, this is the `localOriginEastNorthUp` reference frame.
	                 */
	                ContextService.prototype.getDefaultReferenceFrame = function () {
	                    return this._defaultReferenceFrame;
	                };
	                /**
	                 * Adds an entity to this session's set of tracked entities.
	                 *
	                 * @param id - The unique identifier of an entity.
	                 * @returns The entity that was subscribed to.
	                 */
	                ContextService.prototype.subscribeToEntityById = function (id) {
	                    this.sessionService.manager.send('ar.context.subscribe', { id: id });
	                    return this.subscribedEntities.getOrCreateEntity(id);
	                };
	                /**
	                 * Gets the current pose of an entity, relative to a given reference frame.
	                 *
	                 * @param entity - The entity whose state is to be queried.
	                 * @param referenceFrame - The intended reference frame. Defaults to `this.defaultReferenceFrame`.
	                 * @returns If the position and orientation exist for the given entity, an
	                 * object with the fields `position` and `orientation`, both of type
	                 * `Cartesian3`. Otherwise undefined.
	                 */
	                ContextService.prototype.getEntityPose = function (entity, referenceFrame) {
	                    if (referenceFrame === void 0) {
	                        referenceFrame = this._defaultReferenceFrame;
	                    }
	                    var time = this.getTime();
	                    var key = entity.id + '@' + _stringFromReferenceFrame(referenceFrame);
	                    var entityPose = this._entityPoseMap.get(key);
	                    if (!cesium_imports_1.defined(entityPose)) {
	                        entityPose = {
	                            position: new cesium_imports_1.Cartesian3(),
	                            orientation: new cesium_imports_1.Quaternion(),
	                            time: cesium_imports_1.JulianDate.clone(time),
	                            poseStatus: 0
	                        };
	                        this._entityPoseMap.set(key, entityPose);
	                    } else {
	                        cesium_imports_1.JulianDate.clone(time, entityPose.time);
	                    }
	                    var position = utils_1.getEntityPositionInReferenceFrame(entity, time, referenceFrame, entityPose.position);
	                    var orientation = utils_1.getEntityOrientationInReferenceFrame(entity, time, referenceFrame, entityPose.orientation);
	                    var hasPose = position && orientation;
	                    var poseStatus = 0;
	                    var previousStatus = entityPose.poseStatus;
	                    if (hasPose) {
	                        poseStatus |= PoseStatus.KNOWN;
	                    }
	                    if (hasPose && !(previousStatus & PoseStatus.KNOWN)) {
	                        poseStatus |= PoseStatus.FOUND;
	                    } else if (!hasPose && previousStatus & PoseStatus.KNOWN) {
	                        poseStatus |= PoseStatus.LOST;
	                    }
	                    entityPose.poseStatus = poseStatus;
	                    return entityPose;
	                };
	                /**
	                 * deprecated
	                 */
	                ContextService.prototype.getCurrentEntityState = function (entity, referenceFrame) {
	                    console.warn('getCurrentEntityState is deprecated. Use getEntityPose instead.');
	                    return this.getEntityPose(entity, referenceFrame);
	                };
	                // TODO: This function is called a lot. Potential for optimization. 
	                ContextService.prototype._update = function (serializedState) {
	                    var _this = this;
	                    // if this session is the manager, we need to update our child sessions a.s.a.p
	                    if (this.sessionService.isRealityManager) {
	                        delete serializedState.entities[this.user.id]; // children don't need this
	                        this._entityPoseCache = {};
	                        for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
	                            var session = _a[_i];
	                            this._sendUpdateForSession(serializedState, session);
	                        }
	                    }
	                    // our user entity is defined by the current view pose (the current reality must provide this)
	                    serializedState.entities[this.user.id] = serializedState.view.pose;
	                    // update the entities the manager knows about
	                    this._knownEntities.clear();
	                    for (var id in serializedState.entities) {
	                        this.updateEntityFromFrameState(id, serializedState);
	                        this._updatingEntities.add(id);
	                        this._knownEntities.add(id);
	                    }
	                    // if the mangager didn't send us an update for a particular entity,
	                    // assume the manager no longer knows about it
	                    this._updatingEntities.forEach(function (id) {
	                        if (!_this._knownEntities.has(id)) {
	                            var entity = _this.subscribedEntities.getById(id);
	                            entity.position = undefined;
	                            entity.orientation = undefined;
	                            // WORKAROUND until https://github.com/AnalyticalGraphicsInc/cesium/issues/4225 is fixed
	                            entity = _this.entities.getById(id);
	                            entity.position = undefined;
	                            entity.orientation = undefined;
	                            _this._updatingEntities.delete(id);
	                        }
	                    });
	                    // update our local origin
	                    this._updateLocalOrigin(serializedState);
	                    // update our frame object
	                    var frame = this._frame;
	                    var now = typeof performance !== 'undefined' ? performance.now() : Date.now();
	                    frame.deltaTime = Math.max(now - frame.systemTime, this.maxDeltaTime);
	                    frame.systemTime = now;
	                    cesium_imports_1.JulianDate.clone(serializedState.time, frame.time);
	                    this._serializedState = serializedState;
	                    // raise an event for the user update and render the scene
	                    this.updateEvent.raiseEvent(frame);
	                    this.renderEvent.raiseEvent(frame);
	                };
	                ContextService.prototype.updateEntityFromFrameState = function (id, state) {
	                    var entityPose = state.entities[id];
	                    if (!entityPose) {
	                        if (!this.wellKnownReferenceFrames.getById(id)) {
	                            this.subscribedEntities.getOrCreateEntity(id);
	                        }
	                        return;
	                    }
	                    var referenceFrame;
	                    if (cesium_imports_1.defined(entityPose.r)) {
	                        if (typeof entityPose.r === 'number') {
	                            referenceFrame = entityPose.r;
	                        } else {
	                            referenceFrame = this.entities.getById(entityPose.r);
	                        }
	                    } else {
	                        referenceFrame = cesium_imports_1.ReferenceFrame.FIXED;
	                    }
	                    if (!cesium_imports_1.defined(referenceFrame)) {
	                        this.updateEntityFromFrameState(entityPose.r, state);
	                        referenceFrame = this.entities.getById(entityPose.r);
	                    }
	                    var positionValue = entityPose.p === 0 ? cesium_imports_1.Cartesian3.ZERO : entityPose.p;
	                    var orientationValue = entityPose.o === 0 ? cesium_imports_1.Quaternion.IDENTITY : entityPose.o;
	                    var entity = this.subscribedEntities.getOrCreateEntity(id);
	                    var entityPosition = entity.position;
	                    var entityOrientation = entity.orientation;
	                    if (!entityPosition || entityPosition.referenceFrame !== referenceFrame) {
	                        entityPosition = new cesium_imports_1.ConstantPositionProperty(positionValue, referenceFrame);
	                        entity.position = entityPosition;
	                    } else if (entityPosition instanceof cesium_imports_1.ConstantPositionProperty) {
	                        entityPosition.setValue(positionValue, referenceFrame);
	                    } else if (entityPosition instanceof cesium_imports_1.SampledPositionProperty) {
	                        entityPosition.addSample(cesium_imports_1.JulianDate.clone(state.time), positionValue);
	                    }
	                    if (!entityOrientation) {
	                        entityOrientation = new cesium_imports_1.ConstantProperty(orientationValue);
	                        entity.orientation = entityOrientation;
	                    } else if (entityOrientation instanceof cesium_imports_1.ConstantProperty) {
	                        entityOrientation.setValue(orientationValue);
	                    } else if (entityOrientation instanceof cesium_imports_1.SampledProperty) {
	                        entityOrientation.addSample(cesium_imports_1.JulianDate.clone(state.time), orientationValue);
	                    }
	                    return entity;
	                };
	                ContextService.prototype.publishEntityState = function (entity, referenceFrame) {};
	                ContextService.prototype._updateLocalOrigin = function (state) {
	                    var userRootFrame = utils_1.getRootReferenceFrame(this.user);
	                    var userPosition = this.user.position && this.user.position.getValueInReferenceFrame(state.time, userRootFrame, scratchCartesian3);
	                    var localENUFrame = this.localOriginEastNorthUp.position && this.localOriginEastNorthUp.position.referenceFrame;
	                    var localENUPosition = this.localOriginEastNorthUp.position && localENUFrame && this.localOriginEastNorthUp.position.getValueInReferenceFrame(state.time, localENUFrame, scratchOriginCartesian3);
	                    if (userPosition && (!localENUPosition || localENUFrame !== userRootFrame || cesium_imports_1.Cartesian3.magnitudeSquared(cesium_imports_1.Cartesian3.subtract(userPosition, localENUPosition, scratchOriginCartesian3)) > 25000000)) {
	                        var localENUPositionProperty = this.localOriginEastNorthUp.position;
	                        var localENUOrientationProperty = this.localOriginEastNorthUp.orientation;
	                        localENUPositionProperty.setValue(userPosition, userRootFrame);
	                        if (userRootFrame === cesium_imports_1.ReferenceFrame.FIXED) {
	                            var enuOrientation = cesium_imports_1.Transforms.headingPitchRollQuaternion(userPosition, 0, 0, 0, undefined, scratchQuaternion);
	                            localENUOrientationProperty.setValue(enuOrientation);
	                        } else {
	                            localENUOrientationProperty.setValue(cesium_imports_1.Quaternion.IDENTITY);
	                        }
	                        this.localOriginChangeEvent.raiseEvent(undefined);
	                    }
	                };
	                ContextService.prototype._sendUpdateForSession = function (parentState, session) {
	                    var _this = this;
	                    var sessionPoseMap = {};
	                    for (var id in parentState.entities) {
	                        sessionPoseMap[id] = parentState.entities[id];
	                    }
	                    var subscriptions = this._subscribedEntities.get(session);
	                    subscriptions.forEach(function (id) {
	                        _this._addEntityAndAncestorsToPoseMap(sessionPoseMap, id, parentState.time);
	                    });
	                    var sessionState = {
	                        reality: parentState.reality,
	                        index: parentState.index,
	                        time: parentState.time,
	                        view: parentState.view,
	                        entities: sessionPoseMap,
	                        sendTime: cesium_imports_1.JulianDate.now()
	                    };
	                    session.send('ar.context.update', sessionState);
	                };
	                ContextService.prototype._addEntityAndAncestorsToPoseMap = function (poseMap, id, time) {
	                    if (!cesium_imports_1.defined(this._entityPoseCache[id])) {
	                        var entity = this.subscribedEntities.getById(id);
	                        if (!entity) return;
	                        this._entityPoseCache[id] = utils_1.getSerializedEntityPose(entity, time);
	                        if (entity.position && entity.position.referenceFrame instanceof cesium_imports_1.Entity) {
	                            var refId = _stringFromReferenceFrame(entity.position.referenceFrame);
	                            this._addEntityAndAncestorsToPoseMap(poseMap, refId, time);
	                        }
	                    }
	                    poseMap[id] = this._entityPoseCache[id];
	                };
	                ContextService = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, reality_1.RealityService)], ContextService);
	                return ContextService;
	            }();
	            exports_1("ContextService", ContextService);
	        }
	    };
	});
	$__System.register('14', ['c', '10', '12'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, session_1, utils_1;
	    var FocusService;
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	        }, function (utils_1_1) {
	            utils_1 = utils_1_1;
	        }],
	        execute: function () {
	            /**
	             * Manages focus state
	             */
	            FocusService = function () {
	                function FocusService(sessionService) {
	                    var _this = this;
	                    this.sessionService = sessionService;
	                    /**
	                     * An event that is raised when this session has gained focus
	                     */
	                    this.focusEvent = new utils_1.Event();
	                    /**
	                     * An event that is raised when this session has lost focus
	                     */
	                    this.blurEvent = new utils_1.Event();
	                    this._hasFocus = false;
	                    this._sessionFocusEvent = new utils_1.Event();
	                    sessionService.manager.on['ar.focus.state'] = function (message) {
	                        _this._setFocus(message.state);
	                    };
	                    if (sessionService.isRealityManager) {
	                        sessionService.manager.connectEvent.addEventListener(function () {
	                            setTimeout(function () {
	                                if (!_this._session) _this.setSession(_this.sessionService.manager);
	                            });
	                        });
	                    }
	                }
	                Object.defineProperty(FocusService.prototype, "hasFocus", {
	                    /**
	                     * True if this session has focus
	                     */
	                    get: function () {
	                        return this._hasFocus;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(FocusService.prototype, "sessionFocusEvent", {
	                    /**
	                     * Manager-only. An event that is raised when a managed session has acquired focus.
	                     */
	                    get: function () {
	                        this.sessionService.ensureIsRealityManager();
	                        return this._sessionFocusEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Manager-only. The managed session which currently has focus.
	                 */
	                FocusService.prototype.getSession = function () {
	                    this.sessionService.ensureIsRealityManager();
	                    return this._session;
	                };
	                /**
	                 *  Manager-only. Grant focus to a managed session.
	                 */
	                FocusService.prototype.setSession = function (session) {
	                    this.sessionService.ensureIsRealityManager();
	                    if (session && !session.isConnected) throw new Error('Only a connected session can be granted focus');
	                    var previousFocussedSession = this._session;
	                    if (previousFocussedSession !== session) {
	                        if (previousFocussedSession) previousFocussedSession.send('ar.focus.state', { state: false });
	                        if (session) session.send('ar.focus.state', { state: true });
	                        this._session = session;
	                        this.sessionFocusEvent.raiseEvent({
	                            previous: previousFocussedSession,
	                            current: session
	                        });
	                    }
	                };
	                FocusService.prototype.whenSessionHasFocus = function (session) {
	                    var _this = this;
	                    this.sessionService.ensureIsRealityManager();
	                    return new Promise(function (resolve) {
	                        var remove = _this.sessionFocusEvent.addEventListener(function (_a) {
	                            var current = _a.current;
	                            if (current === session) {
	                                remove();
	                                resolve();
	                            }
	                        });
	                    });
	                };
	                FocusService.prototype._setFocus = function (state) {
	                    if (this._hasFocus !== state) {
	                        this._hasFocus = state;
	                        if (state) {
	                            this.focusEvent.raiseEvent(undefined);
	                        } else {
	                            this.blurEvent.raiseEvent(undefined);
	                        }
	                    }
	                };
	                FocusService = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService)], FocusService);
	                return FocusService;
	            }();
	            exports_1("FocusService", FocusService);
	        }
	    };
	});
	(function() {
	var define = $__System.amdDefine;
	define("16", ["exports", "3"], function(exports, _aureliaPal) {
	  'use strict';
	  exports.__esModule = true;
	  var _extends = Object.assign || function(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.decorators = decorators;
	  exports.deprecated = deprecated;
	  exports.mixin = mixin;
	  exports.protocol = protocol;
	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError('Cannot call a class as a function');
	    }
	  }
	  var metadata = {
	    resource: 'aurelia:resource',
	    paramTypes: 'design:paramtypes',
	    properties: 'design:properties',
	    get: function get(metadataKey, target, targetKey) {
	      if (!target) {
	        return undefined;
	      }
	      var result = metadata.getOwn(metadataKey, target, targetKey);
	      return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
	    },
	    getOwn: function getOwn(metadataKey, target, targetKey) {
	      if (!target) {
	        return undefined;
	      }
	      return Reflect.getOwnMetadata(metadataKey, target, targetKey);
	    },
	    define: function define(metadataKey, metadataValue, target, targetKey) {
	      Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
	    },
	    getOrCreateOwn: function getOrCreateOwn(metadataKey, Type, target, targetKey) {
	      var result = metadata.getOwn(metadataKey, target, targetKey);
	      if (result === undefined) {
	        result = new Type();
	        Reflect.defineMetadata(metadataKey, result, target, targetKey);
	      }
	      return result;
	    }
	  };
	  exports.metadata = metadata;
	  var originStorage = new Map();
	  var unknownOrigin = Object.freeze({
	    moduleId: undefined,
	    moduleMember: undefined
	  });
	  var Origin = (function() {
	    function Origin(moduleId, moduleMember) {
	      _classCallCheck(this, Origin);
	      this.moduleId = moduleId;
	      this.moduleMember = moduleMember;
	    }
	    Origin.get = function get(fn) {
	      var origin = originStorage.get(fn);
	      if (origin === undefined) {
	        _aureliaPal.PLATFORM.eachModule(function(key, value) {
	          for (var _name in value) {
	            var exp = value[_name];
	            if (exp === fn) {
	              originStorage.set(fn, origin = new Origin(key, _name));
	              return true;
	            }
	          }
	          if (value === fn) {
	            originStorage.set(fn, origin = new Origin(key, 'default'));
	            return true;
	          }
	        });
	      }
	      return origin || unknownOrigin;
	    };
	    Origin.set = function set(fn, origin) {
	      originStorage.set(fn, origin);
	    };
	    return Origin;
	  })();
	  exports.Origin = Origin;
	  function decorators() {
	    for (var _len = arguments.length,
	        rest = Array(_len),
	        _key = 0; _key < _len; _key++) {
	      rest[_key] = arguments[_key];
	    }
	    var applicator = function applicator(target, key, descriptor) {
	      var i = rest.length;
	      if (key) {
	        descriptor = descriptor || {
	          value: target[key],
	          writable: true,
	          configurable: true,
	          enumerable: true
	        };
	        while (i--) {
	          descriptor = rest[i](target, key, descriptor) || descriptor;
	        }
	        Object.defineProperty(target, key, descriptor);
	      } else {
	        while (i--) {
	          target = rest[i](target) || target;
	        }
	      }
	      return target;
	    };
	    applicator.on = applicator;
	    return applicator;
	  }
	  function deprecated(optionsOrTarget, maybeKey, maybeDescriptor) {
	    function decorator(target, key, descriptor) {
	      var methodSignature = target.constructor.name + '#' + key;
	      var options = maybeKey ? {} : optionsOrTarget || {};
	      var message = 'DEPRECATION - ' + methodSignature;
	      if (typeof descriptor.value !== 'function') {
	        throw new SyntaxError('Only methods can be marked as deprecated.');
	      }
	      if (options.message) {
	        message += ' - ' + options.message;
	      }
	      return _extends({}, descriptor, {value: function deprecationWrapper() {
	          if (options.error) {
	            throw new Error(message);
	          } else {
	            console.warn(message);
	          }
	          return descriptor.value.apply(this, arguments);
	        }});
	    }
	    return maybeKey ? decorator(optionsOrTarget, maybeKey, maybeDescriptor) : decorator;
	  }
	  function mixin(behavior) {
	    var instanceKeys = Object.keys(behavior);
	    function _mixin(possible) {
	      var decorator = function decorator(target) {
	        var resolvedTarget = typeof target === 'function' ? target.prototype : target;
	        for (var _iterator = instanceKeys,
	            _isArray = Array.isArray(_iterator),
	            _i = 0,
	            _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
	          var _ref;
	          if (_isArray) {
	            if (_i >= _iterator.length)
	              break;
	            _ref = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done)
	              break;
	            _ref = _i.value;
	          }
	          var property = _ref;
	          Object.defineProperty(resolvedTarget, property, {
	            value: behavior[property],
	            writable: true
	          });
	        }
	      };
	      return possible ? decorator(possible) : decorator;
	    }
	    return _mixin;
	  }
	  function alwaysValid() {
	    return true;
	  }
	  function noCompose() {}
	  function ensureProtocolOptions(options) {
	    if (options === undefined) {
	      options = {};
	    } else if (typeof options === 'function') {
	      options = {validate: options};
	    }
	    if (!options.validate) {
	      options.validate = alwaysValid;
	    }
	    if (!options.compose) {
	      options.compose = noCompose;
	    }
	    return options;
	  }
	  function createProtocolValidator(validate) {
	    return function(target) {
	      var result = validate(target);
	      return result === true;
	    };
	  }
	  function createProtocolAsserter(name, validate) {
	    return function(target) {
	      var result = validate(target);
	      if (result !== true) {
	        throw new Error(result || name + ' was not correctly implemented.');
	      }
	    };
	  }
	  function protocol(name, options) {
	    options = ensureProtocolOptions(options);
	    var result = function result(target) {
	      var resolvedTarget = typeof target === 'function' ? target.prototype : target;
	      options.compose(resolvedTarget);
	      result.assert(resolvedTarget);
	      Object.defineProperty(resolvedTarget, 'protocol:' + name, {
	        enumerable: false,
	        configurable: false,
	        writable: false,
	        value: true
	      });
	    };
	    result.validate = createProtocolValidator(options.validate);
	    result.assert = createProtocolAsserter(name, options.validate);
	    return result;
	  }
	  protocol.create = function(name, options) {
	    options = ensureProtocolOptions(options);
	    var hidden = 'protocol:' + name;
	    var result = function result(target) {
	      var decorator = protocol(name, options);
	      return target ? decorator(target) : decorator;
	    };
	    result.decorates = function(obj) {
	      return obj[hidden] === true;
	    };
	    result.validate = createProtocolValidator(options.validate);
	    result.assert = createProtocolAsserter(name, options.validate);
	    return result;
	  };
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("3", ["exports"], function(exports) {
	  'use strict';
	  exports.__esModule = true;
	  exports.AggregateError = AggregateError;
	  exports.initializePAL = initializePAL;
	  function AggregateError(message, innerError, skipIfAlreadyAggregate) {
	    if (innerError) {
	      if (innerError.innerError && skipIfAlreadyAggregate) {
	        return innerError;
	      }
	      if (innerError.stack) {
	        message += '\n------------------------------------------------\ninner error: ' + innerError.stack;
	      }
	    }
	    var e = new Error(message);
	    if (innerError) {
	      e.innerError = innerError;
	    }
	    return e;
	  }
	  var FEATURE = {};
	  exports.FEATURE = FEATURE;
	  var PLATFORM = {
	    noop: function noop() {},
	    eachModule: function eachModule() {}
	  };
	  exports.PLATFORM = PLATFORM;
	  PLATFORM.global = (function() {
	    if (typeof self !== 'undefined') {
	      return self;
	    }
	    if (typeof global !== 'undefined') {
	      return global;
	    }
	    return new Function('return this')();
	  })();
	  var DOM = {};
	  exports.DOM = DOM;
	  function initializePAL(callback) {
	    if (typeof Object.getPropertyDescriptor !== 'function') {
	      Object.getPropertyDescriptor = function(subject, name) {
	        var pd = Object.getOwnPropertyDescriptor(subject, name);
	        var proto = Object.getPrototypeOf(subject);
	        while (typeof pd === 'undefined' && proto !== null) {
	          pd = Object.getOwnPropertyDescriptor(proto, name);
	          proto = Object.getPrototypeOf(proto);
	        }
	        return pd;
	      };
	    }
	    callback(PLATFORM, FEATURE, DOM);
	  }
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("c", ["exports", "16", "3"], function(exports, _aureliaMetadata, _aureliaPal) {
	  'use strict';
	  exports.__esModule = true;
	  var _classInvokers;
	  var _createClass = (function() {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ('value' in descriptor)
	          descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }
	    return function(Constructor, protoProps, staticProps) {
	      if (protoProps)
	        defineProperties(Constructor.prototype, protoProps);
	      if (staticProps)
	        defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  })();
	  exports.invoker = invoker;
	  exports.factory = factory;
	  exports.registration = registration;
	  exports.transient = transient;
	  exports.singleton = singleton;
	  exports.autoinject = autoinject;
	  exports.inject = inject;
	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError('Cannot call a class as a function');
	    }
	  }
	  var resolver = _aureliaMetadata.protocol.create('aurelia:resolver', function(target) {
	    if (!(typeof target.get === 'function')) {
	      return 'Resolvers must implement: get(container: Container, key: any): any';
	    }
	    return true;
	  });
	  exports.resolver = resolver;
	  var Lazy = (function() {
	    function Lazy(key) {
	      _classCallCheck(this, _Lazy);
	      this._key = key;
	    }
	    Lazy.prototype.get = function get(container) {
	      var _this = this;
	      return function() {
	        return container.get(_this._key);
	      };
	    };
	    Lazy.of = function of(key) {
	      return new Lazy(key);
	    };
	    var _Lazy = Lazy;
	    Lazy = resolver()(Lazy) || Lazy;
	    return Lazy;
	  })();
	  exports.Lazy = Lazy;
	  var All = (function() {
	    function All(key) {
	      _classCallCheck(this, _All);
	      this._key = key;
	    }
	    All.prototype.get = function get(container) {
	      return container.getAll(this._key);
	    };
	    All.of = function of(key) {
	      return new All(key);
	    };
	    var _All = All;
	    All = resolver()(All) || All;
	    return All;
	  })();
	  exports.All = All;
	  var Optional = (function() {
	    function Optional(key) {
	      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	      _classCallCheck(this, _Optional);
	      this._key = key;
	      this._checkParent = checkParent;
	    }
	    Optional.prototype.get = function get(container) {
	      if (container.hasResolver(this._key, this._checkParent)) {
	        return container.get(this._key);
	      }
	      return null;
	    };
	    Optional.of = function of(key) {
	      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	      return new Optional(key, checkParent);
	    };
	    var _Optional = Optional;
	    Optional = resolver()(Optional) || Optional;
	    return Optional;
	  })();
	  exports.Optional = Optional;
	  var Parent = (function() {
	    function Parent(key) {
	      _classCallCheck(this, _Parent);
	      this._key = key;
	    }
	    Parent.prototype.get = function get(container) {
	      return container.parent ? container.parent.get(this._key) : null;
	    };
	    Parent.of = function of(key) {
	      return new Parent(key);
	    };
	    var _Parent = Parent;
	    Parent = resolver()(Parent) || Parent;
	    return Parent;
	  })();
	  exports.Parent = Parent;
	  var StrategyResolver = (function() {
	    function StrategyResolver(strategy, state) {
	      _classCallCheck(this, _StrategyResolver);
	      this.strategy = strategy;
	      this.state = state;
	    }
	    StrategyResolver.prototype.get = function get(container, key) {
	      switch (this.strategy) {
	        case 0:
	          return this.state;
	        case 1:
	          var singleton = container.invoke(this.state);
	          this.state = singleton;
	          this.strategy = 0;
	          return singleton;
	        case 2:
	          return container.invoke(this.state);
	        case 3:
	          return this.state(container, key, this);
	        case 4:
	          return this.state[0].get(container, key);
	        case 5:
	          return container.get(this.state);
	        default:
	          throw new Error('Invalid strategy: ' + this.strategy);
	      }
	    };
	    var _StrategyResolver = StrategyResolver;
	    StrategyResolver = resolver()(StrategyResolver) || StrategyResolver;
	    return StrategyResolver;
	  })();
	  exports.StrategyResolver = StrategyResolver;
	  function invoker(value) {
	    return function(target) {
	      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, value, target);
	    };
	  }
	  function factory(potentialTarget) {
	    var deco = function deco(target) {
	      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, FactoryInvoker.instance, target);
	    };
	    return potentialTarget ? deco(potentialTarget) : deco;
	  }
	  var FactoryInvoker = (function() {
	    function FactoryInvoker() {
	      _classCallCheck(this, FactoryInvoker);
	    }
	    FactoryInvoker.prototype.invoke = function invoke(container, fn, dependencies) {
	      var i = dependencies.length;
	      var args = new Array(i);
	      while (i--) {
	        args[i] = container.get(dependencies[i]);
	      }
	      return fn.apply(undefined, args);
	    };
	    FactoryInvoker.prototype.invokeWithDynamicDependencies = function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
	      var i = staticDependencies.length;
	      var args = new Array(i);
	      while (i--) {
	        args[i] = container.get(staticDependencies[i]);
	      }
	      if (dynamicDependencies !== undefined) {
	        args = args.concat(dynamicDependencies);
	      }
	      return fn.apply(undefined, args);
	    };
	    _createClass(FactoryInvoker, null, [{
	      key: 'instance',
	      value: new FactoryInvoker(),
	      enumerable: true
	    }]);
	    return FactoryInvoker;
	  })();
	  exports.FactoryInvoker = FactoryInvoker;
	  function registration(value) {
	    return function(target) {
	      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.registration, value, target);
	    };
	  }
	  function transient(key) {
	    return registration(new TransientRegistration(key));
	  }
	  function singleton(keyOrRegisterInChild) {
	    var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
	  }
	  var TransientRegistration = (function() {
	    function TransientRegistration(key) {
	      _classCallCheck(this, TransientRegistration);
	      this._key = key;
	    }
	    TransientRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
	      var resolver = new StrategyResolver(2, fn);
	      container.registerResolver(this._key || key, resolver);
	      return resolver;
	    };
	    return TransientRegistration;
	  })();
	  exports.TransientRegistration = TransientRegistration;
	  var SingletonRegistration = (function() {
	    function SingletonRegistration(keyOrRegisterInChild) {
	      var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	      _classCallCheck(this, SingletonRegistration);
	      if (typeof keyOrRegisterInChild === 'boolean') {
	        this._registerInChild = keyOrRegisterInChild;
	      } else {
	        this._key = keyOrRegisterInChild;
	        this._registerInChild = registerInChild;
	      }
	    }
	    SingletonRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
	      var resolver = new StrategyResolver(1, fn);
	      if (this._registerInChild) {
	        container.registerResolver(this._key || key, resolver);
	      } else {
	        container.root.registerResolver(this._key || key, resolver);
	      }
	      return resolver;
	    };
	    return SingletonRegistration;
	  })();
	  exports.SingletonRegistration = SingletonRegistration;
	  var badKeyError = 'key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?';
	  var _emptyParameters = Object.freeze([]);
	  exports._emptyParameters = _emptyParameters;
	  _aureliaMetadata.metadata.registration = 'aurelia:registration';
	  _aureliaMetadata.metadata.invoker = 'aurelia:invoker';
	  var resolverDecorates = resolver.decorates;
	  var InvocationHandler = (function() {
	    function InvocationHandler(fn, invoker, dependencies) {
	      _classCallCheck(this, InvocationHandler);
	      this.fn = fn;
	      this.invoker = invoker;
	      this.dependencies = dependencies;
	    }
	    InvocationHandler.prototype.invoke = function invoke(container, dynamicDependencies) {
	      return dynamicDependencies !== undefined ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies) : this.invoker.invoke(container, this.fn, this.dependencies);
	    };
	    return InvocationHandler;
	  })();
	  exports.InvocationHandler = InvocationHandler;
	  function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
	    var i = staticDependencies.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = container.get(staticDependencies[i]);
	    }
	    if (dynamicDependencies !== undefined) {
	      args = args.concat(dynamicDependencies);
	    }
	    return Reflect.construct(fn, args);
	  }
	  var classInvokers = (_classInvokers = {}, _classInvokers[0] = {
	    invoke: function invoke(container, Type) {
	      return new Type();
	    },
	    invokeWithDynamicDependencies: invokeWithDynamicDependencies
	  }, _classInvokers[1] = {
	    invoke: function invoke(container, Type, deps) {
	      return new Type(container.get(deps[0]));
	    },
	    invokeWithDynamicDependencies: invokeWithDynamicDependencies
	  }, _classInvokers[2] = {
	    invoke: function invoke(container, Type, deps) {
	      return new Type(container.get(deps[0]), container.get(deps[1]));
	    },
	    invokeWithDynamicDependencies: invokeWithDynamicDependencies
	  }, _classInvokers[3] = {
	    invoke: function invoke(container, Type, deps) {
	      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));
	    },
	    invokeWithDynamicDependencies: invokeWithDynamicDependencies
	  }, _classInvokers[4] = {
	    invoke: function invoke(container, Type, deps) {
	      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));
	    },
	    invokeWithDynamicDependencies: invokeWithDynamicDependencies
	  }, _classInvokers[5] = {
	    invoke: function invoke(container, Type, deps) {
	      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));
	    },
	    invokeWithDynamicDependencies: invokeWithDynamicDependencies
	  }, _classInvokers.fallback = {
	    invoke: invokeWithDynamicDependencies,
	    invokeWithDynamicDependencies: invokeWithDynamicDependencies
	  }, _classInvokers);
	  var Container = (function() {
	    function Container(configuration) {
	      _classCallCheck(this, Container);
	      if (configuration === undefined) {
	        configuration = {};
	      }
	      this._configuration = configuration;
	      this._onHandlerCreated = configuration.onHandlerCreated;
	      this._handlers = configuration.handlers || (configuration.handlers = new Map());
	      this._resolvers = new Map();
	      this.root = this;
	      this.parent = null;
	    }
	    Container.prototype.makeGlobal = function makeGlobal() {
	      Container.instance = this;
	      return this;
	    };
	    Container.prototype.setHandlerCreatedCallback = function setHandlerCreatedCallback(onHandlerCreated) {
	      this._onHandlerCreated = onHandlerCreated;
	      this._configuration.onHandlerCreated = onHandlerCreated;
	    };
	    Container.prototype.registerInstance = function registerInstance(key, instance) {
	      this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
	    };
	    Container.prototype.registerSingleton = function registerSingleton(key, fn) {
	      this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
	    };
	    Container.prototype.registerTransient = function registerTransient(key, fn) {
	      this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
	    };
	    Container.prototype.registerHandler = function registerHandler(key, handler) {
	      this.registerResolver(key, new StrategyResolver(3, handler));
	    };
	    Container.prototype.registerAlias = function registerAlias(originalKey, aliasKey) {
	      this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
	    };
	    Container.prototype.registerResolver = function registerResolver(key, resolver) {
	      if (key === null || key === undefined) {
	        throw new Error(badKeyError);
	      }
	      var allResolvers = this._resolvers;
	      var result = allResolvers.get(key);
	      if (result === undefined) {
	        allResolvers.set(key, resolver);
	      } else if (result.strategy === 4) {
	        result.state.push(resolver);
	      } else {
	        allResolvers.set(key, new StrategyResolver(4, [result, resolver]));
	      }
	    };
	    Container.prototype.autoRegister = function autoRegister(fn, key) {
	      var resolver = undefined;
	      if (typeof fn === 'function') {
	        var _registration = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, fn);
	        if (_registration === undefined) {
	          resolver = new StrategyResolver(1, fn);
	          this.registerResolver(key === undefined ? fn : key, resolver);
	        } else {
	          resolver = _registration.registerResolver(this, key === undefined ? fn : key, fn);
	        }
	      } else {
	        resolver = new StrategyResolver(0, fn);
	        this.registerResolver(key === undefined ? fn : key, resolver);
	      }
	      return resolver;
	    };
	    Container.prototype.autoRegisterAll = function autoRegisterAll(fns) {
	      var i = fns.length;
	      while (i--) {
	        this.autoRegister(fns[i]);
	      }
	    };
	    Container.prototype.unregister = function unregister(key) {
	      this._resolvers['delete'](key);
	    };
	    Container.prototype.hasResolver = function hasResolver(key) {
	      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	      if (key === null || key === undefined) {
	        throw new Error(badKeyError);
	      }
	      return this._resolvers.has(key) || checkParent && this.parent !== null && this.parent.hasResolver(key, checkParent);
	    };
	    Container.prototype.get = function get(key) {
	      if (key === null || key === undefined) {
	        throw new Error(badKeyError);
	      }
	      if (key === Container) {
	        return this;
	      }
	      if (resolverDecorates(key)) {
	        return key.get(this, key);
	      }
	      var resolver = this._resolvers.get(key);
	      if (resolver === undefined) {
	        if (this.parent === null) {
	          return this.autoRegister(key).get(this, key);
	        }
	        return this.parent._get(key);
	      }
	      return resolver.get(this, key);
	    };
	    Container.prototype._get = function _get(key) {
	      var resolver = this._resolvers.get(key);
	      if (resolver === undefined) {
	        if (this.parent === null) {
	          return this.autoRegister(key).get(this, key);
	        }
	        return this.parent._get(key);
	      }
	      return resolver.get(this, key);
	    };
	    Container.prototype.getAll = function getAll(key) {
	      if (key === null || key === undefined) {
	        throw new Error(badKeyError);
	      }
	      var resolver = this._resolvers.get(key);
	      if (resolver === undefined) {
	        if (this.parent === null) {
	          return _emptyParameters;
	        }
	        return this.parent.getAll(key);
	      }
	      if (resolver.strategy === 4) {
	        var state = resolver.state;
	        var i = state.length;
	        var results = new Array(i);
	        while (i--) {
	          results[i] = state[i].get(this, key);
	        }
	        return results;
	      }
	      return [resolver.get(this, key)];
	    };
	    Container.prototype.createChild = function createChild() {
	      var child = new Container(this._configuration);
	      child.root = this.root;
	      child.parent = this;
	      return child;
	    };
	    Container.prototype.invoke = function invoke(fn, dynamicDependencies) {
	      try {
	        var _handler = this._handlers.get(fn);
	        if (_handler === undefined) {
	          _handler = this._createInvocationHandler(fn);
	          this._handlers.set(fn, _handler);
	        }
	        return _handler.invoke(this, dynamicDependencies);
	      } catch (e) {
	        throw new _aureliaPal.AggregateError('Error invoking ' + fn.name + '. Check the inner error for details.', e, true);
	      }
	    };
	    Container.prototype._createInvocationHandler = function _createInvocationHandler(fn) {
	      var dependencies = undefined;
	      if (typeof fn.inject === 'function') {
	        dependencies = fn.inject();
	      } else if (fn.inject === undefined) {
	        dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, fn) || _emptyParameters;
	      } else {
	        dependencies = fn.inject;
	      }
	      var invoker = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.invoker, fn) || classInvokers[dependencies.length] || classInvokers.fallback;
	      var handler = new InvocationHandler(fn, invoker, dependencies);
	      return this._onHandlerCreated !== undefined ? this._onHandlerCreated(handler) : handler;
	    };
	    return Container;
	  })();
	  exports.Container = Container;
	  function autoinject(potentialTarget) {
	    var deco = function deco(target) {
	      target.inject = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target) || _emptyParameters;
	    };
	    return potentialTarget ? deco(potentialTarget) : deco;
	  }
	  function inject() {
	    for (var _len = arguments.length,
	        rest = Array(_len),
	        _key = 0; _key < _len; _key++) {
	      rest[_key] = arguments[_key];
	    }
	    return function(target, key, descriptor) {
	      if (descriptor) {
	        var _fn = descriptor.value;
	        _fn.inject = rest;
	      } else {
	        target.inject = rest;
	      }
	    };
	  }
	});

	})();
	$__System.register("f", [], function (exports_1, context_1) {
	  "use strict";

	  var __moduleName = context_1 && context_1.id;
	  var Role, SubviewType, RealityView;
	  return {
	    setters: [],
	    execute: function () {
	      /**
	       * Describes the role of an [[ArgonSystem]]
	       */
	      (function (Role) {
	        /**
	         * A system with this role is responsible for augmenting an arbitrary view of reality,
	         * generally by overlaying computer generated graphics. A reality augmentor may also,
	         * if appropriate, be elevated to the role of a [[REALITY_MANAGER]].
	         */
	        Role[Role["REALITY_AUGMENTOR"] = "RealityAugmentor"] = "REALITY_AUGMENTOR";
	        /**
	         * A system with this role is responsible for (at minimum) describing (and providing,
	         * if necessary) a visual representation of the world and the 3D eye pose of the viewer.
	         */
	        Role[Role["REALITY_VIEW"] = "RealityView"] = "REALITY_VIEW";
	        /**
	         * A system with this role is responsible for mediating access to sensors/trackers
	         * and pose data for known entities in the world, selecting/configuring/loading
	         * [[REALITY_VIEW]]s, and providing the mechanism by which any given [[REALITY_AUGMENTOR]]
	         * can augment any given [[REALITY_VIEW]]. The reality manager may also, when appropriate,
	         * take on the role of [[REALITY_AUGMENTOR]].
	         */
	        Role[Role["REALITY_MANAGER"] = "RealityManager"] = "REALITY_MANAGER";
	        /**
	         * Deprecated. Use [[REALITY_AUGMENTOR]].
	         * @private
	         */
	        Role[Role["APPLICATION"] = "Application"] = "APPLICATION";
	        /**
	         * Deprecated. Use [[REALITY_MANAGER]].
	         * @private
	         */
	        Role[Role["MANAGER"] = "Manager"] = "MANAGER";
	      })(Role || (Role = {}));
	      exports_1("Role", Role);
	      /**
	       * Identifies a subview in a [[SerializedSubview]]
	       */
	      (function (SubviewType) {
	        /*
	         * Identities a subview for a handheld display.
	         */
	        SubviewType[SubviewType["SINGULAR"] = "Singular"] = "SINGULAR";
	        /*
	         * Identifies a subview for the left eye (when the user is wearing an HMD or Viewer)
	         */
	        SubviewType[SubviewType["LEFTEYE"] = "LeftEye"] = "LEFTEYE";
	        /*
	         * Identifies a subview for the right eye (when the user is wearing an HMD or Viewer)
	         */
	        SubviewType[SubviewType["RIGHTEYE"] = "RightEye"] = "RIGHTEYE";
	        /*
	         * Identifies a subview for a custom view configuration
	         */
	        SubviewType[SubviewType["OTHER"] = "Other"] = "OTHER";
	      })(SubviewType || (SubviewType = {}));
	      exports_1("SubviewType", SubviewType);
	      /**
	      * Represents a view of Reality
	      */
	      RealityView = function () {
	        function RealityView() {}
	        RealityView.getType = function (reality) {
	          var uri = reality.uri;
	          var parts = uri.split(':');
	          if (parts[0] === 'reality') {
	            return parts[1];
	          }
	          return 'hosted';
	        };
	        RealityView.EMPTY = {
	          uri: 'reality:empty',
	          title: 'Reality',
	          providedReferenceFrames: ['FIXED']
	        };
	        return RealityView;
	      }();
	      exports_1("RealityView", RealityView);
	    }
	  };
	});
	$__System.register('10', ['a', 'c', 'f', '12'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __extends = this && this.__extends || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var cesium_imports_1, aurelia_dependency_injection_1, common_1, utils_1;
	    var SessionPort, SessionPortFactory, ConnectService, SessionService, LoopbackConnectService, DOMConnectService, DebugConnectService, WKWebViewConnectService;
	    return {
	        setters: [function (cesium_imports_1_1) {
	            cesium_imports_1 = cesium_imports_1_1;
	        }, function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (common_1_1) {
	            common_1 = common_1_1;
	        }, function (utils_1_1) {
	            utils_1 = utils_1_1;
	        }],
	        execute: function () {
	            ;
	            /**
	             * Provides two-way communication between two [[SessionPort]] instances.
	             */
	            SessionPort = function () {
	                function SessionPort(uri) {
	                    var _this = this;
	                    this.uri = uri;
	                    this._connectEvent = new utils_1.Event();
	                    /**
	                     * An event which fires when this port has closed
	                     */
	                    this.closeEvent = new utils_1.Event();
	                    /**
	                     * An error which fires when an error occurs.
	                     */
	                    this.errorEvent = new utils_1.Event();
	                    /**
	                     * A map from topic to message handler.
	                     */
	                    this.on = {};
	                    this._isOpened = false;
	                    this._isConnected = false;
	                    this._isClosed = false;
	                    this.on[SessionPort.OPEN] = function (info) {
	                        if (!info) throw new Error('Session did not provide a configuration');
	                        if (_this._isConnected) throw new Error('Session has already connected!');
	                        _this.info = info;
	                        _this._isConnected = true;
	                        _this._connectEvent.raiseEvent(undefined);
	                    };
	                    this.on[SessionPort.CLOSE] = function () {
	                        _this._isClosed = true;
	                        _this._isConnected = false;
	                        if (_this.messagePort && _this.messagePort.close) _this.messagePort.close();
	                        _this.closeEvent.raiseEvent(undefined);
	                    };
	                    this.on[SessionPort.ERROR] = function (error) {
	                        var e = new Error("Session Error: " + error.message);
	                        if (error.stack) e['stack'] = error.stack;
	                        _this.errorEvent.raiseEvent(e);
	                    };
	                    this.errorEvent.addEventListener(function (error) {
	                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
	                    });
	                }
	                Object.defineProperty(SessionPort.prototype, "connectEvent", {
	                    /**
	                     * An event which fires when a connection has been
	                     * established to the other [[SessionPort]].
	                     */
	                    get: function () {
	                        if (this._isConnected) throw new Error('The connectEvent only fires once and the session is already connected.');
	                        return this._connectEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                ;
	                /**
	                 * Check if a protocol is supported by this session.
	                 */
	                SessionPort.prototype.supportsProtocol = function (name, versions) {
	                    if (!this._isConnected) throw new Error('Session has not yet connected');
	                    var protocols = this.info.protocols;
	                    if (!protocols) return false;
	                    var supported = false;
	                    var foundVersions = new Set();
	                    protocols.forEach(function (p) {
	                        if (p.indexOf(name) !== -1) {
	                            var v = +p.split('@v')[1] || 0;
	                            foundVersions.add(v);
	                        }
	                    });
	                    if (versions) {
	                        if (Array.isArray(versions)) {
	                            versions.forEach(function (v) {
	                                if (foundVersions.has(v)) {
	                                    supported = true;
	                                }
	                            });
	                        } else {
	                            if (foundVersions.has(versions)) {
	                                supported = true;
	                            }
	                        }
	                    } else if (!versions) {
	                        supported = true;
	                    }
	                    return supported;
	                };
	                /**
	                 * Establish a connection to another [[SessionPort]] via the provided [[MessagePort]] instance.
	                 * @param messagePort the message port to post and receive messages.
	                 * @param options the configuration which describes this [[ArgonSystem]].
	                 */
	                SessionPort.prototype.open = function (messagePort, options) {
	                    var _this = this;
	                    if (this._isClosed) return;
	                    if (this._isOpened) throw new Error('Session can only be opened once');
	                    if (!options) throw new Error('Session options must be provided');
	                    this.messagePort = messagePort;
	                    this._isOpened = true;
	                    this.messagePort.onmessage = function (evt) {
	                        if (_this._isClosed) return;
	                        var id = evt.data[0];
	                        var topic = evt.data[1];
	                        var message = evt.data[2] || {};
	                        var expectsResponse = evt.data[3];
	                        var handler = _this.on[topic];
	                        if (handler && !expectsResponse) {
	                            try {
	                                var response = handler(message, evt);
	                                if (response) console.warn("Handler for " + topic + " returned an unexpected response");
	                            } catch (e) {
	                                _this.sendError(e);
	                                _this.errorEvent.raiseEvent(e);
	                            }
	                        } else if (handler) {
	                            var response = new Promise(function (resolve) {
	                                return resolve(handler(message, evt));
	                            });
	                            Promise.resolve(response).then(function (response) {
	                                if (_this._isClosed) return;
	                                _this.send(topic + ':resolve:' + id, response);
	                            }).catch(function (error) {
	                                if (_this._isClosed) return;
	                                var errorMessage;
	                                if (typeof error === 'string') errorMessage = error;else if (typeof error.message === 'string') errorMessage = error.message;
	                                _this.send(topic + ':reject:' + id, { reason: errorMessage });
	                            });
	                        } else {
	                            var errorMessage = 'Unable to handle message ' + topic;
	                            if (expectsResponse) {
	                                _this.send(topic + ':reject:' + id, { reason: errorMessage });
	                            } else {
	                                _this.sendError({ message: errorMessage });
	                            }
	                            _this.errorEvent.raiseEvent(new Error('No handlers are available for topic ' + topic));
	                        }
	                    };
	                    this.send(SessionPort.OPEN, options);
	                };
	                /**
	                 * Send a message
	                 * @param topic the message topic.
	                 * @param message the message to be sent.
	                 * @return Return true if the message is posted successfully,
	                 * return false if the session is closed.
	                 */
	                SessionPort.prototype.send = function (topic, message) {
	                    if (!this._isOpened) throw new Error('Session must be open to send messages');
	                    if (this._isClosed) return false;
	                    var id = cesium_imports_1.createGuid();
	                    this.messagePort.postMessage([id, topic, message]);
	                    return true;
	                };
	                /**
	                 * Send an error message.
	                 * @param errorMessage An error message.
	                 * @return Return true if the error message is sent successfully,
	                 * otherwise, return false.
	                 */
	                SessionPort.prototype.sendError = function (e) {
	                    var errorMessage = e;
	                    if (errorMessage instanceof Error) {
	                        errorMessage = {
	                            message: errorMessage.message,
	                            stack: errorMessage['stack']
	                        };
	                    }
	                    return this.send(SessionPort.ERROR, errorMessage);
	                };
	                /**
	                 * Send a request and return a promise for the result.
	                 * @param topic the message topic.
	                 * @param message the message to be sent.
	                 * @return if the session is not opened or is closed, return a rejected promise,
	                 * Otherwise, the returned promise is resolved or rejected based on the response.
	                 */
	                SessionPort.prototype.request = function (topic, message) {
	                    var _this = this;
	                    if (!this._isOpened || this._isClosed) throw new Error('Session must be open to make requests');
	                    var id = cesium_imports_1.createGuid();
	                    var resolveTopic = topic + ':resolve:' + id;
	                    var rejectTopic = topic + ':reject:' + id;
	                    var result = new Promise(function (resolve, reject) {
	                        _this.on[resolveTopic] = function (message) {
	                            delete _this.on[resolveTopic];
	                            delete _this.on[rejectTopic];
	                            resolve(message);
	                        };
	                        _this.on[rejectTopic] = function (message) {
	                            delete _this.on[resolveTopic];
	                            delete _this.on[rejectTopic];
	                            console.warn("Request '" + topic + "' rejected with reason:\n" + message.reason);
	                            reject(new Error(message.reason));
	                        };
	                    });
	                    this.messagePort.postMessage([id, topic, message || {}, true]);
	                    return result;
	                };
	                /**
	                 * Close the connection to the remote session.
	                 */
	                SessionPort.prototype.close = function () {
	                    if (this._isClosed) return;
	                    if (this._isOpened) {
	                        this.send(SessionPort.CLOSE);
	                    }
	                    this._isClosed = true;
	                    this._isConnected = false;
	                    if (this.messagePort && this.messagePort.close) this.messagePort.close();
	                    this.closeEvent.raiseEvent(undefined);
	                };
	                Object.defineProperty(SessionPort.prototype, "isConnected", {
	                    get: function () {
	                        return this._isConnected;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                SessionPort.OPEN = 'ar.session.open';
	                SessionPort.CLOSE = 'ar.session.close';
	                SessionPort.ERROR = 'ar.session.error';
	                return SessionPort;
	            }();
	            exports_1("SessionPort", SessionPort);
	            /**
	             * A factory for creating [[SessionPort]] instances.
	             */
	            SessionPortFactory = function () {
	                function SessionPortFactory() {}
	                SessionPortFactory.prototype.create = function (uri) {
	                    return new SessionPort(uri);
	                };
	                return SessionPortFactory;
	            }();
	            exports_1("SessionPortFactory", SessionPortFactory);
	            /**
	             * A service for establishing a connection to the [[REALITY_MANAGER]].
	             */
	            ConnectService = function () {
	                function ConnectService() {}
	                return ConnectService;
	            }();
	            exports_1("ConnectService", ConnectService);
	            /**
	             * A service for managing connections to other ArgonSystem instances
	             */
	            SessionService = function () {
	                function SessionService(
	                /**
	                 * The configuration of this [[ArgonSystem]]
	                 */
	                configuration, connectService, sessionPortFactory, messageChannelFactory) {
	                    var _this = this;
	                    this.configuration = configuration;
	                    this.connectService = connectService;
	                    this.sessionPortFactory = sessionPortFactory;
	                    this.messageChannelFactory = messageChannelFactory;
	                    /**
	                     * The port which handles communication between this session and the manager session.
	                     */
	                    this.manager = this.createSessionPort('argon:manager');
	                    /**
	                     * An event that is raised when an error occurs.
	                     */
	                    this.errorEvent = new utils_1.Event();
	                    this._connectEvent = new utils_1.Event();
	                    this._managedSessions = [];
	                    this.errorEvent.addEventListener(function (error) {
	                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
	                    });
	                    this.manager.errorEvent.addEventListener(function (error) {
	                        _this.errorEvent.raiseEvent(error);
	                    });
	                    Object.freeze(this);
	                }
	                Object.defineProperty(SessionService.prototype, "connectEvent", {
	                    /**
	                     * An event that is raised when a managed session is opened.
	                     */
	                    get: function () {
	                        return this._connectEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                ;
	                Object.defineProperty(SessionService.prototype, "managedSessions", {
	                    /**
	                     * Manager-only. A collection of ports for the sessions managed by this session.
	                     */
	                    get: function () {
	                        this.ensureIsRealityManager();
	                        return this._managedSessions;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Establishes a connection with the [[REALITY_MANAGER]].
	                 * Called internally by the composition root ([[ArgonSystem]]).
	                 */
	                SessionService.prototype.connect = function () {
	                    if (this.connectService && this.connectService.connect) {
	                        this.connectService.connect(this);
	                    } else {
	                        console.warn('Argon: Unable to connect to a manager session; a connect service is not available');
	                    }
	                };
	                /**
	                 * Manager-only. Creates a [[SessionPort]] that is managed by the current [[ArgonSystem]].
	                 * Session ports that are managed will automatically forward open events to
	                 * [[SessionService#sessionConnectEvent]] and error events to [[SessionService#errorEvent]].
	                 * Other services that are part of the current [[ArgonSystem]] are likely to
	                 * add message handlers to a newly connected [[SessionPort]].
	                 * @return a new [[SessionPort]] instance
	                 */
	                SessionService.prototype.addManagedSessionPort = function (uri) {
	                    var _this = this;
	                    this.ensureIsRealityManager();
	                    var session = this.sessionPortFactory.create(uri);
	                    session.errorEvent.addEventListener(function (error) {
	                        _this.errorEvent.raiseEvent(error);
	                    });
	                    session.connectEvent.addEventListener(function () {
	                        _this.managedSessions.push(session);
	                        _this.connectEvent.raiseEvent(session);
	                    });
	                    session.closeEvent.addEventListener(function () {
	                        var index = _this.managedSessions.indexOf(session);
	                        if (index > -1) _this.managedSessions.splice(index, 1);
	                    });
	                    return session;
	                };
	                /**
	                 * Creates a [[SessionPort]] that is not managed by the current [[ArgonSystem]].
	                 * Unmanaged session ports will not forward open events or error events
	                 * to this [[ArgonSystem]].
	                 * @return a new SessionPort instance
	                 */
	                SessionService.prototype.createSessionPort = function (uri) {
	                    return this.sessionPortFactory.create(uri);
	                };
	                /**
	                 * Creates a message channel which asyncrhonously sends and receives messages.
	                 */
	                SessionService.prototype.createMessageChannel = function () {
	                    return this.messageChannelFactory.create();
	                };
	                /**
	                 * Creates a message channel which syncrhonously sends and receives messages.
	                 */
	                SessionService.prototype.createSynchronousMessageChannel = function () {
	                    return this.messageChannelFactory.createSynchronous();
	                };
	                Object.defineProperty(SessionService.prototype, "isRealityManager", {
	                    /**
	                     * Returns true if this system represents a [[REALITY_MANAGER]]
	                     */
	                    get: function () {
	                        return this.configuration.role === common_1.Role.REALITY_MANAGER || this.configuration.role === common_1.Role.MANAGER; // TODO: phase out of using Role.MANAGER enum
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(SessionService.prototype, "isRealityAugmenter", {
	                    /**
	                     * Returns true if this system represents a [[REALITY_AUGMENTOR]], meaning,
	                     * it is running within a [[REALITY_MANAGER]]
	                     */
	                    get: function () {
	                        return this.configuration.role === common_1.Role.REALITY_AUGMENTOR || this.configuration.role === common_1.Role.APPLICATION; // TODO: phase out use of Role.APPLICATION
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(SessionService.prototype, "isRealityView", {
	                    /**
	                     * Returns true if this system is a [[REALITY_VIEW]]
	                     */
	                    get: function () {
	                        return this.configuration.role === common_1.Role.REALITY_VIEW;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(SessionService.prototype, "isManager", {
	                    /**
	                     * @private
	                     */
	                    get: function () {
	                        console.warn("Deprecated. Use isRealityManager()");return this.isManager;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(SessionService.prototype, "isApplication", {
	                    /**
	                     * @private
	                     */
	                    get: function () {
	                        console.warn("Deprecated. Use isRealityAugmenter()");return this.isRealityAugmenter;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Throws an error if this system is not a [[REALITY_MANAGER]]
	                 */
	                SessionService.prototype.ensureIsRealityManager = function () {
	                    if (!this.isRealityManager) throw new Error('An reality-manager only API was accessed from a non reality-manager.');
	                };
	                /**
	                 * Throws an error if this session is not a [[REALITY_VIEW]]
	                 */
	                SessionService.prototype.ensureIsRealityView = function () {
	                    if (!this.isRealityView) throw new Error('An reality-view only API was accessed from a non reality-view.');
	                };
	                /**
	                 * Throws an error if this session is a [[REALITY_VIEW]]
	                 */
	                SessionService.prototype.ensureNotRealityView = function () {
	                    if (this.isRealityView) throw new Error('An non-permitted API was accessed from a reality-view.');
	                };
	                SessionService = __decorate([aurelia_dependency_injection_1.inject('config', ConnectService, SessionPortFactory, utils_1.MessageChannelFactory)], SessionService);
	                return SessionService;
	            }();
	            exports_1("SessionService", SessionService);
	            /**
	             * Connect the current [[ArgonSystem]] to itself as the [[REALITY_MANAGER]].
	             */
	            LoopbackConnectService = function (_super) {
	                __extends(LoopbackConnectService, _super);
	                function LoopbackConnectService() {
	                    _super.apply(this, arguments);
	                }
	                /**
	                 * Create a loopback connection.
	                 */
	                LoopbackConnectService.prototype.connect = function (sessionService) {
	                    var messageChannel = sessionService.createSynchronousMessageChannel();
	                    var messagePort = messageChannel.port1;
	                    messageChannel.port2.onmessage = function (evt) {
	                        messageChannel.port2.postMessage(evt.data);
	                    };
	                    sessionService.manager.connectEvent.addEventListener(function () {
	                        sessionService.connectEvent.raiseEvent(sessionService.manager);
	                    });
	                    sessionService.manager.open(messagePort, sessionService.configuration);
	                };
	                return LoopbackConnectService;
	            }(ConnectService);
	            exports_1("LoopbackConnectService", LoopbackConnectService);
	            /**
	             * Connect this [[ArgonSystem]] to the [[REALITY_MANAGER]] via the parent document
	             * (assuming this system is running in an iFrame).
	             */
	            DOMConnectService = function (_super) {
	                __extends(DOMConnectService, _super);
	                function DOMConnectService() {
	                    _super.apply(this, arguments);
	                }
	                /**
	                  * Check whether this connect method is available or not.
	                  */
	                DOMConnectService.isAvailable = function () {
	                    return typeof window !== 'undefined' && typeof window.parent !== 'undefined';
	                };
	                /**
	                 * Connect to the manager.
	                 */
	                DOMConnectService.prototype.connect = function (sessionService) {
	                    var messageChannel = sessionService.createMessageChannel();
	                    window.parent.postMessage({ type: 'ARGON_SESSION' }, '*', [messageChannel.port1]);
	                    sessionService.manager.open(messageChannel.port2, sessionService.configuration);
	                };
	                return DOMConnectService;
	            }(ConnectService);
	            exports_1("DOMConnectService", DOMConnectService);
	            /**
	             * Connect this system to a remote manager for debugging.
	             */
	            DebugConnectService = function (_super) {
	                __extends(DebugConnectService, _super);
	                function DebugConnectService() {
	                    _super.apply(this, arguments);
	                }
	                /**
	                 * Check whether this connect method is available or not.
	                 */
	                DebugConnectService.isAvailable = function () {
	                    return typeof window !== 'undefined' && !!window['__ARGON_DEBUG_PORT__'];
	                };
	                /**
	                 * Connect to the manager.
	                 */
	                DebugConnectService.prototype.connect = function (_a) {
	                    var manager = _a.manager,
	                        configuration = _a.configuration;
	                    manager.open(window['__ARGON_DEBUG_PORT__'], configuration);
	                };
	                return DebugConnectService;
	            }(ConnectService);
	            exports_1("DebugConnectService", DebugConnectService);
	            /**
	             * A service which connects this system to the [[REALITY_MANAGER]] via a WKWebview message handler.
	             */
	            WKWebViewConnectService = function (_super) {
	                __extends(WKWebViewConnectService, _super);
	                function WKWebViewConnectService() {
	                    _super.apply(this, arguments);
	                }
	                /**
	                 * Check whether this connect method is available or not.
	                 */
	                WKWebViewConnectService.isAvailable = function () {
	                    return typeof window !== 'undefined' && window['webkit'] && window['webkit'].messageHandlers;
	                };
	                /**
	                 * Connect to the manager.
	                 */
	                WKWebViewConnectService.prototype.connect = function (sessionService) {
	                    var messageChannel = sessionService.createSynchronousMessageChannel();
	                    messageChannel.port2.onmessage = function (event) {
	                        webkit.messageHandlers.argon.postMessage(JSON.stringify(event.data));
	                    };
	                    window['__ARGON_PORT__'] = messageChannel.port2;
	                    sessionService.manager.open(messageChannel.port1, sessionService.configuration);
	                    window.addEventListener("beforeunload", function () {
	                        sessionService.manager.close();
	                    });
	                };
	                return WKWebViewConnectService;
	            }(ConnectService);
	            exports_1("WKWebViewConnectService", WKWebViewConnectService);
	        }
	    };
	});
	$__System.register('11', ['c', 'a', 'f', '14', '10', '12'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, cesium_imports_1, common_1, focus_1, session_1, utils_1;
	    var RealityLoader, RealityZoomState, RealityService;
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (cesium_imports_1_1) {
	            cesium_imports_1 = cesium_imports_1_1;
	        }, function (common_1_1) {
	            common_1 = common_1_1;
	        }, function (focus_1_1) {
	            focus_1 = focus_1_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	        }, function (utils_1_1) {
	            utils_1 = utils_1_1;
	        }],
	        execute: function () {
	            /**
	             * Abstract class for a reality setup handler
	             */
	            RealityLoader = function () {
	                function RealityLoader() {}
	                return RealityLoader;
	            }();
	            exports_1("RealityLoader", RealityLoader);
	            (function (RealityZoomState) {
	                RealityZoomState[RealityZoomState["OTHER"] = 0] = "OTHER";
	                RealityZoomState[RealityZoomState["START"] = 1] = "START";
	                RealityZoomState[RealityZoomState["CHANGE"] = 2] = "CHANGE";
	                RealityZoomState[RealityZoomState["END"] = 3] = "END";
	            })(RealityZoomState || (RealityZoomState = {}));
	            exports_1("RealityZoomState", RealityZoomState);
	            /**
	            * A service which manages the reality view.
	            * For an app developer, the RealityService instance can be used to
	            * set preferences which can affect how the manager selects a reality view.
	            */
	            RealityService = function () {
	                function RealityService(sessionService, focusService) {
	                    var _this = this;
	                    this.sessionService = sessionService;
	                    this.focusService = focusService;
	                    /**
	                     * A collection of known reality views from which the reality service can select.
	                     */
	                    this.realities = new Array();
	                    /**
	                     * An event that is raised when a reality control port is opened.
	                     */
	                    this.connectEvent = new utils_1.Event();
	                    /**
	                     * Manager-only. An event that is raised when the current reality is changed.
	                     */
	                    this._changeEvent = new utils_1.Event();
	                    /**
	                     * Manager-only. An event that is raised when the current reality emits the next frame state.
	                     * This event contains pose updates for the entities that are managed by
	                     * the current reality.
	                     */
	                    this._frameEvent = new utils_1.Event();
	                    /**
	                     * Manager-only. A map from a managed session to the desired reality
	                     */
	                    this.desiredRealityMap = new WeakMap();
	                    /**
	                     * Manager-only. A map from a desired reality to the session which requested it
	                     */
	                    this.desiredRealityMapInverse = new WeakMap();
	                    /**
	                     * Manager-only. An event that is raised when a session changes it's desired reality.
	                     */
	                    this.sessionDesiredRealityChangeEvent = new utils_1.Event();
	                    // RealitySetupHandlers
	                    this._loaders = [];
	                    this._defaultFov = Math.PI / 2;
	                    this._scratchFrustum = new cesium_imports_1.PerspectiveFrustum();
	                    this._scratchArray = new Array();
	                    this._loadID = -1;
	                    if (sessionService.isRealityManager) {
	                        sessionService.manager.connectEvent.addEventListener(function () {
	                            setTimeout(function () {
	                                if (_this._loadID === -1) _this._setNextReality(_this.onSelectReality());
	                            });
	                        });
	                    }
	                    sessionService.connectEvent.addEventListener(function (session) {
	                        if (session.info.role !== common_1.Role.REALITY_VIEW) {
	                            session.on['ar.reality.desired'] = function (message) {
	                                var reality = message.reality;
	                                var previous = _this.desiredRealityMap.get(session);
	                                console.log('Session set desired reality: ' + JSON.stringify(reality));
	                                if (reality) {
	                                    if (reality['type']) {
	                                        var type = reality['type'];
	                                        reality.uri = reality.uri || 'reality:' + type;
	                                        if (type === 'hosted') reality.uri = reality['url'];
	                                        if (!reality.title && reality['name']) reality.title = reality['name'];
	                                    }
	                                    if (_this.isSupported(reality)) {
	                                        _this.desiredRealityMap.set(session, reality);
	                                        _this.desiredRealityMapInverse.set(reality, session);
	                                    } else {
	                                        session.sendError({ message: 'Reality of type "' + reality.uri + '" is not available on this platform' });
	                                        return;
	                                    }
	                                } else {
	                                    _this.desiredRealityMap.delete(session);
	                                }
	                                _this._setNextReality(_this.onSelectReality());
	                                _this.sessionDesiredRealityChangeEvent.raiseEvent({ session: session, previous: previous, current: reality });
	                            };
	                        }
	                    });
	                    sessionService.manager.on['ar.reality.connect'] = function (_a) {
	                        var id = _a.id;
	                        var realityControlSession = _this.sessionService.createSessionPort();
	                        var messageChannel = _this.sessionService.createSynchronousMessageChannel();
	                        var ROUTE_MESSAGE_KEY = 'ar.reality.message.route.' + id;
	                        var SEND_MESSAGE_KEY = 'ar.reality.message.send.' + id;
	                        var CLOSE_SESSION_KEY = 'ar.reality.close.' + id;
	                        messageChannel.port1.onmessage = function (msg) {
	                            _this.sessionService.manager.send(ROUTE_MESSAGE_KEY, msg.data);
	                        };
	                        _this.sessionService.manager.on[SEND_MESSAGE_KEY] = function (message) {
	                            messageChannel.port1.postMessage(message);
	                        };
	                        _this.sessionService.manager.on[CLOSE_SESSION_KEY] = function () {
	                            realityControlSession.close();
	                        };
	                        realityControlSession.connectEvent.addEventListener(function () {
	                            _this.connectEvent.raiseEvent(realityControlSession);
	                        });
	                        _this.sessionService.manager.closeEvent.addEventListener(function () {
	                            realityControlSession.close();
	                            delete _this.sessionService.manager.on[SEND_MESSAGE_KEY];
	                            delete _this.sessionService.manager.on[CLOSE_SESSION_KEY];
	                        });
	                        realityControlSession.open(messageChannel.port2, _this.sessionService.configuration);
	                    };
	                    sessionService.manager.on['ar.reality.zoom'] = function (data) {
	                        _this.zoom(data);
	                    };
	                }
	                Object.defineProperty(RealityService.prototype, "changeEvent", {
	                    get: function () {
	                        this.sessionService.ensureIsRealityManager();
	                        return this._changeEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(RealityService.prototype, "frameEvent", {
	                    get: function () {
	                        this.sessionService.ensureIsRealityManager();
	                        return this._frameEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Set the default reality.
	                 */
	                RealityService.prototype.setDefault = function (reality) {
	                    this._default = reality;
	                };
	                /**
	                 * Manager-only. Register a reality loader
	                 */
	                RealityService.prototype.registerLoader = function (handler) {
	                    this.sessionService.ensureIsRealityManager();
	                    this._loaders.push(handler);
	                };
	                /**
	                 * Manager-only. Get the current reality view.
	                 * @deprecated. Use app.context.getCurrentReality()
	                 */
	                RealityService.prototype.getCurrent = function () {
	                    this.sessionService.ensureIsRealityManager();
	                    return this._current;
	                };
	                /**
	                * Manager-only. Check if a type of reality is supported.
	                * @param type reality type
	                * @return true if a handler exists and false otherwise
	                */
	                RealityService.prototype.isSupported = function (reality) {
	                    this.sessionService.ensureIsRealityManager();
	                    return !!this._getLoader(reality);
	                };
	                /**
	                 * Reality-only. Publish the next frame state.
	                 */
	                RealityService.prototype.publishFrame = function (state) {
	                    this.sessionService.ensureIsRealityView();
	                    if (this.sessionService.manager.isConnected) {
	                        this.sessionService.manager.send('ar.reality.frameState', state);
	                    }
	                };
	                /**
	                 * Set the desired reality.
	                 */
	                RealityService.prototype.setDesired = function (reality) {
	                    this.sessionService.ensureNotRealityView();
	                    this._desired = reality;
	                    if (this.sessionService.isRealityManager) {
	                        this._setNextReality(reality, true);
	                    } else {
	                        this.sessionService.manager.send('ar.reality.desired', { reality: reality });
	                    }
	                };
	                /**
	                 * Get the desired reality
	                 */
	                RealityService.prototype.getDesired = function () {
	                    return this._desired;
	                };
	                /**
	                 * Set the optional reference frames for this app
	                 */
	                RealityService.prototype.setOptionalReferenceFrames = function (referenceFrames) {};
	                /**
	                 * Set the optional reference frames for this app
	                 */
	                RealityService.prototype.setRequiredReferenceFrames = function (referenceFrames) {};
	                /**
	                 * Set a desired fov in radians.
	                 */
	                RealityService.prototype.setDesiredFov = function (fov) {
	                    this._desiredFov = fov;
	                    this.zoom({ fov: fov || this._defaultFov, zoom: 1, state: RealityZoomState.OTHER });
	                };
	                /**
	                 * Get the desired fov in radians
	                 */
	                RealityService.prototype.getDesiredFov = function () {
	                    return this._desiredFov;
	                };
	                /**
	                 * Set the default fov in radians, and adjust the desired fov to match the
	                 * previous desired / default ratio.
	                 */
	                RealityService.prototype.setDefaultFov = function (fov) {
	                    if (cesium_imports_1.defined(this._desiredFov)) {
	                        var ratio = this._desiredFov / this._defaultFov;
	                        this.setDesiredFov(fov * ratio);
	                    }
	                    this._defaultFov = fov;
	                };
	                /**
	                 * Get the default fov in radians
	                 */
	                RealityService.prototype.getDefaultFov = function () {
	                    return this._defaultFov;
	                };
	                /**
	                 * Returns a maximum viewport
	                 */
	                RealityService.prototype.getMaximumViewport = function () {
	                    if (typeof document !== 'undefined' && document.documentElement) {
	                        return {
	                            x: 0,
	                            y: 0,
	                            width: document.documentElement.clientWidth,
	                            height: document.documentElement.clientHeight
	                        };
	                    }
	                    throw new Error("Not implemeneted for the current platform");
	                };
	                /**
	                * Manager-only. Selects the best reality based on the realites
	                * requested by all managed sessions. Can be overriden for customized selection.
	                *
	                * @returns The reality chosen for this context. May be undefined if no
	                * realities have been requested.
	                */
	                RealityService.prototype.onSelectReality = function () {
	                    this.sessionService.ensureIsRealityManager();
	                    var selectedReality = this.desiredRealityMap.get(this.sessionService.manager);
	                    if (!selectedReality) {
	                        var focusSession = this.focusService.getSession();
	                        if (focusSession && focusSession.isConnected) {
	                            selectedReality = this.desiredRealityMap.get(focusSession);
	                        }
	                    }
	                    if (!selectedReality) {
	                        // TODO: sort and select based on some kind of ranking system
	                        for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
	                            var session = _a[_i];
	                            if (!session.isConnected) continue;
	                            var desiredReality = this.desiredRealityMap.get(session);
	                            if (desiredReality && this.isSupported(desiredReality)) {
	                                selectedReality = desiredReality;
	                                break;
	                            }
	                        }
	                    }
	                    return selectedReality;
	                };
	                RealityService.prototype.onGenerateViewFromEyeParameters = function (eye) {
	                    var fov = eye.fov || this._desiredFov || this._defaultFov;
	                    var viewport = eye.viewport || this.getMaximumViewport();
	                    var aspectRatio = eye.aspect || viewport.width / viewport.height;
	                    this._scratchFrustum.fov = fov;
	                    this._scratchFrustum.aspectRatio = aspectRatio;
	                    this._scratchFrustum.near = 0.01;
	                    this._scratchFrustum.far = 10000000;
	                    return {
	                        viewport: viewport,
	                        pose: eye.pose,
	                        subviews: [{
	                            type: common_1.SubviewType.SINGULAR,
	                            frustum: {
	                                fov: fov,
	                                aspectRatio: aspectRatio
	                            },
	                            // TODO: remove this later  
	                            projectionMatrix: cesium_imports_1.Matrix4.toArray(this._scratchFrustum.projectionMatrix, this._scratchArray)
	                        }]
	                    };
	                };
	                RealityService.prototype.zoom = function (data) {
	                    data.naturalFov = data.naturalFov || this._defaultFov;
	                    if (this._realitySession && this._realitySession.info['reality.handlesZoom']) {
	                        this._realitySession.send('ar.reality.zoom', data);
	                    } else {
	                        var fov = this._desiredFov = this.onZoom(data);
	                        if (this.sessionService.isRealityView) {
	                            this.sessionService.manager.send('ar.reality.desiredFov', { fov: fov });
	                        }
	                    }
	                };
	                RealityService.prototype.onZoom = function (data) {
	                    var newFov = 2 * Math.atan(Math.tan(data.fov * 0.5) / data.zoom);
	                    newFov = Math.max(10 * cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE, Math.min(newFov, 160 * cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE));
	                    if (data.state === RealityZoomState.END && Math.abs(newFov - data.naturalFov) < 0.05 /* +-6deg */) {
	                            newFov = data.naturalFov;
	                        }
	                    return newFov;
	                };
	                RealityService.prototype._setNextReality = function (reality, force) {
	                    var _this = this;
	                    if (force === void 0) {
	                        force = false;
	                    }
	                    if (this._current && reality && this._current === reality && !force) return;
	                    if (this._current && !reality && this._realitySession) return;
	                    if (!this._current && !cesium_imports_1.defined(reality)) {
	                        reality = this._default;
	                    }
	                    if (cesium_imports_1.defined(reality)) {
	                        if (!this.isSupported(reality)) {
	                            this.sessionService.errorEvent.raiseEvent(new Error('Reality of type "' + reality.uri + '" is not available on this platform'));
	                            return;
	                        }
	                        var loadID_1 = ++this._loadID;
	                        this._executeRealityLoader(reality, function (realitySession) {
	                            if (realitySession.isConnected) throw new Error('Expected an unconnected session');
	                            if (loadID_1 !== _this._loadID) {
	                                realitySession.close();
	                                return;
	                            }
	                            var previousRealitySession = _this._realitySession;
	                            _this._realitySession = realitySession;
	                            _this._setCurrent(reality);
	                            realitySession.on['ar.reality.frameState'] = function (serializedState) {
	                                var state = serializedState;
	                                if (!cesium_imports_1.defined(serializedState.view)) {
	                                    if (!cesium_imports_1.defined(serializedState.eye)) throw new Error("Unable to construct view configuration: missing eye parameters");
	                                    state.view = _this.onGenerateViewFromEyeParameters(serializedState.eye);
	                                    state.eye = undefined;
	                                    state.entities = serializedState.entities || {};
	                                }
	                                state.reality = _this.getCurrent();
	                                _this.frameEvent.raiseEvent(state);
	                            };
	                            realitySession.on['ar.reality.desiredFov'] = function (state) {
	                                _this._desiredFov = state.fov;
	                            };
	                            realitySession.closeEvent.addEventListener(function () {
	                                console.log('Reality session closed: ' + JSON.stringify(reality));
	                                // select a new reality if the current reality has closed without 
	                                // another reality having been requested
	                                if (_this._loadID === loadID_1) {
	                                    _this._realitySession = undefined;
	                                    _this._current = undefined;
	                                    _this._setNextReality(_this.onSelectReality());
	                                }
	                            });
	                            realitySession.connectEvent.addEventListener(function () {
	                                if (realitySession.info.role !== common_1.Role.REALITY_VIEW) {
	                                    realitySession.sendError({ message: "Expected a reality session" });
	                                    realitySession.close();
	                                    throw new Error('The application "' + realitySession.uri + '" does not support being loaded as a reality');
	                                }
	                                if (previousRealitySession) {
	                                    previousRealitySession.close();
	                                }
	                                if (realitySession.info['reality.supportsControlPort']) {
	                                    var ownerSession_1 = _this.desiredRealityMapInverse.get(reality) || _this.sessionService.manager;
	                                    var id = cesium_imports_1.createGuid();
	                                    var ROUTE_MESSAGE_KEY = 'ar.reality.message.route.' + id;
	                                    var SEND_MESSAGE_KEY_1 = 'ar.reality.message.send.' + id;
	                                    var CLOSE_SESSION_KEY_1 = 'ar.reality.close.' + id;
	                                    realitySession.on[ROUTE_MESSAGE_KEY] = function (message) {
	                                        ownerSession_1.send(SEND_MESSAGE_KEY_1, message);
	                                    };
	                                    ownerSession_1.on[ROUTE_MESSAGE_KEY] = function (message) {
	                                        realitySession.send(SEND_MESSAGE_KEY_1, message);
	                                    };
	                                    realitySession.send('ar.reality.connect', { id: id });
	                                    ownerSession_1.send('ar.reality.connect', { id: id });
	                                    realitySession.closeEvent.addEventListener(function () {
	                                        ownerSession_1.send(CLOSE_SESSION_KEY_1);
	                                    });
	                                    ownerSession_1.closeEvent.addEventListener(function () {
	                                        realitySession.send(CLOSE_SESSION_KEY_1);
	                                        realitySession.close();
	                                    });
	                                }
	                            });
	                        });
	                    }
	                };
	                RealityService.prototype._getLoader = function (reality) {
	                    var found;
	                    for (var _i = 0, _a = this._loaders; _i < _a.length; _i++) {
	                        var loader = _a[_i];
	                        if (loader.type === common_1.RealityView.getType(reality)) {
	                            found = loader;
	                            break;
	                        }
	                    }
	                    return found;
	                };
	                RealityService.prototype._setCurrent = function (reality) {
	                    if (this._current === undefined || this._current !== reality) {
	                        var previous = this._current;
	                        this._current = reality;
	                        this.changeEvent.raiseEvent({ previous: previous, current: reality });
	                        console.log('Reality changed to: ' + JSON.stringify(reality));
	                    }
	                };
	                RealityService.prototype._executeRealityLoader = function (reality, callback) {
	                    this.sessionService.ensureIsRealityManager();
	                    var loader = this._getLoader(reality);
	                    if (!loader) throw new Error('Unable to setup unsupported reality type: ' + reality.uri);
	                    loader.load(reality, callback);
	                };
	                RealityService = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, focus_1.FocusService)], RealityService);
	                return RealityService;
	            }();
	            exports_1("RealityService", RealityService);
	        }
	    };
	});
	$__System.register('17', ['c', 'a', '10', 'b', '12', '14', '11'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, cesium_imports_1, session_1, context_2, utils_1, focus_1, reality_1;
	    var argonContainer, argonContainerPromise, ViewService, PinchZoomService;
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (cesium_imports_1_1) {
	            cesium_imports_1 = cesium_imports_1_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	        }, function (context_2_1) {
	            context_2 = context_2_1;
	        }, function (utils_1_1) {
	            utils_1 = utils_1_1;
	        }, function (focus_1_1) {
	            focus_1 = focus_1_1;
	        }, function (reality_1_1) {
	            reality_1 = reality_1_1;
	        }],
	        execute: function () {
	            // setup our DOM environment
	            if (typeof document !== 'undefined' && document.createElement) {
	                var viewportMetaTag = document.querySelector('meta[name=viewport]');
	                if (!viewportMetaTag) viewportMetaTag = document.createElement('meta');
	                viewportMetaTag.name = 'viewport';
	                viewportMetaTag.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0';
	                document.head.appendChild(viewportMetaTag);
	                var argonMetaTag = document.querySelector('meta[name=argon]');
	                if (!argonMetaTag) argonMetaTag = document.createElement('meta');
	                argonMetaTag.name = 'argon';
	                document.head.appendChild(argonMetaTag);
	                argonContainerPromise = new Promise(function (resolve) {
	                    var resolveArgonContainer = function () {
	                        var container = document.querySelector('#argon');
	                        if (!container) container = document.createElement('div');
	                        container.id = 'argon';
	                        container.classList.add('argon-view');
	                        document.body.appendChild(container);
	                        argonContainer = container;
	                        resolve(container);
	                    };
	                    if (document.readyState == 'loading') {
	                        document.addEventListener('DOMContentLoaded', resolveArgonContainer);
	                    } else {
	                        resolveArgonContainer();
	                    }
	                });
	                var style = document.createElement("style");
	                style.type = 'text/css';
	                document.head.insertBefore(style, document.head.firstChild);
	                var sheet = style.sheet;
	                sheet.insertRule("\n        #argon {\n            position: fixed;\n            left: 0px;\n            bottom: 0px;\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            border: 0;\n            padding: 0;\n        }\n    ", 0);
	                sheet.insertRule("\n        .argon-view > * {\n            position: absolute;\n            pointer-events: none;\n        }\n    ", 1);
	            }
	            /**
	             * Manages the view state
	             */
	            ViewService = function () {
	                function ViewService(containerElement, sessionService, focusService, contextService) {
	                    var _this = this;
	                    this.sessionService = sessionService;
	                    this.focusService = focusService;
	                    this.contextService = contextService;
	                    /**
	                     * An event that is raised when the root viewport has changed
	                     */
	                    this.viewportChangeEvent = new utils_1.Event();
	                    /**
	                     * An event that is raised when ownership of the view has been acquired by this application
	                     */
	                    this.acquireEvent = new utils_1.Event();
	                    /**
	                     * An event that is raised when ownership of the view has been released from this application
	                    */
	                    this.releaseEvent = new utils_1.Event();
	                    /**
	                     *  Manager-only. A map of sessions to their desired viewports.
	                     */
	                    this.desiredViewportMap = new WeakMap();
	                    this._subviews = [];
	                    this._subviewEntities = [];
	                    this._frustums = [];
	                    if (typeof document !== 'undefined' && document.createElement) {
	                        var element_1 = this.element = document.createElement('div');
	                        element_1.style.width = '100%';
	                        element_1.style.height = '100%';
	                        element_1.classList.add('argon-view');
	                        this.containingElementPromise = new Promise(function (resolve) {
	                            if (containerElement && containerElement instanceof HTMLElement) {
	                                containerElement.insertBefore(element_1, containerElement.firstChild);
	                                resolve(containerElement);
	                            } else {
	                                argonContainer = document.querySelector('#argon');
	                                if (argonContainer) {
	                                    argonContainer.insertBefore(element_1, argonContainer.firstChild);
	                                    resolve(argonContainer);
	                                } else {
	                                    argonContainerPromise.then(function (argonContainer) {
	                                        argonContainer.insertBefore(element_1, argonContainer.firstChild);
	                                        resolve(argonContainer);
	                                    });
	                                }
	                                _this.focusService.focusEvent.addEventListener(function () {
	                                    argonContainerPromise.then(function (argonContainer) {
	                                        argonContainer.classList.remove('argon-no-focus');
	                                        argonContainer.classList.add('argon-focus');
	                                    });
	                                });
	                                _this.focusService.blurEvent.addEventListener(function () {
	                                    argonContainerPromise.then(function (argonContainer) {
	                                        argonContainer.classList.remove('argon-focus');
	                                        argonContainer.classList.add('argon-no-focus');
	                                    });
	                                });
	                            }
	                        });
	                    }
	                    if (this.sessionService.isRealityManager) {
	                        this.sessionService.connectEvent.addEventListener(function (session) {
	                            session.on['ar.viewport.desired'] = function (viewport) {
	                                _this.desiredViewportMap.set(session, viewport);
	                            };
	                        });
	                    }
	                    this.contextService.renderEvent.addEventListener(function () {
	                        var state = _this.contextService.serializedFrameState;
	                        var subviewEntities = _this._subviewEntities;
	                        subviewEntities.length = 0;
	                        state.view.subviews.forEach(function (subview, index) {
	                            var id = 'ar.view_' + index;
	                            state.entities[id] = subview.pose || state.view.pose;
	                            _this.contextService.updateEntityFromFrameState(id, state);
	                            delete state.entities[id];
	                            subviewEntities[index] = _this.contextService.entities.getById(id);
	                        });
	                        _this._update();
	                    });
	                }
	                ViewService.prototype.getSubviews = function (referenceFrame) {
	                    var _this = this;
	                    this._update();
	                    var subviews = this._subviews;
	                    subviews.length = this._current.subviews.length;
	                    this._current.subviews.forEach(function (serializedSubview, index) {
	                        var subviewEntity = _this._subviewEntities[index];
	                        var subview = subviews[index] = subviews[index] || {};
	                        subview.index = index;
	                        subview.type = serializedSubview.type;
	                        subview.pose = _this.contextService.getEntityPose(subviewEntity, referenceFrame);
	                        subview.viewport = serializedSubview.viewport || _this._current.viewport;
	                        subview.frustum = _this._frustums[index];
	                        if (!subview.frustum) {
	                            subview.frustum = _this._frustums[index] = new cesium_imports_1.PerspectiveFrustum();
	                            subview.frustum.near = 0.01;
	                            subview.frustum.far = 10000000;
	                        }
	                        subview.frustum.fov = serializedSubview.frustum.fov;
	                        subview.frustum.aspectRatio = serializedSubview.frustum.aspectRatio || subview.viewport.width / subview.viewport.height;
	                        subview.frustum.xOffset = serializedSubview.frustum.xOffset || 0;
	                        subview.frustum.yOffset = serializedSubview.frustum.yOffset || 0;
	                        subview.projectionMatrix = serializedSubview.projectionMatrix || subview.frustum.infiniteProjectionMatrix;
	                    });
	                    return subviews;
	                };
	                ViewService.prototype.getViewport = function () {
	                    return this._current.viewport;
	                };
	                /**
	                 * Set the desired root viewport
	                 */
	                ViewService.prototype.setDesiredViewport = function (viewport) {
	                    this.sessionService.manager.send('ar.view.desiredViewport', viewport);
	                };
	                /**
	                 * Request control over the view.
	                 * The manager is likely to reject this request if this application is not in focus.
	                 * When running on an HMD, this request will always fail. If the current reality view
	                 * does not support custom views, this request will fail. The manager may revoke
	                 * ownership at any time (even without this application calling releaseOwnership)
	                 */
	                ViewService.prototype.requestOwnership = function () {};
	                /**
	                 * Release control over the view.
	                 */
	                ViewService.prototype.releaseOwnership = function () {};
	                /**
	                 * Returns true if this application has control over the view.
	                 */
	                ViewService.prototype.isOwner = function () {};
	                // Updates the element, if necessary, and raise a view change event
	                ViewService.prototype._update = function () {
	                    var _this = this;
	                    var state = this.contextService.serializedFrameState;
	                    if (!state) throw new Error('Expected state to be defined');
	                    var view = state.view;
	                    var viewportJSON = JSON.stringify(view.viewport);
	                    var previousViewport = this._current && this._current.viewport;
	                    this._current = view;
	                    if (!this._currentViewportJSON || this._currentViewportJSON !== viewportJSON) {
	                        this._currentViewportJSON = viewportJSON;
	                        if (this.element) {
	                            requestAnimationFrame(function () {
	                                var viewport = view.viewport;
	                                _this.element.style.left = viewport.x + 'px';
	                                _this.element.style.bottom = viewport.y + 'px';
	                                _this.element.style.width = viewport.width + 'px';
	                                _this.element.style.height = viewport.height + 'px';
	                            });
	                        }
	                        this.viewportChangeEvent.raiseEvent({ previous: previousViewport });
	                    }
	                };
	                ViewService = __decorate([aurelia_dependency_injection_1.inject('containerElement', session_1.SessionService, focus_1.FocusService, context_2.ContextService)], ViewService);
	                return ViewService;
	            }();
	            exports_1("ViewService", ViewService);
	            PinchZoomService = function () {
	                function PinchZoomService(viewService, realityService, contextService, sessionService) {
	                    var _this = this;
	                    this.viewService = viewService;
	                    this.realityService = realityService;
	                    this.contextService = contextService;
	                    this.sessionService = sessionService;
	                    if (this.sessionService.isRealityManager) {
	                        this.viewService.containingElementPromise.then(function (el) {
	                            el.style.pointerEvents = 'auto';
	                            var fov = -1;
	                            if (typeof PointerEvent !== 'undefined') {
	                                var evCache_1 = new Array();
	                                var startDistSquared_1 = -1;
	                                var zoom_1 = 1;
	                                var remove_event_1 = function (ev) {
	                                    // Remove this event from the target's cache
	                                    for (var i = 0; i < evCache_1.length; i++) {
	                                        if (evCache_1[i].pointerId == ev.pointerId) {
	                                            evCache_1.splice(i, 1);
	                                            break;
	                                        }
	                                    }
	                                };
	                                var pointerdown_handler = function (ev) {
	                                    // The pointerdown event signals the start of a touch interaction.
	                                    // This event is cached to support 2-finger gestures
	                                    evCache_1.push(ev);
	                                };
	                                var pointermove_handler = function (ev) {
	                                    // This function implements a 2-pointer pinch/zoom gesture. 
	                                    // Find this event in the cache and update its record with this event
	                                    for (var i = 0; i < evCache_1.length; i++) {
	                                        if (ev.pointerId == evCache_1[i].pointerId) {
	                                            evCache_1[i] = ev;
	                                            break;
	                                        }
	                                    }
	                                    var state = _this.contextService.serializedFrameState;
	                                    if (!state) return;
	                                    // If two pointers are down, check for pinch gestures
	                                    if (evCache_1.length == 2) {
	                                        // Calculate the distance between the two pointers
	                                        var curDiffX = Math.abs(evCache_1[0].clientX - evCache_1[1].clientX);
	                                        var curDiffY = Math.abs(evCache_1[0].clientY - evCache_1[1].clientY);
	                                        var currDistSquared = curDiffX * curDiffX + curDiffY * curDiffY;
	                                        if (startDistSquared_1 == -1) {
	                                            // start pinch
	                                            startDistSquared_1 = currDistSquared;
	                                            fov = state.view.subviews[0].frustum.fov;
	                                            zoom_1 = 1;
	                                            _this.realityService.zoom({ zoom: zoom_1, fov: fov, state: reality_1.RealityZoomState.START });
	                                        } else {
	                                            // change pinch
	                                            zoom_1 = currDistSquared / startDistSquared_1;
	                                            _this.realityService.zoom({ zoom: zoom_1, fov: fov, state: reality_1.RealityZoomState.CHANGE });
	                                        }
	                                    } else {
	                                        // end pinch                            
	                                        _this.realityService.zoom({ zoom: zoom_1, fov: fov, state: reality_1.RealityZoomState.END });
	                                        startDistSquared_1 = -1;
	                                    }
	                                };
	                                var pointerup_handler = function (ev) {
	                                    // Remove this pointer from the cache
	                                    remove_event_1(ev);
	                                    // If the number of pointers down is less than two then reset diff tracker
	                                    if (evCache_1.length < 2) startDistSquared_1 = -1;
	                                };
	                                el.onpointerdown = pointerdown_handler;
	                                el.onpointermove = pointermove_handler;
	                                // Use same handler for pointer{up,cancel,out,leave} events since
	                                // the semantics for these events - in this app - are the same.
	                                el.onpointerup = pointerup_handler;
	                                el.onpointercancel = pointerup_handler;
	                                el.onpointerout = pointerup_handler;
	                                el.onpointerleave = pointerup_handler;
	                            } else {
	                                el.addEventListener('gesturestart', function (ev) {
	                                    var state = _this.contextService.serializedFrameState;
	                                    if (state && state.view.subviews[0]) {
	                                        fov = state.view.subviews[0].frustum.fov;
	                                        _this.realityService.zoom({ zoom: ev.scale, fov: fov, state: reality_1.RealityZoomState.START });
	                                    }
	                                });
	                                el.addEventListener('gesturechange', function (ev) {
	                                    _this.realityService.zoom({ zoom: ev.scale, fov: fov, state: reality_1.RealityZoomState.CHANGE });
	                                });
	                                el.addEventListener('gestureend', function (ev) {
	                                    _this.realityService.zoom({ zoom: ev.scale, fov: fov, state: reality_1.RealityZoomState.END });
	                                });
	                            }
	                        });
	                    }
	                }
	                PinchZoomService = __decorate([aurelia_dependency_injection_1.inject(ViewService, reality_1.RealityService, context_2.ContextService, session_1.SessionService)], PinchZoomService);
	                return PinchZoomService;
	            }();
	            exports_1("PinchZoomService", PinchZoomService);
	        }
	    };
	});
	$__System.register('18', ['c', '10', '11', '17'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var __extends = this && this.__extends || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() {
	            this.constructor = d;
	        }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
	        var c = arguments.length,
	            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	            d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	    var aurelia_dependency_injection_1, session_1, reality_1, view_1;
	    var HostedRealityLoader;
	    return {
	        setters: [function (aurelia_dependency_injection_1_1) {
	            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	        }, function (reality_1_1) {
	            reality_1 = reality_1_1;
	        }, function (view_1_1) {
	            view_1 = view_1_1;
	        }],
	        execute: function () {
	            HostedRealityLoader = function (_super) {
	                __extends(HostedRealityLoader, _super);
	                function HostedRealityLoader(sessionService, viewService) {
	                    var _this = this;
	                    _super.call(this);
	                    this.sessionService = sessionService;
	                    this.viewService = viewService;
	                    this.type = 'hosted';
	                    this.iframeElement = document.createElement('iframe');
	                    this.iframeElement.style.border = '0';
	                    this.iframeElement.width = '100%';
	                    this.iframeElement.height = '100%';
	                    viewService.containingElementPromise.then(function (container) {
	                        container.insertBefore(_this.iframeElement, container.firstChild);
	                    });
	                }
	                HostedRealityLoader.prototype.load = function (reality, callback) {
	                    var _this = this;
	                    this.viewService.containingElementPromise.then(function (container) {
	                        var handleConnectMessage = function (ev) {
	                            if (ev.data.type !== 'ARGON_SESSION') return;
	                            var messagePort = ev.ports && ev.ports[0];
	                            if (!messagePort) throw new Error('Received an ARGON_SESSION message without a MessagePort object');
	                            // get the event.source iframe
	                            var i = 0;
	                            var frame;
	                            while (i < window.frames.length && !frame) {
	                                if (window.frames[i] == ev.source) frame = document.getElementsByTagName('iframe')[i];
	                            }
	                            if (frame !== _this.iframeElement) return;
	                            window.removeEventListener('message', handleConnectMessage);
	                            var realitySession = _this.sessionService.addManagedSessionPort(reality.uri);
	                            callback(realitySession);
	                            realitySession.open(messagePort, _this.sessionService.configuration);
	                        };
	                        window.addEventListener('message', handleConnectMessage);
	                        _this.iframeElement.src = '';
	                        _this.iframeElement.src = reality.uri;
	                        _this.iframeElement.style.pointerEvents = 'auto';
	                    });
	                };
	                HostedRealityLoader = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, view_1.ViewService)], HostedRealityLoader);
	                return HostedRealityLoader;
	            }(reality_1.RealityLoader);
	            exports_1("HostedRealityLoader", HostedRealityLoader);
	        }
	    };
	});
	// @singleton()
	// @inject(SessionFactory)
	// export class DOMSessionListenerService {
	// 	public sessionEvent = new Event<Session>();
	// 	constructor(sessionFactory:SessionFactory) {
	// 		window.addEventListener('message', ev => {
	// 			if (ev.data.type != 'ARGON_SESSION') return;
	// 			const messagePort:MessagePortLike = ev.ports && ev.ports[0];
	// 			if (!messagePort) 
	// 				throw new Error('Received an ARGON_SESSION message without a MessagePort object');
	// 			// get the event.source iframe
	// 			let i = 0;
	// 			let frame:HTMLIFrameElement = null;
	// 			while (i < window.frames.length && frame != null) {
	// 				if (window.frames[i] == ev.source)
	// 					frame = document.getElementsByTagName( 'iframe' )[i];
	// 			}			
	// 			const session = sessionFactory.create();
	// 			session.frame = frame;
	// 			if (frame) frame.addEventListener('load', function close() {
	// 				frame.removeEventListener('load', close);
	// 				console.log('IFrameSessionHandler: frame load detected, closing current session.', frame, session)
	// 				session.close()
	// 			});
	// 			this.sessionEvent.raiseEvent(session);
	// 		});
	// 	}
	// }
	(function() {
	var define = $__System.amdDefine;
	define("19", ["1a", "1b", "1c", "1d"], function(defined, defineProperties, DeveloperError, Event) {
	  'use strict';
	  function CallbackProperty(callback, isConstant) {
	    this._callback = undefined;
	    this._isConstant = undefined;
	    this._definitionChanged = new Event();
	    this.setCallback(callback, isConstant);
	  }
	  defineProperties(CallbackProperty.prototype, {
	    isConstant: {get: function() {
	        return this._isConstant;
	      }},
	    definitionChanged: {get: function() {
	        return this._definitionChanged;
	      }}
	  });
	  CallbackProperty.prototype.getValue = function(time, result) {
	    return this._callback(time, result);
	  };
	  CallbackProperty.prototype.setCallback = function(callback, isConstant) {
	    if (!defined(callback)) {
	      throw new DeveloperError('callback is required.');
	    }
	    if (!defined(isConstant)) {
	      throw new DeveloperError('isConstant is required.');
	    }
	    var changed = this._callback !== callback || this._isConstant !== isConstant;
	    this._callback = callback;
	    this._isConstant = isConstant;
	    if (changed) {
	      this._definitionChanged.raiseEvent(this);
	    }
	  };
	  CallbackProperty.prototype.equals = function(other) {
	    return this === other || (other instanceof CallbackProperty && this._callback === other._callback && this._isConstant === other._isConstant);
	  };
	  return CallbackProperty;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("1e", ["1f"], function(freezeObject) {
	  'use strict';
	  var ClockRange = {
	    UNBOUNDED: 0,
	    CLAMPED: 1,
	    LOOP_STOP: 2
	  };
	  return freezeObject(ClockRange);
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("20", ["1a"], function(defined) {
	  'use strict';
	  var getTimestamp;
	  if (typeof performance !== 'undefined' && defined(performance.now)) {
	    getTimestamp = function() {
	      return performance.now();
	    };
	  } else {
	    getTimestamp = function() {
	      return Date.now();
	    };
	  }
	  return getTimestamp;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("21", ["1e", "22", "23", "1a", "1c", "1d", "20", "24"], function(ClockRange, ClockStep, defaultValue, defined, DeveloperError, Event, getTimestamp, JulianDate) {
	  'use strict';
	  function Clock(options) {
	    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	    var startTime = options.startTime;
	    var startTimeUndefined = !defined(startTime);
	    var stopTime = options.stopTime;
	    var stopTimeUndefined = !defined(stopTime);
	    var currentTime = options.currentTime;
	    var currentTimeUndefined = !defined(currentTime);
	    if (startTimeUndefined && stopTimeUndefined && currentTimeUndefined) {
	      currentTime = JulianDate.now();
	      startTime = JulianDate.clone(currentTime);
	      stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
	    } else if (startTimeUndefined && stopTimeUndefined) {
	      startTime = JulianDate.clone(currentTime);
	      stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
	    } else if (startTimeUndefined && currentTimeUndefined) {
	      startTime = JulianDate.addDays(stopTime, -1.0, new JulianDate());
	      currentTime = JulianDate.clone(startTime);
	    } else if (currentTimeUndefined && stopTimeUndefined) {
	      currentTime = JulianDate.clone(startTime);
	      stopTime = JulianDate.addDays(startTime, 1.0, new JulianDate());
	    } else if (currentTimeUndefined) {
	      currentTime = JulianDate.clone(startTime);
	    } else if (stopTimeUndefined) {
	      stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
	    } else if (startTimeUndefined) {
	      startTime = JulianDate.clone(currentTime);
	    }
	    if (JulianDate.greaterThan(startTime, stopTime)) {
	      throw new DeveloperError('startTime must come before stopTime.');
	    }
	    this.startTime = startTime;
	    this.stopTime = stopTime;
	    this.currentTime = currentTime;
	    this.multiplier = defaultValue(options.multiplier, 1.0);
	    this.clockStep = defaultValue(options.clockStep, ClockStep.SYSTEM_CLOCK_MULTIPLIER);
	    this.clockRange = defaultValue(options.clockRange, ClockRange.UNBOUNDED);
	    this.canAnimate = defaultValue(options.canAnimate, true);
	    this.shouldAnimate = defaultValue(options.shouldAnimate, true);
	    this.onTick = new Event();
	    this._lastSystemTime = getTimestamp();
	  }
	  Clock.prototype.tick = function() {
	    var currentSystemTime = getTimestamp();
	    var currentTime = JulianDate.clone(this.currentTime);
	    var startTime = this.startTime;
	    var stopTime = this.stopTime;
	    var multiplier = this.multiplier;
	    if (this.canAnimate && this.shouldAnimate) {
	      if (this.clockStep === ClockStep.SYSTEM_CLOCK) {
	        currentTime = JulianDate.now(currentTime);
	      } else {
	        if (this.clockStep === ClockStep.TICK_DEPENDENT) {
	          currentTime = JulianDate.addSeconds(currentTime, multiplier, currentTime);
	        } else {
	          var milliseconds = currentSystemTime - this._lastSystemTime;
	          currentTime = JulianDate.addSeconds(currentTime, multiplier * (milliseconds / 1000.0), currentTime);
	        }
	        if (this.clockRange === ClockRange.CLAMPED) {
	          if (JulianDate.lessThan(currentTime, startTime)) {
	            currentTime = JulianDate.clone(startTime, currentTime);
	          } else if (JulianDate.greaterThan(currentTime, stopTime)) {
	            currentTime = JulianDate.clone(stopTime, currentTime);
	          }
	        } else if (this.clockRange === ClockRange.LOOP_STOP) {
	          if (JulianDate.lessThan(currentTime, startTime)) {
	            currentTime = JulianDate.clone(startTime, currentTime);
	          }
	          while (JulianDate.greaterThan(currentTime, stopTime)) {
	            currentTime = JulianDate.addSeconds(startTime, JulianDate.secondsDifference(currentTime, stopTime), currentTime);
	          }
	        }
	      }
	    }
	    this.currentTime = currentTime;
	    this._lastSystemTime = currentSystemTime;
	    this.onTick.raiseEvent(this);
	    return currentTime;
	  };
	  return Clock;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("22", ["1f"], function(freezeObject) {
	  'use strict';
	  var ClockStep = {
	    TICK_DEPENDENT: 0,
	    SYSTEM_CLOCK_MULTIPLIER: 1,
	    SYSTEM_CLOCK: 2
	  };
	  return freezeObject(ClockStep);
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("25", ["26", "1a", "1b", "1c", "27", "28", "29"], function(createGuid, defined, defineProperties, DeveloperError, CesiumMath, Entity, EntityCollection) {
	  'use strict';
	  var entityOptionsScratch = {id: undefined};
	  var entityIdScratch = new Array(2);
	  function clean(entity) {
	    var propertyNames = entity.propertyNames;
	    var propertyNamesLength = propertyNames.length;
	    for (var i = 0; i < propertyNamesLength; i++) {
	      entity[propertyNames[i]] = undefined;
	    }
	  }
	  function subscribeToEntity(that, eventHash, collectionId, entity) {
	    entityIdScratch[0] = collectionId;
	    entityIdScratch[1] = entity.id;
	    eventHash[JSON.stringify(entityIdScratch)] = entity.definitionChanged.addEventListener(CompositeEntityCollection.prototype._onDefinitionChanged, that);
	  }
	  function unsubscribeFromEntity(that, eventHash, collectionId, entity) {
	    entityIdScratch[0] = collectionId;
	    entityIdScratch[1] = entity.id;
	    var id = JSON.stringify(entityIdScratch);
	    eventHash[id]();
	    eventHash[id] = undefined;
	  }
	  function recomposite(that) {
	    that._shouldRecomposite = true;
	    if (that._suspendCount !== 0) {
	      return;
	    }
	    var collections = that._collections;
	    var collectionsLength = collections.length;
	    var collectionsCopy = that._collectionsCopy;
	    var collectionsCopyLength = collectionsCopy.length;
	    var i;
	    var entity;
	    var entities;
	    var iEntities;
	    var collection;
	    var composite = that._composite;
	    var newEntities = new EntityCollection(that);
	    var eventHash = that._eventHash;
	    var collectionId;
	    for (i = 0; i < collectionsCopyLength; i++) {
	      collection = collectionsCopy[i];
	      collection.collectionChanged.removeEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);
	      entities = collection.values;
	      collectionId = collection.id;
	      for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {
	        entity = entities[iEntities];
	        unsubscribeFromEntity(that, eventHash, collectionId, entity);
	      }
	    }
	    for (i = collectionsLength - 1; i >= 0; i--) {
	      collection = collections[i];
	      collection.collectionChanged.addEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);
	      entities = collection.values;
	      collectionId = collection.id;
	      for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {
	        entity = entities[iEntities];
	        subscribeToEntity(that, eventHash, collectionId, entity);
	        var compositeEntity = newEntities.getById(entity.id);
	        if (!defined(compositeEntity)) {
	          compositeEntity = composite.getById(entity.id);
	          if (!defined(compositeEntity)) {
	            entityOptionsScratch.id = entity.id;
	            compositeEntity = new Entity(entityOptionsScratch);
	          } else {
	            clean(compositeEntity);
	          }
	          newEntities.add(compositeEntity);
	        }
	        compositeEntity.merge(entity);
	      }
	    }
	    that._collectionsCopy = collections.slice(0);
	    composite.suspendEvents();
	    composite.removeAll();
	    var newEntitiesArray = newEntities.values;
	    for (i = 0; i < newEntitiesArray.length; i++) {
	      composite.add(newEntitiesArray[i]);
	    }
	    composite.resumeEvents();
	  }
	  function CompositeEntityCollection(collections, owner) {
	    this._owner = owner;
	    this._composite = new EntityCollection(this);
	    this._suspendCount = 0;
	    this._collections = defined(collections) ? collections.slice() : [];
	    this._collectionsCopy = [];
	    this._id = createGuid();
	    this._eventHash = {};
	    recomposite(this);
	    this._shouldRecomposite = false;
	  }
	  defineProperties(CompositeEntityCollection.prototype, {
	    collectionChanged: {get: function() {
	        return this._composite._collectionChanged;
	      }},
	    id: {get: function() {
	        return this._id;
	      }},
	    values: {get: function() {
	        return this._composite.values;
	      }},
	    owner: {get: function() {
	        return this._owner;
	      }}
	  });
	  CompositeEntityCollection.prototype.addCollection = function(collection, index) {
	    var hasIndex = defined(index);
	    if (!defined(collection)) {
	      throw new DeveloperError('collection is required.');
	    }
	    if (hasIndex) {
	      if (index < 0) {
	        throw new DeveloperError('index must be greater than or equal to zero.');
	      } else if (index > this._collections.length) {
	        throw new DeveloperError('index must be less than or equal to the number of collections.');
	      }
	    }
	    if (!hasIndex) {
	      index = this._collections.length;
	      this._collections.push(collection);
	    } else {
	      this._collections.splice(index, 0, collection);
	    }
	    recomposite(this);
	  };
	  CompositeEntityCollection.prototype.removeCollection = function(collection) {
	    var index = this._collections.indexOf(collection);
	    if (index !== -1) {
	      this._collections.splice(index, 1);
	      recomposite(this);
	      return true;
	    }
	    return false;
	  };
	  CompositeEntityCollection.prototype.removeAllCollections = function() {
	    this._collections.length = 0;
	    recomposite(this);
	  };
	  CompositeEntityCollection.prototype.containsCollection = function(collection) {
	    return this._collections.indexOf(collection) !== -1;
	  };
	  CompositeEntityCollection.prototype.contains = function(entity) {
	    return this._composite.contains(entity);
	  };
	  CompositeEntityCollection.prototype.indexOfCollection = function(collection) {
	    return this._collections.indexOf(collection);
	  };
	  CompositeEntityCollection.prototype.getCollection = function(index) {
	    if (!defined(index)) {
	      throw new DeveloperError('index is required.', 'index');
	    }
	    return this._collections[index];
	  };
	  CompositeEntityCollection.prototype.getCollectionsLength = function() {
	    return this._collections.length;
	  };
	  function getCollectionIndex(collections, collection) {
	    if (!defined(collection)) {
	      throw new DeveloperError('collection is required.');
	    }
	    var index = collections.indexOf(collection);
	    if (index === -1) {
	      throw new DeveloperError('collection is not in this composite.');
	    }
	    return index;
	  }
	  function swapCollections(composite, i, j) {
	    var arr = composite._collections;
	    i = CesiumMath.clamp(i, 0, arr.length - 1);
	    j = CesiumMath.clamp(j, 0, arr.length - 1);
	    if (i === j) {
	      return;
	    }
	    var temp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = temp;
	    recomposite(composite);
	  }
	  CompositeEntityCollection.prototype.raiseCollection = function(collection) {
	    var index = getCollectionIndex(this._collections, collection);
	    swapCollections(this, index, index + 1);
	  };
	  CompositeEntityCollection.prototype.lowerCollection = function(collection) {
	    var index = getCollectionIndex(this._collections, collection);
	    swapCollections(this, index, index - 1);
	  };
	  CompositeEntityCollection.prototype.raiseCollectionToTop = function(collection) {
	    var index = getCollectionIndex(this._collections, collection);
	    if (index === this._collections.length - 1) {
	      return;
	    }
	    this._collections.splice(index, 1);
	    this._collections.push(collection);
	    recomposite(this);
	  };
	  CompositeEntityCollection.prototype.lowerCollectionToBottom = function(collection) {
	    var index = getCollectionIndex(this._collections, collection);
	    if (index === 0) {
	      return;
	    }
	    this._collections.splice(index, 1);
	    this._collections.splice(0, 0, collection);
	    recomposite(this);
	  };
	  CompositeEntityCollection.prototype.suspendEvents = function() {
	    this._suspendCount++;
	    this._composite.suspendEvents();
	  };
	  CompositeEntityCollection.prototype.resumeEvents = function() {
	    if (this._suspendCount === 0) {
	      throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
	    }
	    this._suspendCount--;
	    if (this._shouldRecomposite && this._suspendCount === 0) {
	      recomposite(this);
	      this._shouldRecomposite = false;
	    }
	    this._composite.resumeEvents();
	  };
	  CompositeEntityCollection.prototype.computeAvailability = function() {
	    return this._composite.computeAvailability();
	  };
	  CompositeEntityCollection.prototype.getById = function(id) {
	    return this._composite.getById(id);
	  };
	  CompositeEntityCollection.prototype._onCollectionChanged = function(collection, added, removed) {
	    var collections = this._collectionsCopy;
	    var collectionsLength = collections.length;
	    var composite = this._composite;
	    composite.suspendEvents();
	    var i;
	    var q;
	    var entity;
	    var compositeEntity;
	    var removedLength = removed.length;
	    var eventHash = this._eventHash;
	    var collectionId = collection.id;
	    for (i = 0; i < removedLength; i++) {
	      var removedEntity = removed[i];
	      unsubscribeFromEntity(this, eventHash, collectionId, removedEntity);
	      var removedId = removedEntity.id;
	      for (q = collectionsLength - 1; q >= 0; q--) {
	        entity = collections[q].getById(removedId);
	        if (defined(entity)) {
	          if (!defined(compositeEntity)) {
	            compositeEntity = composite.getById(removedId);
	            clean(compositeEntity);
	          }
	          compositeEntity.merge(entity);
	        }
	      }
	      if (!defined(compositeEntity)) {
	        composite.removeById(removedId);
	      }
	      compositeEntity = undefined;
	    }
	    var addedLength = added.length;
	    for (i = 0; i < addedLength; i++) {
	      var addedEntity = added[i];
	      subscribeToEntity(this, eventHash, collectionId, addedEntity);
	      var addedId = addedEntity.id;
	      for (q = collectionsLength - 1; q >= 0; q--) {
	        entity = collections[q].getById(addedId);
	        if (defined(entity)) {
	          if (!defined(compositeEntity)) {
	            compositeEntity = composite.getById(addedId);
	            if (!defined(compositeEntity)) {
	              entityOptionsScratch.id = addedId;
	              compositeEntity = new Entity(entityOptionsScratch);
	              composite.add(compositeEntity);
	            } else {
	              clean(compositeEntity);
	            }
	          }
	          compositeEntity.merge(entity);
	        }
	      }
	      compositeEntity = undefined;
	    }
	    composite.resumeEvents();
	  };
	  CompositeEntityCollection.prototype._onDefinitionChanged = function(entity, propertyName, newValue, oldValue) {
	    var collections = this._collections;
	    var composite = this._composite;
	    var collectionsLength = collections.length;
	    var id = entity.id;
	    var compositeEntity = composite.getById(id);
	    var compositeProperty = compositeEntity[propertyName];
	    var newProperty = !defined(compositeProperty);
	    var firstTime = true;
	    for (var q = collectionsLength - 1; q >= 0; q--) {
	      var innerEntity = collections[q].getById(entity.id);
	      if (defined(innerEntity)) {
	        var property = innerEntity[propertyName];
	        if (defined(property)) {
	          if (firstTime) {
	            firstTime = false;
	            if (defined(property.merge) && defined(property.clone)) {
	              compositeProperty = property.clone(compositeProperty);
	            } else {
	              compositeProperty = property;
	              break;
	            }
	          }
	          compositeProperty.merge(property);
	        }
	      }
	    }
	    if (newProperty && compositeEntity.propertyNames.indexOf(propertyName) === -1) {
	      compositeEntity.addProperty(propertyName);
	    }
	    compositeEntity[propertyName] = compositeProperty;
	  };
	  return CompositeEntityCollection;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("2a", ["1a", "1b", "1c"], function(defined, defineProperties, DeveloperError) {
	  'use strict';
	  function AssociativeArray() {
	    this._array = [];
	    this._hash = {};
	  }
	  defineProperties(AssociativeArray.prototype, {
	    length: {get: function() {
	        return this._array.length;
	      }},
	    values: {get: function() {
	        return this._array;
	      }}
	  });
	  AssociativeArray.prototype.contains = function(key) {
	    if (typeof key !== 'string' && typeof key !== 'number') {
	      throw new DeveloperError('key is required to be a string or number.');
	    }
	    return defined(this._hash[key]);
	  };
	  AssociativeArray.prototype.set = function(key, value) {
	    if (typeof key !== 'string' && typeof key !== 'number') {
	      throw new DeveloperError('key is required to be a string or number.');
	    }
	    var oldValue = this._hash[key];
	    if (value !== oldValue) {
	      this.remove(key);
	      this._hash[key] = value;
	      this._array.push(value);
	    }
	  };
	  AssociativeArray.prototype.get = function(key) {
	    if (typeof key !== 'string' && typeof key !== 'number') {
	      throw new DeveloperError('key is required to be a string or number.');
	    }
	    return this._hash[key];
	  };
	  AssociativeArray.prototype.remove = function(key) {
	    if (defined(key) && typeof key !== 'string' && typeof key !== 'number') {
	      throw new DeveloperError('key is required to be a string or number.');
	    }
	    var value = this._hash[key];
	    var hasValue = defined(value);
	    if (hasValue) {
	      var array = this._array;
	      array.splice(array.indexOf(value), 1);
	      delete this._hash[key];
	    }
	    return hasValue;
	  };
	  AssociativeArray.prototype.removeAll = function() {
	    var array = this._array;
	    if (array.length > 0) {
	      this._hash = {};
	      array.length = 0;
	    }
	  };
	  return AssociativeArray;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("26", [], function() {
	  'use strict';
	  function createGuid() {
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	      var r = Math.random() * 16 | 0;
	      var v = c === 'x' ? r : (r & 0x3 | 0x8);
	      return v.toString(16);
	    });
	  }
	  return createGuid;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("2b", ["2c", "23", "1a", "1b", "1c", "1d", "2d", "2e"], function(Cartesian3, defaultValue, defined, defineProperties, DeveloperError, Event, ReferenceFrame, PositionProperty) {
	  'use strict';
	  function ConstantPositionProperty(value, referenceFrame) {
	    this._definitionChanged = new Event();
	    this._value = Cartesian3.clone(value);
	    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
	  }
	  defineProperties(ConstantPositionProperty.prototype, {
	    isConstant: {get: function() {
	        return !defined(this._value) || this._referenceFrame === ReferenceFrame.FIXED;
	      }},
	    definitionChanged: {get: function() {
	        return this._definitionChanged;
	      }},
	    referenceFrame: {get: function() {
	        return this._referenceFrame;
	      }}
	  });
	  ConstantPositionProperty.prototype.getValue = function(time, result) {
	    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
	  };
	  ConstantPositionProperty.prototype.setValue = function(value, referenceFrame) {
	    var definitionChanged = false;
	    if (!Cartesian3.equals(this._value, value)) {
	      definitionChanged = true;
	      this._value = Cartesian3.clone(value);
	    }
	    if (defined(referenceFrame) && this._referenceFrame !== referenceFrame) {
	      definitionChanged = true;
	      this._referenceFrame = referenceFrame;
	    }
	    if (definitionChanged) {
	      this._definitionChanged.raiseEvent(this);
	    }
	  };
	  ConstantPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	    if (!defined(time)) {
	      throw new DeveloperError('time is required.');
	    }
	    if (!defined(referenceFrame)) {
	      throw new DeveloperError('referenceFrame is required.');
	    }
	    return PositionProperty.convertToReferenceFrame(time, this._value, this._referenceFrame, referenceFrame, result);
	  };
	  ConstantPositionProperty.prototype.equals = function(other) {
	    return this === other || (other instanceof ConstantPositionProperty && Cartesian3.equals(this._value, other._value) && this._referenceFrame === other._referenceFrame);
	  };
	  return ConstantPositionProperty;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("2f", ["23", "1a", "1b", "1c", "1d"], function(defaultValue, defined, defineProperties, DeveloperError, Event) {
	  'use strict';
	  function ConstantProperty(value) {
	    this._value = undefined;
	    this._hasClone = false;
	    this._hasEquals = false;
	    this._definitionChanged = new Event();
	    this.setValue(value);
	  }
	  defineProperties(ConstantProperty.prototype, {
	    isConstant: {value: true},
	    definitionChanged: {get: function() {
	        return this._definitionChanged;
	      }}
	  });
	  ConstantProperty.prototype.getValue = function(time, result) {
	    return this._hasClone ? this._value.clone(result) : this._value;
	  };
	  ConstantProperty.prototype.setValue = function(value) {
	    var oldValue = this._value;
	    if (oldValue !== value) {
	      var isDefined = defined(value);
	      var hasClone = isDefined && typeof value.clone === 'function';
	      var hasEquals = isDefined && typeof value.equals === 'function';
	      this._hasClone = hasClone;
	      this._hasEquals = hasEquals;
	      var changed = !hasEquals || !value.equals(oldValue);
	      if (changed) {
	        this._value = !hasClone ? value : value.clone();
	        this._definitionChanged.raiseEvent(this);
	      }
	    }
	  };
	  ConstantProperty.prototype.equals = function(other) {
	    return this === other || (other instanceof ConstantProperty && ((!this._hasEquals && (this._value === other._value)) || (this._hasEquals && this._value.equals(other._value))));
	  };
	  return ConstantProperty;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("30", ["23", "1a", "2f"], function(defaultValue, defined, ConstantProperty) {
	  'use strict';
	  function createProperty(name, privateName, subscriptionName, configurable, createPropertyCallback) {
	    return {
	      configurable: configurable,
	      get: function() {
	        return this[privateName];
	      },
	      set: function(value) {
	        var oldValue = this[privateName];
	        var subscription = this[subscriptionName];
	        if (defined(subscription)) {
	          subscription();
	          this[subscriptionName] = undefined;
	        }
	        var hasValue = defined(value);
	        if (hasValue && !defined(value.getValue) && defined(createPropertyCallback)) {
	          value = createPropertyCallback(value);
	        }
	        if (oldValue !== value) {
	          this[privateName] = value;
	          this._definitionChanged.raiseEvent(this, name, value, oldValue);
	        }
	        if (defined(value) && defined(value.definitionChanged)) {
	          this[subscriptionName] = value.definitionChanged.addEventListener(function() {
	            this._definitionChanged.raiseEvent(this, name, value, value);
	          }, this);
	        }
	      }
	    };
	  }
	  function createConstantProperty(value) {
	    return new ConstantProperty(value);
	  }
	  function createPropertyDescriptor(name, configurable, createPropertyCallback) {
	    return createProperty(name, '_' + name.toString(), '_' + name.toString() + 'Subscription', defaultValue(configurable, false), defaultValue(createPropertyCallback, createConstantProperty));
	  }
	  return createPropertyDescriptor;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("31", ["30"], function(createPropertyDescriptor) {
	  'use strict';
	  function createRawProperty(value) {
	    return value;
	  }
	  function createRawPropertyDescriptor(name, configurable) {
	    return createPropertyDescriptor(name, configurable, createRawProperty);
	  }
	  return createRawPropertyDescriptor;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("28", ["2c", "26", "23", "1a", "1b", "1c", "1d", "32", "33", "34", "35", "@empty", "@empty", "2b", "@empty", "30", "31", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "36", "@empty", "@empty"], function(Cartesian3, createGuid, defaultValue, defined, defineProperties, DeveloperError, Event, Matrix3, Matrix4, Quaternion, Transforms, BillboardGraphics, BoxGraphics, ConstantPositionProperty, CorridorGraphics, createPropertyDescriptor, createRawPropertyDescriptor, CylinderGraphics, EllipseGraphics, EllipsoidGraphics, LabelGraphics, ModelGraphics, PathGraphics, PointGraphics, PolygonGraphics, PolylineGraphics, PolylineVolumeGraphics, Property, RectangleGraphics, WallGraphics) {
	  'use strict';
	  function createConstantPositionProperty(value) {
	    return new ConstantPositionProperty(value);
	  }
	  function createPositionPropertyDescriptor(name) {
	    return createPropertyDescriptor(name, undefined, createConstantPositionProperty);
	  }
	  function createPropertyTypeDescriptor(name, Type) {
	    return createPropertyDescriptor(name, undefined, function(value) {
	      if (value instanceof Type) {
	        return value;
	      }
	      return new Type(value);
	    });
	  }
	  function Entity(options) {
	    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	    var id = options.id;
	    if (!defined(id)) {
	      id = createGuid();
	    }
	    this._availability = undefined;
	    this._id = id;
	    this._definitionChanged = new Event();
	    this._name = options.name;
	    this._show = defaultValue(options.show, true);
	    this._parent = undefined;
	    this._propertyNames = ['billboard', 'box', 'corridor', 'cylinder', 'description', 'ellipse', 'ellipsoid', 'label', 'model', 'orientation', 'path', 'point', 'polygon', 'polyline', 'polylineVolume', 'position', 'rectangle', 'viewFrom', 'wall'];
	    this._billboard = undefined;
	    this._billboardSubscription = undefined;
	    this._box = undefined;
	    this._boxSubscription = undefined;
	    this._corridor = undefined;
	    this._corridorSubscription = undefined;
	    this._cylinder = undefined;
	    this._cylinderSubscription = undefined;
	    this._description = undefined;
	    this._descriptionSubscription = undefined;
	    this._ellipse = undefined;
	    this._ellipseSubscription = undefined;
	    this._ellipsoid = undefined;
	    this._ellipsoidSubscription = undefined;
	    this._label = undefined;
	    this._labelSubscription = undefined;
	    this._model = undefined;
	    this._modelSubscription = undefined;
	    this._orientation = undefined;
	    this._orientationSubscription = undefined;
	    this._path = undefined;
	    this._pathSubscription = undefined;
	    this._point = undefined;
	    this._pointSubscription = undefined;
	    this._polygon = undefined;
	    this._polygonSubscription = undefined;
	    this._polyline = undefined;
	    this._polylineSubscription = undefined;
	    this._polylineVolume = undefined;
	    this._polylineVolumeSubscription = undefined;
	    this._position = undefined;
	    this._positionSubscription = undefined;
	    this._rectangle = undefined;
	    this._rectangleSubscription = undefined;
	    this._viewFrom = undefined;
	    this._viewFromSubscription = undefined;
	    this._wall = undefined;
	    this._wallSubscription = undefined;
	    this._children = [];
	    this.entityCollection = undefined;
	    this.parent = options.parent;
	    this.merge(options);
	  }
	  function updateShow(entity, children, isShowing) {
	    var length = children.length;
	    for (var i = 0; i < length; i++) {
	      var child = children[i];
	      var childShow = child._show;
	      var oldValue = !isShowing && childShow;
	      var newValue = isShowing && childShow;
	      if (oldValue !== newValue) {
	        updateShow(child, child._children, isShowing);
	      }
	    }
	    entity._definitionChanged.raiseEvent(entity, 'isShowing', isShowing, !isShowing);
	  }
	  defineProperties(Entity.prototype, {
	    availability: createRawPropertyDescriptor('availability'),
	    id: {get: function() {
	        return this._id;
	      }},
	    definitionChanged: {get: function() {
	        return this._definitionChanged;
	      }},
	    name: createRawPropertyDescriptor('name'),
	    show: {
	      get: function() {
	        return this._show;
	      },
	      set: function(value) {
	        if (!defined(value)) {
	          throw new DeveloperError('value is required.');
	        }
	        if (value === this._show) {
	          return;
	        }
	        var wasShowing = this.isShowing;
	        this._show = value;
	        var isShowing = this.isShowing;
	        if (wasShowing !== isShowing) {
	          updateShow(this, this._children, isShowing);
	        }
	        this._definitionChanged.raiseEvent(this, 'show', value, !value);
	      }
	    },
	    isShowing: {get: function() {
	        return this._show && (!defined(this.entityCollection) || this.entityCollection.show) && (!defined(this._parent) || this._parent.isShowing);
	      }},
	    parent: {
	      get: function() {
	        return this._parent;
	      },
	      set: function(value) {
	        var oldValue = this._parent;
	        if (oldValue === value) {
	          return;
	        }
	        var wasShowing = this.isShowing;
	        if (defined(oldValue)) {
	          var index = oldValue._children.indexOf(this);
	          oldValue._children.splice(index, 1);
	        }
	        this._parent = value;
	        if (defined(value)) {
	          value._children.push(this);
	        }
	        var isShowing = this.isShowing;
	        if (wasShowing !== isShowing) {
	          updateShow(this, this._children, isShowing);
	        }
	        this._definitionChanged.raiseEvent(this, 'parent', value, oldValue);
	      }
	    },
	    propertyNames: {get: function() {
	        return this._propertyNames;
	      }},
	    billboard: createPropertyTypeDescriptor('billboard', BillboardGraphics),
	    box: createPropertyTypeDescriptor('box', BoxGraphics),
	    corridor: createPropertyTypeDescriptor('corridor', CorridorGraphics),
	    cylinder: createPropertyTypeDescriptor('cylinder', CylinderGraphics),
	    description: createPropertyDescriptor('description'),
	    ellipse: createPropertyTypeDescriptor('ellipse', EllipseGraphics),
	    ellipsoid: createPropertyTypeDescriptor('ellipsoid', EllipsoidGraphics),
	    label: createPropertyTypeDescriptor('label', LabelGraphics),
	    model: createPropertyTypeDescriptor('model', ModelGraphics),
	    orientation: createPropertyDescriptor('orientation'),
	    path: createPropertyTypeDescriptor('path', PathGraphics),
	    point: createPropertyTypeDescriptor('point', PointGraphics),
	    polygon: createPropertyTypeDescriptor('polygon', PolygonGraphics),
	    polyline: createPropertyTypeDescriptor('polyline', PolylineGraphics),
	    polylineVolume: createPropertyTypeDescriptor('polylineVolume', PolylineVolumeGraphics),
	    position: createPositionPropertyDescriptor('position'),
	    rectangle: createPropertyTypeDescriptor('rectangle', RectangleGraphics),
	    viewFrom: createPropertyDescriptor('viewFrom'),
	    wall: createPropertyTypeDescriptor('wall', WallGraphics)
	  });
	  Entity.prototype.isAvailable = function(time) {
	    if (!defined(time)) {
	      throw new DeveloperError('time is required.');
	    }
	    var availability = this._availability;
	    return !defined(availability) || availability.contains(time);
	  };
	  Entity.prototype.addProperty = function(propertyName) {
	    var propertyNames = this._propertyNames;
	    if (!defined(propertyName)) {
	      throw new DeveloperError('propertyName is required.');
	    }
	    if (propertyNames.indexOf(propertyName) !== -1) {
	      throw new DeveloperError(propertyName + ' is already a registered property.');
	    }
	    if (propertyName in this) {
	      throw new DeveloperError(propertyName + ' is a reserved property name.');
	    }
	    propertyNames.push(propertyName);
	    Object.defineProperty(this, propertyName, createRawPropertyDescriptor(propertyName, true));
	  };
	  Entity.prototype.removeProperty = function(propertyName) {
	    var propertyNames = this._propertyNames;
	    var index = propertyNames.indexOf(propertyName);
	    if (!defined(propertyName)) {
	      throw new DeveloperError('propertyName is required.');
	    }
	    if (index === -1) {
	      throw new DeveloperError(propertyName + ' is not a registered property.');
	    }
	    this._propertyNames.splice(index, 1);
	    delete this[propertyName];
	  };
	  Entity.prototype.merge = function(source) {
	    if (!defined(source)) {
	      throw new DeveloperError('source is required.');
	    }
	    this.name = defaultValue(this.name, source.name);
	    this.availability = defaultValue(source.availability, this.availability);
	    var propertyNames = this._propertyNames;
	    var sourcePropertyNames = defined(source._propertyNames) ? source._propertyNames : Object.keys(source);
	    var propertyNamesLength = sourcePropertyNames.length;
	    for (var i = 0; i < propertyNamesLength; i++) {
	      var name = sourcePropertyNames[i];
	      if (name === 'parent') {
	        continue;
	      }
	      var targetProperty = this[name];
	      var sourceProperty = source[name];
	      if (!defined(targetProperty) && propertyNames.indexOf(name) === -1) {
	        this.addProperty(name);
	      }
	      if (defined(sourceProperty)) {
	        if (defined(targetProperty)) {
	          if (defined(targetProperty.merge)) {
	            targetProperty.merge(sourceProperty);
	          }
	        } else if (defined(sourceProperty.merge) && defined(sourceProperty.clone)) {
	          this[name] = sourceProperty.clone();
	        } else {
	          this[name] = sourceProperty;
	        }
	      }
	    }
	  };
	  var matrix3Scratch = new Matrix3();
	  var positionScratch = new Cartesian3();
	  var orientationScratch = new Quaternion();
	  Entity.prototype._getModelMatrix = function(time, result) {
	    var position = Property.getValueOrUndefined(this._position, time, positionScratch);
	    if (!defined(position)) {
	      return undefined;
	    }
	    var orientation = Property.getValueOrUndefined(this._orientation, time, orientationScratch);
	    if (!defined(orientation)) {
	      result = Transforms.eastNorthUpToFixedFrame(position, undefined, result);
	    } else {
	      result = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, result);
	    }
	    return result;
	  };
	  return Entity;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("29", ["2a", "26", "1a", "1b", "1c", "1d", "37", "24", "38", "39", "28"], function(AssociativeArray, createGuid, defined, defineProperties, DeveloperError, Event, Iso8601, JulianDate, RuntimeError, TimeInterval, Entity) {
	  'use strict';
	  var entityOptionsScratch = {id: undefined};
	  function fireChangedEvent(collection) {
	    if (collection._firing) {
	      collection._refire = true;
	      return;
	    }
	    if (collection._suspendCount === 0) {
	      var added = collection._addedEntities;
	      var removed = collection._removedEntities;
	      var changed = collection._changedEntities;
	      if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {
	        collection._firing = true;
	        do {
	          collection._refire = false;
	          var addedArray = added.values.slice(0);
	          var removedArray = removed.values.slice(0);
	          var changedArray = changed.values.slice(0);
	          added.removeAll();
	          removed.removeAll();
	          changed.removeAll();
	          collection._collectionChanged.raiseEvent(collection, addedArray, removedArray, changedArray);
	        } while (collection._refire);
	        collection._firing = false;
	      }
	    }
	  }
	  function EntityCollection(owner) {
	    this._owner = owner;
	    this._entities = new AssociativeArray();
	    this._addedEntities = new AssociativeArray();
	    this._removedEntities = new AssociativeArray();
	    this._changedEntities = new AssociativeArray();
	    this._suspendCount = 0;
	    this._collectionChanged = new Event();
	    this._id = createGuid();
	    this._show = true;
	    this._firing = false;
	    this._refire = false;
	  }
	  EntityCollection.prototype.suspendEvents = function() {
	    this._suspendCount++;
	  };
	  EntityCollection.prototype.resumeEvents = function() {
	    if (this._suspendCount === 0) {
	      throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
	    }
	    this._suspendCount--;
	    fireChangedEvent(this);
	  };
	  EntityCollection.collectionChangedEventCallback = undefined;
	  defineProperties(EntityCollection.prototype, {
	    collectionChanged: {get: function() {
	        return this._collectionChanged;
	      }},
	    id: {get: function() {
	        return this._id;
	      }},
	    values: {get: function() {
	        return this._entities.values;
	      }},
	    show: {
	      get: function() {
	        return this._show;
	      },
	      set: function(value) {
	        if (!defined(value)) {
	          throw new DeveloperError('value is required.');
	        }
	        if (value === this._show) {
	          return;
	        }
	        this.suspendEvents();
	        var i;
	        var oldShows = [];
	        var entities = this._entities.values;
	        var entitiesLength = entities.length;
	        for (i = 0; i < entitiesLength; i++) {
	          oldShows.push(entities[i].isShowing);
	        }
	        this._show = value;
	        for (i = 0; i < entitiesLength; i++) {
	          var oldShow = oldShows[i];
	          var entity = entities[i];
	          if (oldShow !== entity.isShowing) {
	            entity.definitionChanged.raiseEvent(entity, 'isShowing', entity.isShowing, oldShow);
	          }
	        }
	        this.resumeEvents();
	      }
	    },
	    owner: {get: function() {
	        return this._owner;
	      }}
	  });
	  EntityCollection.prototype.computeAvailability = function() {
	    var startTime = Iso8601.MAXIMUM_VALUE;
	    var stopTime = Iso8601.MINIMUM_VALUE;
	    var entities = this._entities.values;
	    for (var i = 0,
	        len = entities.length; i < len; i++) {
	      var entity = entities[i];
	      var availability = entity.availability;
	      if (defined(availability)) {
	        var start = availability.start;
	        var stop = availability.stop;
	        if (JulianDate.lessThan(start, startTime) && !start.equals(Iso8601.MINIMUM_VALUE)) {
	          startTime = start;
	        }
	        if (JulianDate.greaterThan(stop, stopTime) && !stop.equals(Iso8601.MAXIMUM_VALUE)) {
	          stopTime = stop;
	        }
	      }
	    }
	    if (Iso8601.MAXIMUM_VALUE.equals(startTime)) {
	      startTime = Iso8601.MINIMUM_VALUE;
	    }
	    if (Iso8601.MINIMUM_VALUE.equals(stopTime)) {
	      stopTime = Iso8601.MAXIMUM_VALUE;
	    }
	    return new TimeInterval({
	      start: startTime,
	      stop: stopTime
	    });
	  };
	  EntityCollection.prototype.add = function(entity) {
	    if (!defined(entity)) {
	      throw new DeveloperError('entity is required.');
	    }
	    if (!(entity instanceof Entity)) {
	      entity = new Entity(entity);
	    }
	    var id = entity.id;
	    var entities = this._entities;
	    if (entities.contains(id)) {
	      throw new RuntimeError('An entity with id ' + id + ' already exists in this collection.');
	    }
	    entity.entityCollection = this;
	    entities.set(id, entity);
	    if (!this._removedEntities.remove(id)) {
	      this._addedEntities.set(id, entity);
	    }
	    entity.definitionChanged.addEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
	    fireChangedEvent(this);
	    return entity;
	  };
	  EntityCollection.prototype.remove = function(entity) {
	    if (!defined(entity)) {
	      return false;
	    }
	    return this.removeById(entity.id);
	  };
	  EntityCollection.prototype.contains = function(entity) {
	    if (!defined(entity)) {
	      throw new DeveloperError('entity is required');
	    }
	    return this._entities.get(entity.id) === entity;
	  };
	  EntityCollection.prototype.removeById = function(id) {
	    if (!defined(id)) {
	      return false;
	    }
	    var entities = this._entities;
	    var entity = entities.get(id);
	    if (!this._entities.remove(id)) {
	      return false;
	    }
	    if (!this._addedEntities.remove(id)) {
	      this._removedEntities.set(id, entity);
	      this._changedEntities.remove(id);
	    }
	    this._entities.remove(id);
	    entity.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
	    fireChangedEvent(this);
	    return true;
	  };
	  EntityCollection.prototype.removeAll = function() {
	    var entities = this._entities;
	    var entitiesLength = entities.length;
	    var array = entities.values;
	    var addedEntities = this._addedEntities;
	    var removed = this._removedEntities;
	    for (var i = 0; i < entitiesLength; i++) {
	      var existingItem = array[i];
	      var existingItemId = existingItem.id;
	      var addedItem = addedEntities.get(existingItemId);
	      if (!defined(addedItem)) {
	        existingItem.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
	        removed.set(existingItemId, existingItem);
	      }
	    }
	    entities.removeAll();
	    addedEntities.removeAll();
	    this._changedEntities.removeAll();
	    fireChangedEvent(this);
	  };
	  EntityCollection.prototype.getById = function(id) {
	    if (!defined(id)) {
	      throw new DeveloperError('id is required.');
	    }
	    return this._entities.get(id);
	  };
	  EntityCollection.prototype.getOrCreateEntity = function(id) {
	    if (!defined(id)) {
	      throw new DeveloperError('id is required.');
	    }
	    var entity = this._entities.get(id);
	    if (!defined(entity)) {
	      entityOptionsScratch.id = id;
	      entity = new Entity(entityOptionsScratch);
	      this.add(entity);
	    }
	    return entity;
	  };
	  EntityCollection.prototype._onEntityDefinitionChanged = function(entity) {
	    var id = entity.id;
	    if (!this._addedEntities.contains(id)) {
	      this._changedEntities.set(id, entity);
	    }
	    fireChangedEvent(this);
	  };
	  return EntityCollection;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("3a", ["2c", "3b", "23", "1a", "1b", "1c", "3c"], function(Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid) {
	  'use strict';
	  function GeographicProjection(ellipsoid) {
	    this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	    this._semimajorAxis = this._ellipsoid.maximumRadius;
	    this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;
	  }
	  defineProperties(GeographicProjection.prototype, {ellipsoid: {get: function() {
	        return this._ellipsoid;
	      }}});
	  GeographicProjection.prototype.project = function(cartographic, result) {
	    var semimajorAxis = this._semimajorAxis;
	    var x = cartographic.longitude * semimajorAxis;
	    var y = cartographic.latitude * semimajorAxis;
	    var z = cartographic.height;
	    if (!defined(result)) {
	      return new Cartesian3(x, y, z);
	    }
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return result;
	  };
	  GeographicProjection.prototype.unproject = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
	    var longitude = cartesian.x * oneOverEarthSemimajorAxis;
	    var latitude = cartesian.y * oneOverEarthSemimajorAxis;
	    var height = cartesian.z;
	    if (!defined(result)) {
	      return new Cartographic(longitude, latitude, height);
	    }
	    result.longitude = longitude;
	    result.latitude = latitude;
	    result.height = height;
	    return result;
	  };
	  return GeographicProjection;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("3d", ["23", "1a", "1c", "27"], function(defaultValue, defined, DeveloperError, CesiumMath) {
	  'use strict';
	  var factorial = CesiumMath.factorial;
	  function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {
	    var result = 0;
	    var reserved;
	    var i;
	    var j;
	    if (derivOrder > 0) {
	      for (i = 0; i < termOrder; i++) {
	        reserved = false;
	        for (j = 0; j < reservedIndices.length && !reserved; j++) {
	          if (i === reservedIndices[j]) {
	            reserved = true;
	          }
	        }
	        if (!reserved) {
	          reservedIndices.push(i);
	          result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);
	          reservedIndices.splice(reservedIndices.length - 1, 1);
	        }
	      }
	      return result;
	    }
	    result = 1;
	    for (i = 0; i < termOrder; i++) {
	      reserved = false;
	      for (j = 0; j < reservedIndices.length && !reserved; j++) {
	        if (i === reservedIndices[j]) {
	          reserved = true;
	        }
	      }
	      if (!reserved) {
	        result *= x - xTable[zIndices[i]];
	      }
	    }
	    return result;
	  }
	  var HermitePolynomialApproximation = {type: 'Hermite'};
	  HermitePolynomialApproximation.getRequiredDataPoints = function(degree, inputOrder) {
	    inputOrder = defaultValue(inputOrder, 0);
	    if (!defined(degree)) {
	      throw new DeveloperError('degree is required.');
	    }
	    if (degree < 0) {
	      throw new DeveloperError('degree must be 0 or greater.');
	    }
	    if (inputOrder < 0) {
	      throw new DeveloperError('inputOrder must be 0 or greater.');
	    }
	    return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);
	  };
	  HermitePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
	    if (!defined(result)) {
	      result = new Array(yStride);
	    }
	    var i;
	    var j;
	    var d;
	    var s;
	    var len;
	    var index;
	    var length = xTable.length;
	    var coefficients = new Array(yStride);
	    for (i = 0; i < yStride; i++) {
	      result[i] = 0;
	      var l = new Array(length);
	      coefficients[i] = l;
	      for (j = 0; j < length; j++) {
	        l[j] = [];
	      }
	    }
	    var zIndicesLength = length,
	        zIndices = new Array(zIndicesLength);
	    for (i = 0; i < zIndicesLength; i++) {
	      zIndices[i] = i;
	    }
	    var highestNonZeroCoef = length - 1;
	    for (s = 0; s < yStride; s++) {
	      for (j = 0; j < zIndicesLength; j++) {
	        index = zIndices[j] * yStride + s;
	        coefficients[s][0].push(yTable[index]);
	      }
	      for (i = 1; i < zIndicesLength; i++) {
	        var nonZeroCoefficients = false;
	        for (j = 0; j < zIndicesLength - i; j++) {
	          var zj = xTable[zIndices[j]];
	          var zn = xTable[zIndices[j + i]];
	          var numerator;
	          if (zn - zj <= 0) {
	            index = zIndices[j] * yStride + yStride * i + s;
	            numerator = yTable[index];
	            coefficients[s][i].push(numerator / factorial(i));
	          } else {
	            numerator = (coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j]);
	            coefficients[s][i].push(numerator / (zn - zj));
	          }
	          nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0);
	        }
	        if (!nonZeroCoefficients) {
	          highestNonZeroCoef = i - 1;
	        }
	      }
	    }
	    for (d = 0, len = 0; d <= len; d++) {
	      for (i = d; i <= highestNonZeroCoef; i++) {
	        var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);
	        for (s = 0; s < yStride; s++) {
	          var coeff = coefficients[s][i][0];
	          result[s + d * yStride] += coeff * tempTerm;
	        }
	      }
	    }
	    return result;
	  };
	  var arrayScratch = [];
	  HermitePolynomialApproximation.interpolate = function(x, xTable, yTable, yStride, inputOrder, outputOrder, result) {
	    var resultLength = yStride * (outputOrder + 1);
	    if (!defined(result)) {
	      result = new Array(resultLength);
	    }
	    for (var r = 0; r < resultLength; r++) {
	      result[r] = 0;
	    }
	    var length = xTable.length;
	    var zIndices = new Array(length * (inputOrder + 1));
	    for (var i = 0; i < length; i++) {
	      for (var j = 0; j < (inputOrder + 1); j++) {
	        zIndices[i * (inputOrder + 1) + j] = i;
	      }
	    }
	    var zIndiceslength = zIndices.length;
	    var coefficients = arrayScratch;
	    var highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);
	    var reservedIndices = [];
	    var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
	    var loopStop = Math.min(highestNonZeroCoef, outputOrder);
	    for (var d = 0; d <= loopStop; d++) {
	      for (i = d; i <= highestNonZeroCoef; i++) {
	        reservedIndices.length = 0;
	        var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);
	        var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);
	        for (var s = 0; s < yStride; s++) {
	          var dimOne = Math.floor(s * tmp);
	          var coef = coefficients[dimOne + dimTwo];
	          result[s + d * yStride] += coef * tempTerm;
	        }
	      }
	    }
	    return result;
	  };
	  function fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {
	    var j;
	    var index;
	    var highestNonZero = -1;
	    var zIndiceslength = zIndices.length;
	    var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
	    for (var s = 0; s < yStride; s++) {
	      var dimOne = Math.floor(s * tmp);
	      for (j = 0; j < zIndiceslength; j++) {
	        index = zIndices[j] * yStride * (inputOrder + 1) + s;
	        coefficients[dimOne + j] = yTable[index];
	      }
	      for (var i = 1; i < zIndiceslength; i++) {
	        var coefIndex = 0;
	        var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);
	        var nonZeroCoefficients = false;
	        for (j = 0; j < zIndiceslength - i; j++) {
	          var zj = xTable[zIndices[j]];
	          var zn = xTable[zIndices[j + i]];
	          var numerator;
	          var coefficient;
	          if (zn - zj <= 0) {
	            index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;
	            numerator = yTable[index];
	            coefficient = (numerator / CesiumMath.factorial(i));
	            coefficients[dimOne + dimTwo + coefIndex] = coefficient;
	            coefIndex++;
	          } else {
	            var dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + (zIndiceslength * (i - 1));
	            numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];
	            coefficient = (numerator / (zn - zj));
	            coefficients[dimOne + dimTwo + coefIndex] = coefficient;
	            coefIndex++;
	          }
	          nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0.0);
	        }
	        if (nonZeroCoefficients) {
	          highestNonZero = Math.max(highestNonZero, i);
	        }
	      }
	    }
	    return highestNonZero;
	  }
	  return HermitePolynomialApproximation;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("3e", ["1a", "1b", "1c", "32", "34", "2d", "35"], function(defined, defineProperties, DeveloperError, Matrix3, Quaternion, ReferenceFrame, Transforms) {
	  "use strict";
	  var OrientationProperty = function() {
	    DeveloperError.throwInstantiationError();
	  };
	  defineProperties(OrientationProperty.prototype, {
	    isConstant: {get: DeveloperError.throwInstantiationError},
	    definitionChanged: {get: DeveloperError.throwInstantiationError}
	  });
	  OrientationProperty.prototype.getValue = DeveloperError.throwInstantiationError;
	  OrientationProperty.prototype.equals = DeveloperError.throwInstantiationError;
	  function framesEqual(frame1, frame2) {
	    return frame1 && frame1.id ? frame1.id === (frame2 && frame2.id) : frame1 === frame2;
	  }
	  function frameParents(frame) {
	    var frames = [];
	    while (defined(frame)) {
	      frames.unshift(frame);
	      frame = frame.position && frame.position.referenceFrame;
	    }
	    return frames;
	  }
	  function lowestCommonAncestor(parents1, parents2) {
	    if (!framesEqual(parents1[0], parents2[0])) {
	      return -1;
	    }
	    var h = Math.min(parents1.length, parents2.length);
	    for (var i = 0; i <= h; i++) {
	      if (!framesEqual(parents1[i], parents2[i])) {
	        return i - 1;
	      }
	    }
	    return -1;
	  }
	  var scratchIcrfToFixedMatrix3 = new Matrix3();
	  var scratchIcrfToFixed = new Quaternion();
	  function getIcrfToFixed(time) {
	    var icrfToFixedRotation = Transforms.computeIcrfToFixedMatrix(time, scratchIcrfToFixedMatrix3);
	    if (!defined(icrfToFixedRotation)) {
	      icrfToFixedRotation = Transforms.computeTemeToPseudoFixedMatrix(time, scratchIcrfToFixedMatrix3);
	    }
	    return Quaternion.fromRotationMatrix(icrfToFixedRotation, scratchIcrfToFixed);
	  }
	  var scratchQuaternion = new Quaternion();
	  OrientationProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
	    if (!defined(value)) {
	      return value;
	    }
	    if (!defined(result)) {
	      result = new Quaternion();
	    }
	    if (inputFrame === outputFrame) {
	      return Quaternion.clone(value, result);
	    }
	    if (!defined(inputFrame) || !defined(outputFrame)) {
	      return undefined;
	    }
	    var inputFrameParents = frameParents(inputFrame);
	    var outputFrameParents = frameParents(outputFrame);
	    var lcaIndex = lowestCommonAncestor(inputFrameParents, outputFrameParents);
	    var lcaFrame = inputFrameParents[lcaIndex];
	    var inputOrientationAccumulator = function(accumulatedOrientationValue, frame) {
	      if (!defined(accumulatedOrientationValue)) {
	        return accumulatedOrientationValue;
	      }
	      var frameOrientationProperty = frame.orientation;
	      if (!defined(frameOrientationProperty)) {
	        return undefined;
	      }
	      var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
	      if (!defined(frameOrientationValue)) {
	        return undefined;
	      }
	      return Quaternion.multiply(frameOrientationValue, accumulatedOrientationValue, accumulatedOrientationValue);
	    };
	    var outputOrientationAccumulator = function(accumulatedOrientationValue, frame) {
	      if (!defined(accumulatedOrientationValue)) {
	        return accumulatedOrientationValue;
	      }
	      var frameOrientationProperty = frame.orientation;
	      if (!defined(frameOrientationProperty)) {
	        return undefined;
	      }
	      var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
	      if (!defined(frameOrientationValue)) {
	        return undefined;
	      }
	      Quaternion.conjugate(frameOrientationValue, frameOrientationValue);
	      return Quaternion.multiply(frameOrientationValue, accumulatedOrientationValue, accumulatedOrientationValue);
	    };
	    if (defined(lcaFrame)) {
	      inputFrameParents = inputFrameParents.slice(lcaIndex + 1);
	      outputFrameParents = outputFrameParents.slice(lcaIndex + 1);
	      var lcaFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
	      if (!defined(lcaFrameValue)) {
	        return undefined;
	      }
	      return outputFrameParents.reduce(outputOrientationAccumulator, lcaFrameValue);
	    }
	    var inputRootFrame = inputFrameParents.shift();
	    var outputRootFrame = outputFrameParents.shift();
	    var fixedFrameValue,
	        inertialFrameValue;
	    if (inputRootFrame === ReferenceFrame.INERTIAL && outputRootFrame === ReferenceFrame.FIXED) {
	      inertialFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
	      if (!defined(inertialFrameValue)) {
	        return undefined;
	      }
	      fixedFrameValue = Quaternion.multiply(getIcrfToFixed(time), inertialFrameValue, result);
	      return outputFrameParents.reduce(outputOrientationAccumulator, fixedFrameValue);
	    }
	    if (inputRootFrame === ReferenceFrame.FIXED && outputRootFrame === ReferenceFrame.INERTIAL) {
	      fixedFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
	      if (!defined(fixedFrameValue)) {
	        return undefined;
	      }
	      var fixedToIcrf = Quaternion.conjugate(getIcrfToFixed(time), scratchQuaternion);
	      inertialFrameValue = Quaternion.multiply(fixedToIcrf, fixedFrameValue, result);
	      return outputFrameParents.reduce(outputOrientationAccumulator, inertialFrameValue);
	    }
	    return undefined;
	  };
	  return OrientationProperty;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("3f", ["1a", "1b", "1c", "40"], function(defined, defineProperties, DeveloperError, PerspectiveOffCenterFrustum) {
	  'use strict';
	  function PerspectiveFrustum() {
	    this._offCenterFrustum = new PerspectiveOffCenterFrustum();
	    this.fov = undefined;
	    this._fov = undefined;
	    this._fovy = undefined;
	    this._sseDenominator = undefined;
	    this.aspectRatio = undefined;
	    this._aspectRatio = undefined;
	    this.near = 1.0;
	    this._near = this.near;
	    this.far = 500000000.0;
	    this._far = this.far;
	    this.xOffset = 0.0;
	    this._xOffset = this.xOffset;
	    this.yOffset = 0.0;
	    this._yOffset = this.yOffset;
	  }
	  function update(frustum) {
	    if (!defined(frustum.fov) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {
	      throw new DeveloperError('fov, aspectRatio, near, or far parameters are not set.');
	    }
	    var f = frustum._offCenterFrustum;
	    if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far || frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {
	      if (frustum.fov < 0 || frustum.fov >= Math.PI) {
	        throw new DeveloperError('fov must be in the range [0, PI).');
	      }
	      if (frustum.aspectRatio < 0) {
	        throw new DeveloperError('aspectRatio must be positive.');
	      }
	      if (frustum.near < 0 || frustum.near > frustum.far) {
	        throw new DeveloperError('near must be greater than zero and less than far.');
	      }
	      frustum._aspectRatio = frustum.aspectRatio;
	      frustum._fov = frustum.fov;
	      frustum._fovy = (frustum.aspectRatio <= 1) ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;
	      frustum._near = frustum.near;
	      frustum._far = frustum.far;
	      frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);
	      frustum._xOffset = frustum.xOffset;
	      frustum._yOffset = frustum.yOffset;
	      f.top = frustum.near * Math.tan(0.5 * frustum._fovy);
	      f.bottom = -f.top;
	      f.right = frustum.aspectRatio * f.top;
	      f.left = -f.right;
	      f.near = frustum.near;
	      f.far = frustum.far;
	      f.right += frustum.xOffset;
	      f.left += frustum.xOffset;
	      f.top += frustum.yOffset;
	      f.bottom += frustum.yOffset;
	    }
	  }
	  defineProperties(PerspectiveFrustum.prototype, {
	    projectionMatrix: {get: function() {
	        update(this);
	        return this._offCenterFrustum.projectionMatrix;
	      }},
	    infiniteProjectionMatrix: {get: function() {
	        update(this);
	        return this._offCenterFrustum.infiniteProjectionMatrix;
	      }},
	    fovy: {get: function() {
	        update(this);
	        return this._fovy;
	      }},
	    sseDenominator: {get: function() {
	        update(this);
	        return this._sseDenominator;
	      }}
	  });
	  PerspectiveFrustum.prototype.computeCullingVolume = function(position, direction, up) {
	    update(this);
	    return this._offCenterFrustum.computeCullingVolume(position, direction, up);
	  };
	  PerspectiveFrustum.prototype.getPixelDimensions = function(drawingBufferWidth, drawingBufferHeight, distance, result) {
	    update(this);
	    return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result);
	  };
	  PerspectiveFrustum.prototype.clone = function(result) {
	    if (!defined(result)) {
	      result = new PerspectiveFrustum();
	    }
	    result.aspectRatio = this.aspectRatio;
	    result.fov = this.fov;
	    result.near = this.near;
	    result.far = this.far;
	    result._aspectRatio = undefined;
	    result._fov = undefined;
	    result._near = undefined;
	    result._far = undefined;
	    this._offCenterFrustum.clone(result._offCenterFrustum);
	    return result;
	  };
	  PerspectiveFrustum.prototype.equals = function(other) {
	    if (!defined(other)) {
	      return false;
	    }
	    update(this);
	    update(other);
	    return (this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum));
	  };
	  return PerspectiveFrustum;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("41", ["1f"], function(freezeObject) {
	  'use strict';
	  var Intersect = {
	    OUTSIDE: -1,
	    INTERSECTING: 0,
	    INSIDE: 1
	  };
	  return freezeObject(Intersect);
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("42", ["2c", "43", "23", "1a", "1c", "41", "44"], function(Cartesian3, Cartesian4, defaultValue, defined, DeveloperError, Intersect, Plane) {
	  'use strict';
	  function CullingVolume(planes) {
	    this.planes = defaultValue(planes, []);
	  }
	  var faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];
	  Cartesian3.clone(Cartesian3.UNIT_X, faces[0]);
	  Cartesian3.clone(Cartesian3.UNIT_Y, faces[1]);
	  Cartesian3.clone(Cartesian3.UNIT_Z, faces[2]);
	  var scratchPlaneCenter = new Cartesian3();
	  var scratchPlaneNormal = new Cartesian3();
	  var scratchPlane = new Plane(new Cartesian3(), 0.0);
	  CullingVolume.fromBoundingSphere = function(boundingSphere, result) {
	    if (!defined(boundingSphere)) {
	      throw new DeveloperError('boundingSphere is required.');
	    }
	    if (!defined(result)) {
	      result = new CullingVolume();
	    }
	    var length = faces.length;
	    var planes = result.planes;
	    planes.length = 2 * length;
	    var center = boundingSphere.center;
	    var radius = boundingSphere.radius;
	    var planeIndex = 0;
	    for (var i = 0; i < length; ++i) {
	      var faceNormal = faces[i];
	      var plane0 = planes[planeIndex];
	      var plane1 = planes[planeIndex + 1];
	      if (!defined(plane0)) {
	        plane0 = planes[planeIndex] = new Cartesian4();
	      }
	      if (!defined(plane1)) {
	        plane1 = planes[planeIndex + 1] = new Cartesian4();
	      }
	      Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);
	      Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);
	      plane0.x = faceNormal.x;
	      plane0.y = faceNormal.y;
	      plane0.z = faceNormal.z;
	      plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);
	      Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);
	      Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);
	      plane1.x = -faceNormal.x;
	      plane1.y = -faceNormal.y;
	      plane1.z = -faceNormal.z;
	      plane1.w = -Cartesian3.dot(Cartesian3.negate(faceNormal, scratchPlaneNormal), scratchPlaneCenter);
	      planeIndex += 2;
	    }
	    return result;
	  };
	  CullingVolume.prototype.computeVisibility = function(boundingVolume) {
	    if (!defined(boundingVolume)) {
	      throw new DeveloperError('boundingVolume is required.');
	    }
	    var planes = this.planes;
	    var intersecting = false;
	    for (var k = 0,
	        len = planes.length; k < len; ++k) {
	      var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));
	      if (result === Intersect.OUTSIDE) {
	        return Intersect.OUTSIDE;
	      } else if (result === Intersect.INTERSECTING) {
	        intersecting = true;
	      }
	    }
	    return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;
	  };
	  CullingVolume.prototype.computeVisibilityWithPlaneMask = function(boundingVolume, parentPlaneMask) {
	    if (!defined(boundingVolume)) {
	      throw new DeveloperError('boundingVolume is required.');
	    }
	    if (!defined(parentPlaneMask)) {
	      throw new DeveloperError('parentPlaneMask is required.');
	    }
	    if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
	      return parentPlaneMask;
	    }
	    var mask = CullingVolume.MASK_INSIDE;
	    var planes = this.planes;
	    for (var k = 0,
	        len = planes.length; k < len; ++k) {
	      var flag = (k < 31) ? (1 << k) : 0;
	      if (k < 31 && (parentPlaneMask & flag) === 0) {
	        continue;
	      }
	      var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));
	      if (result === Intersect.OUTSIDE) {
	        return CullingVolume.MASK_OUTSIDE;
	      } else if (result === Intersect.INTERSECTING) {
	        mask |= flag;
	      }
	    }
	    return mask;
	  };
	  CullingVolume.MASK_OUTSIDE = 0xffffffff;
	  CullingVolume.MASK_INSIDE = 0x00000000;
	  CullingVolume.MASK_INDETERMINATE = 0x7fffffff;
	  return CullingVolume;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("40", ["45", "2c", "43", "23", "1a", "1b", "1c", "33", "42"], function(Cartesian2, Cartesian3, Cartesian4, defaultValue, defined, defineProperties, DeveloperError, Matrix4, CullingVolume) {
	  'use strict';
	  function PerspectiveOffCenterFrustum() {
	    this.left = undefined;
	    this._left = undefined;
	    this.right = undefined;
	    this._right = undefined;
	    this.top = undefined;
	    this._top = undefined;
	    this.bottom = undefined;
	    this._bottom = undefined;
	    this.near = 1.0;
	    this._near = this.near;
	    this.far = 500000000.0;
	    this._far = this.far;
	    this._cullingVolume = new CullingVolume();
	    this._perspectiveMatrix = new Matrix4();
	    this._infinitePerspective = new Matrix4();
	  }
	  function update(frustum) {
	    if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {
	      throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
	    }
	    var t = frustum.top;
	    var b = frustum.bottom;
	    var r = frustum.right;
	    var l = frustum.left;
	    var n = frustum.near;
	    var f = frustum.far;
	    if (t !== frustum._top || b !== frustum._bottom || l !== frustum._left || r !== frustum._right || n !== frustum._near || f !== frustum._far) {
	      if (frustum.near <= 0 || frustum.near > frustum.far) {
	        throw new DeveloperError('near must be greater than zero and less than far.');
	      }
	      frustum._left = l;
	      frustum._right = r;
	      frustum._top = t;
	      frustum._bottom = b;
	      frustum._near = n;
	      frustum._far = f;
	      frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);
	      frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);
	    }
	  }
	  defineProperties(PerspectiveOffCenterFrustum.prototype, {
	    projectionMatrix: {get: function() {
	        update(this);
	        return this._perspectiveMatrix;
	      }},
	    infiniteProjectionMatrix: {get: function() {
	        update(this);
	        return this._infinitePerspective;
	      }}
	  });
	  var getPlanesRight = new Cartesian3();
	  var getPlanesNearCenter = new Cartesian3();
	  var getPlanesFarCenter = new Cartesian3();
	  var getPlanesNormal = new Cartesian3();
	  PerspectiveOffCenterFrustum.prototype.computeCullingVolume = function(position, direction, up) {
	    if (!defined(position)) {
	      throw new DeveloperError('position is required.');
	    }
	    if (!defined(direction)) {
	      throw new DeveloperError('direction is required.');
	    }
	    if (!defined(up)) {
	      throw new DeveloperError('up is required.');
	    }
	    var planes = this._cullingVolume.planes;
	    var t = this.top;
	    var b = this.bottom;
	    var r = this.right;
	    var l = this.left;
	    var n = this.near;
	    var f = this.far;
	    var right = Cartesian3.cross(direction, up, getPlanesRight);
	    var nearCenter = getPlanesNearCenter;
	    Cartesian3.multiplyByScalar(direction, n, nearCenter);
	    Cartesian3.add(position, nearCenter, nearCenter);
	    var farCenter = getPlanesFarCenter;
	    Cartesian3.multiplyByScalar(direction, f, farCenter);
	    Cartesian3.add(position, farCenter, farCenter);
	    var normal = getPlanesNormal;
	    Cartesian3.multiplyByScalar(right, l, normal);
	    Cartesian3.add(nearCenter, normal, normal);
	    Cartesian3.subtract(normal, position, normal);
	    Cartesian3.normalize(normal, normal);
	    Cartesian3.cross(normal, up, normal);
	    var plane = planes[0];
	    if (!defined(plane)) {
	      plane = planes[0] = new Cartesian4();
	    }
	    plane.x = normal.x;
	    plane.y = normal.y;
	    plane.z = normal.z;
	    plane.w = -Cartesian3.dot(normal, position);
	    Cartesian3.multiplyByScalar(right, r, normal);
	    Cartesian3.add(nearCenter, normal, normal);
	    Cartesian3.subtract(normal, position, normal);
	    Cartesian3.normalize(normal, normal);
	    Cartesian3.cross(up, normal, normal);
	    plane = planes[1];
	    if (!defined(plane)) {
	      plane = planes[1] = new Cartesian4();
	    }
	    plane.x = normal.x;
	    plane.y = normal.y;
	    plane.z = normal.z;
	    plane.w = -Cartesian3.dot(normal, position);
	    Cartesian3.multiplyByScalar(up, b, normal);
	    Cartesian3.add(nearCenter, normal, normal);
	    Cartesian3.subtract(normal, position, normal);
	    Cartesian3.normalize(normal, normal);
	    Cartesian3.cross(right, normal, normal);
	    plane = planes[2];
	    if (!defined(plane)) {
	      plane = planes[2] = new Cartesian4();
	    }
	    plane.x = normal.x;
	    plane.y = normal.y;
	    plane.z = normal.z;
	    plane.w = -Cartesian3.dot(normal, position);
	    Cartesian3.multiplyByScalar(up, t, normal);
	    Cartesian3.add(nearCenter, normal, normal);
	    Cartesian3.subtract(normal, position, normal);
	    Cartesian3.normalize(normal, normal);
	    Cartesian3.cross(normal, right, normal);
	    plane = planes[3];
	    if (!defined(plane)) {
	      plane = planes[3] = new Cartesian4();
	    }
	    plane.x = normal.x;
	    plane.y = normal.y;
	    plane.z = normal.z;
	    plane.w = -Cartesian3.dot(normal, position);
	    plane = planes[4];
	    if (!defined(plane)) {
	      plane = planes[4] = new Cartesian4();
	    }
	    plane.x = direction.x;
	    plane.y = direction.y;
	    plane.z = direction.z;
	    plane.w = -Cartesian3.dot(direction, nearCenter);
	    Cartesian3.negate(direction, normal);
	    plane = planes[5];
	    if (!defined(plane)) {
	      plane = planes[5] = new Cartesian4();
	    }
	    plane.x = normal.x;
	    plane.y = normal.y;
	    plane.z = normal.z;
	    plane.w = -Cartesian3.dot(normal, farCenter);
	    return this._cullingVolume;
	  };
	  PerspectiveOffCenterFrustum.prototype.getPixelDimensions = function(drawingBufferWidth, drawingBufferHeight, distance, result) {
	    update(this);
	    if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {
	      throw new DeveloperError('Both drawingBufferWidth and drawingBufferHeight are required.');
	    }
	    if (drawingBufferWidth <= 0) {
	      throw new DeveloperError('drawingBufferWidth must be greater than zero.');
	    }
	    if (drawingBufferHeight <= 0) {
	      throw new DeveloperError('drawingBufferHeight must be greater than zero.');
	    }
	    if (!defined(distance)) {
	      throw new DeveloperError('distance is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('A result object is required.');
	    }
	    var inverseNear = 1.0 / this.near;
	    var tanTheta = this.top * inverseNear;
	    var pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
	    tanTheta = this.right * inverseNear;
	    var pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;
	    result.x = pixelWidth;
	    result.y = pixelHeight;
	    return result;
	  };
	  PerspectiveOffCenterFrustum.prototype.clone = function(result) {
	    if (!defined(result)) {
	      result = new PerspectiveOffCenterFrustum();
	    }
	    result.right = this.right;
	    result.left = this.left;
	    result.top = this.top;
	    result.bottom = this.bottom;
	    result.near = this.near;
	    result.far = this.far;
	    result._left = undefined;
	    result._right = undefined;
	    result._top = undefined;
	    result._bottom = undefined;
	    result._near = undefined;
	    result._far = undefined;
	    return result;
	  };
	  PerspectiveOffCenterFrustum.prototype.equals = function(other) {
	    return (defined(other) && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far);
	  };
	  return PerspectiveOffCenterFrustum;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("46", ["1a", "1b", "1c", "1d", "36"], function(defined, defineProperties, DeveloperError, Event, Property) {
	  "use strict";
	  function resolve(that) {
	    var targetEntity = that._targetEntity;
	    if (that._resolveEntity) {
	      targetEntity = that._targetCollection.getById(that._targetId);
	      if (defined(targetEntity)) {
	        that._targetEntity = targetEntity;
	        that._resolveEntity = false;
	      }
	    }
	    return targetEntity;
	  }
	  var ReferenceEntity = function(targetCollection, targetId) {
	    if (!defined(targetCollection)) {
	      throw new DeveloperError('targetCollection is required.');
	    }
	    if (!defined(targetId) || targetId === '') {
	      throw new DeveloperError('targetId is required.');
	    }
	    this._targetCollection = targetCollection;
	    this._targetId = targetId;
	    this._targetEntity = undefined;
	    this._definitionChanged = new Event();
	    this._resolveEntity = true;
	    targetCollection.collectionChanged.addEventListener(ReferenceEntity.prototype._onCollectionChanged, this);
	  };
	  defineProperties(ReferenceEntity.prototype, {
	    definitionChanged: {get: function() {
	        return this._definitionChanged;
	      }},
	    id: {get: function() {
	        return this._targetId;
	      }},
	    position: {get: function() {
	        var entity = resolve(this);
	        return defined(entity) ? entity.position : undefined;
	      }},
	    orientation: {get: function() {
	        var entity = resolve(this);
	        return defined(entity) ? entity.orientation : undefined;
	      }},
	    targetId: {get: function() {
	        return this._targetId;
	      }},
	    targetCollection: {get: function() {
	        return this._targetCollection;
	      }},
	    resolvedEntity: {get: function() {
	        return resolve(this);
	      }}
	  });
	  ReferenceEntity.prototype._onCollectionChanged = function(collection, added, removed) {
	    var targetEntity = this._targetEntity;
	    if (defined(targetEntity)) {
	      if (removed.indexOf(targetEntity) !== -1) {
	        this._resolveEntity = true;
	      } else if (this._resolveEntity) {
	        resolve(this);
	        if (!this._resolveEntity) {
	          this._definitionChanged.raiseEvent(this);
	        }
	      }
	    }
	  };
	  return ReferenceEntity;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("47", ["1a", "1b", "1c", "1d", "38", "36"], function(defined, defineProperties, DeveloperError, Event, RuntimeError, Property) {
	  'use strict';
	  function resolveEntity(that) {
	    var entityIsResolved = true;
	    if (that._resolveEntity) {
	      var targetEntity = that._targetCollection.getById(that._targetId);
	      if (defined(targetEntity)) {
	        targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);
	        that._targetEntity = targetEntity;
	        that._resolveEntity = false;
	      } else {
	        targetEntity = that._targetEntity;
	        entityIsResolved = false;
	      }
	      if (!defined(targetEntity)) {
	        throw new RuntimeError('target entity "' + that._targetId + '" could not be resolved.');
	      }
	    }
	    return entityIsResolved;
	  }
	  function resolve(that) {
	    var targetProperty = that._targetProperty;
	    if (that._resolveProperty) {
	      var entityIsResolved = resolveEntity(that);
	      var names = that._targetPropertyNames;
	      targetProperty = that._targetEntity;
	      var length = names.length;
	      for (var i = 0; i < length && defined(targetProperty); i++) {
	        targetProperty = targetProperty[names[i]];
	      }
	      if (defined(targetProperty)) {
	        that._targetProperty = targetProperty;
	        that._resolveProperty = !entityIsResolved;
	      } else if (!defined(that._targetProperty)) {
	        throw new RuntimeError('targetProperty "' + that._targetId + '.' + names.join('.') + '" could not be resolved.');
	      }
	    }
	    return targetProperty;
	  }
	  function ReferenceProperty(targetCollection, targetId, targetPropertyNames) {
	    if (!defined(targetCollection)) {
	      throw new DeveloperError('targetCollection is required.');
	    }
	    if (!defined(targetId) || targetId === '') {
	      throw new DeveloperError('targetId is required.');
	    }
	    if (!defined(targetPropertyNames) || targetPropertyNames.length === 0) {
	      throw new DeveloperError('targetPropertyNames is required.');
	    }
	    for (var i = 0; i < targetPropertyNames.length; i++) {
	      var item = targetPropertyNames[i];
	      if (!defined(item) || item === '') {
	        throw new DeveloperError('reference contains invalid properties.');
	      }
	    }
	    this._targetCollection = targetCollection;
	    this._targetId = targetId;
	    this._targetPropertyNames = targetPropertyNames;
	    this._targetProperty = undefined;
	    this._targetEntity = undefined;
	    this._definitionChanged = new Event();
	    this._resolveEntity = true;
	    this._resolveProperty = true;
	    targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);
	  }
	  defineProperties(ReferenceProperty.prototype, {
	    isConstant: {get: function() {
	        return Property.isConstant(resolve(this));
	      }},
	    definitionChanged: {get: function() {
	        return this._definitionChanged;
	      }},
	    referenceFrame: {get: function() {
	        return resolve(this).referenceFrame;
	      }},
	    targetId: {get: function() {
	        return this._targetId;
	      }},
	    targetCollection: {get: function() {
	        return this._targetCollection;
	      }},
	    targetPropertyNames: {get: function() {
	        return this._targetPropertyNames;
	      }},
	    resolvedProperty: {get: function() {
	        return resolve(this);
	      }}
	  });
	  ReferenceProperty.fromString = function(targetCollection, referenceString) {
	    if (!defined(targetCollection)) {
	      throw new DeveloperError('targetCollection is required.');
	    }
	    if (!defined(referenceString)) {
	      throw new DeveloperError('referenceString is required.');
	    }
	    var identifier;
	    var values = [];
	    var inIdentifier = true;
	    var isEscaped = false;
	    var token = '';
	    for (var i = 0; i < referenceString.length; ++i) {
	      var c = referenceString.charAt(i);
	      if (isEscaped) {
	        token += c;
	        isEscaped = false;
	      } else if (c === '\\') {
	        isEscaped = true;
	      } else if (inIdentifier && c === '#') {
	        identifier = token;
	        inIdentifier = false;
	        token = '';
	      } else if (!inIdentifier && c === '.') {
	        values.push(token);
	        token = '';
	      } else {
	        token += c;
	      }
	    }
	    values.push(token);
	    return new ReferenceProperty(targetCollection, identifier, values);
	  };
	  ReferenceProperty.prototype.getValue = function(time, result) {
	    return resolve(this).getValue(time, result);
	  };
	  ReferenceProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	    return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);
	  };
	  ReferenceProperty.prototype.getType = function(time) {
	    return resolve(this).getType(time);
	  };
	  ReferenceProperty.prototype.equals = function(other) {
	    if (this === other) {
	      return true;
	    }
	    var names = this._targetPropertyNames;
	    var otherNames = other._targetPropertyNames;
	    if (this._targetCollection !== other._targetCollection || this._targetId !== other._targetId || names.length !== otherNames.length) {
	      return false;
	    }
	    var length = this._targetPropertyNames.length;
	    for (var i = 0; i < length; i++) {
	      if (names[i] !== otherNames[i]) {
	        return false;
	      }
	    }
	    return true;
	  };
	  ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function(targetEntity, name, value, oldValue) {
	    if (this._targetPropertyNames[0] === name) {
	      this._resolveProperty = true;
	      this._definitionChanged.raiseEvent(this);
	    }
	  };
	  ReferenceProperty.prototype._onCollectionChanged = function(collection, added, removed) {
	    var targetEntity = this._targetEntity;
	    if (defined(targetEntity)) {
	      if (removed.indexOf(targetEntity) !== -1) {
	        targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);
	        this._resolveEntity = true;
	        this._resolveProperty = true;
	      } else if (this._resolveEntity) {
	        resolve(this);
	        if (!this._resolveEntity) {
	          this._definitionChanged.raiseEvent(this);
	        }
	      }
	    }
	  };
	  return ReferenceProperty;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("2d", ["1f"], function(freezeObject) {
	  'use strict';
	  var ReferenceFrame = {
	    FIXED: 0,
	    INERTIAL: 1
	  };
	  return freezeObject(ReferenceFrame);
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("2e", ["2c", "1a", "1b", "1c", "32", "33", "34", "2d", "35"], function(Cartesian3, defined, defineProperties, DeveloperError, Matrix3, Matrix4, Quaternion, ReferenceFrame, Transforms) {
	  'use strict';
	  function PositionProperty() {
	    DeveloperError.throwInstantiationError();
	  }
	  defineProperties(PositionProperty.prototype, {
	    isConstant: {get: DeveloperError.throwInstantiationError},
	    definitionChanged: {get: DeveloperError.throwInstantiationError},
	    referenceFrame: {get: DeveloperError.throwInstantiationError}
	  });
	  PositionProperty.prototype.getValue = DeveloperError.throwInstantiationError;
	  PositionProperty.prototype.getValueInReferenceFrame = DeveloperError.throwInstantiationError;
	  PositionProperty.prototype.equals = DeveloperError.throwInstantiationError;
	  function framesEqual(frame1, frame2) {
	    return frame1 && frame1.id ? frame1.id === (frame2 && frame2.id) : frame1 === frame2;
	  }
	  function frameParents(frame) {
	    var frames = [];
	    while (defined(frame)) {
	      frames.unshift(frame);
	      frame = frame.position && frame.position.referenceFrame;
	    }
	    return frames;
	  }
	  function lowestCommonAncestor(parents1, parents2) {
	    if (!framesEqual(parents1[0], parents2[0])) {
	      return -1;
	    }
	    var h = Math.min(parents1.length, parents2.length);
	    for (var i = 0; i <= h; i++) {
	      if (!framesEqual(parents1[i], parents2[i])) {
	        return i - 1;
	      }
	    }
	    return -1;
	  }
	  var scratchIcrfToFixedMatrix3 = new Matrix3();
	  function getIcrfToFixed(time) {
	    var icrfToFixed = Transforms.computeIcrfToFixedMatrix(time, scratchIcrfToFixedMatrix3);
	    if (!defined(icrfToFixed)) {
	      icrfToFixed = Transforms.computeTemeToPseudoFixedMatrix(time, scratchIcrfToFixedMatrix3);
	    }
	    return icrfToFixed;
	  }
	  var scratchMatrix3 = new Matrix3();
	  var scratchCartesian3 = new Cartesian3();
	  var scratchQuaternion = new Quaternion();
	  PositionProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
	    if (!defined(value)) {
	      return value;
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    if (inputFrame === outputFrame) {
	      return Cartesian3.clone(value, result);
	    }
	    if (!defined(inputFrame) || !defined(outputFrame)) {
	      return undefined;
	    }
	    var inputFrameParents = frameParents(inputFrame);
	    var outputFrameParents = frameParents(outputFrame);
	    var lcaIndex = lowestCommonAncestor(inputFrameParents, outputFrameParents);
	    var lcaFrame = inputFrameParents[lcaIndex];
	    var inputPositionAccumulator = function(accumulatedPositionValue, frame) {
	      if (!defined(accumulatedPositionValue)) {
	        return accumulatedPositionValue;
	      }
	      var framePositionProperty = frame.position;
	      if (!defined(framePositionProperty)) {
	        return undefined;
	      }
	      var frameReferenceFrame = framePositionProperty.referenceFrame;
	      var framePositionValue = framePositionProperty.getValueInReferenceFrame(time, frameReferenceFrame, scratchCartesian3);
	      if (!defined(framePositionValue)) {
	        return undefined;
	      }
	      var frameOrientationProperty = frame.orientation;
	      if (defined(frameOrientationProperty)) {
	        var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
	        if (!defined(frameOrientationValue)) {
	          return undefined;
	        }
	        Matrix3.fromQuaternion(frameOrientationValue, scratchMatrix3);
	        Matrix3.multiplyByVector(scratchMatrix3, accumulatedPositionValue, accumulatedPositionValue);
	        return Cartesian3.add(framePositionValue, accumulatedPositionValue, accumulatedPositionValue);
	      }
	      return Cartesian3.add(framePositionValue, accumulatedPositionValue, accumulatedPositionValue);
	    };
	    var outputPositionAccumulator = function(accumulatedPositionValue, frame) {
	      if (!defined(accumulatedPositionValue)) {
	        return accumulatedPositionValue;
	      }
	      var framePositionProperty = frame.position;
	      if (!defined(framePositionProperty)) {
	        return undefined;
	      }
	      var frameReferenceFrame = framePositionProperty.referenceFrame;
	      var framePositionValue = framePositionProperty.getValueInReferenceFrame(time, frameReferenceFrame, scratchCartesian3);
	      if (!defined(framePositionValue)) {
	        return undefined;
	      }
	      accumulatedPositionValue = Cartesian3.subtract(accumulatedPositionValue, framePositionValue, accumulatedPositionValue);
	      var frameOrientationProperty = frame.orientation;
	      if (defined(frameOrientationProperty)) {
	        var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
	        if (!defined(frameOrientationValue)) {
	          return undefined;
	        }
	        Quaternion.conjugate(frameOrientationValue, frameOrientationValue);
	        Matrix3.fromQuaternion(frameOrientationValue, scratchMatrix3);
	        Matrix3.multiplyByVector(scratchMatrix3, accumulatedPositionValue, accumulatedPositionValue);
	      }
	      return accumulatedPositionValue;
	    };
	    if (defined(lcaFrame)) {
	      inputFrameParents = inputFrameParents.slice(lcaIndex + 1);
	      outputFrameParents = outputFrameParents.slice(lcaIndex + 1);
	      var lcaFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
	      if (!defined(lcaFrameValue)) {
	        return undefined;
	      }
	      return outputFrameParents.reduce(outputPositionAccumulator, lcaFrameValue);
	    }
	    var inputRootFrame = inputFrameParents.shift();
	    var outputRootFrame = outputFrameParents.shift();
	    var fixedFrameValue,
	        inertialFrameValue;
	    if (inputRootFrame === ReferenceFrame.INERTIAL && outputRootFrame === ReferenceFrame.FIXED) {
	      inertialFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
	      if (!defined(inertialFrameValue)) {
	        return undefined;
	      }
	      fixedFrameValue = Matrix3.multiplyByVector(getIcrfToFixed(time), inertialFrameValue, result);
	      return outputFrameParents.reduce(outputPositionAccumulator, fixedFrameValue);
	    }
	    if (inputRootFrame === ReferenceFrame.FIXED && outputRootFrame === ReferenceFrame.INERTIAL) {
	      fixedFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
	      if (!defined(fixedFrameValue)) {
	        return undefined;
	      }
	      var fixedToIcrf = Matrix3.transpose(getIcrfToFixed(time), scratchMatrix3);
	      inertialFrameValue = Matrix3.multiplyByVector(fixedToIcrf, fixedFrameValue, result);
	      return outputFrameParents.reduce(outputPositionAccumulator, inertialFrameValue);
	    }
	    return undefined;
	  };
	  return PositionProperty;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("39", ["23", "1a", "1b", "1c", "1f", "24"], function(defaultValue, defined, defineProperties, DeveloperError, freezeObject, JulianDate) {
	  'use strict';
	  function TimeInterval(options) {
	    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	    this.start = defined(options.start) ? JulianDate.clone(options.start) : new JulianDate();
	    this.stop = defined(options.stop) ? JulianDate.clone(options.stop) : new JulianDate();
	    this.data = options.data;
	    this.isStartIncluded = defaultValue(options.isStartIncluded, true);
	    this.isStopIncluded = defaultValue(options.isStopIncluded, true);
	  }
	  defineProperties(TimeInterval.prototype, {isEmpty: {get: function() {
	        var stopComparedToStart = JulianDate.compare(this.stop, this.start);
	        return stopComparedToStart < 0 || (stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded));
	      }}});
	  var scratchInterval = {
	    start: undefined,
	    stop: undefined,
	    isStartIncluded: undefined,
	    isStopIncluded: undefined,
	    data: undefined
	  };
	  TimeInterval.fromIso8601 = function(options, result) {
	    if (!defined(options)) {
	      throw new DeveloperError('options is required.');
	    }
	    if (!defined(options.iso8601)) {
	      throw new DeveloperError('options.iso8601 is required.');
	    }
	    var dates = options.iso8601.split('/');
	    var start = JulianDate.fromIso8601(dates[0]);
	    var stop = JulianDate.fromIso8601(dates[1]);
	    var isStartIncluded = defaultValue(options.isStartIncluded, true);
	    var isStopIncluded = defaultValue(options.isStopIncluded, true);
	    var data = options.data;
	    if (!defined(result)) {
	      scratchInterval.start = start;
	      scratchInterval.stop = stop;
	      scratchInterval.isStartIncluded = isStartIncluded;
	      scratchInterval.isStopIncluded = isStopIncluded;
	      scratchInterval.data = data;
	      return new TimeInterval(scratchInterval);
	    }
	    result.start = start;
	    result.stop = stop;
	    result.isStartIncluded = isStartIncluded;
	    result.isStopIncluded = isStopIncluded;
	    result.data = data;
	    return result;
	  };
	  TimeInterval.toIso8601 = function(timeInterval, precision) {
	    if (!defined(timeInterval)) {
	      throw new DeveloperError('timeInterval is required.');
	    }
	    return JulianDate.toIso8601(timeInterval.start, precision) + '/' + JulianDate.toIso8601(timeInterval.stop, precision);
	  };
	  TimeInterval.clone = function(timeInterval, result) {
	    if (!defined(timeInterval)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new TimeInterval(timeInterval);
	    }
	    result.start = timeInterval.start;
	    result.stop = timeInterval.stop;
	    result.isStartIncluded = timeInterval.isStartIncluded;
	    result.isStopIncluded = timeInterval.isStopIncluded;
	    result.data = timeInterval.data;
	    return result;
	  };
	  TimeInterval.equals = function(left, right, dataComparer) {
	    return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equals(left.start, right.start) && JulianDate.equals(left.stop, right.stop) && (left.data === right.data || (defined(dataComparer) && dataComparer(left.data, right.data))));
	  };
	  TimeInterval.equalsEpsilon = function(left, right, epsilon, dataComparer) {
	    if (typeof epsilon !== 'number') {
	      throw new DeveloperError('epsilon is required and must be a number.');
	    }
	    return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equalsEpsilon(left.start, right.start, epsilon) && JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) && (left.data === right.data || (defined(dataComparer) && dataComparer(left.data, right.data))));
	  };
	  TimeInterval.intersect = function(left, right, result, mergeCallback) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    if (!defined(right)) {
	      return TimeInterval.clone(TimeInterval.EMPTY, result);
	    }
	    var leftStart = left.start;
	    var leftStop = left.stop;
	    var rightStart = right.start;
	    var rightStop = right.stop;
	    var intersectsStartRight = JulianDate.greaterThanOrEquals(rightStart, leftStart) && JulianDate.greaterThanOrEquals(leftStop, rightStart);
	    var intersectsStartLeft = !intersectsStartRight && JulianDate.lessThanOrEquals(rightStart, leftStart) && JulianDate.lessThanOrEquals(leftStart, rightStop);
	    if (!intersectsStartRight && !intersectsStartLeft) {
	      return TimeInterval.clone(TimeInterval.EMPTY, result);
	    }
	    var leftIsStartIncluded = left.isStartIncluded;
	    var leftIsStopIncluded = left.isStopIncluded;
	    var rightIsStartIncluded = right.isStartIncluded;
	    var rightIsStopIncluded = right.isStopIncluded;
	    var leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);
	    result.start = intersectsStartRight ? rightStart : leftStart;
	    result.isStartIncluded = (leftIsStartIncluded && rightIsStartIncluded) || (!JulianDate.equals(rightStart, leftStart) && ((intersectsStartRight && rightIsStartIncluded) || (intersectsStartLeft && leftIsStartIncluded)));
	    result.stop = leftLessThanRight ? leftStop : rightStop;
	    result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : (leftIsStopIncluded && rightIsStopIncluded) || (!JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded);
	    result.data = defined(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;
	    return result;
	  };
	  TimeInterval.contains = function(timeInterval, julianDate) {
	    if (!defined(timeInterval)) {
	      throw new DeveloperError('timeInterval is required.');
	    }
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    if (timeInterval.isEmpty) {
	      return false;
	    }
	    var startComparedToDate = JulianDate.compare(timeInterval.start, julianDate);
	    if (startComparedToDate === 0) {
	      return timeInterval.isStartIncluded;
	    }
	    var dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);
	    if (dateComparedToStop === 0) {
	      return timeInterval.isStopIncluded;
	    }
	    return startComparedToDate < 0 && dateComparedToStop < 0;
	  };
	  TimeInterval.prototype.clone = function(result) {
	    return TimeInterval.clone(this, result);
	  };
	  TimeInterval.prototype.equals = function(right, dataComparer) {
	    return TimeInterval.equals(this, right, dataComparer);
	  };
	  TimeInterval.prototype.equalsEpsilon = function(right, epsilon, dataComparer) {
	    return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);
	  };
	  TimeInterval.prototype.toString = function() {
	    return TimeInterval.toIso8601(this);
	  };
	  TimeInterval.EMPTY = freezeObject(new TimeInterval({
	    start: new JulianDate(),
	    stop: new JulianDate(),
	    isStartIncluded: false,
	    isStopIncluded: false
	  }));
	  return TimeInterval;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("37", ["1f", "24", "39"], function(freezeObject, JulianDate, TimeInterval) {
	  'use strict';
	  var MINIMUM_VALUE = freezeObject(JulianDate.fromIso8601('0000-01-01T00:00:00Z'));
	  var MAXIMUM_VALUE = freezeObject(JulianDate.fromIso8601('9999-12-31T24:00:00Z'));
	  var MAXIMUM_INTERVAL = freezeObject(new TimeInterval({
	    start: MINIMUM_VALUE,
	    stop: MAXIMUM_VALUE
	  }));
	  var Iso8601 = {
	    MINIMUM_VALUE: MINIMUM_VALUE,
	    MAXIMUM_VALUE: MAXIMUM_VALUE,
	    MAXIMUM_INTERVAL: MAXIMUM_INTERVAL
	  };
	  return Iso8601;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("36", ["23", "1a", "1b", "1c", "37"], function(defaultValue, defined, defineProperties, DeveloperError, Iso8601) {
	  'use strict';
	  function Property() {
	    DeveloperError.throwInstantiationError();
	  }
	  defineProperties(Property.prototype, {
	    isConstant: {get: DeveloperError.throwInstantiationError},
	    definitionChanged: {get: DeveloperError.throwInstantiationError}
	  });
	  Property.prototype.getValue = DeveloperError.throwInstantiationError;
	  Property.prototype.equals = DeveloperError.throwInstantiationError;
	  Property.equals = function(left, right) {
	    return left === right || (defined(left) && left.equals(right));
	  };
	  Property.arrayEquals = function(left, right) {
	    if (left === right) {
	      return true;
	    }
	    if ((!defined(left) || !defined(right)) || (left.length !== right.length)) {
	      return false;
	    }
	    var length = left.length;
	    for (var i = 0; i < length; i++) {
	      if (!Property.equals(left[i], right[i])) {
	        return false;
	      }
	    }
	    return true;
	  };
	  Property.isConstant = function(property) {
	    return !defined(property) || property.isConstant;
	  };
	  Property.getValueOrUndefined = function(property, time, result) {
	    return defined(property) ? property.getValue(time, result) : undefined;
	  };
	  Property.getValueOrDefault = function(property, time, valueDefault, result) {
	    return defined(property) ? defaultValue(property.getValue(time, result), valueDefault) : valueDefault;
	  };
	  Property.getValueOrClonedDefault = function(property, time, valueDefault, result) {
	    var value;
	    if (defined(property)) {
	      value = property.getValue(time, result);
	    }
	    if (!defined(value)) {
	      value = valueDefault.clone(value);
	    }
	    return value;
	  };
	  return Property;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("48", ["2c", "23", "1a", "1b", "1c", "1d", "2d", "2e", "36", "49"], function(Cartesian3, defaultValue, defined, defineProperties, DeveloperError, Event, ReferenceFrame, PositionProperty, Property, SampledProperty) {
	  'use strict';
	  function SampledPositionProperty(referenceFrame, numberOfDerivatives) {
	    numberOfDerivatives = defaultValue(numberOfDerivatives, 0);
	    var derivativeTypes;
	    if (numberOfDerivatives > 0) {
	      derivativeTypes = new Array(numberOfDerivatives);
	      for (var i = 0; i < numberOfDerivatives; i++) {
	        derivativeTypes[i] = Cartesian3;
	      }
	    }
	    this._numberOfDerivatives = numberOfDerivatives;
	    this._property = new SampledProperty(Cartesian3, derivativeTypes);
	    this._definitionChanged = new Event();
	    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
	    this._property._definitionChanged.addEventListener(function() {
	      this._definitionChanged.raiseEvent(this);
	    }, this);
	  }
	  defineProperties(SampledPositionProperty.prototype, {
	    isConstant: {get: function() {
	        return this._property.isConstant;
	      }},
	    definitionChanged: {get: function() {
	        return this._definitionChanged;
	      }},
	    referenceFrame: {get: function() {
	        return this._referenceFrame;
	      }},
	    interpolationDegree: {get: function() {
	        return this._property.interpolationDegree;
	      }},
	    interpolationAlgorithm: {get: function() {
	        return this._property.interpolationAlgorithm;
	      }},
	    numberOfDerivatives: {get: function() {
	        return this._numberOfDerivatives;
	      }},
	    forwardExtrapolationType: {
	      get: function() {
	        return this._property.forwardExtrapolationType;
	      },
	      set: function(value) {
	        this._property.forwardExtrapolationType = value;
	      }
	    },
	    forwardExtrapolationDuration: {
	      get: function() {
	        return this._property.forwardExtrapolationDuration;
	      },
	      set: function(value) {
	        this._property.forwardExtrapolationDuration = value;
	      }
	    },
	    backwardExtrapolationType: {
	      get: function() {
	        return this._property.backwardExtrapolationType;
	      },
	      set: function(value) {
	        this._property.backwardExtrapolationType = value;
	      }
	    },
	    backwardExtrapolationDuration: {
	      get: function() {
	        return this._property.backwardExtrapolationDuration;
	      },
	      set: function(value) {
	        this._property.backwardExtrapolationDuration = value;
	      }
	    }
	  });
	  SampledPositionProperty.prototype.getValue = function(time, result) {
	    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
	  };
	  SampledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	    if (!defined(time)) {
	      throw new DeveloperError('time is required.');
	    }
	    if (!defined(referenceFrame)) {
	      throw new DeveloperError('referenceFrame is required.');
	    }
	    result = this._property.getValue(time, result);
	    if (defined(result)) {
	      return PositionProperty.convertToReferenceFrame(time, result, this._referenceFrame, referenceFrame, result);
	    }
	    return undefined;
	  };
	  SampledPositionProperty.prototype.setInterpolationOptions = function(options) {
	    this._property.setInterpolationOptions(options);
	  };
	  SampledPositionProperty.prototype.addSample = function(time, position, derivatives) {
	    var numberOfDerivatives = this._numberOfDerivatives;
	    if (numberOfDerivatives > 0 && (!defined(derivatives) || derivatives.length !== numberOfDerivatives)) {
	      throw new DeveloperError('derivatives length must be equal to the number of derivatives.');
	    }
	    this._property.addSample(time, position, derivatives);
	  };
	  SampledPositionProperty.prototype.addSamples = function(times, positions, derivatives) {
	    this._property.addSamples(times, positions, derivatives);
	  };
	  SampledPositionProperty.prototype.addSamplesPackedArray = function(data, epoch) {
	    this._property.addSamplesPackedArray(data, epoch);
	  };
	  SampledPositionProperty.prototype.equals = function(other) {
	    return this === other || (other instanceof SampledPositionProperty && Property.equals(this._property, other._property) && this._referenceFrame === other._referenceFrame);
	  };
	  return SampledPositionProperty;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("1d", ["1a", "1b", "1c"], function(defined, defineProperties, DeveloperError) {
	  'use strict';
	  function Event() {
	    this._listeners = [];
	    this._scopes = [];
	    this._toRemove = [];
	    this._insideRaiseEvent = false;
	  }
	  defineProperties(Event.prototype, {numberOfListeners: {get: function() {
	        return this._listeners.length - this._toRemove.length;
	      }}});
	  Event.prototype.addEventListener = function(listener, scope) {
	    if (typeof listener !== 'function') {
	      throw new DeveloperError('listener is required and must be a function.');
	    }
	    this._listeners.push(listener);
	    this._scopes.push(scope);
	    var event = this;
	    return function() {
	      event.removeEventListener(listener, scope);
	    };
	  };
	  Event.prototype.removeEventListener = function(listener, scope) {
	    if (typeof listener !== 'function') {
	      throw new DeveloperError('listener is required and must be a function.');
	    }
	    var listeners = this._listeners;
	    var scopes = this._scopes;
	    var index = -1;
	    for (var i = 0; i < listeners.length; i++) {
	      if (listeners[i] === listener && scopes[i] === scope) {
	        index = i;
	        break;
	      }
	    }
	    if (index !== -1) {
	      if (this._insideRaiseEvent) {
	        this._toRemove.push(index);
	        listeners[index] = undefined;
	        scopes[index] = undefined;
	      } else {
	        listeners.splice(index, 1);
	        scopes.splice(index, 1);
	      }
	      return true;
	    }
	    return false;
	  };
	  Event.prototype.raiseEvent = function() {
	    this._insideRaiseEvent = true;
	    var i;
	    var listeners = this._listeners;
	    var scopes = this._scopes;
	    var length = listeners.length;
	    for (i = 0; i < length; i++) {
	      var listener = listeners[i];
	      if (defined(listener)) {
	        listeners[i].apply(scopes[i], arguments);
	      }
	    }
	    var toRemove = this._toRemove;
	    length = toRemove.length;
	    for (i = 0; i < length; i++) {
	      var index = toRemove[i];
	      listeners.splice(index, 1);
	      scopes.splice(index, 1);
	    }
	    toRemove.length = 0;
	    this._insideRaiseEvent = false;
	  };
	  return Event;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("4a", ["1f"], function(freezeObject) {
	  'use strict';
	  var ExtrapolationType = {
	    NONE: 0,
	    HOLD: 1,
	    EXTRAPOLATE: 2
	  };
	  return freezeObject(ExtrapolationType);
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("4b", ["1a", "1c"], function(defined, DeveloperError) {
	  'use strict';
	  var LinearApproximation = {type: 'Linear'};
	  LinearApproximation.getRequiredDataPoints = function(degree) {
	    return 2;
	  };
	  LinearApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
	    if (xTable.length !== 2) {
	      throw new DeveloperError('The xTable provided to the linear interpolator must have exactly two elements.');
	    } else if (yStride <= 0) {
	      throw new DeveloperError('There must be at least 1 dependent variable for each independent variable.');
	    }
	    if (!defined(result)) {
	      result = new Array(yStride);
	    }
	    var i;
	    var y0;
	    var y1;
	    var x0 = xTable[0];
	    var x1 = xTable[1];
	    if (x0 === x1) {
	      throw new DeveloperError('Divide by zero error: xTable[0] and xTable[1] are equal');
	    }
	    for (i = 0; i < yStride; i++) {
	      y0 = yTable[i];
	      y1 = yTable[i + yStride];
	      result[i] = (((y1 - y0) * x) + (x1 * y0) - (x0 * y1)) / (x1 - x0);
	    }
	    return result;
	  };
	  return LinearApproximation;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("49", ["4c", "23", "1a", "1b", "1c", "1d", "4a", "24", "4b"], function(binarySearch, defaultValue, defined, defineProperties, DeveloperError, Event, ExtrapolationType, JulianDate, LinearApproximation) {
	  'use strict';
	  var PackableNumber = {
	    packedLength: 1,
	    pack: function(value, array, startingIndex) {
	      startingIndex = defaultValue(startingIndex, 0);
	      array[startingIndex] = value;
	    },
	    unpack: function(array, startingIndex, result) {
	      startingIndex = defaultValue(startingIndex, 0);
	      return array[startingIndex];
	    }
	  };
	  function arrayInsert(array, startIndex, items) {
	    var i;
	    var arrayLength = array.length;
	    var itemsLength = items.length;
	    var newLength = arrayLength + itemsLength;
	    array.length = newLength;
	    if (arrayLength !== startIndex) {
	      var q = arrayLength - 1;
	      for (i = newLength - 1; i >= startIndex; i--) {
	        array[i] = array[q--];
	      }
	    }
	    for (i = 0; i < itemsLength; i++) {
	      array[startIndex++] = items[i];
	    }
	  }
	  function convertDate(date, epoch) {
	    if (date instanceof JulianDate) {
	      return date;
	    }
	    if (typeof date === 'string') {
	      return JulianDate.fromIso8601(date);
	    }
	    return JulianDate.addSeconds(epoch, date, new JulianDate());
	  }
	  var timesSpliceArgs = [];
	  var valuesSpliceArgs = [];
	  function mergeNewSamples(epoch, times, values, newData, packedLength) {
	    var newDataIndex = 0;
	    var i;
	    var prevItem;
	    var timesInsertionPoint;
	    var valuesInsertionPoint;
	    var currentTime;
	    var nextTime;
	    while (newDataIndex < newData.length) {
	      currentTime = convertDate(newData[newDataIndex], epoch);
	      timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);
	      var timesSpliceArgsCount = 0;
	      var valuesSpliceArgsCount = 0;
	      if (timesInsertionPoint < 0) {
	        timesInsertionPoint = ~timesInsertionPoint;
	        valuesInsertionPoint = timesInsertionPoint * packedLength;
	        prevItem = undefined;
	        nextTime = times[timesInsertionPoint];
	        while (newDataIndex < newData.length) {
	          currentTime = convertDate(newData[newDataIndex], epoch);
	          if ((defined(prevItem) && JulianDate.compare(prevItem, currentTime) >= 0) || (defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0)) {
	            break;
	          }
	          timesSpliceArgs[timesSpliceArgsCount++] = currentTime;
	          newDataIndex = newDataIndex + 1;
	          for (i = 0; i < packedLength; i++) {
	            valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];
	            newDataIndex = newDataIndex + 1;
	          }
	          prevItem = currentTime;
	        }
	        if (timesSpliceArgsCount > 0) {
	          valuesSpliceArgs.length = valuesSpliceArgsCount;
	          arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);
	          timesSpliceArgs.length = timesSpliceArgsCount;
	          arrayInsert(times, timesInsertionPoint, timesSpliceArgs);
	        }
	      } else {
	        for (i = 0; i < packedLength; i++) {
	          newDataIndex++;
	          values[(timesInsertionPoint * packedLength) + i] = newData[newDataIndex];
	        }
	        newDataIndex++;
	      }
	    }
	  }
	  function SampledProperty(type, derivativeTypes) {
	    if (!defined(type)) {
	      throw new DeveloperError('type is required.');
	    }
	    var innerType = type;
	    if (innerType === Number) {
	      innerType = PackableNumber;
	    }
	    var packedLength = innerType.packedLength;
	    var packedInterpolationLength = defaultValue(innerType.packedInterpolationLength, packedLength);
	    var inputOrder = 0;
	    var innerDerivativeTypes;
	    if (defined(derivativeTypes)) {
	      var length = derivativeTypes.length;
	      innerDerivativeTypes = new Array(length);
	      for (var i = 0; i < length; i++) {
	        var derivativeType = derivativeTypes[i];
	        if (derivativeType === Number) {
	          derivativeType = PackableNumber;
	        }
	        var derivativePackedLength = derivativeType.packedLength;
	        packedLength += derivativePackedLength;
	        packedInterpolationLength += defaultValue(derivativeType.packedInterpolationLength, derivativePackedLength);
	        innerDerivativeTypes[i] = derivativeType;
	      }
	      inputOrder = length;
	    }
	    this._type = type;
	    this._innerType = innerType;
	    this._interpolationDegree = 1;
	    this._interpolationAlgorithm = LinearApproximation;
	    this._numberOfPoints = 0;
	    this._times = [];
	    this._values = [];
	    this._xTable = [];
	    this._yTable = [];
	    this._packedLength = packedLength;
	    this._packedInterpolationLength = packedInterpolationLength;
	    this._updateTableLength = true;
	    this._interpolationResult = new Array(packedInterpolationLength);
	    this._definitionChanged = new Event();
	    this._derivativeTypes = derivativeTypes;
	    this._innerDerivativeTypes = innerDerivativeTypes;
	    this._inputOrder = inputOrder;
	    this._forwardExtrapolationType = ExtrapolationType.NONE;
	    this._forwardExtrapolationDuration = 0;
	    this._backwardExtrapolationType = ExtrapolationType.NONE;
	    this._backwardExtrapolationDuration = 0;
	  }
	  defineProperties(SampledProperty.prototype, {
	    isConstant: {get: function() {
	        return this._values.length === 0;
	      }},
	    definitionChanged: {get: function() {
	        return this._definitionChanged;
	      }},
	    type: {get: function() {
	        return this._type;
	      }},
	    derivativeTypes: {get: function() {
	        return this._derivativeTypes;
	      }},
	    interpolationDegree: {get: function() {
	        return this._interpolationDegree;
	      }},
	    interpolationAlgorithm: {get: function() {
	        return this._interpolationAlgorithm;
	      }},
	    forwardExtrapolationType: {
	      get: function() {
	        return this._forwardExtrapolationType;
	      },
	      set: function(value) {
	        if (this._forwardExtrapolationType !== value) {
	          this._forwardExtrapolationType = value;
	          this._definitionChanged.raiseEvent(this);
	        }
	      }
	    },
	    forwardExtrapolationDuration: {
	      get: function() {
	        return this._forwardExtrapolationDuration;
	      },
	      set: function(value) {
	        if (this._forwardExtrapolationDuration !== value) {
	          this._forwardExtrapolationDuration = value;
	          this._definitionChanged.raiseEvent(this);
	        }
	      }
	    },
	    backwardExtrapolationType: {
	      get: function() {
	        return this._backwardExtrapolationType;
	      },
	      set: function(value) {
	        if (this._backwardExtrapolationType !== value) {
	          this._backwardExtrapolationType = value;
	          this._definitionChanged.raiseEvent(this);
	        }
	      }
	    },
	    backwardExtrapolationDuration: {
	      get: function() {
	        return this._backwardExtrapolationDuration;
	      },
	      set: function(value) {
	        if (this._backwardExtrapolationDuration !== value) {
	          this._backwardExtrapolationDuration = value;
	          this._definitionChanged.raiseEvent(this);
	        }
	      }
	    }
	  });
	  SampledProperty.prototype.getValue = function(time, result) {
	    if (!defined(time)) {
	      throw new DeveloperError('time is required.');
	    }
	    var times = this._times;
	    var timesLength = times.length;
	    if (timesLength === 0) {
	      return undefined;
	    }
	    var timeout;
	    var innerType = this._innerType;
	    var values = this._values;
	    var index = binarySearch(times, time, JulianDate.compare);
	    if (index < 0) {
	      index = ~index;
	      if (index === 0) {
	        var startTime = times[index];
	        timeout = this._backwardExtrapolationDuration;
	        if (this._backwardExtrapolationType === ExtrapolationType.NONE || (timeout !== 0 && JulianDate.secondsDifference(startTime, time) > timeout)) {
	          return undefined;
	        }
	        if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {
	          return innerType.unpack(values, 0, result);
	        }
	      }
	      if (index >= timesLength) {
	        index = timesLength - 1;
	        var endTime = times[index];
	        timeout = this._forwardExtrapolationDuration;
	        if (this._forwardExtrapolationType === ExtrapolationType.NONE || (timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout)) {
	          return undefined;
	        }
	        if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {
	          index = timesLength - 1;
	          return innerType.unpack(values, index * innerType.packedLength, result);
	        }
	      }
	      var xTable = this._xTable;
	      var yTable = this._yTable;
	      var interpolationAlgorithm = this._interpolationAlgorithm;
	      var packedInterpolationLength = this._packedInterpolationLength;
	      var inputOrder = this._inputOrder;
	      if (this._updateTableLength) {
	        this._updateTableLength = false;
	        var numberOfPoints = Math.min(interpolationAlgorithm.getRequiredDataPoints(this._interpolationDegree, inputOrder), timesLength);
	        if (numberOfPoints !== this._numberOfPoints) {
	          this._numberOfPoints = numberOfPoints;
	          xTable.length = numberOfPoints;
	          yTable.length = numberOfPoints * packedInterpolationLength;
	        }
	      }
	      var degree = this._numberOfPoints - 1;
	      if (degree < 1) {
	        return undefined;
	      }
	      var firstIndex = 0;
	      var lastIndex = timesLength - 1;
	      var pointsInCollection = lastIndex - firstIndex + 1;
	      if (pointsInCollection >= degree + 1) {
	        var computedFirstIndex = index - ((degree / 2) | 0) - 1;
	        if (computedFirstIndex < firstIndex) {
	          computedFirstIndex = firstIndex;
	        }
	        var computedLastIndex = computedFirstIndex + degree;
	        if (computedLastIndex > lastIndex) {
	          computedLastIndex = lastIndex;
	          computedFirstIndex = computedLastIndex - degree;
	          if (computedFirstIndex < firstIndex) {
	            computedFirstIndex = firstIndex;
	          }
	        }
	        firstIndex = computedFirstIndex;
	        lastIndex = computedLastIndex;
	      }
	      var length = lastIndex - firstIndex + 1;
	      for (var i = 0; i < length; ++i) {
	        xTable[i] = JulianDate.secondsDifference(times[firstIndex + i], times[lastIndex]);
	      }
	      if (!defined(innerType.convertPackedArrayForInterpolation)) {
	        var destinationIndex = 0;
	        var packedLength = this._packedLength;
	        var sourceIndex = firstIndex * packedLength;
	        var stop = (lastIndex + 1) * packedLength;
	        while (sourceIndex < stop) {
	          yTable[destinationIndex] = values[sourceIndex];
	          sourceIndex++;
	          destinationIndex++;
	        }
	      } else {
	        innerType.convertPackedArrayForInterpolation(values, firstIndex, lastIndex, yTable);
	      }
	      var x = JulianDate.secondsDifference(time, times[lastIndex]);
	      var interpolationResult;
	      if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {
	        interpolationResult = interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, packedInterpolationLength, this._interpolationResult);
	      } else {
	        var yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));
	        interpolationResult = interpolationAlgorithm.interpolate(x, xTable, yTable, yStride, inputOrder, inputOrder, this._interpolationResult);
	      }
	      if (!defined(innerType.unpackInterpolationResult)) {
	        return innerType.unpack(interpolationResult, 0, result);
	      }
	      return innerType.unpackInterpolationResult(interpolationResult, values, firstIndex, lastIndex, result);
	    }
	    return innerType.unpack(values, index * this._packedLength, result);
	  };
	  SampledProperty.prototype.setInterpolationOptions = function(options) {
	    if (!defined(options)) {
	      throw new DeveloperError('options is required.');
	    }
	    var valuesChanged = false;
	    var interpolationAlgorithm = options.interpolationAlgorithm;
	    var interpolationDegree = options.interpolationDegree;
	    if (this._interpolationAlgorithm !== interpolationAlgorithm) {
	      this._interpolationAlgorithm = interpolationAlgorithm;
	      valuesChanged = true;
	    }
	    if (this._interpolationDegree !== interpolationDegree) {
	      this._interpolationDegree = interpolationDegree;
	      valuesChanged = true;
	    }
	    if (valuesChanged) {
	      this._updateTableLength = true;
	      this._definitionChanged.raiseEvent(this);
	    }
	  };
	  SampledProperty.prototype.addSample = function(time, value, derivatives) {
	    var innerDerivativeTypes = this._innerDerivativeTypes;
	    var hasDerivatives = defined(innerDerivativeTypes);
	    if (!defined(time)) {
	      throw new DeveloperError('time is required.');
	    }
	    if (!defined(value)) {
	      throw new DeveloperError('value is required.');
	    }
	    if (hasDerivatives && !defined(derivatives)) {
	      throw new DeveloperError('derivatives is required.');
	    }
	    var innerType = this._innerType;
	    var data = [];
	    data.push(time);
	    innerType.pack(value, data, data.length);
	    if (hasDerivatives) {
	      var derivativesLength = innerDerivativeTypes.length;
	      for (var x = 0; x < derivativesLength; x++) {
	        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
	      }
	    }
	    mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
	    this._updateTableLength = true;
	    this._definitionChanged.raiseEvent(this);
	  };
	  SampledProperty.prototype.addSamples = function(times, values, derivativeValues) {
	    var innerDerivativeTypes = this._innerDerivativeTypes;
	    var hasDerivatives = defined(innerDerivativeTypes);
	    if (!defined(times)) {
	      throw new DeveloperError('times is required.');
	    }
	    if (!defined(values)) {
	      throw new DeveloperError('values is required.');
	    }
	    if (times.length !== values.length) {
	      throw new DeveloperError('times and values must be the same length.');
	    }
	    if (hasDerivatives && (!defined(derivativeValues) || derivativeValues.length !== times.length)) {
	      throw new DeveloperError('times and derivativeValues must be the same length.');
	    }
	    var innerType = this._innerType;
	    var length = times.length;
	    var data = [];
	    for (var i = 0; i < length; i++) {
	      data.push(times[i]);
	      innerType.pack(values[i], data, data.length);
	      if (hasDerivatives) {
	        var derivatives = derivativeValues[i];
	        var derivativesLength = innerDerivativeTypes.length;
	        for (var x = 0; x < derivativesLength; x++) {
	          innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
	        }
	      }
	    }
	    mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
	    this._updateTableLength = true;
	    this._definitionChanged.raiseEvent(this);
	  };
	  SampledProperty.prototype.addSamplesPackedArray = function(packedSamples, epoch) {
	    if (!defined(packedSamples)) {
	      throw new DeveloperError('packedSamples is required.');
	    }
	    mergeNewSamples(epoch, this._times, this._values, packedSamples, this._packedLength);
	    this._updateTableLength = true;
	    this._definitionChanged.raiseEvent(this);
	  };
	  SampledProperty.prototype.equals = function(other) {
	    if (this === other) {
	      return true;
	    }
	    if (!defined(other)) {
	      return false;
	    }
	    if (this._type !== other._type || this._interpolationDegree !== other._interpolationDegree || this._interpolationAlgorithm !== other._interpolationAlgorithm) {
	      return false;
	    }
	    var derivativeTypes = this._derivativeTypes;
	    var hasDerivatives = defined(derivativeTypes);
	    var otherDerivativeTypes = other._derivativeTypes;
	    var otherHasDerivatives = defined(otherDerivativeTypes);
	    if (hasDerivatives !== otherHasDerivatives) {
	      return false;
	    }
	    var i;
	    var length;
	    if (hasDerivatives) {
	      length = derivativeTypes.length;
	      if (length !== otherDerivativeTypes.length) {
	        return false;
	      }
	      for (i = 0; i < length; i++) {
	        if (derivativeTypes[i] !== otherDerivativeTypes[i]) {
	          return false;
	        }
	      }
	    }
	    var times = this._times;
	    var otherTimes = other._times;
	    length = times.length;
	    if (length !== otherTimes.length) {
	      return false;
	    }
	    for (i = 0; i < length; i++) {
	      if (!JulianDate.equals(times[i], otherTimes[i])) {
	        return false;
	      }
	    }
	    var values = this._values;
	    var otherValues = other._values;
	    for (i = 0; i < length; i++) {
	      if (values[i] !== otherValues[i]) {
	        return false;
	      }
	    }
	    return true;
	  };
	  SampledProperty._mergeNewSamples = mergeNewSamples;
	  return SampledProperty;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("45", ["23", "1a", "1c", "1f", "27"], function(defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
	  'use strict';
	  function Cartesian2(x, y) {
	    this.x = defaultValue(x, 0.0);
	    this.y = defaultValue(y, 0.0);
	  }
	  Cartesian2.fromElements = function(x, y, result) {
	    if (!defined(result)) {
	      return new Cartesian2(x, y);
	    }
	    result.x = x;
	    result.y = y;
	    return result;
	  };
	  Cartesian2.clone = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new Cartesian2(cartesian.x, cartesian.y);
	    }
	    result.x = cartesian.x;
	    result.y = cartesian.y;
	    return result;
	  };
	  Cartesian2.fromCartesian3 = Cartesian2.clone;
	  Cartesian2.fromCartesian4 = Cartesian2.clone;
	  Cartesian2.packedLength = 2;
	  Cartesian2.pack = function(value, array, startingIndex) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required');
	    }
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    array[startingIndex++] = value.x;
	    array[startingIndex] = value.y;
	  };
	  Cartesian2.unpack = function(array, startingIndex, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    if (!defined(result)) {
	      result = new Cartesian2();
	    }
	    result.x = array[startingIndex++];
	    result.y = array[startingIndex];
	    return result;
	  };
	  Cartesian2.packArray = function(array, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    var length = array.length;
	    if (!defined(result)) {
	      result = new Array(length * 2);
	    } else {
	      result.length = length * 2;
	    }
	    for (var i = 0; i < length; ++i) {
	      Cartesian2.pack(array[i], result, i * 2);
	    }
	    return result;
	  };
	  Cartesian2.unpackArray = function(array, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    var length = array.length;
	    if (!defined(result)) {
	      result = new Array(length / 2);
	    } else {
	      result.length = length / 2;
	    }
	    for (var i = 0; i < length; i += 2) {
	      var index = i / 2;
	      result[index] = Cartesian2.unpack(array, i, result[index]);
	    }
	    return result;
	  };
	  Cartesian2.fromArray = Cartesian2.unpack;
	  Cartesian2.maximumComponent = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return Math.max(cartesian.x, cartesian.y);
	  };
	  Cartesian2.minimumComponent = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return Math.min(cartesian.x, cartesian.y);
	  };
	  Cartesian2.minimumByComponent = function(first, second, result) {
	    if (!defined(first)) {
	      throw new DeveloperError('first is required.');
	    }
	    if (!defined(second)) {
	      throw new DeveloperError('second is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    result.x = Math.min(first.x, second.x);
	    result.y = Math.min(first.y, second.y);
	    return result;
	  };
	  Cartesian2.maximumByComponent = function(first, second, result) {
	    if (!defined(first)) {
	      throw new DeveloperError('first is required.');
	    }
	    if (!defined(second)) {
	      throw new DeveloperError('second is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    result.x = Math.max(first.x, second.x);
	    result.y = Math.max(first.y, second.y);
	    return result;
	  };
	  Cartesian2.magnitudeSquared = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
	  };
	  Cartesian2.magnitude = function(cartesian) {
	    return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
	  };
	  var distanceScratch = new Cartesian2();
	  Cartesian2.distance = function(left, right) {
	    if (!defined(left) || !defined(right)) {
	      throw new DeveloperError('left and right are required.');
	    }
	    Cartesian2.subtract(left, right, distanceScratch);
	    return Cartesian2.magnitude(distanceScratch);
	  };
	  Cartesian2.distanceSquared = function(left, right) {
	    if (!defined(left) || !defined(right)) {
	      throw new DeveloperError('left and right are required.');
	    }
	    Cartesian2.subtract(left, right, distanceScratch);
	    return Cartesian2.magnitudeSquared(distanceScratch);
	  };
	  Cartesian2.normalize = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var magnitude = Cartesian2.magnitude(cartesian);
	    result.x = cartesian.x / magnitude;
	    result.y = cartesian.y / magnitude;
	    return result;
	  };
	  Cartesian2.dot = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    return left.x * right.x + left.y * right.y;
	  };
	  Cartesian2.multiplyComponents = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x * right.x;
	    result.y = left.y * right.y;
	    return result;
	  };
	  Cartesian2.add = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x + right.x;
	    result.y = left.y + right.y;
	    return result;
	  };
	  Cartesian2.subtract = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x - right.x;
	    result.y = left.y - right.y;
	    return result;
	  };
	  Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = cartesian.x * scalar;
	    result.y = cartesian.y * scalar;
	    return result;
	  };
	  Cartesian2.divideByScalar = function(cartesian, scalar, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = cartesian.x / scalar;
	    result.y = cartesian.y / scalar;
	    return result;
	  };
	  Cartesian2.negate = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = -cartesian.x;
	    result.y = -cartesian.y;
	    return result;
	  };
	  Cartesian2.abs = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = Math.abs(cartesian.x);
	    result.y = Math.abs(cartesian.y);
	    return result;
	  };
	  var lerpScratch = new Cartesian2();
	  Cartesian2.lerp = function(start, end, t, result) {
	    if (!defined(start)) {
	      throw new DeveloperError('start is required.');
	    }
	    if (!defined(end)) {
	      throw new DeveloperError('end is required.');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    Cartesian2.multiplyByScalar(end, t, lerpScratch);
	    result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);
	    return Cartesian2.add(lerpScratch, result, result);
	  };
	  var angleBetweenScratch = new Cartesian2();
	  var angleBetweenScratch2 = new Cartesian2();
	  Cartesian2.angleBetween = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    Cartesian2.normalize(left, angleBetweenScratch);
	    Cartesian2.normalize(right, angleBetweenScratch2);
	    return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));
	  };
	  var mostOrthogonalAxisScratch = new Cartesian2();
	  Cartesian2.mostOrthogonalAxis = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);
	    Cartesian2.abs(f, f);
	    if (f.x <= f.y) {
	      result = Cartesian2.clone(Cartesian2.UNIT_X, result);
	    } else {
	      result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
	    }
	    return result;
	  };
	  Cartesian2.equals = function(left, right) {
	    return (left === right) || ((defined(left)) && (defined(right)) && (left.x === right.x) && (left.y === right.y));
	  };
	  Cartesian2.equalsArray = function(cartesian, array, offset) {
	    return cartesian.x === array[offset] && cartesian.y === array[offset + 1];
	  };
	  Cartesian2.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
	    return (left === right) || (defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon));
	  };
	  Cartesian2.ZERO = freezeObject(new Cartesian2(0.0, 0.0));
	  Cartesian2.UNIT_X = freezeObject(new Cartesian2(1.0, 0.0));
	  Cartesian2.UNIT_Y = freezeObject(new Cartesian2(0.0, 1.0));
	  Cartesian2.prototype.clone = function(result) {
	    return Cartesian2.clone(this, result);
	  };
	  Cartesian2.prototype.equals = function(right) {
	    return Cartesian2.equals(this, right);
	  };
	  Cartesian2.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
	    return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
	  };
	  Cartesian2.prototype.toString = function() {
	    return '(' + this.x + ', ' + this.y + ')';
	  };
	  return Cartesian2;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("4d", ["4e", "4c", "23", "1a", "4f", "1f", "24", "50", "51", "38", "52", "53"], function(when, binarySearch, defaultValue, defined, EarthOrientationParametersSample, freezeObject, JulianDate, LeapSecond, loadJson, RuntimeError, TimeConstants, TimeStandard) {
	  'use strict';
	  function EarthOrientationParameters(options) {
	    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	    this._dates = undefined;
	    this._samples = undefined;
	    this._dateColumn = -1;
	    this._xPoleWanderRadiansColumn = -1;
	    this._yPoleWanderRadiansColumn = -1;
	    this._ut1MinusUtcSecondsColumn = -1;
	    this._xCelestialPoleOffsetRadiansColumn = -1;
	    this._yCelestialPoleOffsetRadiansColumn = -1;
	    this._taiMinusUtcSecondsColumn = -1;
	    this._columnCount = 0;
	    this._lastIndex = -1;
	    this._downloadPromise = undefined;
	    this._dataError = undefined;
	    this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);
	    if (defined(options.data)) {
	      onDataReady(this, options.data);
	    } else if (defined(options.url)) {
	      var that = this;
	      this._downloadPromise = when(loadJson(options.url), function(eopData) {
	        onDataReady(that, eopData);
	      }, function() {
	        that._dataError = 'An error occurred while retrieving the EOP data from the URL ' + options.url + '.';
	      });
	    } else {
	      onDataReady(this, {
	        'columnNames': ['dateIso8601', 'modifiedJulianDateUtc', 'xPoleWanderRadians', 'yPoleWanderRadians', 'ut1MinusUtcSeconds', 'lengthOfDayCorrectionSeconds', 'xCelestialPoleOffsetRadians', 'yCelestialPoleOffsetRadians', 'taiMinusUtcSeconds'],
	        'samples': []
	      });
	    }
	  }
	  EarthOrientationParameters.NONE = freezeObject({
	    getPromiseToLoad: function() {
	      return when();
	    },
	    compute: function(date, result) {
	      if (!defined(result)) {
	        result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
	      } else {
	        result.xPoleWander = 0.0;
	        result.yPoleWander = 0.0;
	        result.xPoleOffset = 0.0;
	        result.yPoleOffset = 0.0;
	        result.ut1MinusUtc = 0.0;
	      }
	      return result;
	    }
	  });
	  EarthOrientationParameters.prototype.getPromiseToLoad = function() {
	    return when(this._downloadPromise);
	  };
	  EarthOrientationParameters.prototype.compute = function(date, result) {
	    if (!defined(this._samples)) {
	      if (defined(this._dataError)) {
	        throw new RuntimeError(this._dataError);
	      }
	      return undefined;
	    }
	    if (!defined(result)) {
	      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
	    }
	    if (this._samples.length === 0) {
	      result.xPoleWander = 0.0;
	      result.yPoleWander = 0.0;
	      result.xPoleOffset = 0.0;
	      result.yPoleOffset = 0.0;
	      result.ut1MinusUtc = 0.0;
	      return result;
	    }
	    var dates = this._dates;
	    var lastIndex = this._lastIndex;
	    var before = 0;
	    var after = 0;
	    if (defined(lastIndex)) {
	      var previousIndexDate = dates[lastIndex];
	      var nextIndexDate = dates[lastIndex + 1];
	      var isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);
	      var isAfterLastSample = !defined(nextIndexDate);
	      var isBeforeNext = isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);
	      if (isAfterPrevious && isBeforeNext) {
	        before = lastIndex;
	        if (!isAfterLastSample && nextIndexDate.equals(date)) {
	          ++before;
	        }
	        after = before + 1;
	        interpolate(this, dates, this._samples, date, before, after, result);
	        return result;
	      }
	    }
	    var index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);
	    if (index >= 0) {
	      if (index < dates.length - 1 && dates[index + 1].equals(date)) {
	        ++index;
	      }
	      before = index;
	      after = index;
	    } else {
	      after = ~index;
	      before = after - 1;
	      if (before < 0) {
	        before = 0;
	      }
	    }
	    this._lastIndex = before;
	    interpolate(this, dates, this._samples, date, before, after, result);
	    return result;
	  };
	  function compareLeapSecondDates(leapSecond, dateToFind) {
	    return JulianDate.compare(leapSecond.julianDate, dateToFind);
	  }
	  function onDataReady(eop, eopData) {
	    if (!defined(eopData.columnNames)) {
	      eop._dataError = 'Error in loaded EOP data: The columnNames property is required.';
	      return;
	    }
	    if (!defined(eopData.samples)) {
	      eop._dataError = 'Error in loaded EOP data: The samples property is required.';
	      return;
	    }
	    var dateColumn = eopData.columnNames.indexOf('modifiedJulianDateUtc');
	    var xPoleWanderRadiansColumn = eopData.columnNames.indexOf('xPoleWanderRadians');
	    var yPoleWanderRadiansColumn = eopData.columnNames.indexOf('yPoleWanderRadians');
	    var ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf('ut1MinusUtcSeconds');
	    var xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('xCelestialPoleOffsetRadians');
	    var yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('yCelestialPoleOffsetRadians');
	    var taiMinusUtcSecondsColumn = eopData.columnNames.indexOf('taiMinusUtcSeconds');
	    if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {
	      eop._dataError = 'Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns';
	      return;
	    }
	    var samples = eop._samples = eopData.samples;
	    var dates = eop._dates = [];
	    eop._dateColumn = dateColumn;
	    eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;
	    eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;
	    eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;
	    eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;
	    eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;
	    eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;
	    eop._columnCount = eopData.columnNames.length;
	    eop._lastIndex = undefined;
	    var lastTaiMinusUtc;
	    var addNewLeapSeconds = eop._addNewLeapSeconds;
	    for (var i = 0,
	        len = samples.length; i < len; i += eop._columnCount) {
	      var mjd = samples[i + dateColumn];
	      var taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];
	      var day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;
	      var date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);
	      dates.push(date);
	      if (addNewLeapSeconds) {
	        if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {
	          var leapSeconds = JulianDate.leapSeconds;
	          var leapSecondIndex = binarySearch(leapSeconds, date, compareLeapSecondDates);
	          if (leapSecondIndex < 0) {
	            var leapSecond = new LeapSecond(date, taiMinusUtc);
	            leapSeconds.splice(~leapSecondIndex, 0, leapSecond);
	          }
	        }
	        lastTaiMinusUtc = taiMinusUtc;
	      }
	    }
	  }
	  function fillResultFromIndex(eop, samples, index, columnCount, result) {
	    var start = index * columnCount;
	    result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];
	    result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];
	    result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];
	    result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];
	    result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];
	  }
	  function linearInterp(dx, y1, y2) {
	    return y1 + dx * (y2 - y1);
	  }
	  function interpolate(eop, dates, samples, date, before, after, result) {
	    var columnCount = eop._columnCount;
	    if (after > dates.length - 1) {
	      result.xPoleWander = 0;
	      result.yPoleWander = 0;
	      result.xPoleOffset = 0;
	      result.yPoleOffset = 0;
	      result.ut1MinusUtc = 0;
	      return result;
	    }
	    var beforeDate = dates[before];
	    var afterDate = dates[after];
	    if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {
	      fillResultFromIndex(eop, samples, before, columnCount, result);
	      return result;
	    } else if (date.equals(afterDate)) {
	      fillResultFromIndex(eop, samples, after, columnCount, result);
	      return result;
	    }
	    var factor = JulianDate.secondsDifference(date, beforeDate) / JulianDate.secondsDifference(afterDate, beforeDate);
	    var startBefore = before * columnCount;
	    var startAfter = after * columnCount;
	    var beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];
	    var afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];
	    var offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;
	    if (offsetDifference > 0.5 || offsetDifference < -0.5) {
	      var beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];
	      var afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];
	      if (beforeTaiMinusUtc !== afterTaiMinusUtc) {
	        if (afterDate.equals(date)) {
	          beforeUt1MinusUtc = afterUt1MinusUtc;
	        } else {
	          afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;
	        }
	      }
	    }
	    result.xPoleWander = linearInterp(factor, samples[startBefore + eop._xPoleWanderRadiansColumn], samples[startAfter + eop._xPoleWanderRadiansColumn]);
	    result.yPoleWander = linearInterp(factor, samples[startBefore + eop._yPoleWanderRadiansColumn], samples[startAfter + eop._yPoleWanderRadiansColumn]);
	    result.xPoleOffset = linearInterp(factor, samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]);
	    result.yPoleOffset = linearInterp(factor, samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]);
	    result.ut1MinusUtc = linearInterp(factor, beforeUt1MinusUtc, afterUt1MinusUtc);
	    return result;
	  }
	  return EarthOrientationParameters;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("4f", [], function() {
	  'use strict';
	  function EarthOrientationParametersSample(xPoleWander, yPoleWander, xPoleOffset, yPoleOffset, ut1MinusUtc) {
	    this.xPoleWander = xPoleWander;
	    this.yPoleWander = yPoleWander;
	    this.xPoleOffset = xPoleOffset;
	    this.yPoleOffset = yPoleOffset;
	    this.ut1MinusUtc = ut1MinusUtc;
	  }
	  return EarthOrientationParametersSample;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("54", ["55", "23", "1a", "1c"], function(Uri, defaultValue, defined, DeveloperError) {
	  'use strict';
	  function getAbsoluteUri(relative, base) {
	    if (!defined(relative)) {
	      throw new DeveloperError('relative uri is required.');
	    }
	    base = defaultValue(base, document.location.href);
	    var baseUri = new Uri(base);
	    var relativeUri = new Uri(relative);
	    return relativeUri.resolve(baseUri).toString();
	  }
	  return getAbsoluteUri;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("55", [], function() {
	  function URI(uri) {
	    if (uri instanceof URI) {
	      this.scheme = uri.scheme;
	      this.authority = uri.authority;
	      this.path = uri.path;
	      this.query = uri.query;
	      this.fragment = uri.fragment;
	    } else if (uri) {
	      var c = parseRegex.exec(uri);
	      this.scheme = c[1];
	      this.authority = c[2];
	      this.path = c[3];
	      this.query = c[4];
	      this.fragment = c[5];
	    }
	  }
	  URI.prototype.scheme = null;
	  URI.prototype.authority = null;
	  URI.prototype.path = '';
	  URI.prototype.query = null;
	  URI.prototype.fragment = null;
	  var parseRegex = new RegExp('^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$');
	  URI.prototype.getScheme = function() {
	    return this.scheme;
	  };
	  URI.prototype.getAuthority = function() {
	    return this.authority;
	  };
	  URI.prototype.getPath = function() {
	    return this.path;
	  };
	  URI.prototype.getQuery = function() {
	    return this.query;
	  };
	  URI.prototype.getFragment = function() {
	    return this.fragment;
	  };
	  URI.prototype.isAbsolute = function() {
	    return !!this.scheme && !this.fragment;
	  };
	  URI.prototype.isSameDocumentAs = function(uri) {
	    return uri.scheme == this.scheme && uri.authority == this.authority && uri.path == this.path && uri.query == this.query;
	  };
	  URI.prototype.equals = function(uri) {
	    return this.isSameDocumentAs(uri) && uri.fragment == this.fragment;
	  };
	  URI.prototype.normalize = function() {
	    this.removeDotSegments();
	    if (this.scheme)
	      this.scheme = this.scheme.toLowerCase();
	    if (this.authority)
	      this.authority = this.authority.replace(authorityRegex, replaceAuthority).replace(caseRegex, replaceCase);
	    if (this.path)
	      this.path = this.path.replace(caseRegex, replaceCase);
	    if (this.query)
	      this.query = this.query.replace(caseRegex, replaceCase);
	    if (this.fragment)
	      this.fragment = this.fragment.replace(caseRegex, replaceCase);
	  };
	  var caseRegex = /%[0-9a-z]{2}/gi;
	  var percentRegex = /[a-zA-Z0-9\-\._~]/;
	  var authorityRegex = /(.*@)?([^@:]*)(:.*)?/;
	  function replaceCase(str) {
	    var dec = unescape(str);
	    return percentRegex.test(dec) ? dec : str.toUpperCase();
	  }
	  function replaceAuthority(str, p1, p2, p3) {
	    return (p1 || '') + p2.toLowerCase() + (p3 || '');
	  }
	  URI.prototype.resolve = function(baseURI) {
	    var uri = new URI();
	    if (this.scheme) {
	      uri.scheme = this.scheme;
	      uri.authority = this.authority;
	      uri.path = this.path;
	      uri.query = this.query;
	    } else {
	      uri.scheme = baseURI.scheme;
	      if (this.authority) {
	        uri.authority = this.authority;
	        uri.path = this.path;
	        uri.query = this.query;
	      } else {
	        uri.authority = baseURI.authority;
	        if (this.path == '') {
	          uri.path = baseURI.path;
	          uri.query = this.query || baseURI.query;
	        } else {
	          if (this.path.charAt(0) == '/') {
	            uri.path = this.path;
	            uri.removeDotSegments();
	          } else {
	            if (baseURI.authority && baseURI.path == '') {
	              uri.path = '/' + this.path;
	            } else {
	              uri.path = baseURI.path.substring(0, baseURI.path.lastIndexOf('/') + 1) + this.path;
	            }
	            uri.removeDotSegments();
	          }
	          uri.query = this.query;
	        }
	      }
	    }
	    uri.fragment = this.fragment;
	    return uri;
	  };
	  URI.prototype.removeDotSegments = function() {
	    var input = this.path.split('/'),
	        output = [],
	        segment,
	        absPath = input[0] == '';
	    if (absPath)
	      input.shift();
	    var sFirst = input[0] == '' ? input.shift() : null;
	    while (input.length) {
	      segment = input.shift();
	      if (segment == '..') {
	        output.pop();
	      } else if (segment != '.') {
	        output.push(segment);
	      }
	    }
	    if (segment == '.' || segment == '..')
	      output.push('');
	    if (absPath)
	      output.unshift('');
	    this.path = output.join('/');
	  };
	  URI.prototype.toString = function() {
	    var result = '';
	    if (this.scheme)
	      result += this.scheme + ':';
	    if (this.authority)
	      result += '//' + this.authority;
	    result += this.path;
	    if (this.query)
	      result += '?' + this.query;
	    if (this.fragment)
	      result += '#' + this.fragment;
	    return result;
	  };
	  return URI;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("56", ["55", "23", "1a", "1c"], function(Uri, defaultValue, defined, DeveloperError) {
	  'use strict';
	  function joinUrls(first, second, appendSlash) {
	    if (!defined(first)) {
	      throw new DeveloperError('first is required');
	    }
	    if (!defined(second)) {
	      throw new DeveloperError('second is required');
	    }
	    appendSlash = defaultValue(appendSlash, true);
	    if (!(first instanceof Uri)) {
	      first = new Uri(first);
	    }
	    if (!(second instanceof Uri)) {
	      second = new Uri(second);
	    }
	    if (defined(second.authority) && !defined(second.scheme)) {
	      if (typeof document !== 'undefined' && defined(document.location) && defined(document.location.href)) {
	        second.scheme = new Uri(document.location.href).scheme;
	      } else {
	        second.scheme = first.scheme;
	      }
	    }
	    var baseUri = first;
	    if (second.isAbsolute()) {
	      baseUri = second;
	    }
	    var url = '';
	    if (defined(baseUri.scheme)) {
	      url += baseUri.scheme + ':';
	    }
	    if (defined(baseUri.authority)) {
	      url += '//' + baseUri.authority;
	      if (baseUri.path !== '' && baseUri.path !== '/') {
	        url = url.replace(/\/?$/, '/');
	        baseUri.path = baseUri.path.replace(/^\/?/g, '');
	      }
	    }
	    if (baseUri === first) {
	      if (appendSlash) {
	        url += first.path.replace(/\/?$/, '/') + second.path.replace(/^\/?/g, '');
	      } else {
	        url += first.path + second.path;
	      }
	    } else {
	      url += second.path;
	    }
	    var hasFirstQuery = defined(first.query);
	    var hasSecondQuery = defined(second.query);
	    if (hasFirstQuery && hasSecondQuery) {
	      url += '?' + first.query + '&' + second.query;
	    } else if (hasFirstQuery && !hasSecondQuery) {
	      url += '?' + first.query;
	    } else if (!hasFirstQuery && hasSecondQuery) {
	      url += '?' + second.query;
	    }
	    var hasSecondFragment = defined(second.fragment);
	    if (defined(first.fragment) && !hasSecondFragment) {
	      url += '#' + first.fragment;
	    } else if (hasSecondFragment) {
	      url += '#' + second.fragment;
	    }
	    return url;
	  }
	  return joinUrls;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("57", ["55", "1a", "1c", "54", "56", "require"], function(Uri, defined, DeveloperError, getAbsoluteUri, joinUrls, _dereq_) {
	  'use strict';
	  var cesiumScriptRegex = /((?:.*\/)|^)cesium[\w-]*\.js(?:\W|$)/i;
	  function getBaseUrlFromCesiumScript() {
	    var scripts = document.getElementsByTagName('script');
	    for (var i = 0,
	        len = scripts.length; i < len; ++i) {
	      var src = scripts[i].getAttribute('src');
	      var result = cesiumScriptRegex.exec(src);
	      if (result !== null) {
	        return result[1];
	      }
	    }
	    return undefined;
	  }
	  var baseUrl;
	  function getCesiumBaseUrl() {
	    if (defined(baseUrl)) {
	      return baseUrl;
	    }
	    var baseUrlString;
	    if (typeof CESIUM_BASE_URL !== 'undefined') {
	      baseUrlString = CESIUM_BASE_URL;
	    } else {
	      baseUrlString = getBaseUrlFromCesiumScript();
	    }
	    if (!defined(baseUrlString)) {
	      throw new DeveloperError('Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.');
	    }
	    baseUrl = new Uri(getAbsoluteUri(baseUrlString));
	    return baseUrl;
	  }
	  function buildModuleUrlFromRequireToUrl(moduleID) {
	    return _dereq_.toUrl('../' + moduleID);
	  }
	  function buildModuleUrlFromBaseUrl(moduleID) {
	    return joinUrls(getCesiumBaseUrl(), moduleID);
	  }
	  var implementation;
	  var a;
	  function buildModuleUrl(moduleID) {
	    if (!defined(implementation)) {
	      if (defined(_dereq_.toUrl)) {
	        implementation = buildModuleUrlFromRequireToUrl;
	      } else {
	        implementation = buildModuleUrlFromBaseUrl;
	      }
	    }
	    if (!defined(a)) {
	      a = document.createElement('a');
	    }
	    var url = implementation(moduleID);
	    a.href = url;
	    a.href = a.href;
	    return a.href;
	  }
	  buildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;
	  buildModuleUrl.setBaseUrl = function(value) {
	    baseUrl = new Uri(value).resolve(new Uri(document.location.href));
	  };
	  return buildModuleUrl;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("58", ["23"], function(defaultValue) {
	  'use strict';
	  function clone(object, deep) {
	    if (object === null || typeof object !== 'object') {
	      return object;
	    }
	    deep = defaultValue(deep, false);
	    var result = new object.constructor();
	    for (var propertyName in object) {
	      if (object.hasOwnProperty(propertyName)) {
	        var value = object[propertyName];
	        if (deep) {
	          value = clone(value, deep);
	        }
	        result[propertyName] = value;
	      }
	    }
	    return result;
	  }
	  return clone;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	(function(define) {
	  'use strict';
	  define("4e", [], function() {
	    var reduceArray,
	        slice,
	        undef;
	    when.defer = defer;
	    when.resolve = resolve;
	    when.reject = reject;
	    when.join = join;
	    when.all = all;
	    when.map = map;
	    when.reduce = reduce;
	    when.any = any;
	    when.some = some;
	    when.chain = chain;
	    when.isPromise = isPromise;
	    function when(promiseOrValue, onFulfilled, onRejected, onProgress) {
	      return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);
	    }
	    function resolve(promiseOrValue) {
	      var promise,
	          deferred;
	      if (promiseOrValue instanceof Promise) {
	        promise = promiseOrValue;
	      } else {
	        if (isPromise(promiseOrValue)) {
	          deferred = defer();
	          promiseOrValue.then(function(value) {
	            deferred.resolve(value);
	          }, function(reason) {
	            deferred.reject(reason);
	          }, function(update) {
	            deferred.progress(update);
	          });
	          promise = deferred.promise;
	        } else {
	          promise = fulfilled(promiseOrValue);
	        }
	      }
	      return promise;
	    }
	    function reject(promiseOrValue) {
	      return when(promiseOrValue, rejected);
	    }
	    function Promise(then) {
	      this.then = then;
	    }
	    Promise.prototype = {
	      always: function(onFulfilledOrRejected, onProgress) {
	        return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);
	      },
	      otherwise: function(onRejected) {
	        return this.then(undef, onRejected);
	      },
	      yield: function(value) {
	        return this.then(function() {
	          return value;
	        });
	      },
	      spread: function(onFulfilled) {
	        return this.then(function(array) {
	          return all(array, function(array) {
	            return onFulfilled.apply(undef, array);
	          });
	        });
	      }
	    };
	    function fulfilled(value) {
	      var p = new Promise(function(onFulfilled) {
	        try {
	          return resolve(onFulfilled ? onFulfilled(value) : value);
	        } catch (e) {
	          return rejected(e);
	        }
	      });
	      return p;
	    }
	    function rejected(reason) {
	      var p = new Promise(function(_, onRejected) {
	        try {
	          return onRejected ? resolve(onRejected(reason)) : rejected(reason);
	        } catch (e) {
	          return rejected(e);
	        }
	      });
	      return p;
	    }
	    function defer() {
	      var deferred,
	          promise,
	          handlers,
	          progressHandlers,
	          _then,
	          _progress,
	          _resolve;
	      promise = new Promise(then);
	      deferred = {
	        then: then,
	        resolve: promiseResolve,
	        reject: promiseReject,
	        progress: promiseProgress,
	        promise: promise,
	        resolver: {
	          resolve: promiseResolve,
	          reject: promiseReject,
	          progress: promiseProgress
	        }
	      };
	      handlers = [];
	      progressHandlers = [];
	      _then = function(onFulfilled, onRejected, onProgress) {
	        var deferred,
	            progressHandler;
	        deferred = defer();
	        progressHandler = typeof onProgress === 'function' ? function(update) {
	          try {
	            deferred.progress(onProgress(update));
	          } catch (e) {
	            deferred.progress(e);
	          }
	        } : function(update) {
	          deferred.progress(update);
	        };
	        handlers.push(function(promise) {
	          promise.then(onFulfilled, onRejected).then(deferred.resolve, deferred.reject, progressHandler);
	        });
	        progressHandlers.push(progressHandler);
	        return deferred.promise;
	      };
	      _progress = function(update) {
	        processQueue(progressHandlers, update);
	        return update;
	      };
	      _resolve = function(value) {
	        value = resolve(value);
	        _then = value.then;
	        _resolve = resolve;
	        _progress = noop;
	        processQueue(handlers, value);
	        progressHandlers = handlers = undef;
	        return value;
	      };
	      return deferred;
	      function then(onFulfilled, onRejected, onProgress) {
	        return _then(onFulfilled, onRejected, onProgress);
	      }
	      function promiseResolve(val) {
	        return _resolve(val);
	      }
	      function promiseReject(err) {
	        return _resolve(rejected(err));
	      }
	      function promiseProgress(update) {
	        return _progress(update);
	      }
	    }
	    function isPromise(promiseOrValue) {
	      return promiseOrValue && typeof promiseOrValue.then === 'function';
	    }
	    function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {
	      checkCallbacks(2, arguments);
	      return when(promisesOrValues, function(promisesOrValues) {
	        var toResolve,
	            toReject,
	            values,
	            reasons,
	            deferred,
	            fulfillOne,
	            rejectOne,
	            progress,
	            len,
	            i;
	        len = promisesOrValues.length >>> 0;
	        toResolve = Math.max(0, Math.min(howMany, len));
	        values = [];
	        toReject = (len - toResolve) + 1;
	        reasons = [];
	        deferred = defer();
	        if (!toResolve) {
	          deferred.resolve(values);
	        } else {
	          progress = deferred.progress;
	          rejectOne = function(reason) {
	            reasons.push(reason);
	            if (!--toReject) {
	              fulfillOne = rejectOne = noop;
	              deferred.reject(reasons);
	            }
	          };
	          fulfillOne = function(val) {
	            values.push(val);
	            if (!--toResolve) {
	              fulfillOne = rejectOne = noop;
	              deferred.resolve(values);
	            }
	          };
	          for (i = 0; i < len; ++i) {
	            if (i in promisesOrValues) {
	              when(promisesOrValues[i], fulfiller, rejecter, progress);
	            }
	          }
	        }
	        return deferred.then(onFulfilled, onRejected, onProgress);
	        function rejecter(reason) {
	          rejectOne(reason);
	        }
	        function fulfiller(val) {
	          fulfillOne(val);
	        }
	      });
	    }
	    function any(promisesOrValues, onFulfilled, onRejected, onProgress) {
	      function unwrapSingleResult(val) {
	        return onFulfilled ? onFulfilled(val[0]) : val[0];
	      }
	      return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);
	    }
	    function all(promisesOrValues, onFulfilled, onRejected, onProgress) {
	      checkCallbacks(1, arguments);
	      return map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);
	    }
	    function join() {
	      return map(arguments, identity);
	    }
	    function map(promise, mapFunc) {
	      return when(promise, function(array) {
	        var results,
	            len,
	            toResolve,
	            resolve,
	            i,
	            d;
	        toResolve = len = array.length >>> 0;
	        results = [];
	        d = defer();
	        if (!toResolve) {
	          d.resolve(results);
	        } else {
	          resolve = function resolveOne(item, i) {
	            when(item, mapFunc).then(function(mapped) {
	              results[i] = mapped;
	              if (!--toResolve) {
	                d.resolve(results);
	              }
	            }, d.reject);
	          };
	          for (i = 0; i < len; i++) {
	            if (i in array) {
	              resolve(array[i], i);
	            } else {
	              --toResolve;
	            }
	          }
	        }
	        return d.promise;
	      });
	    }
	    function reduce(promise, reduceFunc) {
	      var args = slice.call(arguments, 1);
	      return when(promise, function(array) {
	        var total;
	        total = array.length;
	        args[0] = function(current, val, i) {
	          return when(current, function(c) {
	            return when(val, function(value) {
	              return reduceFunc(c, value, i, total);
	            });
	          });
	        };
	        return reduceArray.apply(array, args);
	      });
	    }
	    function chain(promiseOrValue, resolver, resolveValue) {
	      var useResolveValue = arguments.length > 2;
	      return when(promiseOrValue, function(val) {
	        val = useResolveValue ? resolveValue : val;
	        resolver.resolve(val);
	        return val;
	      }, function(reason) {
	        resolver.reject(reason);
	        return rejected(reason);
	      }, resolver.progress);
	    }
	    function processQueue(queue, value) {
	      var handler,
	          i = 0;
	      while (handler = queue[i++]) {
	        handler(value);
	      }
	    }
	    function checkCallbacks(start, arrayOfCallbacks) {
	      var arg,
	          i = arrayOfCallbacks.length;
	      while (i > start) {
	        arg = arrayOfCallbacks[--i];
	        if (arg != null && typeof arg != 'function') {
	          throw new Error('arg ' + i + ' must be a function');
	        }
	      }
	    }
	    function noop() {}
	    slice = [].slice;
	    reduceArray = [].reduce || function(reduceFunc) {
	      var arr,
	          args,
	          reduced,
	          len,
	          i;
	      i = 0;
	      arr = Object(this);
	      len = arr.length >>> 0;
	      args = arguments;
	      if (args.length <= 1) {
	        for (; ; ) {
	          if (i in arr) {
	            reduced = arr[i++];
	            break;
	          }
	          if (++i >= len) {
	            throw new TypeError();
	          }
	        }
	      } else {
	        reduced = args[1];
	      }
	      for (; i < len; ++i) {
	        if (i in arr) {
	          reduced = reduceFunc(reduced, arr[i], i, arr);
	        }
	      }
	      return reduced;
	    };
	    function identity(x) {
	      return x;
	    }
	    return when;
	  });
	})(typeof define == 'function' && define.amd ? define : function(factory) {
	  typeof exports === 'object' ? (module.exports = factory()) : (this.when = factory());
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("59", [], function() {
	  'use strict';
	  function parseResponseHeaders(headerString) {
	    var headers = {};
	    if (!headerString) {
	      return headers;
	    }
	    var headerPairs = headerString.split('\u000d\u000a');
	    for (var i = 0; i < headerPairs.length; ++i) {
	      var headerPair = headerPairs[i];
	      var index = headerPair.indexOf('\u003a\u0020');
	      if (index > 0) {
	        var key = headerPair.substring(0, index);
	        var val = headerPair.substring(index + 2);
	        headers[key] = val;
	      }
	    }
	    return headers;
	  }
	  return parseResponseHeaders;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("5a", ["1a", "59"], function(defined, parseResponseHeaders) {
	  'use strict';
	  function RequestErrorEvent(statusCode, response, responseHeaders) {
	    this.statusCode = statusCode;
	    this.response = response;
	    this.responseHeaders = responseHeaders;
	    if (typeof this.responseHeaders === 'string') {
	      this.responseHeaders = parseResponseHeaders(this.responseHeaders);
	    }
	  }
	  RequestErrorEvent.prototype.toString = function() {
	    var str = 'Request has failed.';
	    if (defined(this.statusCode)) {
	      str += ' Status Code: ' + this.statusCode;
	    }
	    return str;
	  };
	  return RequestErrorEvent;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("5b", ["4e", "23", "1a", "1c", "5a", "38"], function(when, defaultValue, defined, DeveloperError, RequestErrorEvent, RuntimeError) {
	  'use strict';
	  function loadWithXhr(options) {
	    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	    if (!defined(options.url)) {
	      throw new DeveloperError('options.url is required.');
	    }
	    var responseType = options.responseType;
	    var method = defaultValue(options.method, 'GET');
	    var data = options.data;
	    var headers = options.headers;
	    var overrideMimeType = options.overrideMimeType;
	    return when(options.url, function(url) {
	      var deferred = when.defer();
	      loadWithXhr.load(url, responseType, method, data, headers, deferred, overrideMimeType);
	      return deferred.promise;
	    });
	  }
	  var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
	  function decodeDataUriText(isBase64, data) {
	    var result = decodeURIComponent(data);
	    if (isBase64) {
	      return atob(result);
	    }
	    return result;
	  }
	  function decodeDataUriArrayBuffer(isBase64, data) {
	    var byteString = decodeDataUriText(isBase64, data);
	    var buffer = new ArrayBuffer(byteString.length);
	    var view = new Uint8Array(buffer);
	    for (var i = 0; i < byteString.length; i++) {
	      view[i] = byteString.charCodeAt(i);
	    }
	    return buffer;
	  }
	  function decodeDataUri(dataUriRegexResult, responseType) {
	    responseType = defaultValue(responseType, '');
	    var mimeType = dataUriRegexResult[1];
	    var isBase64 = !!dataUriRegexResult[2];
	    var data = dataUriRegexResult[3];
	    switch (responseType) {
	      case '':
	      case 'text':
	        return decodeDataUriText(isBase64, data);
	      case 'arraybuffer':
	        return decodeDataUriArrayBuffer(isBase64, data);
	      case 'blob':
	        var buffer = decodeDataUriArrayBuffer(isBase64, data);
	        return new Blob([buffer], {type: mimeType});
	      case 'document':
	        var parser = new DOMParser();
	        return parser.parseFromString(decodeDataUriText(isBase64, data), mimeType);
	      case 'json':
	        return JSON.parse(decodeDataUriText(isBase64, data));
	      default:
	        throw new DeveloperError('Unhandled responseType: ' + responseType);
	    }
	  }
	  loadWithXhr.load = function(url, responseType, method, data, headers, deferred, overrideMimeType) {
	    var dataUriRegexResult = dataUriRegex.exec(url);
	    if (dataUriRegexResult !== null) {
	      deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));
	      return;
	    }
	    var xhr = new XMLHttpRequest();
	    if (defined(overrideMimeType) && defined(xhr.overrideMimeType)) {
	      xhr.overrideMimeType(overrideMimeType);
	    }
	    xhr.open(method, url, true);
	    if (defined(headers)) {
	      for (var key in headers) {
	        if (headers.hasOwnProperty(key)) {
	          xhr.setRequestHeader(key, headers[key]);
	        }
	      }
	    }
	    if (defined(responseType)) {
	      xhr.responseType = responseType;
	    }
	    xhr.onload = function() {
	      if (xhr.status >= 200 && xhr.status < 300) {
	        if (defined(xhr.response)) {
	          deferred.resolve(xhr.response);
	        } else {
	          if (defined(xhr.responseXML) && xhr.responseXML.hasChildNodes()) {
	            deferred.resolve(xhr.responseXML);
	          } else if (defined(xhr.responseText)) {
	            deferred.resolve(xhr.responseText);
	          } else {
	            deferred.reject(new RuntimeError('unknown XMLHttpRequest response type.'));
	          }
	        }
	      } else {
	        deferred.reject(new RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()));
	      }
	    };
	    xhr.onerror = function(e) {
	      deferred.reject(new RequestErrorEvent());
	    };
	    xhr.send(data);
	  };
	  loadWithXhr.defaultLoad = loadWithXhr.load;
	  return loadWithXhr;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("5c", ["5b"], function(loadWithXhr) {
	  'use strict';
	  function loadText(url, headers) {
	    return loadWithXhr({
	      url: url,
	      headers: headers
	    });
	  }
	  return loadText;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("51", ["58", "1a", "1c", "5c"], function(clone, defined, DeveloperError, loadText) {
	  'use strict';
	  var defaultHeaders = {Accept: 'application/json,*/*;q=0.01'};
	  function loadJson(url, headers) {
	    if (!defined(url)) {
	      throw new DeveloperError('url is required.');
	    }
	    if (!defined(headers)) {
	      headers = defaultHeaders;
	    } else if (!defined(headers.Accept)) {
	      headers = clone(headers);
	      headers.Accept = defaultHeaders.Accept;
	    }
	    return loadText(url, headers).then(function(value) {
	      return JSON.parse(value);
	    });
	  }
	  return loadJson;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("5d", ["4e", "57", "23", "1a", "5e", "24", "51", "53"], function(when, buildModuleUrl, defaultValue, defined, Iau2006XysSample, JulianDate, loadJson, TimeStandard) {
	  'use strict';
	  function Iau2006XysData(options) {
	    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	    this._xysFileUrlTemplate = options.xysFileUrlTemplate;
	    this._interpolationOrder = defaultValue(options.interpolationOrder, 9);
	    this._sampleZeroJulianEphemerisDate = defaultValue(options.sampleZeroJulianEphemerisDate, 2442396.5);
	    this._sampleZeroDateTT = new JulianDate(this._sampleZeroJulianEphemerisDate, 0.0, TimeStandard.TAI);
	    this._stepSizeDays = defaultValue(options.stepSizeDays, 1.0);
	    this._samplesPerXysFile = defaultValue(options.samplesPerXysFile, 1000);
	    this._totalSamples = defaultValue(options.totalSamples, 27426);
	    this._samples = new Array(this._totalSamples * 3);
	    this._chunkDownloadsInProgress = [];
	    var order = this._interpolationOrder;
	    var denom = this._denominators = new Array(order + 1);
	    var xTable = this._xTable = new Array(order + 1);
	    var stepN = Math.pow(this._stepSizeDays, order);
	    for (var i = 0; i <= order; ++i) {
	      denom[i] = stepN;
	      xTable[i] = i * this._stepSizeDays;
	      for (var j = 0; j <= order; ++j) {
	        if (j !== i) {
	          denom[i] *= (i - j);
	        }
	      }
	      denom[i] = 1.0 / denom[i];
	    }
	    this._work = new Array(order + 1);
	    this._coef = new Array(order + 1);
	  }
	  var julianDateScratch = new JulianDate(0, 0.0, TimeStandard.TAI);
	  function getDaysSinceEpoch(xys, dayTT, secondTT) {
	    var dateTT = julianDateScratch;
	    dateTT.dayNumber = dayTT;
	    dateTT.secondsOfDay = secondTT;
	    return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);
	  }
	  Iau2006XysData.prototype.preload = function(startDayTT, startSecondTT, stopDayTT, stopSecondTT) {
	    var startDaysSinceEpoch = getDaysSinceEpoch(this, startDayTT, startSecondTT);
	    var stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);
	    var startIndex = (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) | 0;
	    if (startIndex < 0) {
	      startIndex = 0;
	    }
	    var stopIndex = (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) | 0 + this._interpolationOrder;
	    if (stopIndex >= this._totalSamples) {
	      stopIndex = this._totalSamples - 1;
	    }
	    var startChunk = (startIndex / this._samplesPerXysFile) | 0;
	    var stopChunk = (stopIndex / this._samplesPerXysFile) | 0;
	    var promises = [];
	    for (var i = startChunk; i <= stopChunk; ++i) {
	      promises.push(requestXysChunk(this, i));
	    }
	    return when.all(promises);
	  };
	  Iau2006XysData.prototype.computeXysRadians = function(dayTT, secondTT, result) {
	    var daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);
	    if (daysSinceEpoch < 0.0) {
	      return undefined;
	    }
	    var centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;
	    if (centerIndex >= this._totalSamples) {
	      return undefined;
	    }
	    var degree = this._interpolationOrder;
	    var firstIndex = centerIndex - ((degree / 2) | 0);
	    if (firstIndex < 0) {
	      firstIndex = 0;
	    }
	    var lastIndex = firstIndex + degree;
	    if (lastIndex >= this._totalSamples) {
	      lastIndex = this._totalSamples - 1;
	      firstIndex = lastIndex - degree;
	      if (firstIndex < 0) {
	        firstIndex = 0;
	      }
	    }
	    var isDataMissing = false;
	    var samples = this._samples;
	    if (!defined(samples[firstIndex * 3])) {
	      requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);
	      isDataMissing = true;
	    }
	    if (!defined(samples[lastIndex * 3])) {
	      requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);
	      isDataMissing = true;
	    }
	    if (isDataMissing) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      result = new Iau2006XysSample(0.0, 0.0, 0.0);
	    } else {
	      result.x = 0.0;
	      result.y = 0.0;
	      result.s = 0.0;
	    }
	    var x = daysSinceEpoch - firstIndex * this._stepSizeDays;
	    var work = this._work;
	    var denom = this._denominators;
	    var coef = this._coef;
	    var xTable = this._xTable;
	    var i,
	        j;
	    for (i = 0; i <= degree; ++i) {
	      work[i] = x - xTable[i];
	    }
	    for (i = 0; i <= degree; ++i) {
	      coef[i] = 1.0;
	      for (j = 0; j <= degree; ++j) {
	        if (j !== i) {
	          coef[i] *= work[j];
	        }
	      }
	      coef[i] *= denom[i];
	      var sampleIndex = (firstIndex + i) * 3;
	      result.x += coef[i] * samples[sampleIndex++];
	      result.y += coef[i] * samples[sampleIndex++];
	      result.s += coef[i] * samples[sampleIndex];
	    }
	    return result;
	  };
	  function requestXysChunk(xysData, chunkIndex) {
	    if (xysData._chunkDownloadsInProgress[chunkIndex]) {
	      return xysData._chunkDownloadsInProgress[chunkIndex];
	    }
	    var deferred = when.defer();
	    xysData._chunkDownloadsInProgress[chunkIndex] = deferred;
	    var chunkUrl;
	    var xysFileUrlTemplate = xysData._xysFileUrlTemplate;
	    if (defined(xysFileUrlTemplate)) {
	      chunkUrl = xysFileUrlTemplate.replace('{0}', chunkIndex);
	    } else {
	      chunkUrl = buildModuleUrl('Assets/IAU2006_XYS/IAU2006_XYS_' + chunkIndex + '.json');
	    }
	    when(loadJson(chunkUrl), function(chunk) {
	      xysData._chunkDownloadsInProgress[chunkIndex] = false;
	      var samples = xysData._samples;
	      var newSamples = chunk.samples;
	      var startIndex = chunkIndex * xysData._samplesPerXysFile * 3;
	      for (var i = 0,
	          len = newSamples.length; i < len; ++i) {
	        samples[startIndex + i] = newSamples[i];
	      }
	      deferred.resolve();
	    });
	    return deferred.promise;
	  }
	  return Iau2006XysData;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("5e", [], function() {
	  'use strict';
	  function Iau2006XysSample(x, y, s) {
	    this.x = x;
	    this.y = y;
	    this.s = s;
	  }
	  return Iau2006XysSample;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("5f", ["1a", "1b"], function(defined, defineProperties) {
	  'use strict';
	  var _supportsFullscreen;
	  var _names = {
	    requestFullscreen: undefined,
	    exitFullscreen: undefined,
	    fullscreenEnabled: undefined,
	    fullscreenElement: undefined,
	    fullscreenchange: undefined,
	    fullscreenerror: undefined
	  };
	  var Fullscreen = {};
	  defineProperties(Fullscreen, {
	    element: {get: function() {
	        if (!Fullscreen.supportsFullscreen()) {
	          return undefined;
	        }
	        return document[_names.fullscreenElement];
	      }},
	    changeEventName: {get: function() {
	        if (!Fullscreen.supportsFullscreen()) {
	          return undefined;
	        }
	        return _names.fullscreenchange;
	      }},
	    errorEventName: {get: function() {
	        if (!Fullscreen.supportsFullscreen()) {
	          return undefined;
	        }
	        return _names.fullscreenerror;
	      }},
	    enabled: {get: function() {
	        if (!Fullscreen.supportsFullscreen()) {
	          return undefined;
	        }
	        return document[_names.fullscreenEnabled];
	      }},
	    fullscreen: {get: function() {
	        if (!Fullscreen.supportsFullscreen()) {
	          return undefined;
	        }
	        return Fullscreen.element !== null;
	      }}
	  });
	  Fullscreen.supportsFullscreen = function() {
	    if (defined(_supportsFullscreen)) {
	      return _supportsFullscreen;
	    }
	    _supportsFullscreen = false;
	    var body = document.body;
	    if (typeof body.requestFullscreen === 'function') {
	      _names.requestFullscreen = 'requestFullscreen';
	      _names.exitFullscreen = 'exitFullscreen';
	      _names.fullscreenEnabled = 'fullscreenEnabled';
	      _names.fullscreenElement = 'fullscreenElement';
	      _names.fullscreenchange = 'fullscreenchange';
	      _names.fullscreenerror = 'fullscreenerror';
	      _supportsFullscreen = true;
	      return _supportsFullscreen;
	    }
	    var prefixes = ['webkit', 'moz', 'o', 'ms', 'khtml'];
	    var name;
	    for (var i = 0,
	        len = prefixes.length; i < len; ++i) {
	      var prefix = prefixes[i];
	      name = prefix + 'RequestFullscreen';
	      if (typeof body[name] === 'function') {
	        _names.requestFullscreen = name;
	        _supportsFullscreen = true;
	      } else {
	        name = prefix + 'RequestFullScreen';
	        if (typeof body[name] === 'function') {
	          _names.requestFullscreen = name;
	          _supportsFullscreen = true;
	        }
	      }
	      name = prefix + 'ExitFullscreen';
	      if (typeof document[name] === 'function') {
	        _names.exitFullscreen = name;
	      } else {
	        name = prefix + 'CancelFullScreen';
	        if (typeof document[name] === 'function') {
	          _names.exitFullscreen = name;
	        }
	      }
	      name = prefix + 'FullscreenEnabled';
	      if (document[name] !== undefined) {
	        _names.fullscreenEnabled = name;
	      } else {
	        name = prefix + 'FullScreenEnabled';
	        if (document[name] !== undefined) {
	          _names.fullscreenEnabled = name;
	        }
	      }
	      name = prefix + 'FullscreenElement';
	      if (document[name] !== undefined) {
	        _names.fullscreenElement = name;
	      } else {
	        name = prefix + 'FullScreenElement';
	        if (document[name] !== undefined) {
	          _names.fullscreenElement = name;
	        }
	      }
	      name = prefix + 'fullscreenchange';
	      if (document['on' + name] !== undefined) {
	        if (prefix === 'ms') {
	          name = 'MSFullscreenChange';
	        }
	        _names.fullscreenchange = name;
	      }
	      name = prefix + 'fullscreenerror';
	      if (document['on' + name] !== undefined) {
	        if (prefix === 'ms') {
	          name = 'MSFullscreenError';
	        }
	        _names.fullscreenerror = name;
	      }
	    }
	    return _supportsFullscreen;
	  };
	  Fullscreen.requestFullscreen = function(element, vrDevice) {
	    if (!Fullscreen.supportsFullscreen()) {
	      return;
	    }
	    element[_names.requestFullscreen]({vrDisplay: vrDevice});
	  };
	  Fullscreen.exitFullscreen = function() {
	    if (!Fullscreen.supportsFullscreen()) {
	      return;
	    }
	    document[_names.exitFullscreen]();
	  };
	  return Fullscreen;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("60", ["23", "1a", "5f"], function(defaultValue, defined, Fullscreen) {
	  'use strict';
	  var theNavigator;
	  if (typeof navigator !== 'undefined') {
	    theNavigator = navigator;
	  } else {
	    theNavigator = {};
	  }
	  function extractVersion(versionString) {
	    var parts = versionString.split('.');
	    for (var i = 0,
	        len = parts.length; i < len; ++i) {
	      parts[i] = parseInt(parts[i], 10);
	    }
	    return parts;
	  }
	  var isChromeResult;
	  var chromeVersionResult;
	  function isChrome() {
	    if (!defined(isChromeResult)) {
	      isChromeResult = false;
	      var fields = (/ Chrome\/([\.0-9]+)/).exec(theNavigator.userAgent);
	      if (fields !== null) {
	        isChromeResult = true;
	        chromeVersionResult = extractVersion(fields[1]);
	      }
	    }
	    return isChromeResult;
	  }
	  function chromeVersion() {
	    return isChrome() && chromeVersionResult;
	  }
	  var isSafariResult;
	  var safariVersionResult;
	  function isSafari() {
	    if (!defined(isSafariResult)) {
	      isSafariResult = false;
	      if (!isChrome() && (/ Safari\/[\.0-9]+/).test(theNavigator.userAgent)) {
	        var fields = (/ Version\/([\.0-9]+)/).exec(theNavigator.userAgent);
	        if (fields !== null) {
	          isSafariResult = true;
	          safariVersionResult = extractVersion(fields[1]);
	        }
	      }
	    }
	    return isSafariResult;
	  }
	  function safariVersion() {
	    return isSafari() && safariVersionResult;
	  }
	  var isWebkitResult;
	  var webkitVersionResult;
	  function isWebkit() {
	    if (!defined(isWebkitResult)) {
	      isWebkitResult = false;
	      var fields = (/ AppleWebKit\/([\.0-9]+)(\+?)/).exec(theNavigator.userAgent);
	      if (fields !== null) {
	        isWebkitResult = true;
	        webkitVersionResult = extractVersion(fields[1]);
	        webkitVersionResult.isNightly = !!fields[2];
	      }
	    }
	    return isWebkitResult;
	  }
	  function webkitVersion() {
	    return isWebkit() && webkitVersionResult;
	  }
	  var isInternetExplorerResult;
	  var internetExplorerVersionResult;
	  function isInternetExplorer() {
	    if (!defined(isInternetExplorerResult)) {
	      isInternetExplorerResult = false;
	      var fields;
	      if (theNavigator.appName === 'Microsoft Internet Explorer') {
	        fields = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
	        if (fields !== null) {
	          isInternetExplorerResult = true;
	          internetExplorerVersionResult = extractVersion(fields[1]);
	        }
	      } else if (theNavigator.appName === 'Netscape') {
	        fields = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
	        if (fields !== null) {
	          isInternetExplorerResult = true;
	          internetExplorerVersionResult = extractVersion(fields[1]);
	        }
	      }
	    }
	    return isInternetExplorerResult;
	  }
	  function internetExplorerVersion() {
	    return isInternetExplorer() && internetExplorerVersionResult;
	  }
	  var isFirefoxResult;
	  var firefoxVersionResult;
	  function isFirefox() {
	    if (!defined(isFirefoxResult)) {
	      isFirefoxResult = false;
	      var fields = /Firefox\/([\.0-9]+)/.exec(theNavigator.userAgent);
	      if (fields !== null) {
	        isFirefoxResult = true;
	        firefoxVersionResult = extractVersion(fields[1]);
	      }
	    }
	    return isFirefoxResult;
	  }
	  var isWindowsResult;
	  function isWindows() {
	    if (!defined(isWindowsResult)) {
	      isWindowsResult = /Windows/i.test(theNavigator.appVersion);
	    }
	    return isWindowsResult;
	  }
	  function firefoxVersion() {
	    return isFirefox() && firefoxVersionResult;
	  }
	  var hasPointerEvents;
	  function supportsPointerEvents() {
	    if (!defined(hasPointerEvents)) {
	      hasPointerEvents = typeof PointerEvent !== 'undefined' && (!defined(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);
	    }
	    return hasPointerEvents;
	  }
	  var imageRenderingValueResult;
	  var supportsImageRenderingPixelatedResult;
	  function supportsImageRenderingPixelated() {
	    if (!defined(supportsImageRenderingPixelatedResult)) {
	      var canvas = document.createElement('canvas');
	      canvas.setAttribute('style', 'image-rendering: -moz-crisp-edges;' + 'image-rendering: pixelated;');
	      var tmp = canvas.style.imageRendering;
	      supportsImageRenderingPixelatedResult = defined(tmp) && tmp !== '';
	      if (supportsImageRenderingPixelatedResult) {
	        imageRenderingValueResult = tmp;
	      }
	    }
	    return supportsImageRenderingPixelatedResult;
	  }
	  function imageRenderingValue() {
	    return supportsImageRenderingPixelated() ? imageRenderingValueResult : undefined;
	  }
	  var FeatureDetection = {
	    isChrome: isChrome,
	    chromeVersion: chromeVersion,
	    isSafari: isSafari,
	    safariVersion: safariVersion,
	    isWebkit: isWebkit,
	    webkitVersion: webkitVersion,
	    isInternetExplorer: isInternetExplorer,
	    internetExplorerVersion: internetExplorerVersion,
	    isFirefox: isFirefox,
	    firefoxVersion: firefoxVersion,
	    isWindows: isWindows,
	    hardwareConcurrency: defaultValue(theNavigator.hardwareConcurrency, 3),
	    supportsPointerEvents: supportsPointerEvents,
	    supportsImageRenderingPixelated: supportsImageRenderingPixelated,
	    imageRenderingValue: imageRenderingValue
	  };
	  FeatureDetection.supportsFullscreen = function() {
	    return Fullscreen.supportsFullscreen();
	  };
	  FeatureDetection.supportsTypedArrays = function() {
	    return typeof ArrayBuffer !== 'undefined';
	  };
	  FeatureDetection.supportsWebWorkers = function() {
	    return typeof Worker !== 'undefined';
	  };
	  return FeatureDetection;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("34", ["2c", "23", "1a", "1c", "60", "1f", "27", "32"], function(Cartesian3, defaultValue, defined, DeveloperError, FeatureDetection, freezeObject, CesiumMath, Matrix3) {
	  'use strict';
	  function Quaternion(x, y, z, w) {
	    this.x = defaultValue(x, 0.0);
	    this.y = defaultValue(y, 0.0);
	    this.z = defaultValue(z, 0.0);
	    this.w = defaultValue(w, 0.0);
	  }
	  var fromAxisAngleScratch = new Cartesian3();
	  Quaternion.fromAxisAngle = function(axis, angle, result) {
	    if (!defined(axis)) {
	      throw new DeveloperError('axis is required.');
	    }
	    if (typeof angle !== 'number') {
	      throw new DeveloperError('angle is required and must be a number.');
	    }
	    var halfAngle = angle / 2.0;
	    var s = Math.sin(halfAngle);
	    fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);
	    var x = fromAxisAngleScratch.x * s;
	    var y = fromAxisAngleScratch.y * s;
	    var z = fromAxisAngleScratch.z * s;
	    var w = Math.cos(halfAngle);
	    if (!defined(result)) {
	      return new Quaternion(x, y, z, w);
	    }
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    result.w = w;
	    return result;
	  };
	  var fromRotationMatrixNext = [1, 2, 0];
	  var fromRotationMatrixQuat = new Array(3);
	  Quaternion.fromRotationMatrix = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    var root;
	    var x;
	    var y;
	    var z;
	    var w;
	    var m00 = matrix[Matrix3.COLUMN0ROW0];
	    var m11 = matrix[Matrix3.COLUMN1ROW1];
	    var m22 = matrix[Matrix3.COLUMN2ROW2];
	    var trace = m00 + m11 + m22;
	    if (trace > 0.0) {
	      root = Math.sqrt(trace + 1.0);
	      w = 0.5 * root;
	      root = 0.5 / root;
	      x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;
	      y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;
	      z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;
	    } else {
	      var next = fromRotationMatrixNext;
	      var i = 0;
	      if (m11 > m00) {
	        i = 1;
	      }
	      if (m22 > m00 && m22 > m11) {
	        i = 2;
	      }
	      var j = next[i];
	      var k = next[j];
	      root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1.0);
	      var quat = fromRotationMatrixQuat;
	      quat[i] = 0.5 * root;
	      root = 0.5 / root;
	      w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;
	      quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;
	      quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;
	      x = -quat[0];
	      y = -quat[1];
	      z = -quat[2];
	    }
	    if (!defined(result)) {
	      return new Quaternion(x, y, z, w);
	    }
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    result.w = w;
	    return result;
	  };
	  var scratchHPRQuaternion = new Quaternion();
	  Quaternion.fromHeadingPitchRoll = function(heading, pitch, roll, result) {
	    if (!defined(heading)) {
	      throw new DeveloperError('heading is required.');
	    }
	    if (!defined(pitch)) {
	      throw new DeveloperError('pitch is required.');
	    }
	    if (!defined(roll)) {
	      throw new DeveloperError('roll is required.');
	    }
	    var rollQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, roll, scratchHPRQuaternion);
	    var pitchQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -pitch, result);
	    result = Quaternion.multiply(pitchQuaternion, rollQuaternion, pitchQuaternion);
	    var headingQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -heading, scratchHPRQuaternion);
	    return Quaternion.multiply(headingQuaternion, result, result);
	  };
	  var sampledQuaternionAxis = new Cartesian3();
	  var sampledQuaternionRotation = new Cartesian3();
	  var sampledQuaternionTempQuaternion = new Quaternion();
	  var sampledQuaternionQuaternion0 = new Quaternion();
	  var sampledQuaternionQuaternion0Conjugate = new Quaternion();
	  Quaternion.packedLength = 4;
	  Quaternion.pack = function(value, array, startingIndex) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required');
	    }
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    array[startingIndex++] = value.x;
	    array[startingIndex++] = value.y;
	    array[startingIndex++] = value.z;
	    array[startingIndex] = value.w;
	  };
	  Quaternion.unpack = function(array, startingIndex, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    if (!defined(result)) {
	      result = new Quaternion();
	    }
	    result.x = array[startingIndex];
	    result.y = array[startingIndex + 1];
	    result.z = array[startingIndex + 2];
	    result.w = array[startingIndex + 3];
	    return result;
	  };
	  Quaternion.packedInterpolationLength = 3;
	  Quaternion.convertPackedArrayForInterpolation = function(packedArray, startingIndex, lastIndex, result) {
	    Quaternion.unpack(packedArray, lastIndex * 4, sampledQuaternionQuaternion0Conjugate);
	    Quaternion.conjugate(sampledQuaternionQuaternion0Conjugate, sampledQuaternionQuaternion0Conjugate);
	    for (var i = 0,
	        len = lastIndex - startingIndex + 1; i < len; i++) {
	      var offset = i * 3;
	      Quaternion.unpack(packedArray, (startingIndex + i) * 4, sampledQuaternionTempQuaternion);
	      Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0Conjugate, sampledQuaternionTempQuaternion);
	      if (sampledQuaternionTempQuaternion.w < 0) {
	        Quaternion.negate(sampledQuaternionTempQuaternion, sampledQuaternionTempQuaternion);
	      }
	      Quaternion.computeAxis(sampledQuaternionTempQuaternion, sampledQuaternionAxis);
	      var angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);
	      result[offset] = sampledQuaternionAxis.x * angle;
	      result[offset + 1] = sampledQuaternionAxis.y * angle;
	      result[offset + 2] = sampledQuaternionAxis.z * angle;
	    }
	  };
	  Quaternion.unpackInterpolationResult = function(array, sourceArray, firstIndex, lastIndex, result) {
	    if (!defined(result)) {
	      result = new Quaternion();
	    }
	    Cartesian3.fromArray(array, 0, sampledQuaternionRotation);
	    var magnitude = Cartesian3.magnitude(sampledQuaternionRotation);
	    Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);
	    if (magnitude === 0) {
	      Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);
	    } else {
	      Quaternion.fromAxisAngle(sampledQuaternionRotation, magnitude, sampledQuaternionTempQuaternion);
	    }
	    return Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0, result);
	  };
	  Quaternion.clone = function(quaternion, result) {
	    if (!defined(quaternion)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
	    }
	    result.x = quaternion.x;
	    result.y = quaternion.y;
	    result.z = quaternion.z;
	    result.w = quaternion.w;
	    return result;
	  };
	  Quaternion.conjugate = function(quaternion, result) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = -quaternion.x;
	    result.y = -quaternion.y;
	    result.z = -quaternion.z;
	    result.w = quaternion.w;
	    return result;
	  };
	  Quaternion.magnitudeSquared = function(quaternion) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required');
	    }
	    return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
	  };
	  Quaternion.magnitude = function(quaternion) {
	    return Math.sqrt(Quaternion.magnitudeSquared(quaternion));
	  };
	  Quaternion.normalize = function(quaternion, result) {
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);
	    var x = quaternion.x * inverseMagnitude;
	    var y = quaternion.y * inverseMagnitude;
	    var z = quaternion.z * inverseMagnitude;
	    var w = quaternion.w * inverseMagnitude;
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    result.w = w;
	    return result;
	  };
	  Quaternion.inverse = function(quaternion, result) {
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);
	    result = Quaternion.conjugate(quaternion, result);
	    return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);
	  };
	  Quaternion.add = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x + right.x;
	    result.y = left.y + right.y;
	    result.z = left.z + right.z;
	    result.w = left.w + right.w;
	    return result;
	  };
	  Quaternion.subtract = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x - right.x;
	    result.y = left.y - right.y;
	    result.z = left.z - right.z;
	    result.w = left.w - right.w;
	    return result;
	  };
	  Quaternion.negate = function(quaternion, result) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = -quaternion.x;
	    result.y = -quaternion.y;
	    result.z = -quaternion.z;
	    result.w = -quaternion.w;
	    return result;
	  };
	  Quaternion.dot = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
	  };
	  Quaternion.multiply = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var leftX = left.x;
	    var leftY = left.y;
	    var leftZ = left.z;
	    var leftW = left.w;
	    var rightX = right.x;
	    var rightY = right.y;
	    var rightZ = right.z;
	    var rightW = right.w;
	    var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;
	    var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;
	    var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;
	    var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    result.w = w;
	    return result;
	  };
	  Quaternion.multiplyByScalar = function(quaternion, scalar, result) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = quaternion.x * scalar;
	    result.y = quaternion.y * scalar;
	    result.z = quaternion.z * scalar;
	    result.w = quaternion.w * scalar;
	    return result;
	  };
	  Quaternion.divideByScalar = function(quaternion, scalar, result) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = quaternion.x / scalar;
	    result.y = quaternion.y / scalar;
	    result.z = quaternion.z / scalar;
	    result.w = quaternion.w / scalar;
	    return result;
	  };
	  Quaternion.computeAxis = function(quaternion, result) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var w = quaternion.w;
	    if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {
	      result.x = result.y = result.z = 0;
	      return result;
	    }
	    var scalar = 1.0 / Math.sqrt(1.0 - (w * w));
	    result.x = quaternion.x * scalar;
	    result.y = quaternion.y * scalar;
	    result.z = quaternion.z * scalar;
	    return result;
	  };
	  Quaternion.computeAngle = function(quaternion) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required');
	    }
	    if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {
	      return 0.0;
	    }
	    return 2.0 * Math.acos(quaternion.w);
	  };
	  var lerpScratch = new Quaternion();
	  Quaternion.lerp = function(start, end, t, result) {
	    if (!defined(start)) {
	      throw new DeveloperError('start is required.');
	    }
	    if (!defined(end)) {
	      throw new DeveloperError('end is required.');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);
	    result = Quaternion.multiplyByScalar(start, 1.0 - t, result);
	    return Quaternion.add(lerpScratch, result, result);
	  };
	  var slerpEndNegated = new Quaternion();
	  var slerpScaledP = new Quaternion();
	  var slerpScaledR = new Quaternion();
	  Quaternion.slerp = function(start, end, t, result) {
	    if (!defined(start)) {
	      throw new DeveloperError('start is required.');
	    }
	    if (!defined(end)) {
	      throw new DeveloperError('end is required.');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var dot = Quaternion.dot(start, end);
	    var r = end;
	    if (dot < 0.0) {
	      dot = -dot;
	      r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);
	    }
	    if (1.0 - dot < CesiumMath.EPSILON6) {
	      return Quaternion.lerp(start, r, t, result);
	    }
	    var theta = Math.acos(dot);
	    slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);
	    slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);
	    result = Quaternion.add(slerpScaledP, slerpScaledR, result);
	    return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);
	  };
	  Quaternion.log = function(quaternion, result) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var theta = CesiumMath.acosClamped(quaternion.w);
	    var thetaOverSinTheta = 0.0;
	    if (theta !== 0.0) {
	      thetaOverSinTheta = theta / Math.sin(theta);
	    }
	    return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);
	  };
	  Quaternion.exp = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var theta = Cartesian3.magnitude(cartesian);
	    var sinThetaOverTheta = 0.0;
	    if (theta !== 0.0) {
	      sinThetaOverTheta = Math.sin(theta) / theta;
	    }
	    result.x = cartesian.x * sinThetaOverTheta;
	    result.y = cartesian.y * sinThetaOverTheta;
	    result.z = cartesian.z * sinThetaOverTheta;
	    result.w = Math.cos(theta);
	    return result;
	  };
	  var squadScratchCartesian0 = new Cartesian3();
	  var squadScratchCartesian1 = new Cartesian3();
	  var squadScratchQuaternion0 = new Quaternion();
	  var squadScratchQuaternion1 = new Quaternion();
	  Quaternion.computeInnerQuadrangle = function(q0, q1, q2, result) {
	    if (!defined(q0) || !defined(q1) || !defined(q2)) {
	      throw new DeveloperError('q0, q1, and q2 are required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);
	    Quaternion.multiply(qInv, q2, squadScratchQuaternion1);
	    var cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);
	    Quaternion.multiply(qInv, q0, squadScratchQuaternion1);
	    var cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);
	    Cartesian3.add(cart0, cart1, cart0);
	    Cartesian3.multiplyByScalar(cart0, 0.25, cart0);
	    Cartesian3.negate(cart0, cart0);
	    Quaternion.exp(cart0, squadScratchQuaternion0);
	    return Quaternion.multiply(q1, squadScratchQuaternion0, result);
	  };
	  Quaternion.squad = function(q0, q1, s0, s1, t, result) {
	    if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {
	      throw new DeveloperError('q0, q1, s0, and s1 are required.');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);
	    var slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);
	    return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
	  };
	  var fastSlerpScratchQuaternion = new Quaternion();
	  var opmu = 1.90110745351730037;
	  var u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	  var v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	  var bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	  var bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	  for (var i = 0; i < 7; ++i) {
	    var s = i + 1.0;
	    var t = 2.0 * s + 1.0;
	    u[i] = 1.0 / (s * t);
	    v[i] = s / t;
	  }
	  u[7] = opmu / (8.0 * 17.0);
	  v[7] = opmu * 8.0 / 17.0;
	  Quaternion.fastSlerp = function(start, end, t, result) {
	    if (!defined(start)) {
	      throw new DeveloperError('start is required.');
	    }
	    if (!defined(end)) {
	      throw new DeveloperError('end is required.');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var x = Quaternion.dot(start, end);
	    var sign;
	    if (x >= 0) {
	      sign = 1.0;
	    } else {
	      sign = -1.0;
	      x = -x;
	    }
	    var xm1 = x - 1.0;
	    var d = 1.0 - t;
	    var sqrT = t * t;
	    var sqrD = d * d;
	    for (var i = 7; i >= 0; --i) {
	      bT[i] = (u[i] * sqrT - v[i]) * xm1;
	      bD[i] = (u[i] * sqrD - v[i]) * xm1;
	    }
	    var cT = sign * t * (1.0 + bT[0] * (1.0 + bT[1] * (1.0 + bT[2] * (1.0 + bT[3] * (1.0 + bT[4] * (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));
	    var cD = d * (1.0 + bD[0] * (1.0 + bD[1] * (1.0 + bD[2] * (1.0 + bD[3] * (1.0 + bD[4] * (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));
	    var temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);
	    Quaternion.multiplyByScalar(end, cT, result);
	    return Quaternion.add(temp, result, result);
	  };
	  Quaternion.fastSquad = function(q0, q1, s0, s1, t, result) {
	    if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {
	      throw new DeveloperError('q0, q1, s0, and s1 are required.');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);
	    var slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);
	    return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
	  };
	  Quaternion.equals = function(left, right) {
	    return (left === right) || ((defined(left)) && (defined(right)) && (left.x === right.x) && (left.y === right.y) && (left.z === right.z) && (left.w === right.w));
	  };
	  Quaternion.equalsEpsilon = function(left, right, epsilon) {
	    if (typeof epsilon !== 'number') {
	      throw new DeveloperError('epsilon is required and must be a number.');
	    }
	    return (left === right) || ((defined(left)) && (defined(right)) && (Math.abs(left.x - right.x) <= epsilon) && (Math.abs(left.y - right.y) <= epsilon) && (Math.abs(left.z - right.z) <= epsilon) && (Math.abs(left.w - right.w) <= epsilon));
	  };
	  Quaternion.ZERO = freezeObject(new Quaternion(0.0, 0.0, 0.0, 0.0));
	  Quaternion.IDENTITY = freezeObject(new Quaternion(0.0, 0.0, 0.0, 1.0));
	  Quaternion.prototype.clone = function(result) {
	    return Quaternion.clone(this, result);
	  };
	  Quaternion.prototype.equals = function(right) {
	    return Quaternion.equals(this, right);
	  };
	  Quaternion.prototype.equalsEpsilon = function(right, epsilon) {
	    return Quaternion.equalsEpsilon(this, right, epsilon);
	  };
	  Quaternion.prototype.toString = function() {
	    return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
	  };
	  return Quaternion;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("35", ["4e", "45", "2c", "43", "3b", "23", "1a", "1c", "4d", "4f", "3c", "5d", "5e", "24", "27", "32", "33", "34", "52"], function(when, Cartesian2, Cartesian3, Cartesian4, Cartographic, defaultValue, defined, DeveloperError, EarthOrientationParameters, EarthOrientationParametersSample, Ellipsoid, Iau2006XysData, Iau2006XysSample, JulianDate, CesiumMath, Matrix3, Matrix4, Quaternion, TimeConstants) {
	  'use strict';
	  var Transforms = {};
	  var eastNorthUpToFixedFrameNormal = new Cartesian3();
	  var eastNorthUpToFixedFrameTangent = new Cartesian3();
	  var eastNorthUpToFixedFrameBitangent = new Cartesian3();
	  Transforms.eastNorthUpToFixedFrame = function(origin, ellipsoid, result) {
	    if (!defined(origin)) {
	      throw new DeveloperError('origin is required.');
	    }
	    if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
	      var sign = CesiumMath.sign(origin.z);
	      if (!defined(result)) {
	        return new Matrix4(0.0, -sign, 0.0, origin.x, 1.0, 0.0, 0.0, origin.y, 0.0, 0.0, sign, origin.z, 0.0, 0.0, 0.0, 1.0);
	      }
	      result[0] = 0.0;
	      result[1] = 1.0;
	      result[2] = 0.0;
	      result[3] = 0.0;
	      result[4] = -sign;
	      result[5] = 0.0;
	      result[6] = 0.0;
	      result[7] = 0.0;
	      result[8] = 0.0;
	      result[9] = 0.0;
	      result[10] = sign;
	      result[11] = 0.0;
	      result[12] = origin.x;
	      result[13] = origin.y;
	      result[14] = origin.z;
	      result[15] = 1.0;
	      return result;
	    }
	    var normal = eastNorthUpToFixedFrameNormal;
	    var tangent = eastNorthUpToFixedFrameTangent;
	    var bitangent = eastNorthUpToFixedFrameBitangent;
	    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	    ellipsoid.geodeticSurfaceNormal(origin, normal);
	    tangent.x = -origin.y;
	    tangent.y = origin.x;
	    tangent.z = 0.0;
	    Cartesian3.normalize(tangent, tangent);
	    Cartesian3.cross(normal, tangent, bitangent);
	    if (!defined(result)) {
	      return new Matrix4(tangent.x, bitangent.x, normal.x, origin.x, tangent.y, bitangent.y, normal.y, origin.y, tangent.z, bitangent.z, normal.z, origin.z, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = tangent.x;
	    result[1] = tangent.y;
	    result[2] = tangent.z;
	    result[3] = 0.0;
	    result[4] = bitangent.x;
	    result[5] = bitangent.y;
	    result[6] = bitangent.z;
	    result[7] = 0.0;
	    result[8] = normal.x;
	    result[9] = normal.y;
	    result[10] = normal.z;
	    result[11] = 0.0;
	    result[12] = origin.x;
	    result[13] = origin.y;
	    result[14] = origin.z;
	    result[15] = 1.0;
	    return result;
	  };
	  var northEastDownToFixedFrameNormal = new Cartesian3();
	  var northEastDownToFixedFrameTangent = new Cartesian3();
	  var northEastDownToFixedFrameBitangent = new Cartesian3();
	  Transforms.northEastDownToFixedFrame = function(origin, ellipsoid, result) {
	    if (!defined(origin)) {
	      throw new DeveloperError('origin is required.');
	    }
	    if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
	      var sign = CesiumMath.sign(origin.z);
	      if (!defined(result)) {
	        return new Matrix4(-sign, 0.0, 0.0, origin.x, 0.0, 1.0, 0.0, origin.y, 0.0, 0.0, -sign, origin.z, 0.0, 0.0, 0.0, 1.0);
	      }
	      result[0] = -sign;
	      result[1] = 0.0;
	      result[2] = 0.0;
	      result[3] = 0.0;
	      result[4] = 0.0;
	      result[5] = 1.0;
	      result[6] = 0.0;
	      result[7] = 0.0;
	      result[8] = 0.0;
	      result[9] = 0.0;
	      result[10] = -sign;
	      result[11] = 0.0;
	      result[12] = origin.x;
	      result[13] = origin.y;
	      result[14] = origin.z;
	      result[15] = 1.0;
	      return result;
	    }
	    var normal = northEastDownToFixedFrameNormal;
	    var tangent = northEastDownToFixedFrameTangent;
	    var bitangent = northEastDownToFixedFrameBitangent;
	    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	    ellipsoid.geodeticSurfaceNormal(origin, normal);
	    tangent.x = -origin.y;
	    tangent.y = origin.x;
	    tangent.z = 0.0;
	    Cartesian3.normalize(tangent, tangent);
	    Cartesian3.cross(normal, tangent, bitangent);
	    if (!defined(result)) {
	      return new Matrix4(bitangent.x, tangent.x, -normal.x, origin.x, bitangent.y, tangent.y, -normal.y, origin.y, bitangent.z, tangent.z, -normal.z, origin.z, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = bitangent.x;
	    result[1] = bitangent.y;
	    result[2] = bitangent.z;
	    result[3] = 0.0;
	    result[4] = tangent.x;
	    result[5] = tangent.y;
	    result[6] = tangent.z;
	    result[7] = 0.0;
	    result[8] = -normal.x;
	    result[9] = -normal.y;
	    result[10] = -normal.z;
	    result[11] = 0.0;
	    result[12] = origin.x;
	    result[13] = origin.y;
	    result[14] = origin.z;
	    result[15] = 1.0;
	    return result;
	  };
	  Transforms.northUpEastToFixedFrame = function(origin, ellipsoid, result) {
	    if (!defined(origin)) {
	      throw new DeveloperError('origin is required.');
	    }
	    if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
	      var sign = CesiumMath.sign(origin.z);
	      if (!defined(result)) {
	        return new Matrix4(-sign, 0.0, 0.0, origin.x, 0.0, 0.0, 1.0, origin.y, 0.0, sign, 0.0, origin.z, 0.0, 0.0, 0.0, 1.0);
	      }
	      result[0] = -sign;
	      result[1] = 0.0;
	      result[2] = 0.0;
	      result[3] = 0.0;
	      result[4] = 0.0;
	      result[5] = 0.0;
	      result[6] = sign;
	      result[7] = 0.0;
	      result[8] = 0.0;
	      result[9] = 1.0;
	      result[10] = 0.0;
	      result[11] = 0.0;
	      result[12] = origin.x;
	      result[13] = origin.y;
	      result[14] = origin.z;
	      result[15] = 1.0;
	      return result;
	    }
	    var normal = eastNorthUpToFixedFrameNormal;
	    var tangent = eastNorthUpToFixedFrameTangent;
	    var bitangent = eastNorthUpToFixedFrameBitangent;
	    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	    ellipsoid.geodeticSurfaceNormal(origin, normal);
	    tangent.x = -origin.y;
	    tangent.y = origin.x;
	    tangent.z = 0.0;
	    Cartesian3.normalize(tangent, tangent);
	    Cartesian3.cross(normal, tangent, bitangent);
	    if (!defined(result)) {
	      return new Matrix4(bitangent.x, normal.x, tangent.x, origin.x, bitangent.y, normal.y, tangent.y, origin.y, bitangent.z, normal.z, tangent.z, origin.z, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = bitangent.x;
	    result[1] = bitangent.y;
	    result[2] = bitangent.z;
	    result[3] = 0.0;
	    result[4] = normal.x;
	    result[5] = normal.y;
	    result[6] = normal.z;
	    result[7] = 0.0;
	    result[8] = tangent.x;
	    result[9] = tangent.y;
	    result[10] = tangent.z;
	    result[11] = 0.0;
	    result[12] = origin.x;
	    result[13] = origin.y;
	    result[14] = origin.z;
	    result[15] = 1.0;
	    return result;
	  };
	  var scratchHPRQuaternion = new Quaternion();
	  var scratchScale = new Cartesian3(1.0, 1.0, 1.0);
	  var scratchHPRMatrix4 = new Matrix4();
	  Transforms.headingPitchRollToFixedFrame = function(origin, heading, pitch, roll, ellipsoid, result) {
	    var hprQuaternion = Quaternion.fromHeadingPitchRoll(heading, pitch, roll, scratchHPRQuaternion);
	    var hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, hprQuaternion, scratchScale, scratchHPRMatrix4);
	    result = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid, result);
	    return Matrix4.multiply(result, hprMatrix, result);
	  };
	  var scratchENUMatrix4 = new Matrix4();
	  var scratchHPRMatrix3 = new Matrix3();
	  Transforms.headingPitchRollQuaternion = function(origin, heading, pitch, roll, ellipsoid, result) {
	    var transform = Transforms.headingPitchRollToFixedFrame(origin, heading, pitch, roll, ellipsoid, scratchENUMatrix4);
	    var rotation = Matrix4.getRotation(transform, scratchHPRMatrix3);
	    return Quaternion.fromRotationMatrix(rotation, result);
	  };
	  var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
	  var gmstConstant1 = 8640184.812866;
	  var gmstConstant2 = 0.093104;
	  var gmstConstant3 = -6.2E-6;
	  var rateCoef = 1.1772758384668e-19;
	  var wgs84WRPrecessing = 7.2921158553E-5;
	  var twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;
	  var dateInUtc = new JulianDate();
	  Transforms.computeTemeToPseudoFixedMatrix = function(date, result) {
	    if (!defined(date)) {
	      throw new DeveloperError('date is required.');
	    }
	    dateInUtc = JulianDate.addSeconds(date, -JulianDate.computeTaiMinusUtc(date), dateInUtc);
	    var utcDayNumber = dateInUtc.dayNumber;
	    var utcSecondsIntoDay = dateInUtc.secondsOfDay;
	    var t;
	    var diffDays = utcDayNumber - 2451545;
	    if (utcSecondsIntoDay >= 43200.0) {
	      t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
	    } else {
	      t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
	    }
	    var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
	    var angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;
	    var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);
	    var secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;
	    var gha = angle + (ratio * secondsSinceMidnight);
	    var cosGha = Math.cos(gha);
	    var sinGha = Math.sin(gha);
	    if (!defined(result)) {
	      return new Matrix3(cosGha, sinGha, 0.0, -sinGha, cosGha, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = cosGha;
	    result[1] = -sinGha;
	    result[2] = 0.0;
	    result[3] = sinGha;
	    result[4] = cosGha;
	    result[5] = 0.0;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = 1.0;
	    return result;
	  };
	  Transforms.iau2006XysData = new Iau2006XysData();
	  Transforms.earthOrientationParameters = EarthOrientationParameters.NONE;
	  var ttMinusTai = 32.184;
	  var j2000ttDays = 2451545.0;
	  Transforms.preloadIcrfFixed = function(timeInterval) {
	    var startDayTT = timeInterval.start.dayNumber;
	    var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;
	    var stopDayTT = timeInterval.stop.dayNumber;
	    var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;
	    var xysPromise = Transforms.iau2006XysData.preload(startDayTT, startSecondTT, stopDayTT, stopSecondTT);
	    var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();
	    return when.all([xysPromise, eopPromise]);
	  };
	  Transforms.computeIcrfToFixedMatrix = function(date, result) {
	    if (!defined(date)) {
	      throw new DeveloperError('date is required.');
	    }
	    if (!defined(result)) {
	      result = new Matrix3();
	    }
	    var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);
	    if (!defined(fixedToIcrfMtx)) {
	      return undefined;
	    }
	    return Matrix3.transpose(fixedToIcrfMtx, result);
	  };
	  var xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);
	  var eopScratch = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  var rotation1Scratch = new Matrix3();
	  var rotation2Scratch = new Matrix3();
	  Transforms.computeFixedToIcrfMatrix = function(date, result) {
	    if (!defined(date)) {
	      throw new DeveloperError('date is required.');
	    }
	    if (!defined(result)) {
	      result = new Matrix3();
	    }
	    var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);
	    if (!defined(eop)) {
	      return undefined;
	    }
	    var dayTT = date.dayNumber;
	    var secondTT = date.secondsOfDay + ttMinusTai;
	    var xys = Transforms.iau2006XysData.computeXysRadians(dayTT, secondTT, xysScratch);
	    if (!defined(xys)) {
	      return undefined;
	    }
	    var x = xys.x + eop.xPoleOffset;
	    var y = xys.y + eop.yPoleOffset;
	    var a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));
	    var rotation1 = rotation1Scratch;
	    rotation1[0] = 1.0 - a * x * x;
	    rotation1[3] = -a * x * y;
	    rotation1[6] = x;
	    rotation1[1] = -a * x * y;
	    rotation1[4] = 1 - a * y * y;
	    rotation1[7] = y;
	    rotation1[2] = -x;
	    rotation1[5] = -y;
	    rotation1[8] = 1 - a * (x * x + y * y);
	    var rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);
	    var matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);
	    var dateUt1day = date.dayNumber;
	    var dateUt1sec = date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;
	    var daysSinceJ2000 = dateUt1day - 2451545;
	    var fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;
	    var era = 0.7790572732640 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);
	    era = (era % 1.0) * CesiumMath.TWO_PI;
	    var earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);
	    var pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);
	    var cosxp = Math.cos(eop.xPoleWander);
	    var cosyp = Math.cos(eop.yPoleWander);
	    var sinxp = Math.sin(eop.xPoleWander);
	    var sinyp = Math.sin(eop.yPoleWander);
	    var ttt = (dayTT - j2000ttDays) + secondTT / TimeConstants.SECONDS_PER_DAY;
	    ttt /= 36525.0;
	    var sp = -47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE / 3600.0;
	    var cossp = Math.cos(sp);
	    var sinsp = Math.sin(sp);
	    var fToPfMtx = rotation2Scratch;
	    fToPfMtx[0] = cosxp * cossp;
	    fToPfMtx[1] = cosxp * sinsp;
	    fToPfMtx[2] = sinxp;
	    fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;
	    fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;
	    fToPfMtx[5] = -sinyp * cosxp;
	    fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;
	    fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;
	    fToPfMtx[8] = cosyp * cosxp;
	    return Matrix3.multiply(pfToIcrf, fToPfMtx, result);
	  };
	  var pointToWindowCoordinatesTemp = new Cartesian4();
	  Transforms.pointToWindowCoordinates = function(modelViewProjectionMatrix, viewportTransformation, point, result) {
	    result = Transforms.pointToGLWindowCoordinates(modelViewProjectionMatrix, viewportTransformation, point, result);
	    result.y = 2.0 * viewportTransformation[5] - result.y;
	    return result;
	  };
	  Transforms.pointToGLWindowCoordinates = function(modelViewProjectionMatrix, viewportTransformation, point, result) {
	    if (!defined(modelViewProjectionMatrix)) {
	      throw new DeveloperError('modelViewProjectionMatrix is required.');
	    }
	    if (!defined(viewportTransformation)) {
	      throw new DeveloperError('viewportTransformation is required.');
	    }
	    if (!defined(point)) {
	      throw new DeveloperError('point is required.');
	    }
	    if (!defined(result)) {
	      result = new Cartesian2();
	    }
	    var tmp = pointToWindowCoordinatesTemp;
	    Matrix4.multiplyByVector(modelViewProjectionMatrix, Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp), tmp);
	    Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);
	    Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);
	    return Cartesian2.fromCartesian4(tmp, result);
	  };
	  var normalScratch = new Cartesian3();
	  var rightScratch = new Cartesian3();
	  var upScratch = new Cartesian3();
	  Transforms.rotationMatrixFromPositionVelocity = function(position, velocity, ellipsoid, result) {
	    if (!defined(position)) {
	      throw new DeveloperError('position is required.');
	    }
	    if (!defined(velocity)) {
	      throw new DeveloperError('velocity is required.');
	    }
	    var normal = defaultValue(ellipsoid, Ellipsoid.WGS84).geodeticSurfaceNormal(position, normalScratch);
	    var right = Cartesian3.cross(velocity, normal, rightScratch);
	    if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
	      right = Cartesian3.clone(Cartesian3.UNIT_X, right);
	    }
	    var up = Cartesian3.cross(right, velocity, upScratch);
	    Cartesian3.cross(velocity, up, right);
	    Cartesian3.negate(right, right);
	    if (!defined(result)) {
	      result = new Matrix3();
	    }
	    result[0] = velocity.x;
	    result[1] = velocity.y;
	    result[2] = velocity.z;
	    result[3] = right.x;
	    result[4] = right.y;
	    result[5] = right.z;
	    result[6] = up.x;
	    result[7] = up.y;
	    result[8] = up.z;
	    return result;
	  };
	  var scratchCartographic = new Cartographic();
	  var scratchCartesian3Projection = new Cartesian3();
	  var scratchCartesian3 = new Cartesian3();
	  var scratchCartesian4Origin = new Cartesian4();
	  var scratchCartesian4NewOrigin = new Cartesian4();
	  var scratchCartesian4NewXAxis = new Cartesian4();
	  var scratchCartesian4NewYAxis = new Cartesian4();
	  var scratchCartesian4NewZAxis = new Cartesian4();
	  var scratchFromENU = new Matrix4();
	  var scratchToENU = new Matrix4();
	  Transforms.basisTo2D = function(projection, matrix, result) {
	    if (!defined(projection)) {
	      throw new DeveloperError('projection is required.');
	    }
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    var ellipsoid = projection.ellipsoid;
	    var origin = Matrix4.getColumn(matrix, 3, scratchCartesian4Origin);
	    var cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);
	    var fromENU = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid, scratchFromENU);
	    var toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);
	    var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);
	    var newOrigin = scratchCartesian4NewOrigin;
	    newOrigin.x = projectedPosition.z;
	    newOrigin.y = projectedPosition.x;
	    newOrigin.z = projectedPosition.y;
	    newOrigin.w = 1.0;
	    var xAxis = Matrix4.getColumn(matrix, 0, scratchCartesian3);
	    var xScale = Cartesian3.magnitude(xAxis);
	    var newXAxis = Matrix4.multiplyByVector(toENU, xAxis, scratchCartesian4NewXAxis);
	    Cartesian4.fromElements(newXAxis.z, newXAxis.x, newXAxis.y, 0.0, newXAxis);
	    var yAxis = Matrix4.getColumn(matrix, 1, scratchCartesian3);
	    var yScale = Cartesian3.magnitude(yAxis);
	    var newYAxis = Matrix4.multiplyByVector(toENU, yAxis, scratchCartesian4NewYAxis);
	    Cartesian4.fromElements(newYAxis.z, newYAxis.x, newYAxis.y, 0.0, newYAxis);
	    var zAxis = Matrix4.getColumn(matrix, 2, scratchCartesian3);
	    var zScale = Cartesian3.magnitude(zAxis);
	    var newZAxis = scratchCartesian4NewZAxis;
	    Cartesian3.cross(newXAxis, newYAxis, newZAxis);
	    Cartesian3.normalize(newZAxis, newZAxis);
	    Cartesian3.cross(newYAxis, newZAxis, newXAxis);
	    Cartesian3.normalize(newXAxis, newXAxis);
	    Cartesian3.cross(newZAxis, newXAxis, newYAxis);
	    Cartesian3.normalize(newYAxis, newYAxis);
	    Cartesian3.multiplyByScalar(newXAxis, xScale, newXAxis);
	    Cartesian3.multiplyByScalar(newYAxis, yScale, newYAxis);
	    Cartesian3.multiplyByScalar(newZAxis, zScale, newZAxis);
	    Matrix4.setColumn(result, 0, newXAxis, result);
	    Matrix4.setColumn(result, 1, newYAxis, result);
	    Matrix4.setColumn(result, 2, newZAxis, result);
	    Matrix4.setColumn(result, 3, newOrigin, result);
	    return result;
	  };
	  return Transforms;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("61", [], function() {
	  function sprintf() {
	    var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
	    var a = arguments,
	        i = 0,
	        format = a[i++];
	    var pad = function(str, len, chr, leftJustify) {
	      if (!chr) {
	        chr = ' ';
	      }
	      var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
	      return leftJustify ? str + padding : padding + str;
	    };
	    var justify = function(value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
	      var diff = minWidth - value.length;
	      if (diff > 0) {
	        if (leftJustify || !zeroPad) {
	          value = pad(value, minWidth, customPadChar, leftJustify);
	        } else {
	          value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
	        }
	      }
	      return value;
	    };
	    var formatBaseX = function(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
	      var number = value >>> 0;
	      prefix = prefix && number && {
	        '2': '0b',
	        '8': '0',
	        '16': '0x'
	      }[base] || '';
	      value = prefix + pad(number.toString(base), precision || 0, '0', false);
	      return justify(value, prefix, leftJustify, minWidth, zeroPad);
	    };
	    var formatString = function(value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
	      if (precision != null) {
	        value = value.slice(0, precision);
	      }
	      return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
	    };
	    var doFormat = function(substring, valueIndex, flags, minWidth, _, precision, type) {
	      var number;
	      var prefix;
	      var method;
	      var textTransform;
	      var value;
	      if (substring == '%%') {
	        return '%';
	      }
	      var leftJustify = false,
	          positivePrefix = '',
	          zeroPad = false,
	          prefixBaseX = false,
	          customPadChar = ' ';
	      var flagsl = flags.length;
	      for (var j = 0; flags && j < flagsl; j++) {
	        switch (flags.charAt(j)) {
	          case ' ':
	            positivePrefix = ' ';
	            break;
	          case '+':
	            positivePrefix = '+';
	            break;
	          case '-':
	            leftJustify = true;
	            break;
	          case "'":
	            customPadChar = flags.charAt(j + 1);
	            break;
	          case '0':
	            zeroPad = true;
	            break;
	          case '#':
	            prefixBaseX = true;
	            break;
	        }
	      }
	      if (!minWidth) {
	        minWidth = 0;
	      } else if (minWidth == '*') {
	        minWidth = +a[i++];
	      } else if (minWidth.charAt(0) == '*') {
	        minWidth = +a[minWidth.slice(1, -1)];
	      } else {
	        minWidth = +minWidth;
	      }
	      if (minWidth < 0) {
	        minWidth = -minWidth;
	        leftJustify = true;
	      }
	      if (!isFinite(minWidth)) {
	        throw new Error('sprintf: (minimum-)width must be finite');
	      }
	      if (!precision) {
	        precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;
	      } else if (precision == '*') {
	        precision = +a[i++];
	      } else if (precision.charAt(0) == '*') {
	        precision = +a[precision.slice(1, -1)];
	      } else {
	        precision = +precision;
	      }
	      value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];
	      switch (type) {
	        case 's':
	          return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
	        case 'c':
	          return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
	        case 'b':
	          return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
	        case 'o':
	          return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
	        case 'x':
	          return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
	        case 'X':
	          return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
	        case 'u':
	          return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
	        case 'i':
	        case 'd':
	          number = +value || 0;
	          number = Math.round(number - number % 1);
	          prefix = number < 0 ? '-' : positivePrefix;
	          value = prefix + pad(String(Math.abs(number)), precision, '0', false);
	          return justify(value, prefix, leftJustify, minWidth, zeroPad);
	        case 'e':
	        case 'E':
	        case 'f':
	        case 'F':
	        case 'g':
	        case 'G':
	          number = +value;
	          prefix = number < 0 ? '-' : positivePrefix;
	          method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
	          textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
	          value = prefix + Math.abs(number)[method](precision);
	          return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
	        default:
	          return substring;
	      }
	    };
	    return format.replace(regex, doFormat);
	  }
	  return sprintf;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("4c", ["1a", "1c"], function(defined, DeveloperError) {
	  'use strict';
	  function binarySearch(array, itemToFind, comparator) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required.');
	    }
	    if (!defined(itemToFind)) {
	      throw new DeveloperError('itemToFind is required.');
	    }
	    if (!defined(comparator)) {
	      throw new DeveloperError('comparator is required.');
	    }
	    var low = 0;
	    var high = array.length - 1;
	    var i;
	    var comparison;
	    while (low <= high) {
	      i = ~~((low + high) / 2);
	      comparison = comparator(array[i], itemToFind);
	      if (comparison < 0) {
	        low = i + 1;
	        continue;
	      }
	      if (comparison > 0) {
	        high = i - 1;
	        continue;
	      }
	      return i;
	    }
	    return ~(high + 1);
	  }
	  return binarySearch;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("62", [], function() {
	  'use strict';
	  function GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond) {
	    this.year = year;
	    this.month = month;
	    this.day = day;
	    this.hour = hour;
	    this.minute = minute;
	    this.second = second;
	    this.millisecond = millisecond;
	    this.isLeapSecond = isLeapSecond;
	  }
	  return GregorianDate;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("63", ["1c"], function(DeveloperError) {
	  'use strict';
	  function isLeapYear(year) {
	    if (year === null || isNaN(year)) {
	      throw new DeveloperError('year is required and must be a number.');
	    }
	    return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
	  }
	  return isLeapYear;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("50", [], function() {
	  'use strict';
	  function LeapSecond(date, offset) {
	    this.julianDate = date;
	    this.offset = offset;
	  }
	  return LeapSecond;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("24", ["61", "4c", "23", "1a", "1c", "62", "63", "50", "52", "53"], function(sprintf, binarySearch, defaultValue, defined, DeveloperError, GregorianDate, isLeapYear, LeapSecond, TimeConstants, TimeStandard) {
	  'use strict';
	  var gregorianDateScratch = new GregorianDate();
	  var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	  var daysInLeapFeburary = 29;
	  function compareLeapSecondDates(leapSecond, dateToFind) {
	    return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);
	  }
	  var binarySearchScratchLeapSecond = new LeapSecond();
	  function convertUtcToTai(julianDate) {
	    binarySearchScratchLeapSecond.julianDate = julianDate;
	    var leapSeconds = JulianDate.leapSeconds;
	    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
	    if (index < 0) {
	      index = ~index;
	    }
	    if (index >= leapSeconds.length) {
	      index = leapSeconds.length - 1;
	    }
	    var offset = leapSeconds[index].offset;
	    if (index > 0) {
	      var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);
	      if (difference > offset) {
	        index--;
	        offset = leapSeconds[index].offset;
	      }
	    }
	    JulianDate.addSeconds(julianDate, offset, julianDate);
	  }
	  function convertTaiToUtc(julianDate, result) {
	    binarySearchScratchLeapSecond.julianDate = julianDate;
	    var leapSeconds = JulianDate.leapSeconds;
	    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
	    if (index < 0) {
	      index = ~index;
	    }
	    if (index === 0) {
	      return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);
	    }
	    if (index >= leapSeconds.length) {
	      return JulianDate.addSeconds(julianDate, -leapSeconds[index - 1].offset, result);
	    }
	    var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);
	    if (difference === 0) {
	      return JulianDate.addSeconds(julianDate, -leapSeconds[index].offset, result);
	    }
	    if (difference <= 1.0) {
	      return undefined;
	    }
	    return JulianDate.addSeconds(julianDate, -leapSeconds[--index].offset, result);
	  }
	  function setComponents(wholeDays, secondsOfDay, julianDate) {
	    var extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;
	    wholeDays += extraDays;
	    secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;
	    if (secondsOfDay < 0) {
	      wholeDays--;
	      secondsOfDay += TimeConstants.SECONDS_PER_DAY;
	    }
	    julianDate.dayNumber = wholeDays;
	    julianDate.secondsOfDay = secondsOfDay;
	    return julianDate;
	  }
	  function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {
	    var a = ((month - 14) / 12) | 0;
	    var b = year + 4800 + a;
	    var dayNumber = (((1461 * b) / 4) | 0) + (((367 * (month - 2 - 12 * a)) / 12) | 0) - (((3 * (((b + 100) / 100) | 0)) / 4) | 0) + day - 32075;
	    hour = hour - 12;
	    if (hour < 0) {
	      hour += 24;
	    }
	    var secondsOfDay = second + ((hour * TimeConstants.SECONDS_PER_HOUR) + (minute * TimeConstants.SECONDS_PER_MINUTE) + (millisecond * TimeConstants.SECONDS_PER_MILLISECOND));
	    if (secondsOfDay >= 43200.0) {
	      dayNumber -= 1;
	    }
	    return [dayNumber, secondsOfDay];
	  }
	  var matchCalendarYear = /^(\d{4})$/;
	  var matchCalendarMonth = /^(\d{4})-(\d{2})$/;
	  var matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
	  var matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
	  var matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
	  var utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
	  var matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
	  var matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
	  var matchHoursMinutesSeconds = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
	  var iso8601ErrorMessage = 'Invalid ISO 8601 date.';
	  function JulianDate(julianDayNumber, secondsOfDay, timeStandard) {
	    this.dayNumber = undefined;
	    this.secondsOfDay = undefined;
	    julianDayNumber = defaultValue(julianDayNumber, 0.0);
	    secondsOfDay = defaultValue(secondsOfDay, 0.0);
	    timeStandard = defaultValue(timeStandard, TimeStandard.UTC);
	    var wholeDays = julianDayNumber | 0;
	    secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;
	    setComponents(wholeDays, secondsOfDay, this);
	    if (timeStandard === TimeStandard.UTC) {
	      convertUtcToTai(this);
	    }
	  }
	  JulianDate.fromDate = function(date, result) {
	    if (!(date instanceof Date) || isNaN(date.getTime())) {
	      throw new DeveloperError('date must be a valid JavaScript Date.');
	    }
	    var components = computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
	    if (!defined(result)) {
	      return new JulianDate(components[0], components[1], TimeStandard.UTC);
	    }
	    setComponents(components[0], components[1], result);
	    convertUtcToTai(result);
	    return result;
	  };
	  JulianDate.fromIso8601 = function(iso8601String, result) {
	    if (typeof iso8601String !== 'string') {
	      throw new DeveloperError(iso8601ErrorMessage);
	    }
	    iso8601String = iso8601String.replace(',', '.');
	    var tokens = iso8601String.split('T');
	    var year;
	    var month = 1;
	    var day = 1;
	    var hour = 0;
	    var minute = 0;
	    var second = 0;
	    var millisecond = 0;
	    var date = tokens[0];
	    var time = tokens[1];
	    var tmp;
	    var inLeapYear;
	    if (!defined(date)) {
	      throw new DeveloperError(iso8601ErrorMessage);
	    }
	    var dashCount;
	    tokens = date.match(matchCalendarDate);
	    if (tokens !== null) {
	      dashCount = date.split('-').length - 1;
	      if (dashCount > 0 && dashCount !== 2) {
	        throw new DeveloperError(iso8601ErrorMessage);
	      }
	      year = +tokens[1];
	      month = +tokens[2];
	      day = +tokens[3];
	    } else {
	      tokens = date.match(matchCalendarMonth);
	      if (tokens !== null) {
	        year = +tokens[1];
	        month = +tokens[2];
	      } else {
	        tokens = date.match(matchCalendarYear);
	        if (tokens !== null) {
	          year = +tokens[1];
	        } else {
	          var dayOfYear;
	          tokens = date.match(matchOrdinalDate);
	          if (tokens !== null) {
	            year = +tokens[1];
	            dayOfYear = +tokens[2];
	            inLeapYear = isLeapYear(year);
	            if (dayOfYear < 1 || (inLeapYear && dayOfYear > 366) || (!inLeapYear && dayOfYear > 365)) {
	              throw new DeveloperError(iso8601ErrorMessage);
	            }
	          } else {
	            tokens = date.match(matchWeekDate);
	            if (tokens !== null) {
	              year = +tokens[1];
	              var weekNumber = +tokens[2];
	              var dayOfWeek = +tokens[3] || 0;
	              dashCount = date.split('-').length - 1;
	              if (dashCount > 0 && ((!defined(tokens[3]) && dashCount !== 1) || (defined(tokens[3]) && dashCount !== 2))) {
	                throw new DeveloperError(iso8601ErrorMessage);
	              }
	              var january4 = new Date(Date.UTC(year, 0, 4));
	              dayOfYear = (weekNumber * 7) + dayOfWeek - january4.getUTCDay() - 3;
	            } else {
	              throw new DeveloperError(iso8601ErrorMessage);
	            }
	          }
	          tmp = new Date(Date.UTC(year, 0, 1));
	          tmp.setUTCDate(dayOfYear);
	          month = tmp.getUTCMonth() + 1;
	          day = tmp.getUTCDate();
	        }
	      }
	    }
	    inLeapYear = isLeapYear(year);
	    if (month < 1 || month > 12 || day < 1 || ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) || (inLeapYear && month === 2 && day > daysInLeapFeburary)) {
	      throw new DeveloperError(iso8601ErrorMessage);
	    }
	    var offsetIndex;
	    if (defined(time)) {
	      tokens = time.match(matchHoursMinutesSeconds);
	      if (tokens !== null) {
	        dashCount = time.split(':').length - 1;
	        if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {
	          throw new DeveloperError(iso8601ErrorMessage);
	        }
	        hour = +tokens[1];
	        minute = +tokens[2];
	        second = +tokens[3];
	        millisecond = +(tokens[4] || 0) * 1000.0;
	        offsetIndex = 5;
	      } else {
	        tokens = time.match(matchHoursMinutes);
	        if (tokens !== null) {
	          dashCount = time.split(':').length - 1;
	          if (dashCount > 2) {
	            throw new DeveloperError(iso8601ErrorMessage);
	          }
	          hour = +tokens[1];
	          minute = +tokens[2];
	          second = +(tokens[3] || 0) * 60.0;
	          offsetIndex = 4;
	        } else {
	          tokens = time.match(matchHours);
	          if (tokens !== null) {
	            hour = +tokens[1];
	            minute = +(tokens[2] || 0) * 60.0;
	            offsetIndex = 3;
	          } else {
	            throw new DeveloperError(iso8601ErrorMessage);
	          }
	        }
	      }
	      if (minute >= 60 || second >= 61 || hour > 24 || (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))) {
	        throw new DeveloperError(iso8601ErrorMessage);
	      }
	      var offset = tokens[offsetIndex];
	      var offsetHours = +(tokens[offsetIndex + 1]);
	      var offsetMinutes = +(tokens[offsetIndex + 2] || 0);
	      switch (offset) {
	        case '+':
	          hour = hour - offsetHours;
	          minute = minute - offsetMinutes;
	          break;
	        case '-':
	          hour = hour + offsetHours;
	          minute = minute + offsetMinutes;
	          break;
	        case 'Z':
	          break;
	        default:
	          minute = minute + new Date(Date.UTC(year, month - 1, day, hour, minute)).getTimezoneOffset();
	          break;
	      }
	    } else {
	      minute = minute + new Date(year, month - 1, day).getTimezoneOffset();
	    }
	    var isLeapSecond = second === 60;
	    if (isLeapSecond) {
	      second--;
	    }
	    while (minute >= 60) {
	      minute -= 60;
	      hour++;
	    }
	    while (hour >= 24) {
	      hour -= 24;
	      day++;
	    }
	    tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
	    while (day > tmp) {
	      day -= tmp;
	      month++;
	      if (month > 12) {
	        month -= 12;
	        year++;
	      }
	      tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
	    }
	    while (minute < 0) {
	      minute += 60;
	      hour--;
	    }
	    while (hour < 0) {
	      hour += 24;
	      day--;
	    }
	    while (day < 1) {
	      month--;
	      if (month < 1) {
	        month += 12;
	        year--;
	      }
	      tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
	      day += tmp;
	    }
	    var components = computeJulianDateComponents(year, month, day, hour, minute, second, millisecond);
	    if (!defined(result)) {
	      result = new JulianDate(components[0], components[1], TimeStandard.UTC);
	    } else {
	      setComponents(components[0], components[1], result);
	      convertUtcToTai(result);
	    }
	    if (isLeapSecond) {
	      JulianDate.addSeconds(result, 1, result);
	    }
	    return result;
	  };
	  JulianDate.now = function(result) {
	    return JulianDate.fromDate(new Date(), result);
	  };
	  var toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);
	  JulianDate.toGregorianDate = function(julianDate, result) {
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    var isLeapSecond = false;
	    var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);
	    if (!defined(thisUtc)) {
	      JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);
	      thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);
	      isLeapSecond = true;
	    }
	    var julianDayNumber = thisUtc.dayNumber;
	    var secondsOfDay = thisUtc.secondsOfDay;
	    if (secondsOfDay >= 43200.0) {
	      julianDayNumber += 1;
	    }
	    var L = (julianDayNumber + 68569) | 0;
	    var N = (4 * L / 146097) | 0;
	    L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
	    var I = ((4000 * (L + 1)) / 1461001) | 0;
	    L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
	    var J = ((80 * L) / 2447) | 0;
	    var day = (L - (((2447 * J) / 80) | 0)) | 0;
	    L = (J / 11) | 0;
	    var month = (J + 2 - 12 * L) | 0;
	    var year = (100 * (N - 49) + I + L) | 0;
	    var hour = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;
	    var remainingSeconds = secondsOfDay - (hour * TimeConstants.SECONDS_PER_HOUR);
	    var minute = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;
	    remainingSeconds = remainingSeconds - (minute * TimeConstants.SECONDS_PER_MINUTE);
	    var second = remainingSeconds | 0;
	    var millisecond = ((remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND);
	    hour += 12;
	    if (hour > 23) {
	      hour -= 24;
	    }
	    if (isLeapSecond) {
	      second += 1;
	    }
	    if (!defined(result)) {
	      return new GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond);
	    }
	    result.year = year;
	    result.month = month;
	    result.day = day;
	    result.hour = hour;
	    result.minute = minute;
	    result.second = second;
	    result.millisecond = millisecond;
	    result.isLeapSecond = isLeapSecond;
	    return result;
	  };
	  JulianDate.toDate = function(julianDate) {
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
	    var second = gDate.second;
	    if (gDate.isLeapSecond) {
	      second -= 1;
	    }
	    return new Date(Date.UTC(gDate.year, gDate.month - 1, gDate.day, gDate.hour, gDate.minute, second, gDate.millisecond));
	  };
	  JulianDate.toIso8601 = function(julianDate, precision) {
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    var gDate = JulianDate.toGregorianDate(julianDate, gDate);
	    var millisecondStr;
	    if (!defined(precision) && gDate.millisecond !== 0) {
	      millisecondStr = (gDate.millisecond * 0.01).toString().replace('.', '');
	      return sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
	    }
	    if (!defined(precision) || precision === 0) {
	      return sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second);
	    }
	    millisecondStr = (gDate.millisecond * 0.01).toFixed(precision).replace('.', '').slice(0, precision);
	    return sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
	  };
	  JulianDate.clone = function(julianDate, result) {
	    if (!defined(julianDate)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new JulianDate(julianDate.dayNumber, julianDate.secondsOfDay, TimeStandard.TAI);
	    }
	    result.dayNumber = julianDate.dayNumber;
	    result.secondsOfDay = julianDate.secondsOfDay;
	    return result;
	  };
	  JulianDate.compare = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required.');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required.');
	    }
	    var julianDayNumberDifference = left.dayNumber - right.dayNumber;
	    if (julianDayNumberDifference !== 0) {
	      return julianDayNumberDifference;
	    }
	    return left.secondsOfDay - right.secondsOfDay;
	  };
	  JulianDate.equals = function(left, right) {
	    return (left === right) || (defined(left) && defined(right) && left.dayNumber === right.dayNumber && left.secondsOfDay === right.secondsOfDay);
	  };
	  JulianDate.equalsEpsilon = function(left, right, epsilon) {
	    if (!defined(epsilon)) {
	      throw new DeveloperError('epsilon is required.');
	    }
	    return (left === right) || (defined(left) && defined(right) && Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon);
	  };
	  JulianDate.totalDays = function(julianDate) {
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    return julianDate.dayNumber + (julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY);
	  };
	  JulianDate.secondsDifference = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required.');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required.');
	    }
	    var dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;
	    return (dayDifference + (left.secondsOfDay - right.secondsOfDay));
	  };
	  JulianDate.daysDifference = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required.');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required.');
	    }
	    var dayDifference = (left.dayNumber - right.dayNumber);
	    var secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
	    return dayDifference + secondDifference;
	  };
	  JulianDate.computeTaiMinusUtc = function(julianDate) {
	    binarySearchScratchLeapSecond.julianDate = julianDate;
	    var leapSeconds = JulianDate.leapSeconds;
	    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
	    if (index < 0) {
	      index = ~index;
	      --index;
	      if (index < 0) {
	        index = 0;
	      }
	    }
	    return leapSeconds[index].offset;
	  };
	  JulianDate.addSeconds = function(julianDate, seconds, result) {
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    if (!defined(seconds)) {
	      throw new DeveloperError('seconds is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    return setComponents(julianDate.dayNumber, julianDate.secondsOfDay + seconds, result);
	  };
	  JulianDate.addMinutes = function(julianDate, minutes, result) {
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    if (!defined(minutes)) {
	      throw new DeveloperError('minutes is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    var newSecondsOfDay = julianDate.secondsOfDay + (minutes * TimeConstants.SECONDS_PER_MINUTE);
	    return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
	  };
	  JulianDate.addHours = function(julianDate, hours, result) {
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    if (!defined(hours)) {
	      throw new DeveloperError('hours is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    var newSecondsOfDay = julianDate.secondsOfDay + (hours * TimeConstants.SECONDS_PER_HOUR);
	    return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
	  };
	  JulianDate.addDays = function(julianDate, days, result) {
	    if (!defined(julianDate)) {
	      throw new DeveloperError('julianDate is required.');
	    }
	    if (!defined(days)) {
	      throw new DeveloperError('days is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    var newJulianDayNumber = julianDate.dayNumber + days;
	    return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);
	  };
	  JulianDate.lessThan = function(left, right) {
	    return JulianDate.compare(left, right) < 0;
	  };
	  JulianDate.lessThanOrEquals = function(left, right) {
	    return JulianDate.compare(left, right) <= 0;
	  };
	  JulianDate.greaterThan = function(left, right) {
	    return JulianDate.compare(left, right) > 0;
	  };
	  JulianDate.greaterThanOrEquals = function(left, right) {
	    return JulianDate.compare(left, right) >= 0;
	  };
	  JulianDate.prototype.clone = function(result) {
	    return JulianDate.clone(this, result);
	  };
	  JulianDate.prototype.equals = function(right) {
	    return JulianDate.equals(this, right);
	  };
	  JulianDate.prototype.equalsEpsilon = function(right, epsilon) {
	    return JulianDate.equalsEpsilon(this, right, epsilon);
	  };
	  JulianDate.prototype.toString = function() {
	    return JulianDate.toIso8601(this);
	  };
	  JulianDate.leapSeconds = [new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36)];
	  return JulianDate;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("52", ["1f"], function(freezeObject) {
	  'use strict';
	  var TimeConstants = {
	    SECONDS_PER_MILLISECOND: 0.001,
	    SECONDS_PER_MINUTE: 60.0,
	    MINUTES_PER_HOUR: 60.0,
	    HOURS_PER_DAY: 24.0,
	    SECONDS_PER_HOUR: 3600.0,
	    MINUTES_PER_DAY: 1440.0,
	    SECONDS_PER_DAY: 86400.0,
	    DAYS_PER_JULIAN_CENTURY: 36525.0,
	    PICOSECOND: 0.000000001,
	    MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5
	  };
	  return freezeObject(TimeConstants);
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("53", ["1f"], function(freezeObject) {
	  'use strict';
	  var TimeStandard = {
	    UTC: 0,
	    TAI: 1
	  };
	  return freezeObject(TimeStandard);
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("64", ["2c", "1a", "1c", "24", "27", "32", "52", "53"], function(Cartesian3, defined, DeveloperError, JulianDate, CesiumMath, Matrix3, TimeConstants, TimeStandard) {
	  'use strict';
	  var Simon1994PlanetaryPositions = {};
	  function computeTdbMinusTtSpice(daysSinceJ2000InTerrestrialTime) {
	    var g = 6.239996 + (0.0172019696544) * daysSinceJ2000InTerrestrialTime;
	    return 1.657e-3 * Math.sin(g + 1.671e-2 * Math.sin(g));
	  }
	  var TdtMinusTai = 32.184;
	  var J2000d = 2451545;
	  function taiToTdb(date, result) {
	    result = JulianDate.addSeconds(date, TdtMinusTai, result);
	    var days = JulianDate.totalDays(result) - J2000d;
	    result = JulianDate.addSeconds(result, computeTdbMinusTtSpice(days), result);
	    return result;
	  }
	  var epoch = new JulianDate(2451545, 0, TimeStandard.TAI);
	  var GravitationalParameterOfEarth = 3.98600435e14;
	  var GravitationalParameterOfSun = GravitationalParameterOfEarth * (1.0 + 0.012300034) * 328900.56;
	  var MetersPerKilometer = 1000.0;
	  var RadiansPerDegree = CesiumMath.RADIANS_PER_DEGREE;
	  var RadiansPerArcSecond = CesiumMath.RADIANS_PER_ARCSECOND;
	  var MetersPerAstronomicalUnit = 1.49597870e+11;
	  var perifocalToEquatorial = new Matrix3();
	  function elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, gravitationalParameter, result) {
	    if (inclination < 0.0) {
	      inclination = -inclination;
	      longitudeOfNode += CesiumMath.PI;
	    }
	    if (inclination < 0 || inclination > CesiumMath.PI) {
	      throw new DeveloperError('The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.');
	    }
	    var radiusOfPeriapsis = semimajorAxis * (1.0 - eccentricity);
	    var argumentOfPeriapsis = longitudeOfPerigee - longitudeOfNode;
	    var rightAscensionOfAscendingNode = longitudeOfNode;
	    var trueAnomaly = meanAnomalyToTrueAnomaly(meanLongitude - longitudeOfPerigee, eccentricity);
	    var type = chooseOrbit(eccentricity, 0.0);
	    if (type === 'Hyperbolic' && Math.abs(CesiumMath.negativePiToPi(trueAnomaly)) >= Math.acos(-1.0 / eccentricity)) {
	      throw new DeveloperError('The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.');
	    }
	    perifocalToCartesianMatrix(argumentOfPeriapsis, inclination, rightAscensionOfAscendingNode, perifocalToEquatorial);
	    var semilatus = radiusOfPeriapsis * (1.0 + eccentricity);
	    var costheta = Math.cos(trueAnomaly);
	    var sintheta = Math.sin(trueAnomaly);
	    var denom = (1.0 + eccentricity * costheta);
	    if (denom <= CesiumMath.Epsilon10) {
	      throw new DeveloperError('elements cannot be converted to cartesian');
	    }
	    var radius = semilatus / denom;
	    if (!defined(result)) {
	      result = new Cartesian3(radius * costheta, radius * sintheta, 0.0);
	    } else {
	      result.x = radius * costheta;
	      result.y = radius * sintheta;
	      result.z = 0.0;
	    }
	    return Matrix3.multiplyByVector(perifocalToEquatorial, result, result);
	  }
	  function chooseOrbit(eccentricity, tolerance) {
	    if (eccentricity < 0) {
	      throw new DeveloperError('eccentricity cannot be negative.');
	    } else if (eccentricity <= tolerance) {
	      return 'Circular';
	    } else if (eccentricity < 1.0 - tolerance) {
	      return 'Elliptical';
	    } else if (eccentricity <= 1.0 + tolerance) {
	      return 'Parabolic';
	    } else {
	      return 'Hyperbolic';
	    }
	  }
	  function meanAnomalyToTrueAnomaly(meanAnomaly, eccentricity) {
	    if (eccentricity < 0.0 || eccentricity >= 1.0) {
	      throw new DeveloperError('eccentricity out of range.');
	    }
	    var eccentricAnomaly = meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity);
	    return eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity);
	  }
	  var maxIterationCount = 50;
	  var keplerEqConvergence = CesiumMath.EPSILON8;
	  function meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity) {
	    if (eccentricity < 0.0 || eccentricity >= 1.0) {
	      throw new DeveloperError('eccentricity out of range.');
	    }
	    var revs = Math.floor(meanAnomaly / CesiumMath.TWO_PI);
	    meanAnomaly -= revs * CesiumMath.TWO_PI;
	    var iterationValue = meanAnomaly + (eccentricity * Math.sin(meanAnomaly)) / (1.0 - Math.sin(meanAnomaly + eccentricity) + Math.sin(meanAnomaly));
	    var eccentricAnomaly = Number.MAX_VALUE;
	    var count;
	    for (count = 0; count < maxIterationCount && Math.abs(eccentricAnomaly - iterationValue) > keplerEqConvergence; ++count) {
	      eccentricAnomaly = iterationValue;
	      var NRfunction = eccentricAnomaly - eccentricity * Math.sin(eccentricAnomaly) - meanAnomaly;
	      var dNRfunction = 1 - eccentricity * Math.cos(eccentricAnomaly);
	      iterationValue = eccentricAnomaly - NRfunction / dNRfunction;
	    }
	    if (count >= maxIterationCount) {
	      throw new DeveloperError('Kepler equation did not converge');
	    }
	    eccentricAnomaly = iterationValue + revs * CesiumMath.TWO_PI;
	    return eccentricAnomaly;
	  }
	  function eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity) {
	    if (eccentricity < 0.0 || eccentricity >= 1.0) {
	      throw new DeveloperError('eccentricity out of range.');
	    }
	    var revs = Math.floor(eccentricAnomaly / CesiumMath.TWO_PI);
	    eccentricAnomaly -= revs * CesiumMath.TWO_PI;
	    var trueAnomalyX = Math.cos(eccentricAnomaly) - eccentricity;
	    var trueAnomalyY = Math.sin(eccentricAnomaly) * Math.sqrt(1 - eccentricity * eccentricity);
	    var trueAnomaly = Math.atan2(trueAnomalyY, trueAnomalyX);
	    trueAnomaly = CesiumMath.zeroToTwoPi(trueAnomaly);
	    if (eccentricAnomaly < 0) {
	      trueAnomaly -= CesiumMath.TWO_PI;
	    }
	    trueAnomaly += revs * CesiumMath.TWO_PI;
	    return trueAnomaly;
	  }
	  function perifocalToCartesianMatrix(argumentOfPeriapsis, inclination, rightAscension, result) {
	    if (inclination < 0 || inclination > CesiumMath.PI) {
	      throw new DeveloperError('inclination out of range');
	    }
	    var cosap = Math.cos(argumentOfPeriapsis);
	    var sinap = Math.sin(argumentOfPeriapsis);
	    var cosi = Math.cos(inclination);
	    var sini = Math.sin(inclination);
	    var cosraan = Math.cos(rightAscension);
	    var sinraan = Math.sin(rightAscension);
	    if (!defined(result)) {
	      result = new Matrix3(cosraan * cosap - sinraan * sinap * cosi, -cosraan * sinap - sinraan * cosap * cosi, sinraan * sini, sinraan * cosap + cosraan * sinap * cosi, -sinraan * sinap + cosraan * cosap * cosi, -cosraan * sini, sinap * sini, cosap * sini, cosi);
	    } else {
	      result[0] = cosraan * cosap - sinraan * sinap * cosi;
	      result[1] = sinraan * cosap + cosraan * sinap * cosi;
	      result[2] = sinap * sini;
	      result[3] = -cosraan * sinap - sinraan * cosap * cosi;
	      result[4] = -sinraan * sinap + cosraan * cosap * cosi;
	      result[5] = cosap * sini;
	      result[6] = sinraan * sini;
	      result[7] = -cosraan * sini;
	      result[8] = cosi;
	    }
	    return result;
	  }
	  var semiMajorAxis0 = 1.0000010178 * MetersPerAstronomicalUnit;
	  var meanLongitude0 = 100.46645683 * RadiansPerDegree;
	  var meanLongitude1 = 1295977422.83429 * RadiansPerArcSecond;
	  var p1u = 16002;
	  var p2u = 21863;
	  var p3u = 32004;
	  var p4u = 10931;
	  var p5u = 14529;
	  var p6u = 16368;
	  var p7u = 15318;
	  var p8u = 32794;
	  var Ca1 = 64 * 1e-7 * MetersPerAstronomicalUnit;
	  var Ca2 = -152 * 1e-7 * MetersPerAstronomicalUnit;
	  var Ca3 = 62 * 1e-7 * MetersPerAstronomicalUnit;
	  var Ca4 = -8 * 1e-7 * MetersPerAstronomicalUnit;
	  var Ca5 = 32 * 1e-7 * MetersPerAstronomicalUnit;
	  var Ca6 = -41 * 1e-7 * MetersPerAstronomicalUnit;
	  var Ca7 = 19 * 1e-7 * MetersPerAstronomicalUnit;
	  var Ca8 = -11 * 1e-7 * MetersPerAstronomicalUnit;
	  var Sa1 = -150 * 1e-7 * MetersPerAstronomicalUnit;
	  var Sa2 = -46 * 1e-7 * MetersPerAstronomicalUnit;
	  var Sa3 = 68 * 1e-7 * MetersPerAstronomicalUnit;
	  var Sa4 = 54 * 1e-7 * MetersPerAstronomicalUnit;
	  var Sa5 = 14 * 1e-7 * MetersPerAstronomicalUnit;
	  var Sa6 = 24 * 1e-7 * MetersPerAstronomicalUnit;
	  var Sa7 = -28 * 1e-7 * MetersPerAstronomicalUnit;
	  var Sa8 = 22 * 1e-7 * MetersPerAstronomicalUnit;
	  var q1u = 10;
	  var q2u = 16002;
	  var q3u = 21863;
	  var q4u = 10931;
	  var q5u = 1473;
	  var q6u = 32004;
	  var q7u = 4387;
	  var q8u = 73;
	  var Cl1 = -325 * 1e-7;
	  var Cl2 = -322 * 1e-7;
	  var Cl3 = -79 * 1e-7;
	  var Cl4 = 232 * 1e-7;
	  var Cl5 = -52 * 1e-7;
	  var Cl6 = 97 * 1e-7;
	  var Cl7 = 55 * 1e-7;
	  var Cl8 = -41 * 1e-7;
	  var Sl1 = -105 * 1e-7;
	  var Sl2 = -137 * 1e-7;
	  var Sl3 = 258 * 1e-7;
	  var Sl4 = 35 * 1e-7;
	  var Sl5 = -116 * 1e-7;
	  var Sl6 = -88 * 1e-7;
	  var Sl7 = -112 * 1e-7;
	  var Sl8 = -80 * 1e-7;
	  var scratchDate = new JulianDate(0, 0.0, TimeStandard.TAI);
	  function computeSimonEarthMoonBarycenter(date, result) {
	    taiToTdb(date, scratchDate);
	    var x = (scratchDate.dayNumber - epoch.dayNumber) + ((scratchDate.secondsOfDay - epoch.secondsOfDay) / TimeConstants.SECONDS_PER_DAY);
	    var t = x / (TimeConstants.DAYS_PER_JULIAN_CENTURY * 10.0);
	    var u = 0.35953620 * t;
	    var semimajorAxis = semiMajorAxis0 + Ca1 * Math.cos(p1u * u) + Sa1 * Math.sin(p1u * u) + Ca2 * Math.cos(p2u * u) + Sa2 * Math.sin(p2u * u) + Ca3 * Math.cos(p3u * u) + Sa3 * Math.sin(p3u * u) + Ca4 * Math.cos(p4u * u) + Sa4 * Math.sin(p4u * u) + Ca5 * Math.cos(p5u * u) + Sa5 * Math.sin(p5u * u) + Ca6 * Math.cos(p6u * u) + Sa6 * Math.sin(p6u * u) + Ca7 * Math.cos(p7u * u) + Sa7 * Math.sin(p7u * u) + Ca8 * Math.cos(p8u * u) + Sa8 * Math.sin(p8u * u);
	    var meanLongitude = meanLongitude0 + meanLongitude1 * t + Cl1 * Math.cos(q1u * u) + Sl1 * Math.sin(q1u * u) + Cl2 * Math.cos(q2u * u) + Sl2 * Math.sin(q2u * u) + Cl3 * Math.cos(q3u * u) + Sl3 * Math.sin(q3u * u) + Cl4 * Math.cos(q4u * u) + Sl4 * Math.sin(q4u * u) + Cl5 * Math.cos(q5u * u) + Sl5 * Math.sin(q5u * u) + Cl6 * Math.cos(q6u * u) + Sl6 * Math.sin(q6u * u) + Cl7 * Math.cos(q7u * u) + Sl7 * Math.sin(q7u * u) + Cl8 * Math.cos(q8u * u) + Sl8 * Math.sin(q8u * u);
	    var eccentricity = 0.0167086342 - 0.0004203654 * t;
	    var longitudeOfPerigee = 102.93734808 * RadiansPerDegree + 11612.35290 * RadiansPerArcSecond * t;
	    var inclination = 469.97289 * RadiansPerArcSecond * t;
	    var longitudeOfNode = 174.87317577 * RadiansPerDegree - 8679.27034 * RadiansPerArcSecond * t;
	    return elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, GravitationalParameterOfSun, result);
	  }
	  function computeSimonMoon(date, result) {
	    taiToTdb(date, scratchDate);
	    var x = (scratchDate.dayNumber - epoch.dayNumber) + ((scratchDate.secondsOfDay - epoch.secondsOfDay) / TimeConstants.SECONDS_PER_DAY);
	    var t = x / (TimeConstants.DAYS_PER_JULIAN_CENTURY);
	    var t2 = t * t;
	    var t3 = t2 * t;
	    var t4 = t3 * t;
	    var semimajorAxis = 383397.7725 + 0.0040 * t;
	    var eccentricity = 0.055545526 - 0.000000016 * t;
	    var inclinationConstant = 5.15668983 * RadiansPerDegree;
	    var inclinationSecPart = -0.00008 * t + 0.02966 * t2 - 0.000042 * t3 - 0.00000013 * t4;
	    var longitudeOfPerigeeConstant = 83.35324312 * RadiansPerDegree;
	    var longitudeOfPerigeeSecPart = 14643420.2669 * t - 38.2702 * t2 - 0.045047 * t3 + 0.00021301 * t4;
	    var longitudeOfNodeConstant = 125.04455501 * RadiansPerDegree;
	    var longitudeOfNodeSecPart = -6967919.3631 * t + 6.3602 * t2 + 0.007625 * t3 - 0.00003586 * t4;
	    var meanLongitudeConstant = 218.31664563 * RadiansPerDegree;
	    var meanLongitudeSecPart = 1732559343.48470 * t - 6.3910 * t2 + 0.006588 * t3 - 0.00003169 * t4;
	    var D = 297.85019547 * RadiansPerDegree + RadiansPerArcSecond * (1602961601.2090 * t - 6.3706 * t2 + 0.006593 * t3 - 0.00003169 * t4);
	    var F = 93.27209062 * RadiansPerDegree + RadiansPerArcSecond * (1739527262.8478 * t - 12.7512 * t2 - 0.001037 * t3 + 0.00000417 * t4);
	    var l = 134.96340251 * RadiansPerDegree + RadiansPerArcSecond * (1717915923.2178 * t + 31.8792 * t2 + 0.051635 * t3 - 0.00024470 * t4);
	    var lprime = 357.52910918 * RadiansPerDegree + RadiansPerArcSecond * (129596581.0481 * t - 0.5532 * t2 + 0.000136 * t3 - 0.00001149 * t4);
	    var psi = 310.17137918 * RadiansPerDegree - RadiansPerArcSecond * (6967051.4360 * t + 6.2068 * t2 + 0.007618 * t3 - 0.00003219 * t4);
	    var twoD = 2.0 * D;
	    var fourD = 4.0 * D;
	    var sixD = 6.0 * D;
	    var twol = 2.0 * l;
	    var threel = 3.0 * l;
	    var fourl = 4.0 * l;
	    var twoF = 2.0 * F;
	    semimajorAxis += 3400.4 * Math.cos(twoD) - 635.6 * Math.cos(twoD - l) - 235.6 * Math.cos(l) + 218.1 * Math.cos(twoD - lprime) + 181.0 * Math.cos(twoD + l);
	    eccentricity += 0.014216 * Math.cos(twoD - l) + 0.008551 * Math.cos(twoD - twol) - 0.001383 * Math.cos(l) + 0.001356 * Math.cos(twoD + l) - 0.001147 * Math.cos(fourD - threel) - 0.000914 * Math.cos(fourD - twol) + 0.000869 * Math.cos(twoD - lprime - l) - 0.000627 * Math.cos(twoD) - 0.000394 * Math.cos(fourD - fourl) + 0.000282 * Math.cos(twoD - lprime - twol) - 0.000279 * Math.cos(D - l) - 0.000236 * Math.cos(twol) + 0.000231 * Math.cos(fourD) + 0.000229 * Math.cos(sixD - fourl) - 0.000201 * Math.cos(twol - twoF);
	    inclinationSecPart += 486.26 * Math.cos(twoD - twoF) - 40.13 * Math.cos(twoD) + 37.51 * Math.cos(twoF) + 25.73 * Math.cos(twol - twoF) + 19.97 * Math.cos(twoD - lprime - twoF);
	    longitudeOfPerigeeSecPart += -55609 * Math.sin(twoD - l) - 34711 * Math.sin(twoD - twol) - 9792 * Math.sin(l) + 9385 * Math.sin(fourD - threel) + 7505 * Math.sin(fourD - twol) + 5318 * Math.sin(twoD + l) + 3484 * Math.sin(fourD - fourl) - 3417 * Math.sin(twoD - lprime - l) - 2530 * Math.sin(sixD - fourl) - 2376 * Math.sin(twoD) - 2075 * Math.sin(twoD - threel) - 1883 * Math.sin(twol) - 1736 * Math.sin(sixD - 5.0 * l) + 1626 * Math.sin(lprime) - 1370 * Math.sin(sixD - threel);
	    longitudeOfNodeSecPart += -5392 * Math.sin(twoD - twoF) - 540 * Math.sin(lprime) - 441 * Math.sin(twoD) + 423 * Math.sin(twoF) - 288 * Math.sin(twol - twoF);
	    meanLongitudeSecPart += -3332.9 * Math.sin(twoD) + 1197.4 * Math.sin(twoD - l) - 662.5 * Math.sin(lprime) + 396.3 * Math.sin(l) - 218.0 * Math.sin(twoD - lprime);
	    var twoPsi = 2.0 * psi;
	    var threePsi = 3.0 * psi;
	    inclinationSecPart += 46.997 * Math.cos(psi) * t - 0.614 * Math.cos(twoD - twoF + psi) * t + 0.614 * Math.cos(twoD - twoF - psi) * t - 0.0297 * Math.cos(twoPsi) * t2 - 0.0335 * Math.cos(psi) * t2 + 0.0012 * Math.cos(twoD - twoF + twoPsi) * t2 - 0.00016 * Math.cos(psi) * t3 + 0.00004 * Math.cos(threePsi) * t3 + 0.00004 * Math.cos(twoPsi) * t3;
	    var perigeeAndMean = 2.116 * Math.sin(psi) * t - 0.111 * Math.sin(twoD - twoF - psi) * t - 0.0015 * Math.sin(psi) * t2;
	    longitudeOfPerigeeSecPart += perigeeAndMean;
	    meanLongitudeSecPart += perigeeAndMean;
	    longitudeOfNodeSecPart += -520.77 * Math.sin(psi) * t + 13.66 * Math.sin(twoD - twoF + psi) * t + 1.12 * Math.sin(twoD - psi) * t - 1.06 * Math.sin(twoF - psi) * t + 0.660 * Math.sin(twoPsi) * t2 + 0.371 * Math.sin(psi) * t2 - 0.035 * Math.sin(twoD - twoF + twoPsi) * t2 - 0.015 * Math.sin(twoD - twoF + psi) * t2 + 0.0014 * Math.sin(psi) * t3 - 0.0011 * Math.sin(threePsi) * t3 - 0.0009 * Math.sin(twoPsi) * t3;
	    semimajorAxis *= MetersPerKilometer;
	    var inclination = inclinationConstant + inclinationSecPart * RadiansPerArcSecond;
	    var longitudeOfPerigee = longitudeOfPerigeeConstant + longitudeOfPerigeeSecPart * RadiansPerArcSecond;
	    var meanLongitude = meanLongitudeConstant + meanLongitudeSecPart * RadiansPerArcSecond;
	    var longitudeOfNode = longitudeOfNodeConstant + longitudeOfNodeSecPart * RadiansPerArcSecond;
	    return elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, GravitationalParameterOfEarth, result);
	  }
	  var moonEarthMassRatio = 0.012300034;
	  var factor = moonEarthMassRatio / (moonEarthMassRatio + 1.0) * -1;
	  function computeSimonEarth(date, result) {
	    result = computeSimonMoon(date, result);
	    return Cartesian3.multiplyByScalar(result, factor, result);
	  }
	  var axesTransformation = new Matrix3(1.0000000000000002, 5.619723173785822e-16, 4.690511510146299e-19, -5.154129427414611e-16, 0.9174820620691819, -0.39777715593191376, -2.23970096136568e-16, 0.39777715593191376, 0.9174820620691819);
	  var translation = new Cartesian3();
	  Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame = function(date, result) {
	    if (!defined(date)) {
	      date = JulianDate.now();
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    translation = computeSimonEarthMoonBarycenter(date, translation);
	    result = Cartesian3.negate(translation, result);
	    computeSimonEarth(date, translation);
	    Cartesian3.subtract(result, translation, result);
	    Matrix3.multiplyByVector(axesTransformation, result, result);
	    return result;
	  };
	  Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame = function(date, result) {
	    if (!defined(date)) {
	      date = JulianDate.now();
	    }
	    result = computeSimonMoon(date, result);
	    Matrix3.multiplyByVector(axesTransformation, result, result);
	    return result;
	  };
	  return Simon1994PlanetaryPositions;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("3c", ["2c", "3b", "23", "1a", "1b", "1c", "1f", "27", "65"], function(Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, freezeObject, CesiumMath, scaleToGeodeticSurface) {
	  'use strict';
	  function initialize(ellipsoid, x, y, z) {
	    x = defaultValue(x, 0.0);
	    y = defaultValue(y, 0.0);
	    z = defaultValue(z, 0.0);
	    if (x < 0.0 || y < 0.0 || z < 0.0) {
	      throw new DeveloperError('All radii components must be greater than or equal to zero.');
	    }
	    ellipsoid._radii = new Cartesian3(x, y, z);
	    ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);
	    ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x, y * y * y * y, z * z * z * z);
	    ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);
	    ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));
	    ellipsoid._minimumRadius = Math.min(x, y, z);
	    ellipsoid._maximumRadius = Math.max(x, y, z);
	    ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;
	  }
	  function Ellipsoid(x, y, z) {
	    this._radii = undefined;
	    this._radiiSquared = undefined;
	    this._radiiToTheFourth = undefined;
	    this._oneOverRadii = undefined;
	    this._oneOverRadiiSquared = undefined;
	    this._minimumRadius = undefined;
	    this._maximumRadius = undefined;
	    this._centerToleranceSquared = undefined;
	    initialize(this, x, y, z);
	  }
	  defineProperties(Ellipsoid.prototype, {
	    radii: {get: function() {
	        return this._radii;
	      }},
	    radiiSquared: {get: function() {
	        return this._radiiSquared;
	      }},
	    radiiToTheFourth: {get: function() {
	        return this._radiiToTheFourth;
	      }},
	    oneOverRadii: {get: function() {
	        return this._oneOverRadii;
	      }},
	    oneOverRadiiSquared: {get: function() {
	        return this._oneOverRadiiSquared;
	      }},
	    minimumRadius: {get: function() {
	        return this._minimumRadius;
	      }},
	    maximumRadius: {get: function() {
	        return this._maximumRadius;
	      }}
	  });
	  Ellipsoid.clone = function(ellipsoid, result) {
	    if (!defined(ellipsoid)) {
	      return undefined;
	    }
	    var radii = ellipsoid._radii;
	    if (!defined(result)) {
	      return new Ellipsoid(radii.x, radii.y, radii.z);
	    }
	    Cartesian3.clone(radii, result._radii);
	    Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);
	    Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);
	    Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);
	    Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);
	    result._minimumRadius = ellipsoid._minimumRadius;
	    result._maximumRadius = ellipsoid._maximumRadius;
	    result._centerToleranceSquared = ellipsoid._centerToleranceSquared;
	    return result;
	  };
	  Ellipsoid.fromCartesian3 = function(cartesian, result) {
	    if (!defined(result)) {
	      result = new Ellipsoid();
	    }
	    if (!defined(cartesian)) {
	      return result;
	    }
	    initialize(result, cartesian.x, cartesian.y, cartesian.z);
	    return result;
	  };
	  Ellipsoid.WGS84 = freezeObject(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));
	  Ellipsoid.UNIT_SPHERE = freezeObject(new Ellipsoid(1.0, 1.0, 1.0));
	  Ellipsoid.MOON = freezeObject(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));
	  Ellipsoid.prototype.clone = function(result) {
	    return Ellipsoid.clone(this, result);
	  };
	  Ellipsoid.packedLength = Cartesian3.packedLength;
	  Ellipsoid.pack = function(value, array, startingIndex) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required');
	    }
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    Cartesian3.pack(value._radii, array, startingIndex);
	  };
	  Ellipsoid.unpack = function(array, startingIndex, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    var radii = Cartesian3.unpack(array, startingIndex);
	    return Ellipsoid.fromCartesian3(radii, result);
	  };
	  Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;
	  Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {
	    if (!defined(cartographic)) {
	      throw new DeveloperError('cartographic is required.');
	    }
	    var longitude = cartographic.longitude;
	    var latitude = cartographic.latitude;
	    var cosLatitude = Math.cos(latitude);
	    var x = cosLatitude * Math.cos(longitude);
	    var y = cosLatitude * Math.sin(longitude);
	    var z = Math.sin(latitude);
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return Cartesian3.normalize(result, result);
	  };
	  Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);
	    return Cartesian3.normalize(result, result);
	  };
	  var cartographicToCartesianNormal = new Cartesian3();
	  var cartographicToCartesianK = new Cartesian3();
	  Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {
	    var n = cartographicToCartesianNormal;
	    var k = cartographicToCartesianK;
	    this.geodeticSurfaceNormalCartographic(cartographic, n);
	    Cartesian3.multiplyComponents(this._radiiSquared, n, k);
	    var gamma = Math.sqrt(Cartesian3.dot(n, k));
	    Cartesian3.divideByScalar(k, gamma, k);
	    Cartesian3.multiplyByScalar(n, cartographic.height, n);
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    return Cartesian3.add(k, n, result);
	  };
	  Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {
	    if (!defined(cartographics)) {
	      throw new DeveloperError('cartographics is required.');
	    }
	    var length = cartographics.length;
	    if (!defined(result)) {
	      result = new Array(length);
	    } else {
	      result.length = length;
	    }
	    for (var i = 0; i < length; i++) {
	      result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
	    }
	    return result;
	  };
	  var cartesianToCartographicN = new Cartesian3();
	  var cartesianToCartographicP = new Cartesian3();
	  var cartesianToCartographicH = new Cartesian3();
	  Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {
	    var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);
	    if (!defined(p)) {
	      return undefined;
	    }
	    var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);
	    var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);
	    var longitude = Math.atan2(n.y, n.x);
	    var latitude = Math.asin(n.z);
	    var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);
	    if (!defined(result)) {
	      return new Cartographic(longitude, latitude, height);
	    }
	    result.longitude = longitude;
	    result.latitude = latitude;
	    result.height = height;
	    return result;
	  };
	  Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {
	    if (!defined(cartesians)) {
	      throw new DeveloperError('cartesians is required.');
	    }
	    var length = cartesians.length;
	    if (!defined(result)) {
	      result = new Array(length);
	    } else {
	      result.length = length;
	    }
	    for (var i = 0; i < length; ++i) {
	      result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
	    }
	    return result;
	  };
	  Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {
	    return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);
	  };
	  Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required.');
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    var positionX = cartesian.x;
	    var positionY = cartesian.y;
	    var positionZ = cartesian.z;
	    var oneOverRadiiSquared = this._oneOverRadiiSquared;
	    var beta = 1.0 / Math.sqrt((positionX * positionX) * oneOverRadiiSquared.x + (positionY * positionY) * oneOverRadiiSquared.y + (positionZ * positionZ) * oneOverRadiiSquared.z);
	    return Cartesian3.multiplyByScalar(cartesian, beta, result);
	  };
	  Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);
	  };
	  Ellipsoid.prototype.transformPositionFromScaledSpace = function(position, result) {
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    return Cartesian3.multiplyComponents(position, this._radii, result);
	  };
	  Ellipsoid.prototype.equals = function(right) {
	    return (this === right) || (defined(right) && Cartesian3.equals(this._radii, right._radii));
	  };
	  Ellipsoid.prototype.toString = function() {
	    return this._radii.toString();
	  };
	  return Ellipsoid;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("66", ["2c", "3b", "23", "1a", "1b", "1c", "3c", "27"], function(Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid, CesiumMath) {
	  'use strict';
	  function setConstants(ellipsoidGeodesic) {
	    var uSquared = ellipsoidGeodesic._uSquared;
	    var a = ellipsoidGeodesic._ellipsoid.maximumRadius;
	    var b = ellipsoidGeodesic._ellipsoid.minimumRadius;
	    var f = (a - b) / a;
	    var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);
	    var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);
	    var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);
	    var cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);
	    var sineU = cosineU * tanU;
	    var sigma = Math.atan2(tanU, cosineHeading);
	    var sineAlpha = cosineU * sineHeading;
	    var sineSquaredAlpha = sineAlpha * sineAlpha;
	    var cosineSquaredAlpha = 1.0 - sineSquaredAlpha;
	    var cosineAlpha = Math.sqrt(cosineSquaredAlpha);
	    var u2Over4 = uSquared / 4.0;
	    var u4Over16 = u2Over4 * u2Over4;
	    var u6Over64 = u4Over16 * u2Over4;
	    var u8Over256 = u4Over16 * u4Over16;
	    var a0 = (1.0 + u2Over4 - 3.0 * u4Over16 / 4.0 + 5.0 * u6Over64 / 4.0 - 175.0 * u8Over256 / 64.0);
	    var a1 = (1.0 - u2Over4 + 15.0 * u4Over16 / 8.0 - 35.0 * u6Over64 / 8.0);
	    var a2 = (1.0 - 3.0 * u2Over4 + 35.0 * u4Over16 / 4.0);
	    var a3 = (1.0 - 5.0 * u2Over4);
	    var distanceRatio = a0 * sigma - a1 * Math.sin(2.0 * sigma) * u2Over4 / 2.0 - a2 * Math.sin(4.0 * sigma) * u4Over16 / 16.0 - a3 * Math.sin(6.0 * sigma) * u6Over64 / 48.0 - Math.sin(8.0 * sigma) * 5.0 * u8Over256 / 512;
	    var constants = ellipsoidGeodesic._constants;
	    constants.a = a;
	    constants.b = b;
	    constants.f = f;
	    constants.cosineHeading = cosineHeading;
	    constants.sineHeading = sineHeading;
	    constants.tanU = tanU;
	    constants.cosineU = cosineU;
	    constants.sineU = sineU;
	    constants.sigma = sigma;
	    constants.sineAlpha = sineAlpha;
	    constants.sineSquaredAlpha = sineSquaredAlpha;
	    constants.cosineSquaredAlpha = cosineSquaredAlpha;
	    constants.cosineAlpha = cosineAlpha;
	    constants.u2Over4 = u2Over4;
	    constants.u4Over16 = u4Over16;
	    constants.u6Over64 = u6Over64;
	    constants.u8Over256 = u8Over256;
	    constants.a0 = a0;
	    constants.a1 = a1;
	    constants.a2 = a2;
	    constants.a3 = a3;
	    constants.distanceRatio = distanceRatio;
	  }
	  function computeC(f, cosineSquaredAlpha) {
	    return f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha)) / 16.0;
	  }
	  function computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {
	    var C = computeC(f, cosineSquaredAlpha);
	    return (1.0 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint + C * cosineSigma * (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)));
	  }
	  function vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {
	    var eff = (major - minor) / major;
	    var l = secondLongitude - firstLongitude;
	    var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));
	    var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));
	    var cosineU1 = Math.cos(u1);
	    var sineU1 = Math.sin(u1);
	    var cosineU2 = Math.cos(u2);
	    var sineU2 = Math.sin(u2);
	    var cc = cosineU1 * cosineU2;
	    var cs = cosineU1 * sineU2;
	    var ss = sineU1 * sineU2;
	    var sc = sineU1 * cosineU2;
	    var lambda = l;
	    var lambdaDot = CesiumMath.TWO_PI;
	    var cosineLambda = Math.cos(lambda);
	    var sineLambda = Math.sin(lambda);
	    var sigma;
	    var cosineSigma;
	    var sineSigma;
	    var cosineSquaredAlpha;
	    var cosineTwiceSigmaMidpoint;
	    do {
	      cosineLambda = Math.cos(lambda);
	      sineLambda = Math.sin(lambda);
	      var temp = cs - sc * cosineLambda;
	      sineSigma = Math.sqrt(cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp);
	      cosineSigma = ss + cc * cosineLambda;
	      sigma = Math.atan2(sineSigma, cosineSigma);
	      var sineAlpha;
	      if (sineSigma === 0.0) {
	        sineAlpha = 0.0;
	        cosineSquaredAlpha = 1.0;
	      } else {
	        sineAlpha = cc * sineLambda / sineSigma;
	        cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;
	      }
	      lambdaDot = lambda;
	      cosineTwiceSigmaMidpoint = cosineSigma - 2.0 * ss / cosineSquaredAlpha;
	      if (isNaN(cosineTwiceSigmaMidpoint)) {
	        cosineTwiceSigmaMidpoint = 0.0;
	      }
	      lambda = l + computeDeltaLambda(eff, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);
	    } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);
	    var uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);
	    var A = 1.0 + uSquared * (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0)) / 16384.0;
	    var B = uSquared * (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0)) / 1024.0;
	    var cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;
	    var deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) - B * cosineTwiceSigmaMidpoint * (4.0 * sineSigma * sineSigma - 3.0) * (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0) / 6.0) / 4.0);
	    var distance = minor * A * (sigma - deltaSigma);
	    var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);
	    var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);
	    ellipsoidGeodesic._distance = distance;
	    ellipsoidGeodesic._startHeading = startHeading;
	    ellipsoidGeodesic._endHeading = endHeading;
	    ellipsoidGeodesic._uSquared = uSquared;
	  }
	  function computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {
	    var firstCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(start, scratchCart2), scratchCart1);
	    var lastCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(end, scratchCart2), scratchCart2);
	    if (Math.abs(Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI) < 0.0125) {
	      throw new DeveloperError('geodesic position is not unique');
	    }
	    vincentyInverseFormula(ellipsoidGeodesic, ellipsoid.maximumRadius, ellipsoid.minimumRadius, start.longitude, start.latitude, end.longitude, end.latitude);
	    ellipsoidGeodesic._start = Cartographic.clone(start, ellipsoidGeodesic._start);
	    ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);
	    ellipsoidGeodesic._start.height = 0;
	    ellipsoidGeodesic._end.height = 0;
	    setConstants(ellipsoidGeodesic);
	  }
	  var scratchCart1 = new Cartesian3();
	  var scratchCart2 = new Cartesian3();
	  function EllipsoidGeodesic(start, end, ellipsoid) {
	    var e = defaultValue(ellipsoid, Ellipsoid.WGS84);
	    this._ellipsoid = e;
	    this._start = new Cartographic();
	    this._end = new Cartographic();
	    this._constants = {};
	    this._startHeading = undefined;
	    this._endHeading = undefined;
	    this._distance = undefined;
	    this._uSquared = undefined;
	    if (defined(start) && defined(end)) {
	      computeProperties(this, start, end, e);
	    }
	  }
	  defineProperties(EllipsoidGeodesic.prototype, {
	    ellipsoid: {get: function() {
	        return this._ellipsoid;
	      }},
	    surfaceDistance: {get: function() {
	        if (!defined(this._distance)) {
	          throw new DeveloperError('set end positions before getting surfaceDistance');
	        }
	        return this._distance;
	      }},
	    start: {get: function() {
	        return this._start;
	      }},
	    end: {get: function() {
	        return this._end;
	      }},
	    startHeading: {get: function() {
	        if (!defined(this._distance)) {
	          throw new DeveloperError('set end positions before getting startHeading');
	        }
	        return this._startHeading;
	      }},
	    endHeading: {get: function() {
	        if (!defined(this._distance)) {
	          throw new DeveloperError('set end positions before getting endHeading');
	        }
	        return this._endHeading;
	      }}
	  });
	  EllipsoidGeodesic.prototype.setEndPoints = function(start, end) {
	    if (!defined(start)) {
	      throw new DeveloperError('start cartographic position is required');
	    }
	    if (!defined(end)) {
	      throw new DeveloperError('end cartgraphic position is required');
	    }
	    computeProperties(this, start, end, this._ellipsoid);
	  };
	  EllipsoidGeodesic.prototype.interpolateUsingFraction = function(fraction, result) {
	    return this.interpolateUsingSurfaceDistance(this._distance * fraction, result);
	  };
	  EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function(distance, result) {
	    if (!defined(this._distance)) {
	      throw new DeveloperError('start and end must be set before calling funciton interpolateUsingSurfaceDistance');
	    }
	    var constants = this._constants;
	    var s = constants.distanceRatio + distance / constants.b;
	    var cosine2S = Math.cos(2.0 * s);
	    var cosine4S = Math.cos(4.0 * s);
	    var cosine6S = Math.cos(6.0 * s);
	    var sine2S = Math.sin(2.0 * s);
	    var sine4S = Math.sin(4.0 * s);
	    var sine6S = Math.sin(6.0 * s);
	    var sine8S = Math.sin(8.0 * s);
	    var s2 = s * s;
	    var s3 = s * s2;
	    var u8Over256 = constants.u8Over256;
	    var u2Over4 = constants.u2Over4;
	    var u6Over64 = constants.u6Over64;
	    var u4Over16 = constants.u4Over16;
	    var sigma = 2.0 * s3 * u8Over256 * cosine2S / 3.0 + s * (1.0 - u2Over4 + 7.0 * u4Over16 / 4.0 - 15.0 * u6Over64 / 4.0 + 579.0 * u8Over256 / 64.0 - (u4Over16 - 15.0 * u6Over64 / 4.0 + 187.0 * u8Over256 / 16.0) * cosine2S - (5.0 * u6Over64 / 4.0 - 115.0 * u8Over256 / 16.0) * cosine4S - 29.0 * u8Over256 * cosine6S / 16.0) + (u2Over4 / 2.0 - u4Over16 + 71.0 * u6Over64 / 32.0 - 85.0 * u8Over256 / 16.0) * sine2S + (5.0 * u4Over16 / 16.0 - 5.0 * u6Over64 / 4.0 + 383.0 * u8Over256 / 96.0) * sine4S - s2 * ((u6Over64 - 11.0 * u8Over256 / 2.0) * sine2S + 5.0 * u8Over256 * sine4S / 2.0) + (29.0 * u6Over64 / 96.0 - 29.0 * u8Over256 / 16.0) * sine6S + 539.0 * u8Over256 * sine8S / 1536.0;
	    var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);
	    var latitude = Math.atan(constants.a / constants.b * Math.tan(theta));
	    sigma = sigma - constants.sigma;
	    var cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);
	    var sineSigma = Math.sin(sigma);
	    var cosineSigma = Math.cos(sigma);
	    var cc = constants.cosineU * cosineSigma;
	    var ss = constants.sineU * sineSigma;
	    var lambda = Math.atan2(sineSigma * constants.sineHeading, cc - ss * constants.cosineHeading);
	    var l = lambda - computeDeltaLambda(constants.f, constants.sineAlpha, constants.cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);
	    if (defined(result)) {
	      result.longitude = this._start.longitude + l;
	      result.latitude = latitude;
	      result.height = 0.0;
	      return result;
	    }
	    return new Cartographic(this._start.longitude + l, latitude, 0.0);
	  };
	  return EllipsoidGeodesic;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("65", ["2c", "1a", "1c", "27"], function(Cartesian3, defined, DeveloperError, CesiumMath) {
	  'use strict';
	  var scaleToGeodeticSurfaceIntersection = new Cartesian3();
	  var scaleToGeodeticSurfaceGradient = new Cartesian3();
	  function scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required.');
	    }
	    if (!defined(oneOverRadii)) {
	      throw new DeveloperError('oneOverRadii is required.');
	    }
	    if (!defined(oneOverRadiiSquared)) {
	      throw new DeveloperError('oneOverRadiiSquared is required.');
	    }
	    if (!defined(centerToleranceSquared)) {
	      throw new DeveloperError('centerToleranceSquared is required.');
	    }
	    var positionX = cartesian.x;
	    var positionY = cartesian.y;
	    var positionZ = cartesian.z;
	    var oneOverRadiiX = oneOverRadii.x;
	    var oneOverRadiiY = oneOverRadii.y;
	    var oneOverRadiiZ = oneOverRadii.z;
	    var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
	    var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
	    var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
	    var squaredNorm = x2 + y2 + z2;
	    var ratio = Math.sqrt(1.0 / squaredNorm);
	    var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);
	    if (squaredNorm < centerToleranceSquared) {
	      return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);
	    }
	    var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
	    var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
	    var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
	    var gradient = scaleToGeodeticSurfaceGradient;
	    gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;
	    gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;
	    gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;
	    var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));
	    var correction = 0.0;
	    var func;
	    var denominator;
	    var xMultiplier;
	    var yMultiplier;
	    var zMultiplier;
	    var xMultiplier2;
	    var yMultiplier2;
	    var zMultiplier2;
	    var xMultiplier3;
	    var yMultiplier3;
	    var zMultiplier3;
	    do {
	      lambda -= correction;
	      xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);
	      yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);
	      zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);
	      xMultiplier2 = xMultiplier * xMultiplier;
	      yMultiplier2 = yMultiplier * yMultiplier;
	      zMultiplier2 = zMultiplier * zMultiplier;
	      xMultiplier3 = xMultiplier2 * xMultiplier;
	      yMultiplier3 = yMultiplier2 * yMultiplier;
	      zMultiplier3 = zMultiplier2 * zMultiplier;
	      func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;
	      denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
	      var derivative = -2.0 * denominator;
	      correction = func / derivative;
	    } while (Math.abs(func) > CesiumMath.EPSILON12);
	    if (!defined(result)) {
	      return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);
	    }
	    result.x = positionX * xMultiplier;
	    result.y = positionY * yMultiplier;
	    result.z = positionZ * zMultiplier;
	    return result;
	  }
	  return scaleToGeodeticSurface;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("3b", ["2c", "23", "1a", "1c", "1f", "27", "65"], function(Cartesian3, defaultValue, defined, DeveloperError, freezeObject, CesiumMath, scaleToGeodeticSurface) {
	  'use strict';
	  function Cartographic(longitude, latitude, height) {
	    this.longitude = defaultValue(longitude, 0.0);
	    this.latitude = defaultValue(latitude, 0.0);
	    this.height = defaultValue(height, 0.0);
	  }
	  Cartographic.fromRadians = function(longitude, latitude, height, result) {
	    if (!defined(longitude)) {
	      throw new DeveloperError('longitude is required.');
	    }
	    if (!defined(latitude)) {
	      throw new DeveloperError('latitude is required.');
	    }
	    height = defaultValue(height, 0.0);
	    if (!defined(result)) {
	      return new Cartographic(longitude, latitude, height);
	    }
	    result.longitude = longitude;
	    result.latitude = latitude;
	    result.height = height;
	    return result;
	  };
	  Cartographic.fromDegrees = function(longitude, latitude, height, result) {
	    if (!defined(longitude)) {
	      throw new DeveloperError('longitude is required.');
	    }
	    if (!defined(latitude)) {
	      throw new DeveloperError('latitude is required.');
	    }
	    longitude = CesiumMath.toRadians(longitude);
	    latitude = CesiumMath.toRadians(latitude);
	    return Cartographic.fromRadians(longitude, latitude, height, result);
	  };
	  var cartesianToCartographicN = new Cartesian3();
	  var cartesianToCartographicP = new Cartesian3();
	  var cartesianToCartographicH = new Cartesian3();
	  var wgs84OneOverRadii = new Cartesian3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);
	  var wgs84OneOverRadiiSquared = new Cartesian3(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));
	  var wgs84CenterToleranceSquared = CesiumMath.EPSILON1;
	  Cartographic.fromCartesian = function(cartesian, ellipsoid, result) {
	    var oneOverRadii = defined(ellipsoid) ? ellipsoid.oneOverRadii : wgs84OneOverRadii;
	    var oneOverRadiiSquared = defined(ellipsoid) ? ellipsoid.oneOverRadiiSquared : wgs84OneOverRadiiSquared;
	    var centerToleranceSquared = defined(ellipsoid) ? ellipsoid._centerToleranceSquared : wgs84CenterToleranceSquared;
	    var p = scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, cartesianToCartographicP);
	    if (!defined(p)) {
	      return undefined;
	    }
	    var n = Cartesian3.multiplyComponents(cartesian, oneOverRadiiSquared, cartesianToCartographicN);
	    n = Cartesian3.normalize(n, n);
	    var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);
	    var longitude = Math.atan2(n.y, n.x);
	    var latitude = Math.asin(n.z);
	    var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);
	    if (!defined(result)) {
	      return new Cartographic(longitude, latitude, height);
	    }
	    result.longitude = longitude;
	    result.latitude = latitude;
	    result.height = height;
	    return result;
	  };
	  Cartographic.clone = function(cartographic, result) {
	    if (!defined(cartographic)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);
	    }
	    result.longitude = cartographic.longitude;
	    result.latitude = cartographic.latitude;
	    result.height = cartographic.height;
	    return result;
	  };
	  Cartographic.equals = function(left, right) {
	    return (left === right) || ((defined(left)) && (defined(right)) && (left.longitude === right.longitude) && (left.latitude === right.latitude) && (left.height === right.height));
	  };
	  Cartographic.equalsEpsilon = function(left, right, epsilon) {
	    if (typeof epsilon !== 'number') {
	      throw new DeveloperError('epsilon is required and must be a number.');
	    }
	    return (left === right) || ((defined(left)) && (defined(right)) && (Math.abs(left.longitude - right.longitude) <= epsilon) && (Math.abs(left.latitude - right.latitude) <= epsilon) && (Math.abs(left.height - right.height) <= epsilon));
	  };
	  Cartographic.ZERO = freezeObject(new Cartographic(0.0, 0.0, 0.0));
	  Cartographic.prototype.clone = function(result) {
	    return Cartographic.clone(this, result);
	  };
	  Cartographic.prototype.equals = function(right) {
	    return Cartographic.equals(this, right);
	  };
	  Cartographic.prototype.equalsEpsilon = function(right, epsilon) {
	    return Cartographic.equalsEpsilon(this, right, epsilon);
	  };
	  Cartographic.prototype.toString = function() {
	    return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';
	  };
	  return Cartographic;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("67", ["1c", "68"], function(DeveloperError, QuadraticRealPolynomial) {
	  'use strict';
	  var CubicRealPolynomial = {};
	  CubicRealPolynomial.computeDiscriminant = function(a, b, c, d) {
	    if (typeof a !== 'number') {
	      throw new DeveloperError('a is a required number.');
	    }
	    if (typeof b !== 'number') {
	      throw new DeveloperError('b is a required number.');
	    }
	    if (typeof c !== 'number') {
	      throw new DeveloperError('c is a required number.');
	    }
	    if (typeof d !== 'number') {
	      throw new DeveloperError('d is a required number.');
	    }
	    var a2 = a * a;
	    var b2 = b * b;
	    var c2 = c * c;
	    var d2 = d * d;
	    var discriminant = 18.0 * a * b * c * d + b2 * c2 - 27.0 * a2 * d2 - 4.0 * (a * c2 * c + b2 * b * d);
	    return discriminant;
	  };
	  function computeRealRoots(a, b, c, d) {
	    var A = a;
	    var B = b / 3.0;
	    var C = c / 3.0;
	    var D = d;
	    var AC = A * C;
	    var BD = B * D;
	    var B2 = B * B;
	    var C2 = C * C;
	    var delta1 = A * C - B2;
	    var delta2 = A * D - B * C;
	    var delta3 = B * D - C2;
	    var discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;
	    var temp;
	    var temp1;
	    if (discriminant < 0.0) {
	      var ABar;
	      var CBar;
	      var DBar;
	      if (B2 * BD >= AC * C2) {
	        ABar = A;
	        CBar = delta1;
	        DBar = -2.0 * B * delta1 + A * delta2;
	      } else {
	        ABar = D;
	        CBar = delta3;
	        DBar = -D * delta2 + 2.0 * C * delta3;
	      }
	      var s = (DBar < 0.0) ? -1.0 : 1.0;
	      var temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);
	      temp1 = -DBar + temp0;
	      var x = temp1 / 2.0;
	      var p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);
	      var q = (temp1 === temp0) ? -p : -CBar / p;
	      temp = (CBar <= 0.0) ? p + q : -DBar / (p * p + q * q + CBar);
	      if (B2 * BD >= AC * C2) {
	        return [(temp - B) / A];
	      }
	      return [-D / (temp + C)];
	    }
	    var CBarA = delta1;
	    var DBarA = -2.0 * B * delta1 + A * delta2;
	    var CBarD = delta3;
	    var DBarD = -D * delta2 + 2.0 * C * delta3;
	    var squareRootOfDiscriminant = Math.sqrt(discriminant);
	    var halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;
	    var theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);
	    temp = 2.0 * Math.sqrt(-CBarA);
	    var cosine = Math.cos(theta);
	    temp1 = temp * cosine;
	    var temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));
	    var numeratorLarge = (temp1 + temp3 > 2.0 * B) ? temp1 - B : temp3 - B;
	    var denominatorLarge = A;
	    var root1 = numeratorLarge / denominatorLarge;
	    theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);
	    temp = 2.0 * Math.sqrt(-CBarD);
	    cosine = Math.cos(theta);
	    temp1 = temp * cosine;
	    temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));
	    var numeratorSmall = -D;
	    var denominatorSmall = (temp1 + temp3 < 2.0 * C) ? temp1 + C : temp3 + C;
	    var root3 = numeratorSmall / denominatorSmall;
	    var E = denominatorLarge * denominatorSmall;
	    var F = -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;
	    var G = numeratorLarge * numeratorSmall;
	    var root2 = (C * F - B * G) / (-B * F + C * E);
	    if (root1 <= root2) {
	      if (root1 <= root3) {
	        if (root2 <= root3) {
	          return [root1, root2, root3];
	        }
	        return [root1, root3, root2];
	      }
	      return [root3, root1, root2];
	    }
	    if (root1 <= root3) {
	      return [root2, root1, root3];
	    }
	    if (root2 <= root3) {
	      return [root2, root3, root1];
	    }
	    return [root3, root2, root1];
	  }
	  CubicRealPolynomial.computeRealRoots = function(a, b, c, d) {
	    if (typeof a !== 'number') {
	      throw new DeveloperError('a is a required number.');
	    }
	    if (typeof b !== 'number') {
	      throw new DeveloperError('b is a required number.');
	    }
	    if (typeof c !== 'number') {
	      throw new DeveloperError('c is a required number.');
	    }
	    if (typeof d !== 'number') {
	      throw new DeveloperError('d is a required number.');
	    }
	    var roots;
	    var ratio;
	    if (a === 0.0) {
	      return QuadraticRealPolynomial.computeRealRoots(b, c, d);
	    } else if (b === 0.0) {
	      if (c === 0.0) {
	        if (d === 0.0) {
	          return [0.0, 0.0, 0.0];
	        }
	        ratio = -d / a;
	        var root = (ratio < 0.0) ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);
	        return [root, root, root];
	      } else if (d === 0.0) {
	        roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);
	        if (roots.Length === 0) {
	          return [0.0];
	        }
	        return [roots[0], 0.0, roots[1]];
	      }
	      return computeRealRoots(a, 0, c, d);
	    } else if (c === 0.0) {
	      if (d === 0.0) {
	        ratio = -b / a;
	        if (ratio < 0.0) {
	          return [ratio, 0.0, 0.0];
	        }
	        return [0.0, 0.0, ratio];
	      }
	      return computeRealRoots(a, b, 0, d);
	    } else if (d === 0.0) {
	      roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);
	      if (roots.length === 0) {
	        return [0.0];
	      } else if (roots[1] <= 0.0) {
	        return [roots[0], roots[1], 0.0];
	      } else if (roots[0] >= 0.0) {
	        return [0.0, roots[0], roots[1]];
	      }
	      return [roots[0], 0.0, roots[1]];
	    }
	    return computeRealRoots(a, b, c, d);
	  };
	  return CubicRealPolynomial;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("68", ["1c", "27"], function(DeveloperError, CesiumMath) {
	  'use strict';
	  var QuadraticRealPolynomial = {};
	  QuadraticRealPolynomial.computeDiscriminant = function(a, b, c) {
	    if (typeof a !== 'number') {
	      throw new DeveloperError('a is a required number.');
	    }
	    if (typeof b !== 'number') {
	      throw new DeveloperError('b is a required number.');
	    }
	    if (typeof c !== 'number') {
	      throw new DeveloperError('c is a required number.');
	    }
	    var discriminant = b * b - 4.0 * a * c;
	    return discriminant;
	  };
	  function addWithCancellationCheck(left, right, tolerance) {
	    var difference = left + right;
	    if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
	      return 0.0;
	    }
	    return difference;
	  }
	  QuadraticRealPolynomial.computeRealRoots = function(a, b, c) {
	    if (typeof a !== 'number') {
	      throw new DeveloperError('a is a required number.');
	    }
	    if (typeof b !== 'number') {
	      throw new DeveloperError('b is a required number.');
	    }
	    if (typeof c !== 'number') {
	      throw new DeveloperError('c is a required number.');
	    }
	    var ratio;
	    if (a === 0.0) {
	      if (b === 0.0) {
	        return [];
	      }
	      return [-c / b];
	    } else if (b === 0.0) {
	      if (c === 0.0) {
	        return [0.0, 0.0];
	      }
	      var cMagnitude = Math.abs(c);
	      var aMagnitude = Math.abs(a);
	      if ((cMagnitude < aMagnitude) && (cMagnitude / aMagnitude < CesiumMath.EPSILON14)) {
	        return [0.0, 0.0];
	      } else if ((cMagnitude > aMagnitude) && (aMagnitude / cMagnitude < CesiumMath.EPSILON14)) {
	        return [];
	      }
	      ratio = -c / a;
	      if (ratio < 0.0) {
	        return [];
	      }
	      var root = Math.sqrt(ratio);
	      return [-root, root];
	    } else if (c === 0.0) {
	      ratio = -b / a;
	      if (ratio < 0.0) {
	        return [ratio, 0.0];
	      }
	      return [0.0, ratio];
	    }
	    var b2 = b * b;
	    var four_ac = 4.0 * a * c;
	    var radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);
	    if (radicand < 0.0) {
	      return [];
	    }
	    var q = -0.5 * addWithCancellationCheck(b, CesiumMath.sign(b) * Math.sqrt(radicand), CesiumMath.EPSILON14);
	    if (b > 0.0) {
	      return [q / a, c / q];
	    }
	    return [c / q, q / a];
	  };
	  return QuadraticRealPolynomial;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("69", ["67", "1c", "27", "68"], function(CubicRealPolynomial, DeveloperError, CesiumMath, QuadraticRealPolynomial) {
	  'use strict';
	  var QuarticRealPolynomial = {};
	  QuarticRealPolynomial.computeDiscriminant = function(a, b, c, d, e) {
	    if (typeof a !== 'number') {
	      throw new DeveloperError('a is a required number.');
	    }
	    if (typeof b !== 'number') {
	      throw new DeveloperError('b is a required number.');
	    }
	    if (typeof c !== 'number') {
	      throw new DeveloperError('c is a required number.');
	    }
	    if (typeof d !== 'number') {
	      throw new DeveloperError('d is a required number.');
	    }
	    if (typeof e !== 'number') {
	      throw new DeveloperError('e is a required number.');
	    }
	    var a2 = a * a;
	    var a3 = a2 * a;
	    var b2 = b * b;
	    var b3 = b2 * b;
	    var c2 = c * c;
	    var c3 = c2 * c;
	    var d2 = d * d;
	    var d3 = d2 * d;
	    var e2 = e * e;
	    var e3 = e2 * e;
	    var discriminant = (b2 * c2 * d2 - 4.0 * b3 * d3 - 4.0 * a * c3 * d2 + 18 * a * b * c * d3 - 27.0 * a2 * d2 * d2 + 256.0 * a3 * e3) + e * (18.0 * b3 * c * d - 4.0 * b2 * c3 + 16.0 * a * c2 * c2 - 80.0 * a * b * c2 * d - 6.0 * a * b2 * d2 + 144.0 * a2 * c * d2) + e2 * (144.0 * a * b2 * c - 27.0 * b2 * b2 - 128.0 * a2 * c2 - 192.0 * a2 * b * d);
	    return discriminant;
	  };
	  function original(a3, a2, a1, a0) {
	    var a3Squared = a3 * a3;
	    var p = a2 - 3.0 * a3Squared / 8.0;
	    var q = a1 - a2 * a3 / 2.0 + a3Squared * a3 / 8.0;
	    var r = a0 - a1 * a3 / 4.0 + a2 * a3Squared / 16.0 - 3.0 * a3Squared * a3Squared / 256.0;
	    var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, 2.0 * p, p * p - 4.0 * r, -q * q);
	    if (cubicRoots.length > 0) {
	      var temp = -a3 / 4.0;
	      var hSquared = cubicRoots[cubicRoots.length - 1];
	      if (Math.abs(hSquared) < CesiumMath.EPSILON14) {
	        var roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);
	        if (roots.length === 2) {
	          var root0 = roots[0];
	          var root1 = roots[1];
	          var y;
	          if (root0 >= 0.0 && root1 >= 0.0) {
	            var y0 = Math.sqrt(root0);
	            var y1 = Math.sqrt(root1);
	            return [temp - y1, temp - y0, temp + y0, temp + y1];
	          } else if (root0 >= 0.0 && root1 < 0.0) {
	            y = Math.sqrt(root0);
	            return [temp - y, temp + y];
	          } else if (root0 < 0.0 && root1 >= 0.0) {
	            y = Math.sqrt(root1);
	            return [temp - y, temp + y];
	          }
	        }
	        return [];
	      } else if (hSquared > 0.0) {
	        var h = Math.sqrt(hSquared);
	        var m = (p + hSquared - q / h) / 2.0;
	        var n = (p + hSquared + q / h) / 2.0;
	        var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);
	        var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);
	        if (roots1.length !== 0) {
	          roots1[0] += temp;
	          roots1[1] += temp;
	          if (roots2.length !== 0) {
	            roots2[0] += temp;
	            roots2[1] += temp;
	            if (roots1[1] <= roots2[0]) {
	              return [roots1[0], roots1[1], roots2[0], roots2[1]];
	            } else if (roots2[1] <= roots1[0]) {
	              return [roots2[0], roots2[1], roots1[0], roots1[1]];
	            } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
	              return [roots2[0], roots1[0], roots1[1], roots2[1]];
	            } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
	              return [roots1[0], roots2[0], roots2[1], roots1[1]];
	            } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
	              return [roots2[0], roots1[0], roots2[1], roots1[1]];
	            }
	            return [roots1[0], roots2[0], roots1[1], roots2[1]];
	          }
	          return roots1;
	        }
	        if (roots2.length !== 0) {
	          roots2[0] += temp;
	          roots2[1] += temp;
	          return roots2;
	        }
	        return [];
	      }
	    }
	    return [];
	  }
	  function neumark(a3, a2, a1, a0) {
	    var a1Squared = a1 * a1;
	    var a2Squared = a2 * a2;
	    var a3Squared = a3 * a3;
	    var p = -2.0 * a2;
	    var q = a1 * a3 + a2Squared - 4.0 * a0;
	    var r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;
	    var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);
	    if (cubicRoots.length > 0) {
	      var y = cubicRoots[0];
	      var temp = (a2 - y);
	      var tempSquared = temp * temp;
	      var g1 = a3 / 2.0;
	      var h1 = temp / 2.0;
	      var m = tempSquared - 4.0 * a0;
	      var mError = tempSquared + 4.0 * Math.abs(a0);
	      var n = a3Squared - 4.0 * y;
	      var nError = a3Squared + 4.0 * Math.abs(y);
	      var g2;
	      var h2;
	      if (y < 0.0 || (m * nError < n * mError)) {
	        var squareRootOfN = Math.sqrt(n);
	        g2 = squareRootOfN / 2.0;
	        h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;
	      } else {
	        var squareRootOfM = Math.sqrt(m);
	        g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;
	        h2 = squareRootOfM / 2.0;
	      }
	      var G;
	      var g;
	      if (g1 === 0.0 && g2 === 0.0) {
	        G = 0.0;
	        g = 0.0;
	      } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {
	        G = g1 + g2;
	        g = y / G;
	      } else {
	        g = g1 - g2;
	        G = y / g;
	      }
	      var H;
	      var h;
	      if (h1 === 0.0 && h2 === 0.0) {
	        H = 0.0;
	        h = 0.0;
	      } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {
	        H = h1 + h2;
	        h = a0 / H;
	      } else {
	        h = h1 - h2;
	        H = a0 / h;
	      }
	      var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);
	      var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);
	      if (roots1.length !== 0) {
	        if (roots2.length !== 0) {
	          if (roots1[1] <= roots2[0]) {
	            return [roots1[0], roots1[1], roots2[0], roots2[1]];
	          } else if (roots2[1] <= roots1[0]) {
	            return [roots2[0], roots2[1], roots1[0], roots1[1]];
	          } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
	            return [roots2[0], roots1[0], roots1[1], roots2[1]];
	          } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
	            return [roots1[0], roots2[0], roots2[1], roots1[1]];
	          } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
	            return [roots2[0], roots1[0], roots2[1], roots1[1]];
	          } else {
	            return [roots1[0], roots2[0], roots1[1], roots2[1]];
	          }
	        }
	        return roots1;
	      }
	      if (roots2.length !== 0) {
	        return roots2;
	      }
	    }
	    return [];
	  }
	  QuarticRealPolynomial.computeRealRoots = function(a, b, c, d, e) {
	    if (typeof a !== 'number') {
	      throw new DeveloperError('a is a required number.');
	    }
	    if (typeof b !== 'number') {
	      throw new DeveloperError('b is a required number.');
	    }
	    if (typeof c !== 'number') {
	      throw new DeveloperError('c is a required number.');
	    }
	    if (typeof d !== 'number') {
	      throw new DeveloperError('d is a required number.');
	    }
	    if (typeof e !== 'number') {
	      throw new DeveloperError('e is a required number.');
	    }
	    if (Math.abs(a) < CesiumMath.EPSILON15) {
	      return CubicRealPolynomial.computeRealRoots(b, c, d, e);
	    }
	    var a3 = b / a;
	    var a2 = c / a;
	    var a1 = d / a;
	    var a0 = e / a;
	    var k = (a3 < 0.0) ? 1 : 0;
	    k += (a2 < 0.0) ? k + 1 : k;
	    k += (a1 < 0.0) ? k + 1 : k;
	    k += (a0 < 0.0) ? k + 1 : k;
	    switch (k) {
	      case 0:
	        return original(a3, a2, a1, a0);
	      case 1:
	        return neumark(a3, a2, a1, a0);
	      case 2:
	        return neumark(a3, a2, a1, a0);
	      case 3:
	        return original(a3, a2, a1, a0);
	      case 4:
	        return original(a3, a2, a1, a0);
	      case 5:
	        return neumark(a3, a2, a1, a0);
	      case 6:
	        return original(a3, a2, a1, a0);
	      case 7:
	        return original(a3, a2, a1, a0);
	      case 8:
	        return neumark(a3, a2, a1, a0);
	      case 9:
	        return original(a3, a2, a1, a0);
	      case 10:
	        return original(a3, a2, a1, a0);
	      case 11:
	        return neumark(a3, a2, a1, a0);
	      case 12:
	        return original(a3, a2, a1, a0);
	      case 13:
	        return original(a3, a2, a1, a0);
	      case 14:
	        return original(a3, a2, a1, a0);
	      case 15:
	        return original(a3, a2, a1, a0);
	      default:
	        return undefined;
	    }
	  };
	  return QuarticRealPolynomial;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("6a", ["2c", "23", "1a", "1c"], function(Cartesian3, defaultValue, defined, DeveloperError) {
	  'use strict';
	  function Ray(origin, direction) {
	    direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));
	    if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {
	      Cartesian3.normalize(direction, direction);
	    }
	    this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));
	    this.direction = direction;
	  }
	  Ray.getPoint = function(ray, t, result) {
	    if (!defined(ray)) {
	      throw new DeveloperError('ray is requred');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is a required number');
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    result = Cartesian3.multiplyByScalar(ray.direction, t, result);
	    return Cartesian3.add(ray.origin, result, result);
	  };
	  return Ray;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("6b", ["2c", "3b", "23", "1a", "1c", "27", "32", "68", "69", "6a"], function(Cartesian3, Cartographic, defaultValue, defined, DeveloperError, CesiumMath, Matrix3, QuadraticRealPolynomial, QuarticRealPolynomial, Ray) {
	  'use strict';
	  var IntersectionTests = {};
	  IntersectionTests.rayPlane = function(ray, plane, result) {
	    if (!defined(ray)) {
	      throw new DeveloperError('ray is required.');
	    }
	    if (!defined(plane)) {
	      throw new DeveloperError('plane is required.');
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    var origin = ray.origin;
	    var direction = ray.direction;
	    var normal = plane.normal;
	    var denominator = Cartesian3.dot(normal, direction);
	    if (Math.abs(denominator) < CesiumMath.EPSILON15) {
	      return undefined;
	    }
	    var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;
	    if (t < 0) {
	      return undefined;
	    }
	    result = Cartesian3.multiplyByScalar(direction, t, result);
	    return Cartesian3.add(origin, result, result);
	  };
	  var scratchEdge0 = new Cartesian3();
	  var scratchEdge1 = new Cartesian3();
	  var scratchPVec = new Cartesian3();
	  var scratchTVec = new Cartesian3();
	  var scratchQVec = new Cartesian3();
	  function rayTriangle(ray, p0, p1, p2, cullBackFaces) {
	    if (!defined(ray)) {
	      throw new DeveloperError('ray is required.');
	    }
	    if (!defined(p0)) {
	      throw new DeveloperError('p0 is required.');
	    }
	    if (!defined(p1)) {
	      throw new DeveloperError('p1 is required.');
	    }
	    if (!defined(p2)) {
	      throw new DeveloperError('p2 is required.');
	    }
	    cullBackFaces = defaultValue(cullBackFaces, false);
	    var origin = ray.origin;
	    var direction = ray.direction;
	    var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);
	    var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);
	    var p = Cartesian3.cross(direction, edge1, scratchPVec);
	    var det = Cartesian3.dot(edge0, p);
	    var tvec;
	    var q;
	    var u;
	    var v;
	    var t;
	    if (cullBackFaces) {
	      if (det < CesiumMath.EPSILON6) {
	        return undefined;
	      }
	      tvec = Cartesian3.subtract(origin, p0, scratchTVec);
	      u = Cartesian3.dot(tvec, p);
	      if (u < 0.0 || u > det) {
	        return undefined;
	      }
	      q = Cartesian3.cross(tvec, edge0, scratchQVec);
	      v = Cartesian3.dot(direction, q);
	      if (v < 0.0 || u + v > det) {
	        return undefined;
	      }
	      t = Cartesian3.dot(edge1, q) / det;
	    } else {
	      if (Math.abs(det) < CesiumMath.EPSILON6) {
	        return undefined;
	      }
	      var invDet = 1.0 / det;
	      tvec = Cartesian3.subtract(origin, p0, scratchTVec);
	      u = Cartesian3.dot(tvec, p) * invDet;
	      if (u < 0.0 || u > 1.0) {
	        return undefined;
	      }
	      q = Cartesian3.cross(tvec, edge0, scratchQVec);
	      v = Cartesian3.dot(direction, q) * invDet;
	      if (v < 0.0 || u + v > 1.0) {
	        return undefined;
	      }
	      t = Cartesian3.dot(edge1, q) * invDet;
	    }
	    return t;
	  }
	  IntersectionTests.rayTriangle = function(ray, p0, p1, p2, cullBackFaces, result) {
	    var t = rayTriangle(ray, p0, p1, p2, cullBackFaces);
	    if (!defined(t) || t < 0.0) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    Cartesian3.multiplyByScalar(ray.direction, t, result);
	    return Cartesian3.add(ray.origin, result, result);
	  };
	  var scratchLineSegmentTriangleRay = new Ray();
	  IntersectionTests.lineSegmentTriangle = function(v0, v1, p0, p1, p2, cullBackFaces, result) {
	    if (!defined(v0)) {
	      throw new DeveloperError('v0 is required.');
	    }
	    if (!defined(v1)) {
	      throw new DeveloperError('v1 is required.');
	    }
	    var ray = scratchLineSegmentTriangleRay;
	    Cartesian3.clone(v0, ray.origin);
	    Cartesian3.subtract(v1, v0, ray.direction);
	    Cartesian3.normalize(ray.direction, ray.direction);
	    var t = rayTriangle(ray, p0, p1, p2, cullBackFaces);
	    if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    Cartesian3.multiplyByScalar(ray.direction, t, result);
	    return Cartesian3.add(ray.origin, result, result);
	  };
	  function solveQuadratic(a, b, c, result) {
	    var det = b * b - 4.0 * a * c;
	    if (det < 0.0) {
	      return undefined;
	    } else if (det > 0.0) {
	      var denom = 1.0 / (2.0 * a);
	      var disc = Math.sqrt(det);
	      var root0 = (-b + disc) * denom;
	      var root1 = (-b - disc) * denom;
	      if (root0 < root1) {
	        result.root0 = root0;
	        result.root1 = root1;
	      } else {
	        result.root0 = root1;
	        result.root1 = root0;
	      }
	      return result;
	    }
	    var root = -b / (2.0 * a);
	    if (root === 0.0) {
	      return undefined;
	    }
	    result.root0 = result.root1 = root;
	    return result;
	  }
	  var raySphereRoots = {
	    root0: 0.0,
	    root1: 0.0
	  };
	  function raySphere(ray, sphere, result) {
	    if (!defined(result)) {
	      result = {};
	    }
	    var origin = ray.origin;
	    var direction = ray.direction;
	    var center = sphere.center;
	    var radiusSquared = sphere.radius * sphere.radius;
	    var diff = Cartesian3.subtract(origin, center, scratchPVec);
	    var a = Cartesian3.dot(direction, direction);
	    var b = 2.0 * Cartesian3.dot(direction, diff);
	    var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;
	    var roots = solveQuadratic(a, b, c, raySphereRoots);
	    if (!defined(roots)) {
	      return undefined;
	    }
	    result.start = roots.root0;
	    result.stop = roots.root1;
	    return result;
	  }
	  IntersectionTests.raySphere = function(ray, sphere, result) {
	    if (!defined(ray)) {
	      throw new DeveloperError('ray is required.');
	    }
	    if (!defined(sphere)) {
	      throw new DeveloperError('sphere is required.');
	    }
	    result = raySphere(ray, sphere, result);
	    if (!defined(result) || result.stop < 0.0) {
	      return undefined;
	    }
	    result.start = Math.max(result.start, 0.0);
	    return result;
	  };
	  var scratchLineSegmentRay = new Ray();
	  IntersectionTests.lineSegmentSphere = function(p0, p1, sphere, result) {
	    if (!defined(p0)) {
	      throw new DeveloperError('p0 is required.');
	    }
	    if (!defined(p1)) {
	      throw new DeveloperError('p1 is required.');
	    }
	    if (!defined(sphere)) {
	      throw new DeveloperError('sphere is required.');
	    }
	    var ray = scratchLineSegmentRay;
	    Cartesian3.clone(p0, ray.origin);
	    var direction = Cartesian3.subtract(p1, p0, ray.direction);
	    var maxT = Cartesian3.magnitude(direction);
	    Cartesian3.normalize(direction, direction);
	    result = raySphere(ray, sphere, result);
	    if (!defined(result) || result.stop < 0.0 || result.start > maxT) {
	      return undefined;
	    }
	    result.start = Math.max(result.start, 0.0);
	    result.stop = Math.min(result.stop, maxT);
	    return result;
	  };
	  var scratchQ = new Cartesian3();
	  var scratchW = new Cartesian3();
	  IntersectionTests.rayEllipsoid = function(ray, ellipsoid) {
	    if (!defined(ray)) {
	      throw new DeveloperError('ray is required.');
	    }
	    if (!defined(ellipsoid)) {
	      throw new DeveloperError('ellipsoid is required.');
	    }
	    var inverseRadii = ellipsoid.oneOverRadii;
	    var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);
	    var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);
	    var q2 = Cartesian3.magnitudeSquared(q);
	    var qw = Cartesian3.dot(q, w);
	    var difference,
	        w2,
	        product,
	        discriminant,
	        temp;
	    if (q2 > 1.0) {
	      if (qw >= 0.0) {
	        return undefined;
	      }
	      var qw2 = qw * qw;
	      difference = q2 - 1.0;
	      w2 = Cartesian3.magnitudeSquared(w);
	      product = w2 * difference;
	      if (qw2 < product) {
	        return undefined;
	      } else if (qw2 > product) {
	        discriminant = qw * qw - product;
	        temp = -qw + Math.sqrt(discriminant);
	        var root0 = temp / w2;
	        var root1 = difference / temp;
	        if (root0 < root1) {
	          return {
	            start: root0,
	            stop: root1
	          };
	        }
	        return {
	          start: root1,
	          stop: root0
	        };
	      } else {
	        var root = Math.sqrt(difference / w2);
	        return {
	          start: root,
	          stop: root
	        };
	      }
	    } else if (q2 < 1.0) {
	      difference = q2 - 1.0;
	      w2 = Cartesian3.magnitudeSquared(w);
	      product = w2 * difference;
	      discriminant = qw * qw - product;
	      temp = -qw + Math.sqrt(discriminant);
	      return {
	        start: 0.0,
	        stop: temp / w2
	      };
	    } else {
	      if (qw < 0.0) {
	        w2 = Cartesian3.magnitudeSquared(w);
	        return {
	          start: 0.0,
	          stop: -qw / w2
	        };
	      }
	      return undefined;
	    }
	  };
	  function addWithCancellationCheck(left, right, tolerance) {
	    var difference = left + right;
	    if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
	      return 0.0;
	    }
	    return difference;
	  }
	  function quadraticVectorExpression(A, b, c, x, w) {
	    var xSquared = x * x;
	    var wSquared = w * w;
	    var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;
	    var l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);
	    var l0 = (A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared) + x * b.x + c;
	    var r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);
	    var r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);
	    var cosines;
	    var solutions = [];
	    if (r0 === 0.0 && r1 === 0.0) {
	      cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);
	      if (cosines.length === 0) {
	        return solutions;
	      }
	      var cosine0 = cosines[0];
	      var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));
	      solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));
	      solutions.push(new Cartesian3(x, w * cosine0, w * sine0));
	      if (cosines.length === 2) {
	        var cosine1 = cosines[1];
	        var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));
	        solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));
	        solutions.push(new Cartesian3(x, w * cosine1, w * sine1));
	      }
	      return solutions;
	    }
	    var r0Squared = r0 * r0;
	    var r1Squared = r1 * r1;
	    var l2Squared = l2 * l2;
	    var r0r1 = r0 * r1;
	    var c4 = l2Squared + r1Squared;
	    var c3 = 2.0 * (l1 * l2 + r0r1);
	    var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;
	    var c1 = 2.0 * (l0 * l1 - r0r1);
	    var c0 = l0 * l0 - r0Squared;
	    if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {
	      return solutions;
	    }
	    cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);
	    var length = cosines.length;
	    if (length === 0) {
	      return solutions;
	    }
	    for (var i = 0; i < length; ++i) {
	      var cosine = cosines[i];
	      var cosineSquared = cosine * cosine;
	      var sineSquared = Math.max(1.0 - cosineSquared, 0.0);
	      var sine = Math.sqrt(sineSquared);
	      var left;
	      if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {
	        left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);
	      } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {
	        left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);
	      } else {
	        left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);
	      }
	      var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);
	      var product = left * right;
	      if (product < 0.0) {
	        solutions.push(new Cartesian3(x, w * cosine, w * sine));
	      } else if (product > 0.0) {
	        solutions.push(new Cartesian3(x, w * cosine, w * -sine));
	      } else if (sine !== 0.0) {
	        solutions.push(new Cartesian3(x, w * cosine, w * -sine));
	        solutions.push(new Cartesian3(x, w * cosine, w * sine));
	        ++i;
	      } else {
	        solutions.push(new Cartesian3(x, w * cosine, w * sine));
	      }
	    }
	    return solutions;
	  }
	  var firstAxisScratch = new Cartesian3();
	  var secondAxisScratch = new Cartesian3();
	  var thirdAxisScratch = new Cartesian3();
	  var referenceScratch = new Cartesian3();
	  var bCart = new Cartesian3();
	  var bScratch = new Matrix3();
	  var btScratch = new Matrix3();
	  var diScratch = new Matrix3();
	  var dScratch = new Matrix3();
	  var cScratch = new Matrix3();
	  var tempMatrix = new Matrix3();
	  var aScratch = new Matrix3();
	  var sScratch = new Cartesian3();
	  var closestScratch = new Cartesian3();
	  var surfPointScratch = new Cartographic();
	  IntersectionTests.grazingAltitudeLocation = function(ray, ellipsoid) {
	    if (!defined(ray)) {
	      throw new DeveloperError('ray is required.');
	    }
	    if (!defined(ellipsoid)) {
	      throw new DeveloperError('ellipsoid is required.');
	    }
	    var position = ray.origin;
	    var direction = ray.direction;
	    var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);
	    if (Cartesian3.dot(direction, normal) >= 0.0) {
	      return position;
	    }
	    var intersects = defined(this.rayEllipsoid(ray, ellipsoid));
	    var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);
	    var firstAxis = Cartesian3.normalize(f, f);
	    var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);
	    var secondAxis = Cartesian3.normalize(Cartesian3.cross(reference, firstAxis, secondAxisScratch), secondAxisScratch);
	    var thirdAxis = Cartesian3.normalize(Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch), thirdAxisScratch);
	    var B = bScratch;
	    B[0] = firstAxis.x;
	    B[1] = firstAxis.y;
	    B[2] = firstAxis.z;
	    B[3] = secondAxis.x;
	    B[4] = secondAxis.y;
	    B[5] = secondAxis.z;
	    B[6] = thirdAxis.x;
	    B[7] = thirdAxis.y;
	    B[8] = thirdAxis.z;
	    var B_T = Matrix3.transpose(B, btScratch);
	    var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);
	    var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);
	    var C = cScratch;
	    C[0] = 0.0;
	    C[1] = -direction.z;
	    C[2] = direction.y;
	    C[3] = direction.z;
	    C[4] = 0.0;
	    C[5] = -direction.x;
	    C[6] = -direction.y;
	    C[7] = direction.x;
	    C[8] = 0.0;
	    var temp = Matrix3.multiply(Matrix3.multiply(B_T, D, tempMatrix), C, tempMatrix);
	    var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);
	    var b = Matrix3.multiplyByVector(temp, position, bCart);
	    var solutions = quadraticVectorExpression(A, Cartesian3.negate(b, firstAxisScratch), 0.0, 0.0, 1.0);
	    var s;
	    var altitude;
	    var length = solutions.length;
	    if (length > 0) {
	      var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);
	      var maximumValue = Number.NEGATIVE_INFINITY;
	      for (var i = 0; i < length; ++i) {
	        s = Matrix3.multiplyByVector(D_I, Matrix3.multiplyByVector(B, solutions[i], sScratch), sScratch);
	        var v = Cartesian3.normalize(Cartesian3.subtract(s, position, referenceScratch), referenceScratch);
	        var dotProduct = Cartesian3.dot(v, direction);
	        if (dotProduct > maximumValue) {
	          maximumValue = dotProduct;
	          closest = Cartesian3.clone(s, closest);
	        }
	      }
	      var surfacePoint = ellipsoid.cartesianToCartographic(closest, surfPointScratch);
	      maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);
	      altitude = Cartesian3.magnitude(Cartesian3.subtract(closest, position, referenceScratch)) * Math.sqrt(1.0 - maximumValue * maximumValue);
	      altitude = intersects ? -altitude : altitude;
	      surfacePoint.height = altitude;
	      return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());
	    }
	    return undefined;
	  };
	  var lineSegmentPlaneDifference = new Cartesian3();
	  IntersectionTests.lineSegmentPlane = function(endPoint0, endPoint1, plane, result) {
	    if (!defined(endPoint0)) {
	      throw new DeveloperError('endPoint0 is required.');
	    }
	    if (!defined(endPoint1)) {
	      throw new DeveloperError('endPoint1 is required.');
	    }
	    if (!defined(plane)) {
	      throw new DeveloperError('plane is required.');
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    var difference = Cartesian3.subtract(endPoint1, endPoint0, lineSegmentPlaneDifference);
	    var normal = plane.normal;
	    var nDotDiff = Cartesian3.dot(normal, difference);
	    if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {
	      return undefined;
	    }
	    var nDotP0 = Cartesian3.dot(normal, endPoint0);
	    var t = -(plane.distance + nDotP0) / nDotDiff;
	    if (t < 0.0 || t > 1.0) {
	      return undefined;
	    }
	    Cartesian3.multiplyByScalar(difference, t, result);
	    Cartesian3.add(endPoint0, result, result);
	    return result;
	  };
	  IntersectionTests.trianglePlaneIntersection = function(p0, p1, p2, plane) {
	    if ((!defined(p0)) || (!defined(p1)) || (!defined(p2)) || (!defined(plane))) {
	      throw new DeveloperError('p0, p1, p2, and plane are required.');
	    }
	    var planeNormal = plane.normal;
	    var planeD = plane.distance;
	    var p0Behind = (Cartesian3.dot(planeNormal, p0) + planeD) < 0.0;
	    var p1Behind = (Cartesian3.dot(planeNormal, p1) + planeD) < 0.0;
	    var p2Behind = (Cartesian3.dot(planeNormal, p2) + planeD) < 0.0;
	    var numBehind = 0;
	    numBehind += p0Behind ? 1 : 0;
	    numBehind += p1Behind ? 1 : 0;
	    numBehind += p2Behind ? 1 : 0;
	    var u1,
	        u2;
	    if (numBehind === 1 || numBehind === 2) {
	      u1 = new Cartesian3();
	      u2 = new Cartesian3();
	    }
	    if (numBehind === 1) {
	      if (p0Behind) {
	        IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);
	        IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);
	        return {
	          positions: [p0, p1, p2, u1, u2],
	          indices: [0, 3, 4, 1, 2, 4, 1, 4, 3]
	        };
	      } else if (p1Behind) {
	        IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);
	        IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);
	        return {
	          positions: [p0, p1, p2, u1, u2],
	          indices: [1, 3, 4, 2, 0, 4, 2, 4, 3]
	        };
	      } else if (p2Behind) {
	        IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);
	        IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);
	        return {
	          positions: [p0, p1, p2, u1, u2],
	          indices: [2, 3, 4, 0, 1, 4, 0, 4, 3]
	        };
	      }
	    } else if (numBehind === 2) {
	      if (!p0Behind) {
	        IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);
	        IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);
	        return {
	          positions: [p0, p1, p2, u1, u2],
	          indices: [1, 2, 4, 1, 4, 3, 0, 3, 4]
	        };
	      } else if (!p1Behind) {
	        IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);
	        IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);
	        return {
	          positions: [p0, p1, p2, u1, u2],
	          indices: [2, 0, 4, 2, 4, 3, 1, 3, 4]
	        };
	      } else if (!p2Behind) {
	        IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);
	        IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);
	        return {
	          positions: [p0, p1, p2, u1, u2],
	          indices: [0, 1, 4, 0, 4, 3, 2, 3, 4]
	        };
	      }
	    }
	    return undefined;
	  };
	  return IntersectionTests;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("6c", ["1a"], function(defined) {
	  'use strict';
	  var isArray = Array.isArray;
	  if (!defined(isArray)) {
	    isArray = function(value) {
	      return Object.prototype.toString.call(value) === '[object Array]';
	    };
	  }
	  return isArray;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("43", ["23", "1a", "1c", "1f", "27"], function(defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
	  'use strict';
	  function Cartesian4(x, y, z, w) {
	    this.x = defaultValue(x, 0.0);
	    this.y = defaultValue(y, 0.0);
	    this.z = defaultValue(z, 0.0);
	    this.w = defaultValue(w, 0.0);
	  }
	  Cartesian4.fromElements = function(x, y, z, w, result) {
	    if (!defined(result)) {
	      return new Cartesian4(x, y, z, w);
	    }
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    result.w = w;
	    return result;
	  };
	  Cartesian4.fromColor = function(color, result) {
	    if (!defined(color)) {
	      throw new DeveloperError('color is required');
	    }
	    if (!defined(result)) {
	      return new Cartesian4(color.red, color.green, color.blue, color.alpha);
	    }
	    result.x = color.red;
	    result.y = color.green;
	    result.z = color.blue;
	    result.w = color.alpha;
	    return result;
	  };
	  Cartesian4.clone = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	    }
	    result.x = cartesian.x;
	    result.y = cartesian.y;
	    result.z = cartesian.z;
	    result.w = cartesian.w;
	    return result;
	  };
	  Cartesian4.packedLength = 4;
	  Cartesian4.pack = function(value, array, startingIndex) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required');
	    }
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    array[startingIndex++] = value.x;
	    array[startingIndex++] = value.y;
	    array[startingIndex++] = value.z;
	    array[startingIndex] = value.w;
	  };
	  Cartesian4.unpack = function(array, startingIndex, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    if (!defined(result)) {
	      result = new Cartesian4();
	    }
	    result.x = array[startingIndex++];
	    result.y = array[startingIndex++];
	    result.z = array[startingIndex++];
	    result.w = array[startingIndex];
	    return result;
	  };
	  Cartesian4.packArray = function(array, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    var length = array.length;
	    if (!defined(result)) {
	      result = new Array(length * 4);
	    } else {
	      result.length = length * 4;
	    }
	    for (var i = 0; i < length; ++i) {
	      Cartesian4.pack(array[i], result, i * 4);
	    }
	    return result;
	  };
	  Cartesian4.unpackArray = function(array, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    var length = array.length;
	    if (!defined(result)) {
	      result = new Array(length / 4);
	    } else {
	      result.length = length / 4;
	    }
	    for (var i = 0; i < length; i += 4) {
	      var index = i / 4;
	      result[index] = Cartesian4.unpack(array, i, result[index]);
	    }
	    return result;
	  };
	  Cartesian4.fromArray = Cartesian4.unpack;
	  Cartesian4.maximumComponent = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	  };
	  Cartesian4.minimumComponent = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	  };
	  Cartesian4.minimumByComponent = function(first, second, result) {
	    if (!defined(first)) {
	      throw new DeveloperError('first is required.');
	    }
	    if (!defined(second)) {
	      throw new DeveloperError('second is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    result.x = Math.min(first.x, second.x);
	    result.y = Math.min(first.y, second.y);
	    result.z = Math.min(first.z, second.z);
	    result.w = Math.min(first.w, second.w);
	    return result;
	  };
	  Cartesian4.maximumByComponent = function(first, second, result) {
	    if (!defined(first)) {
	      throw new DeveloperError('first is required.');
	    }
	    if (!defined(second)) {
	      throw new DeveloperError('second is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    result.x = Math.max(first.x, second.x);
	    result.y = Math.max(first.y, second.y);
	    result.z = Math.max(first.z, second.z);
	    result.w = Math.max(first.w, second.w);
	    return result;
	  };
	  Cartesian4.magnitudeSquared = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;
	  };
	  Cartesian4.magnitude = function(cartesian) {
	    return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
	  };
	  var distanceScratch = new Cartesian4();
	  Cartesian4.distance = function(left, right) {
	    if (!defined(left) || !defined(right)) {
	      throw new DeveloperError('left and right are required.');
	    }
	    Cartesian4.subtract(left, right, distanceScratch);
	    return Cartesian4.magnitude(distanceScratch);
	  };
	  Cartesian4.distanceSquared = function(left, right) {
	    if (!defined(left) || !defined(right)) {
	      throw new DeveloperError('left and right are required.');
	    }
	    Cartesian4.subtract(left, right, distanceScratch);
	    return Cartesian4.magnitudeSquared(distanceScratch);
	  };
	  Cartesian4.normalize = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var magnitude = Cartesian4.magnitude(cartesian);
	    result.x = cartesian.x / magnitude;
	    result.y = cartesian.y / magnitude;
	    result.z = cartesian.z / magnitude;
	    result.w = cartesian.w / magnitude;
	    return result;
	  };
	  Cartesian4.dot = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
	  };
	  Cartesian4.multiplyComponents = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x * right.x;
	    result.y = left.y * right.y;
	    result.z = left.z * right.z;
	    result.w = left.w * right.w;
	    return result;
	  };
	  Cartesian4.add = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x + right.x;
	    result.y = left.y + right.y;
	    result.z = left.z + right.z;
	    result.w = left.w + right.w;
	    return result;
	  };
	  Cartesian4.subtract = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x - right.x;
	    result.y = left.y - right.y;
	    result.z = left.z - right.z;
	    result.w = left.w - right.w;
	    return result;
	  };
	  Cartesian4.multiplyByScalar = function(cartesian, scalar, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = cartesian.x * scalar;
	    result.y = cartesian.y * scalar;
	    result.z = cartesian.z * scalar;
	    result.w = cartesian.w * scalar;
	    return result;
	  };
	  Cartesian4.divideByScalar = function(cartesian, scalar, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = cartesian.x / scalar;
	    result.y = cartesian.y / scalar;
	    result.z = cartesian.z / scalar;
	    result.w = cartesian.w / scalar;
	    return result;
	  };
	  Cartesian4.negate = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = -cartesian.x;
	    result.y = -cartesian.y;
	    result.z = -cartesian.z;
	    result.w = -cartesian.w;
	    return result;
	  };
	  Cartesian4.abs = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = Math.abs(cartesian.x);
	    result.y = Math.abs(cartesian.y);
	    result.z = Math.abs(cartesian.z);
	    result.w = Math.abs(cartesian.w);
	    return result;
	  };
	  var lerpScratch = new Cartesian4();
	  Cartesian4.lerp = function(start, end, t, result) {
	    if (!defined(start)) {
	      throw new DeveloperError('start is required.');
	    }
	    if (!defined(end)) {
	      throw new DeveloperError('end is required.');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    Cartesian4.multiplyByScalar(end, t, lerpScratch);
	    result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);
	    return Cartesian4.add(lerpScratch, result, result);
	  };
	  var mostOrthogonalAxisScratch = new Cartesian4();
	  Cartesian4.mostOrthogonalAxis = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);
	    Cartesian4.abs(f, f);
	    if (f.x <= f.y) {
	      if (f.x <= f.z) {
	        if (f.x <= f.w) {
	          result = Cartesian4.clone(Cartesian4.UNIT_X, result);
	        } else {
	          result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	        }
	      } else if (f.z <= f.w) {
	        result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
	      } else {
	        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	      }
	    } else if (f.y <= f.z) {
	      if (f.y <= f.w) {
	        result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
	      } else {
	        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	      }
	    } else if (f.z <= f.w) {
	      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
	    } else {
	      result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	    }
	    return result;
	  };
	  Cartesian4.equals = function(left, right) {
	    return (left === right) || ((defined(left)) && (defined(right)) && (left.x === right.x) && (left.y === right.y) && (left.z === right.z) && (left.w === right.w));
	  };
	  Cartesian4.equalsArray = function(cartesian, array, offset) {
	    return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2] && cartesian.w === array[offset + 3];
	  };
	  Cartesian4.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
	    return (left === right) || (defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon));
	  };
	  Cartesian4.ZERO = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 0.0));
	  Cartesian4.UNIT_X = freezeObject(new Cartesian4(1.0, 0.0, 0.0, 0.0));
	  Cartesian4.UNIT_Y = freezeObject(new Cartesian4(0.0, 1.0, 0.0, 0.0));
	  Cartesian4.UNIT_Z = freezeObject(new Cartesian4(0.0, 0.0, 1.0, 0.0));
	  Cartesian4.UNIT_W = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 1.0));
	  Cartesian4.prototype.clone = function(result) {
	    return Cartesian4.clone(this, result);
	  };
	  Cartesian4.prototype.equals = function(right) {
	    return Cartesian4.equals(this, right);
	  };
	  Cartesian4.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
	    return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
	  };
	  Cartesian4.prototype.toString = function() {
	    return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
	  };
	  return Cartesian4;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("1b", ["1a"], function(defined) {
	  'use strict';
	  var definePropertyWorks = (function() {
	    try {
	      return 'x' in Object.defineProperty({}, 'x', {});
	    } catch (e) {
	      return false;
	    }
	  })();
	  var defineProperties = Object.defineProperties;
	  if (!definePropertyWorks || !defined(defineProperties)) {
	    defineProperties = function(o) {
	      return o;
	    };
	  }
	  return defineProperties;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("32", ["2c", "23", "1a", "1b", "1c", "1f", "27"], function(Cartesian3, defaultValue, defined, defineProperties, DeveloperError, freezeObject, CesiumMath) {
	  'use strict';
	  function Matrix3(column0Row0, column1Row0, column2Row0, column0Row1, column1Row1, column2Row1, column0Row2, column1Row2, column2Row2) {
	    this[0] = defaultValue(column0Row0, 0.0);
	    this[1] = defaultValue(column0Row1, 0.0);
	    this[2] = defaultValue(column0Row2, 0.0);
	    this[3] = defaultValue(column1Row0, 0.0);
	    this[4] = defaultValue(column1Row1, 0.0);
	    this[5] = defaultValue(column1Row2, 0.0);
	    this[6] = defaultValue(column2Row0, 0.0);
	    this[7] = defaultValue(column2Row1, 0.0);
	    this[8] = defaultValue(column2Row2, 0.0);
	  }
	  Matrix3.packedLength = 9;
	  Matrix3.pack = function(value, array, startingIndex) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required');
	    }
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    array[startingIndex++] = value[0];
	    array[startingIndex++] = value[1];
	    array[startingIndex++] = value[2];
	    array[startingIndex++] = value[3];
	    array[startingIndex++] = value[4];
	    array[startingIndex++] = value[5];
	    array[startingIndex++] = value[6];
	    array[startingIndex++] = value[7];
	    array[startingIndex++] = value[8];
	  };
	  Matrix3.unpack = function(array, startingIndex, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    if (!defined(result)) {
	      result = new Matrix3();
	    }
	    result[0] = array[startingIndex++];
	    result[1] = array[startingIndex++];
	    result[2] = array[startingIndex++];
	    result[3] = array[startingIndex++];
	    result[4] = array[startingIndex++];
	    result[5] = array[startingIndex++];
	    result[6] = array[startingIndex++];
	    result[7] = array[startingIndex++];
	    result[8] = array[startingIndex++];
	    return result;
	  };
	  Matrix3.clone = function(values, result) {
	    if (!defined(values)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new Matrix3(values[0], values[3], values[6], values[1], values[4], values[7], values[2], values[5], values[8]);
	    }
	    result[0] = values[0];
	    result[1] = values[1];
	    result[2] = values[2];
	    result[3] = values[3];
	    result[4] = values[4];
	    result[5] = values[5];
	    result[6] = values[6];
	    result[7] = values[7];
	    result[8] = values[8];
	    return result;
	  };
	  Matrix3.fromArray = function(array, startingIndex, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    if (!defined(result)) {
	      result = new Matrix3();
	    }
	    result[0] = array[startingIndex];
	    result[1] = array[startingIndex + 1];
	    result[2] = array[startingIndex + 2];
	    result[3] = array[startingIndex + 3];
	    result[4] = array[startingIndex + 4];
	    result[5] = array[startingIndex + 5];
	    result[6] = array[startingIndex + 6];
	    result[7] = array[startingIndex + 7];
	    result[8] = array[startingIndex + 8];
	    return result;
	  };
	  Matrix3.fromColumnMajorArray = function(values, result) {
	    if (!defined(values)) {
	      throw new DeveloperError('values parameter is required');
	    }
	    return Matrix3.clone(values, result);
	  };
	  Matrix3.fromRowMajorArray = function(values, result) {
	    if (!defined(values)) {
	      throw new DeveloperError('values is required.');
	    }
	    if (!defined(result)) {
	      return new Matrix3(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8]);
	    }
	    result[0] = values[0];
	    result[1] = values[3];
	    result[2] = values[6];
	    result[3] = values[1];
	    result[4] = values[4];
	    result[5] = values[7];
	    result[6] = values[2];
	    result[7] = values[5];
	    result[8] = values[8];
	    return result;
	  };
	  Matrix3.fromQuaternion = function(quaternion, result) {
	    if (!defined(quaternion)) {
	      throw new DeveloperError('quaternion is required');
	    }
	    var x2 = quaternion.x * quaternion.x;
	    var xy = quaternion.x * quaternion.y;
	    var xz = quaternion.x * quaternion.z;
	    var xw = quaternion.x * quaternion.w;
	    var y2 = quaternion.y * quaternion.y;
	    var yz = quaternion.y * quaternion.z;
	    var yw = quaternion.y * quaternion.w;
	    var z2 = quaternion.z * quaternion.z;
	    var zw = quaternion.z * quaternion.w;
	    var w2 = quaternion.w * quaternion.w;
	    var m00 = x2 - y2 - z2 + w2;
	    var m01 = 2.0 * (xy - zw);
	    var m02 = 2.0 * (xz + yw);
	    var m10 = 2.0 * (xy + zw);
	    var m11 = -x2 + y2 - z2 + w2;
	    var m12 = 2.0 * (yz - xw);
	    var m20 = 2.0 * (xz - yw);
	    var m21 = 2.0 * (yz + xw);
	    var m22 = -x2 - y2 + z2 + w2;
	    if (!defined(result)) {
	      return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
	    }
	    result[0] = m00;
	    result[1] = m10;
	    result[2] = m20;
	    result[3] = m01;
	    result[4] = m11;
	    result[5] = m21;
	    result[6] = m02;
	    result[7] = m12;
	    result[8] = m22;
	    return result;
	  };
	  Matrix3.fromScale = function(scale, result) {
	    if (!defined(scale)) {
	      throw new DeveloperError('scale is required.');
	    }
	    if (!defined(result)) {
	      return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);
	    }
	    result[0] = scale.x;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = scale.y;
	    result[5] = 0.0;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = scale.z;
	    return result;
	  };
	  Matrix3.fromUniformScale = function(scale, result) {
	    if (typeof scale !== 'number') {
	      throw new DeveloperError('scale is required.');
	    }
	    if (!defined(result)) {
	      return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);
	    }
	    result[0] = scale;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = scale;
	    result[5] = 0.0;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = scale;
	    return result;
	  };
	  Matrix3.fromCrossProduct = function(vector, result) {
	    if (!defined(vector)) {
	      throw new DeveloperError('vector is required.');
	    }
	    if (!defined(result)) {
	      return new Matrix3(0.0, -vector.z, vector.y, vector.z, 0.0, -vector.x, -vector.y, vector.x, 0.0);
	    }
	    result[0] = 0.0;
	    result[1] = vector.z;
	    result[2] = -vector.y;
	    result[3] = -vector.z;
	    result[4] = 0.0;
	    result[5] = vector.x;
	    result[6] = vector.y;
	    result[7] = -vector.x;
	    result[8] = 0.0;
	    return result;
	  };
	  Matrix3.fromRotationX = function(angle, result) {
	    if (!defined(angle)) {
	      throw new DeveloperError('angle is required.');
	    }
	    var cosAngle = Math.cos(angle);
	    var sinAngle = Math.sin(angle);
	    if (!defined(result)) {
	      return new Matrix3(1.0, 0.0, 0.0, 0.0, cosAngle, -sinAngle, 0.0, sinAngle, cosAngle);
	    }
	    result[0] = 1.0;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = cosAngle;
	    result[5] = sinAngle;
	    result[6] = 0.0;
	    result[7] = -sinAngle;
	    result[8] = cosAngle;
	    return result;
	  };
	  Matrix3.fromRotationY = function(angle, result) {
	    if (!defined(angle)) {
	      throw new DeveloperError('angle is required.');
	    }
	    var cosAngle = Math.cos(angle);
	    var sinAngle = Math.sin(angle);
	    if (!defined(result)) {
	      return new Matrix3(cosAngle, 0.0, sinAngle, 0.0, 1.0, 0.0, -sinAngle, 0.0, cosAngle);
	    }
	    result[0] = cosAngle;
	    result[1] = 0.0;
	    result[2] = -sinAngle;
	    result[3] = 0.0;
	    result[4] = 1.0;
	    result[5] = 0.0;
	    result[6] = sinAngle;
	    result[7] = 0.0;
	    result[8] = cosAngle;
	    return result;
	  };
	  Matrix3.fromRotationZ = function(angle, result) {
	    if (!defined(angle)) {
	      throw new DeveloperError('angle is required.');
	    }
	    var cosAngle = Math.cos(angle);
	    var sinAngle = Math.sin(angle);
	    if (!defined(result)) {
	      return new Matrix3(cosAngle, -sinAngle, 0.0, sinAngle, cosAngle, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = cosAngle;
	    result[1] = sinAngle;
	    result[2] = 0.0;
	    result[3] = -sinAngle;
	    result[4] = cosAngle;
	    result[5] = 0.0;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = 1.0;
	    return result;
	  };
	  Matrix3.toArray = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];
	    }
	    result[0] = matrix[0];
	    result[1] = matrix[1];
	    result[2] = matrix[2];
	    result[3] = matrix[3];
	    result[4] = matrix[4];
	    result[5] = matrix[5];
	    result[6] = matrix[6];
	    result[7] = matrix[7];
	    result[8] = matrix[8];
	    return result;
	  };
	  Matrix3.getElementIndex = function(column, row) {
	    if (typeof row !== 'number' || row < 0 || row > 2) {
	      throw new DeveloperError('row must be 0, 1, or 2.');
	    }
	    if (typeof column !== 'number' || column < 0 || column > 2) {
	      throw new DeveloperError('column must be 0, 1, or 2.');
	    }
	    return column * 3 + row;
	  };
	  Matrix3.getColumn = function(matrix, index, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    if (typeof index !== 'number' || index < 0 || index > 2) {
	      throw new DeveloperError('index must be 0, 1, or 2.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var startIndex = index * 3;
	    var x = matrix[startIndex];
	    var y = matrix[startIndex + 1];
	    var z = matrix[startIndex + 2];
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return result;
	  };
	  Matrix3.setColumn = function(matrix, index, cartesian, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof index !== 'number' || index < 0 || index > 2) {
	      throw new DeveloperError('index must be 0, 1, or 2.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result = Matrix3.clone(matrix, result);
	    var startIndex = index * 3;
	    result[startIndex] = cartesian.x;
	    result[startIndex + 1] = cartesian.y;
	    result[startIndex + 2] = cartesian.z;
	    return result;
	  };
	  Matrix3.getRow = function(matrix, index, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    if (typeof index !== 'number' || index < 0 || index > 2) {
	      throw new DeveloperError('index must be 0, 1, or 2.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var x = matrix[index];
	    var y = matrix[index + 3];
	    var z = matrix[index + 6];
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return result;
	  };
	  Matrix3.setRow = function(matrix, index, cartesian, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof index !== 'number' || index < 0 || index > 2) {
	      throw new DeveloperError('index must be 0, 1, or 2.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result = Matrix3.clone(matrix, result);
	    result[index] = cartesian.x;
	    result[index + 3] = cartesian.y;
	    result[index + 6] = cartesian.z;
	    return result;
	  };
	  var scratchColumn = new Cartesian3();
	  Matrix3.getScale = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
	    result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn));
	    result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn));
	    return result;
	  };
	  var scratchScale = new Cartesian3();
	  Matrix3.getMaximumScale = function(matrix) {
	    Matrix3.getScale(matrix, scratchScale);
	    return Cartesian3.maximumComponent(scratchScale);
	  };
	  Matrix3.multiply = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
	    var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
	    var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];
	    var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
	    var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
	    var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];
	    var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
	    var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
	    var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];
	    result[0] = column0Row0;
	    result[1] = column0Row1;
	    result[2] = column0Row2;
	    result[3] = column1Row0;
	    result[4] = column1Row1;
	    result[5] = column1Row2;
	    result[6] = column2Row0;
	    result[7] = column2Row1;
	    result[8] = column2Row2;
	    return result;
	  };
	  Matrix3.add = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = left[0] + right[0];
	    result[1] = left[1] + right[1];
	    result[2] = left[2] + right[2];
	    result[3] = left[3] + right[3];
	    result[4] = left[4] + right[4];
	    result[5] = left[5] + right[5];
	    result[6] = left[6] + right[6];
	    result[7] = left[7] + right[7];
	    result[8] = left[8] + right[8];
	    return result;
	  };
	  Matrix3.subtract = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = left[0] - right[0];
	    result[1] = left[1] - right[1];
	    result[2] = left[2] - right[2];
	    result[3] = left[3] - right[3];
	    result[4] = left[4] - right[4];
	    result[5] = left[5] - right[5];
	    result[6] = left[6] - right[6];
	    result[7] = left[7] - right[7];
	    result[8] = left[8] - right[8];
	    return result;
	  };
	  Matrix3.multiplyByVector = function(matrix, cartesian, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var vX = cartesian.x;
	    var vY = cartesian.y;
	    var vZ = cartesian.z;
	    var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
	    var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
	    var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return result;
	  };
	  Matrix3.multiplyByScalar = function(matrix, scalar, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar must be a number');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = matrix[0] * scalar;
	    result[1] = matrix[1] * scalar;
	    result[2] = matrix[2] * scalar;
	    result[3] = matrix[3] * scalar;
	    result[4] = matrix[4] * scalar;
	    result[5] = matrix[5] * scalar;
	    result[6] = matrix[6] * scalar;
	    result[7] = matrix[7] * scalar;
	    result[8] = matrix[8] * scalar;
	    return result;
	  };
	  Matrix3.multiplyByScale = function(matrix, scale, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(scale)) {
	      throw new DeveloperError('scale is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = matrix[0] * scale.x;
	    result[1] = matrix[1] * scale.x;
	    result[2] = matrix[2] * scale.x;
	    result[3] = matrix[3] * scale.y;
	    result[4] = matrix[4] * scale.y;
	    result[5] = matrix[5] * scale.y;
	    result[6] = matrix[6] * scale.z;
	    result[7] = matrix[7] * scale.z;
	    result[8] = matrix[8] * scale.z;
	    return result;
	  };
	  Matrix3.negate = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = -matrix[0];
	    result[1] = -matrix[1];
	    result[2] = -matrix[2];
	    result[3] = -matrix[3];
	    result[4] = -matrix[4];
	    result[5] = -matrix[5];
	    result[6] = -matrix[6];
	    result[7] = -matrix[7];
	    result[8] = -matrix[8];
	    return result;
	  };
	  Matrix3.transpose = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var column0Row0 = matrix[0];
	    var column0Row1 = matrix[3];
	    var column0Row2 = matrix[6];
	    var column1Row0 = matrix[1];
	    var column1Row1 = matrix[4];
	    var column1Row2 = matrix[7];
	    var column2Row0 = matrix[2];
	    var column2Row1 = matrix[5];
	    var column2Row2 = matrix[8];
	    result[0] = column0Row0;
	    result[1] = column0Row1;
	    result[2] = column0Row2;
	    result[3] = column1Row0;
	    result[4] = column1Row1;
	    result[5] = column1Row2;
	    result[6] = column2Row0;
	    result[7] = column2Row1;
	    result[8] = column2Row2;
	    return result;
	  };
	  function computeFrobeniusNorm(matrix) {
	    var norm = 0.0;
	    for (var i = 0; i < 9; ++i) {
	      var temp = matrix[i];
	      norm += temp * temp;
	    }
	    return Math.sqrt(norm);
	  }
	  var rowVal = [1, 0, 0];
	  var colVal = [2, 2, 1];
	  function offDiagonalFrobeniusNorm(matrix) {
	    var norm = 0.0;
	    for (var i = 0; i < 3; ++i) {
	      var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];
	      norm += 2.0 * temp * temp;
	    }
	    return Math.sqrt(norm);
	  }
	  function shurDecomposition(matrix, result) {
	    var tolerance = CesiumMath.EPSILON15;
	    var maxDiagonal = 0.0;
	    var rotAxis = 1;
	    for (var i = 0; i < 3; ++i) {
	      var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);
	      if (temp > maxDiagonal) {
	        rotAxis = i;
	        maxDiagonal = temp;
	      }
	    }
	    var c = 1.0;
	    var s = 0.0;
	    var p = rowVal[rotAxis];
	    var q = colVal[rotAxis];
	    if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {
	      var qq = matrix[Matrix3.getElementIndex(q, q)];
	      var pp = matrix[Matrix3.getElementIndex(p, p)];
	      var qp = matrix[Matrix3.getElementIndex(q, p)];
	      var tau = (qq - pp) / 2.0 / qp;
	      var t;
	      if (tau < 0.0) {
	        t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
	      } else {
	        t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
	      }
	      c = 1.0 / Math.sqrt(1.0 + t * t);
	      s = t * c;
	    }
	    result = Matrix3.clone(Matrix3.IDENTITY, result);
	    result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;
	    result[Matrix3.getElementIndex(q, p)] = s;
	    result[Matrix3.getElementIndex(p, q)] = -s;
	    return result;
	  }
	  var jMatrix = new Matrix3();
	  var jMatrixTranspose = new Matrix3();
	  Matrix3.computeEigenDecomposition = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    var tolerance = CesiumMath.EPSILON20;
	    var maxSweeps = 10;
	    var count = 0;
	    var sweep = 0;
	    if (!defined(result)) {
	      result = {};
	    }
	    var unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);
	    var diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);
	    var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);
	    while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {
	      shurDecomposition(diagMatrix, jMatrix);
	      Matrix3.transpose(jMatrix, jMatrixTranspose);
	      Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);
	      Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);
	      Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);
	      if (++count > 2) {
	        ++sweep;
	        count = 0;
	      }
	    }
	    return result;
	  };
	  Matrix3.abs = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = Math.abs(matrix[0]);
	    result[1] = Math.abs(matrix[1]);
	    result[2] = Math.abs(matrix[2]);
	    result[3] = Math.abs(matrix[3]);
	    result[4] = Math.abs(matrix[4]);
	    result[5] = Math.abs(matrix[5]);
	    result[6] = Math.abs(matrix[6]);
	    result[7] = Math.abs(matrix[7]);
	    result[8] = Math.abs(matrix[8]);
	    return result;
	  };
	  Matrix3.determinant = function(matrix) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    var m11 = matrix[0];
	    var m21 = matrix[3];
	    var m31 = matrix[6];
	    var m12 = matrix[1];
	    var m22 = matrix[4];
	    var m32 = matrix[7];
	    var m13 = matrix[2];
	    var m23 = matrix[5];
	    var m33 = matrix[8];
	    return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
	  };
	  Matrix3.inverse = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var m11 = matrix[0];
	    var m21 = matrix[1];
	    var m31 = matrix[2];
	    var m12 = matrix[3];
	    var m22 = matrix[4];
	    var m32 = matrix[5];
	    var m13 = matrix[6];
	    var m23 = matrix[7];
	    var m33 = matrix[8];
	    var determinant = Matrix3.determinant(matrix);
	    if (Math.abs(determinant) <= CesiumMath.EPSILON15) {
	      throw new DeveloperError('matrix is not invertible');
	    }
	    result[0] = m22 * m33 - m23 * m32;
	    result[1] = m23 * m31 - m21 * m33;
	    result[2] = m21 * m32 - m22 * m31;
	    result[3] = m13 * m32 - m12 * m33;
	    result[4] = m11 * m33 - m13 * m31;
	    result[5] = m12 * m31 - m11 * m32;
	    result[6] = m12 * m23 - m13 * m22;
	    result[7] = m13 * m21 - m11 * m23;
	    result[8] = m11 * m22 - m12 * m21;
	    var scale = 1.0 / determinant;
	    return Matrix3.multiplyByScalar(result, scale, result);
	  };
	  Matrix3.equals = function(left, right) {
	    return (left === right) || (defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[7] === right[7] && left[8] === right[8]);
	  };
	  Matrix3.equalsEpsilon = function(left, right, epsilon) {
	    if (typeof epsilon !== 'number') {
	      throw new DeveloperError('epsilon must be a number');
	    }
	    return (left === right) || (defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon);
	  };
	  Matrix3.IDENTITY = freezeObject(new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0));
	  Matrix3.ZERO = freezeObject(new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
	  Matrix3.COLUMN0ROW0 = 0;
	  Matrix3.COLUMN0ROW1 = 1;
	  Matrix3.COLUMN0ROW2 = 2;
	  Matrix3.COLUMN1ROW0 = 3;
	  Matrix3.COLUMN1ROW1 = 4;
	  Matrix3.COLUMN1ROW2 = 5;
	  Matrix3.COLUMN2ROW0 = 6;
	  Matrix3.COLUMN2ROW1 = 7;
	  Matrix3.COLUMN2ROW2 = 8;
	  defineProperties(Matrix3.prototype, {length: {get: function() {
	        return Matrix3.packedLength;
	      }}});
	  Matrix3.prototype.clone = function(result) {
	    return Matrix3.clone(this, result);
	  };
	  Matrix3.prototype.equals = function(right) {
	    return Matrix3.equals(this, right);
	  };
	  Matrix3.equalsArray = function(matrix, array, offset) {
	    return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8];
	  };
	  Matrix3.prototype.equalsEpsilon = function(right, epsilon) {
	    return Matrix3.equalsEpsilon(this, right, epsilon);
	  };
	  Matrix3.prototype.toString = function() {
	    return '(' + this[0] + ', ' + this[3] + ', ' + this[6] + ')\n' + '(' + this[1] + ', ' + this[4] + ', ' + this[7] + ')\n' + '(' + this[2] + ', ' + this[5] + ', ' + this[8] + ')';
	  };
	  return Matrix3;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("38", ["1a"], function(defined) {
	  'use strict';
	  function RuntimeError(message) {
	    this.name = 'RuntimeError';
	    this.message = message;
	    var stack;
	    try {
	      throw new Error();
	    } catch (e) {
	      stack = e.stack;
	    }
	    this.stack = stack;
	  }
	  if (defined(Object.create)) {
	    RuntimeError.prototype = Object.create(Error.prototype);
	    RuntimeError.prototype.constructor = RuntimeError;
	  }
	  RuntimeError.prototype.toString = function() {
	    var str = this.name + ': ' + this.message;
	    if (defined(this.stack)) {
	      str += '\n' + this.stack.toString();
	    }
	    return str;
	  };
	  return RuntimeError;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("33", ["2c", "43", "23", "1a", "1b", "1c", "1f", "27", "32", "38"], function(Cartesian3, Cartesian4, defaultValue, defined, defineProperties, DeveloperError, freezeObject, CesiumMath, Matrix3, RuntimeError) {
	  'use strict';
	  function Matrix4(column0Row0, column1Row0, column2Row0, column3Row0, column0Row1, column1Row1, column2Row1, column3Row1, column0Row2, column1Row2, column2Row2, column3Row2, column0Row3, column1Row3, column2Row3, column3Row3) {
	    this[0] = defaultValue(column0Row0, 0.0);
	    this[1] = defaultValue(column0Row1, 0.0);
	    this[2] = defaultValue(column0Row2, 0.0);
	    this[3] = defaultValue(column0Row3, 0.0);
	    this[4] = defaultValue(column1Row0, 0.0);
	    this[5] = defaultValue(column1Row1, 0.0);
	    this[6] = defaultValue(column1Row2, 0.0);
	    this[7] = defaultValue(column1Row3, 0.0);
	    this[8] = defaultValue(column2Row0, 0.0);
	    this[9] = defaultValue(column2Row1, 0.0);
	    this[10] = defaultValue(column2Row2, 0.0);
	    this[11] = defaultValue(column2Row3, 0.0);
	    this[12] = defaultValue(column3Row0, 0.0);
	    this[13] = defaultValue(column3Row1, 0.0);
	    this[14] = defaultValue(column3Row2, 0.0);
	    this[15] = defaultValue(column3Row3, 0.0);
	  }
	  Matrix4.packedLength = 16;
	  Matrix4.pack = function(value, array, startingIndex) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required');
	    }
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    array[startingIndex++] = value[0];
	    array[startingIndex++] = value[1];
	    array[startingIndex++] = value[2];
	    array[startingIndex++] = value[3];
	    array[startingIndex++] = value[4];
	    array[startingIndex++] = value[5];
	    array[startingIndex++] = value[6];
	    array[startingIndex++] = value[7];
	    array[startingIndex++] = value[8];
	    array[startingIndex++] = value[9];
	    array[startingIndex++] = value[10];
	    array[startingIndex++] = value[11];
	    array[startingIndex++] = value[12];
	    array[startingIndex++] = value[13];
	    array[startingIndex++] = value[14];
	    array[startingIndex] = value[15];
	  };
	  Matrix4.unpack = function(array, startingIndex, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    if (!defined(result)) {
	      result = new Matrix4();
	    }
	    result[0] = array[startingIndex++];
	    result[1] = array[startingIndex++];
	    result[2] = array[startingIndex++];
	    result[3] = array[startingIndex++];
	    result[4] = array[startingIndex++];
	    result[5] = array[startingIndex++];
	    result[6] = array[startingIndex++];
	    result[7] = array[startingIndex++];
	    result[8] = array[startingIndex++];
	    result[9] = array[startingIndex++];
	    result[10] = array[startingIndex++];
	    result[11] = array[startingIndex++];
	    result[12] = array[startingIndex++];
	    result[13] = array[startingIndex++];
	    result[14] = array[startingIndex++];
	    result[15] = array[startingIndex];
	    return result;
	  };
	  Matrix4.clone = function(matrix, result) {
	    if (!defined(matrix)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new Matrix4(matrix[0], matrix[4], matrix[8], matrix[12], matrix[1], matrix[5], matrix[9], matrix[13], matrix[2], matrix[6], matrix[10], matrix[14], matrix[3], matrix[7], matrix[11], matrix[15]);
	    }
	    result[0] = matrix[0];
	    result[1] = matrix[1];
	    result[2] = matrix[2];
	    result[3] = matrix[3];
	    result[4] = matrix[4];
	    result[5] = matrix[5];
	    result[6] = matrix[6];
	    result[7] = matrix[7];
	    result[8] = matrix[8];
	    result[9] = matrix[9];
	    result[10] = matrix[10];
	    result[11] = matrix[11];
	    result[12] = matrix[12];
	    result[13] = matrix[13];
	    result[14] = matrix[14];
	    result[15] = matrix[15];
	    return result;
	  };
	  Matrix4.fromArray = Matrix4.unpack;
	  Matrix4.fromColumnMajorArray = function(values, result) {
	    if (!defined(values)) {
	      throw new DeveloperError('values is required');
	    }
	    return Matrix4.clone(values, result);
	  };
	  Matrix4.fromRowMajorArray = function(values, result) {
	    if (!defined(values)) {
	      throw new DeveloperError('values is required.');
	    }
	    if (!defined(result)) {
	      return new Matrix4(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8], values[9], values[10], values[11], values[12], values[13], values[14], values[15]);
	    }
	    result[0] = values[0];
	    result[1] = values[4];
	    result[2] = values[8];
	    result[3] = values[12];
	    result[4] = values[1];
	    result[5] = values[5];
	    result[6] = values[9];
	    result[7] = values[13];
	    result[8] = values[2];
	    result[9] = values[6];
	    result[10] = values[10];
	    result[11] = values[14];
	    result[12] = values[3];
	    result[13] = values[7];
	    result[14] = values[11];
	    result[15] = values[15];
	    return result;
	  };
	  Matrix4.fromRotationTranslation = function(rotation, translation, result) {
	    if (!defined(rotation)) {
	      throw new DeveloperError('rotation is required.');
	    }
	    translation = defaultValue(translation, Cartesian3.ZERO);
	    if (!defined(result)) {
	      return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x, rotation[1], rotation[4], rotation[7], translation.y, rotation[2], rotation[5], rotation[8], translation.z, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = rotation[0];
	    result[1] = rotation[1];
	    result[2] = rotation[2];
	    result[3] = 0.0;
	    result[4] = rotation[3];
	    result[5] = rotation[4];
	    result[6] = rotation[5];
	    result[7] = 0.0;
	    result[8] = rotation[6];
	    result[9] = rotation[7];
	    result[10] = rotation[8];
	    result[11] = 0.0;
	    result[12] = translation.x;
	    result[13] = translation.y;
	    result[14] = translation.z;
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.fromTranslationQuaternionRotationScale = function(translation, rotation, scale, result) {
	    if (!defined(translation)) {
	      throw new DeveloperError('translation is required.');
	    }
	    if (!defined(rotation)) {
	      throw new DeveloperError('rotation is required.');
	    }
	    if (!defined(scale)) {
	      throw new DeveloperError('scale is required.');
	    }
	    if (!defined(result)) {
	      result = new Matrix4();
	    }
	    var scaleX = scale.x;
	    var scaleY = scale.y;
	    var scaleZ = scale.z;
	    var x2 = rotation.x * rotation.x;
	    var xy = rotation.x * rotation.y;
	    var xz = rotation.x * rotation.z;
	    var xw = rotation.x * rotation.w;
	    var y2 = rotation.y * rotation.y;
	    var yz = rotation.y * rotation.z;
	    var yw = rotation.y * rotation.w;
	    var z2 = rotation.z * rotation.z;
	    var zw = rotation.z * rotation.w;
	    var w2 = rotation.w * rotation.w;
	    var m00 = x2 - y2 - z2 + w2;
	    var m01 = 2.0 * (xy - zw);
	    var m02 = 2.0 * (xz + yw);
	    var m10 = 2.0 * (xy + zw);
	    var m11 = -x2 + y2 - z2 + w2;
	    var m12 = 2.0 * (yz - xw);
	    var m20 = 2.0 * (xz - yw);
	    var m21 = 2.0 * (yz + xw);
	    var m22 = -x2 - y2 + z2 + w2;
	    result[0] = m00 * scaleX;
	    result[1] = m10 * scaleX;
	    result[2] = m20 * scaleX;
	    result[3] = 0.0;
	    result[4] = m01 * scaleY;
	    result[5] = m11 * scaleY;
	    result[6] = m21 * scaleY;
	    result[7] = 0.0;
	    result[8] = m02 * scaleZ;
	    result[9] = m12 * scaleZ;
	    result[10] = m22 * scaleZ;
	    result[11] = 0.0;
	    result[12] = translation.x;
	    result[13] = translation.y;
	    result[14] = translation.z;
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.fromTranslationRotationScale = function(translationRotationScale, result) {
	    if (!defined(translationRotationScale)) {
	      throw new DeveloperError('translationRotationScale is required.');
	    }
	    return Matrix4.fromTranslationQuaternionRotationScale(translationRotationScale.translation, translationRotationScale.rotation, translationRotationScale.scale, result);
	  };
	  Matrix4.fromTranslation = function(translation, result) {
	    if (!defined(translation)) {
	      throw new DeveloperError('translation is required.');
	    }
	    return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
	  };
	  Matrix4.fromScale = function(scale, result) {
	    if (!defined(scale)) {
	      throw new DeveloperError('scale is required.');
	    }
	    if (!defined(result)) {
	      return new Matrix4(scale.x, 0.0, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, 0.0, scale.z, 0.0, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = scale.x;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = 0.0;
	    result[5] = scale.y;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = 0.0;
	    result[9] = 0.0;
	    result[10] = scale.z;
	    result[11] = 0.0;
	    result[12] = 0.0;
	    result[13] = 0.0;
	    result[14] = 0.0;
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.fromUniformScale = function(scale, result) {
	    if (typeof scale !== 'number') {
	      throw new DeveloperError('scale is required.');
	    }
	    if (!defined(result)) {
	      return new Matrix4(scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = scale;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = 0.0;
	    result[5] = scale;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = 0.0;
	    result[9] = 0.0;
	    result[10] = scale;
	    result[11] = 0.0;
	    result[12] = 0.0;
	    result[13] = 0.0;
	    result[14] = 0.0;
	    result[15] = 1.0;
	    return result;
	  };
	  var fromCameraF = new Cartesian3();
	  var fromCameraR = new Cartesian3();
	  var fromCameraU = new Cartesian3();
	  Matrix4.fromCamera = function(camera, result) {
	    if (!defined(camera)) {
	      throw new DeveloperError('camera is required.');
	    }
	    var position = camera.position;
	    var direction = camera.direction;
	    var up = camera.up;
	    if (!defined(position)) {
	      throw new DeveloperError('camera.position is required.');
	    }
	    if (!defined(direction)) {
	      throw new DeveloperError('camera.direction is required.');
	    }
	    if (!defined(up)) {
	      throw new DeveloperError('camera.up is required.');
	    }
	    Cartesian3.normalize(direction, fromCameraF);
	    Cartesian3.normalize(Cartesian3.cross(fromCameraF, up, fromCameraR), fromCameraR);
	    Cartesian3.normalize(Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU), fromCameraU);
	    var sX = fromCameraR.x;
	    var sY = fromCameraR.y;
	    var sZ = fromCameraR.z;
	    var fX = fromCameraF.x;
	    var fY = fromCameraF.y;
	    var fZ = fromCameraF.z;
	    var uX = fromCameraU.x;
	    var uY = fromCameraU.y;
	    var uZ = fromCameraU.z;
	    var positionX = position.x;
	    var positionY = position.y;
	    var positionZ = position.z;
	    var t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;
	    var t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;
	    var t2 = fX * positionX + fY * positionY + fZ * positionZ;
	    if (!defined(result)) {
	      return new Matrix4(sX, sY, sZ, t0, uX, uY, uZ, t1, -fX, -fY, -fZ, t2, 0.0, 0.0, 0.0, 1.0);
	    }
	    result[0] = sX;
	    result[1] = uX;
	    result[2] = -fX;
	    result[3] = 0.0;
	    result[4] = sY;
	    result[5] = uY;
	    result[6] = -fY;
	    result[7] = 0.0;
	    result[8] = sZ;
	    result[9] = uZ;
	    result[10] = -fZ;
	    result[11] = 0.0;
	    result[12] = t0;
	    result[13] = t1;
	    result[14] = t2;
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.computePerspectiveFieldOfView = function(fovY, aspectRatio, near, far, result) {
	    if (fovY <= 0.0 || fovY > Math.PI) {
	      throw new DeveloperError('fovY must be in [0, PI).');
	    }
	    if (aspectRatio <= 0.0) {
	      throw new DeveloperError('aspectRatio must be greater than zero.');
	    }
	    if (near <= 0.0) {
	      throw new DeveloperError('near must be greater than zero.');
	    }
	    if (far <= 0.0) {
	      throw new DeveloperError('far must be greater than zero.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var bottom = Math.tan(fovY * 0.5);
	    var column1Row1 = 1.0 / bottom;
	    var column0Row0 = column1Row1 / aspectRatio;
	    var column2Row2 = (far + near) / (near - far);
	    var column3Row2 = (2.0 * far * near) / (near - far);
	    result[0] = column0Row0;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = 0.0;
	    result[5] = column1Row1;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = 0.0;
	    result[9] = 0.0;
	    result[10] = column2Row2;
	    result[11] = -1.0;
	    result[12] = 0.0;
	    result[13] = 0.0;
	    result[14] = column3Row2;
	    result[15] = 0.0;
	    return result;
	  };
	  Matrix4.computeOrthographicOffCenter = function(left, right, bottom, top, near, far, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required.');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required.');
	    }
	    if (!defined(bottom)) {
	      throw new DeveloperError('bottom is required.');
	    }
	    if (!defined(top)) {
	      throw new DeveloperError('top is required.');
	    }
	    if (!defined(near)) {
	      throw new DeveloperError('near is required.');
	    }
	    if (!defined(far)) {
	      throw new DeveloperError('far is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var a = 1.0 / (right - left);
	    var b = 1.0 / (top - bottom);
	    var c = 1.0 / (far - near);
	    var tx = -(right + left) * a;
	    var ty = -(top + bottom) * b;
	    var tz = -(far + near) * c;
	    a *= 2.0;
	    b *= 2.0;
	    c *= -2.0;
	    result[0] = a;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = 0.0;
	    result[5] = b;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = 0.0;
	    result[9] = 0.0;
	    result[10] = c;
	    result[11] = 0.0;
	    result[12] = tx;
	    result[13] = ty;
	    result[14] = tz;
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.computePerspectiveOffCenter = function(left, right, bottom, top, near, far, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required.');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required.');
	    }
	    if (!defined(bottom)) {
	      throw new DeveloperError('bottom is required.');
	    }
	    if (!defined(top)) {
	      throw new DeveloperError('top is required.');
	    }
	    if (!defined(near)) {
	      throw new DeveloperError('near is required.');
	    }
	    if (!defined(far)) {
	      throw new DeveloperError('far is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var column0Row0 = 2.0 * near / (right - left);
	    var column1Row1 = 2.0 * near / (top - bottom);
	    var column2Row0 = (right + left) / (right - left);
	    var column2Row1 = (top + bottom) / (top - bottom);
	    var column2Row2 = -(far + near) / (far - near);
	    var column2Row3 = -1.0;
	    var column3Row2 = -2.0 * far * near / (far - near);
	    result[0] = column0Row0;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = 0.0;
	    result[5] = column1Row1;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = column2Row0;
	    result[9] = column2Row1;
	    result[10] = column2Row2;
	    result[11] = column2Row3;
	    result[12] = 0.0;
	    result[13] = 0.0;
	    result[14] = column3Row2;
	    result[15] = 0.0;
	    return result;
	  };
	  Matrix4.computeInfinitePerspectiveOffCenter = function(left, right, bottom, top, near, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required.');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required.');
	    }
	    if (!defined(bottom)) {
	      throw new DeveloperError('bottom is required.');
	    }
	    if (!defined(top)) {
	      throw new DeveloperError('top is required.');
	    }
	    if (!defined(near)) {
	      throw new DeveloperError('near is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var column0Row0 = 2.0 * near / (right - left);
	    var column1Row1 = 2.0 * near / (top - bottom);
	    var column2Row0 = (right + left) / (right - left);
	    var column2Row1 = (top + bottom) / (top - bottom);
	    var column2Row2 = -1.0;
	    var column2Row3 = -1.0;
	    var column3Row2 = -2.0 * near;
	    result[0] = column0Row0;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = 0.0;
	    result[5] = column1Row1;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = column2Row0;
	    result[9] = column2Row1;
	    result[10] = column2Row2;
	    result[11] = column2Row3;
	    result[12] = 0.0;
	    result[13] = 0.0;
	    result[14] = column3Row2;
	    result[15] = 0.0;
	    return result;
	  };
	  Matrix4.computeViewportTransformation = function(viewport, nearDepthRange, farDepthRange, result) {
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);
	    var x = defaultValue(viewport.x, 0.0);
	    var y = defaultValue(viewport.y, 0.0);
	    var width = defaultValue(viewport.width, 0.0);
	    var height = defaultValue(viewport.height, 0.0);
	    nearDepthRange = defaultValue(nearDepthRange, 0.0);
	    farDepthRange = defaultValue(farDepthRange, 1.0);
	    var halfWidth = width * 0.5;
	    var halfHeight = height * 0.5;
	    var halfDepth = (farDepthRange - nearDepthRange) * 0.5;
	    var column0Row0 = halfWidth;
	    var column1Row1 = halfHeight;
	    var column2Row2 = halfDepth;
	    var column3Row0 = x + halfWidth;
	    var column3Row1 = y + halfHeight;
	    var column3Row2 = nearDepthRange + halfDepth;
	    var column3Row3 = 1.0;
	    result[0] = column0Row0;
	    result[1] = 0.0;
	    result[2] = 0.0;
	    result[3] = 0.0;
	    result[4] = 0.0;
	    result[5] = column1Row1;
	    result[6] = 0.0;
	    result[7] = 0.0;
	    result[8] = 0.0;
	    result[9] = 0.0;
	    result[10] = column2Row2;
	    result[11] = 0.0;
	    result[12] = column3Row0;
	    result[13] = column3Row1;
	    result[14] = column3Row2;
	    result[15] = column3Row3;
	    return result;
	  };
	  Matrix4.computeView = function(position, direction, up, right, result) {
	    if (!defined(position)) {
	      throw new DeveloperError('position is required');
	    }
	    if (!defined(direction)) {
	      throw new DeveloperError('direction is required');
	    }
	    if (!defined(up)) {
	      throw new DeveloperError('up is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = right.x;
	    result[1] = up.x;
	    result[2] = -direction.x;
	    result[3] = 0.0;
	    result[4] = right.y;
	    result[5] = up.y;
	    result[6] = -direction.y;
	    result[7] = 0.0;
	    result[8] = right.z;
	    result[9] = up.z;
	    result[10] = -direction.z;
	    result[11] = 0.0;
	    result[12] = -Cartesian3.dot(right, position);
	    result[13] = -Cartesian3.dot(up, position);
	    result[14] = Cartesian3.dot(direction, position);
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.toArray = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8], matrix[9], matrix[10], matrix[11], matrix[12], matrix[13], matrix[14], matrix[15]];
	    }
	    result[0] = matrix[0];
	    result[1] = matrix[1];
	    result[2] = matrix[2];
	    result[3] = matrix[3];
	    result[4] = matrix[4];
	    result[5] = matrix[5];
	    result[6] = matrix[6];
	    result[7] = matrix[7];
	    result[8] = matrix[8];
	    result[9] = matrix[9];
	    result[10] = matrix[10];
	    result[11] = matrix[11];
	    result[12] = matrix[12];
	    result[13] = matrix[13];
	    result[14] = matrix[14];
	    result[15] = matrix[15];
	    return result;
	  };
	  Matrix4.getElementIndex = function(column, row) {
	    if (typeof row !== 'number' || row < 0 || row > 3) {
	      throw new DeveloperError('row must be 0, 1, 2, or 3.');
	    }
	    if (typeof column !== 'number' || column < 0 || column > 3) {
	      throw new DeveloperError('column must be 0, 1, 2, or 3.');
	    }
	    return column * 4 + row;
	  };
	  Matrix4.getColumn = function(matrix, index, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    if (typeof index !== 'number' || index < 0 || index > 3) {
	      throw new DeveloperError('index must be 0, 1, 2, or 3.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var startIndex = index * 4;
	    var x = matrix[startIndex];
	    var y = matrix[startIndex + 1];
	    var z = matrix[startIndex + 2];
	    var w = matrix[startIndex + 3];
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    result.w = w;
	    return result;
	  };
	  Matrix4.setColumn = function(matrix, index, cartesian, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof index !== 'number' || index < 0 || index > 3) {
	      throw new DeveloperError('index must be 0, 1, 2, or 3.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result = Matrix4.clone(matrix, result);
	    var startIndex = index * 4;
	    result[startIndex] = cartesian.x;
	    result[startIndex + 1] = cartesian.y;
	    result[startIndex + 2] = cartesian.z;
	    result[startIndex + 3] = cartesian.w;
	    return result;
	  };
	  Matrix4.setTranslation = function(matrix, translation, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(translation)) {
	      throw new DeveloperError('translation is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = matrix[0];
	    result[1] = matrix[1];
	    result[2] = matrix[2];
	    result[3] = matrix[3];
	    result[4] = matrix[4];
	    result[5] = matrix[5];
	    result[6] = matrix[6];
	    result[7] = matrix[7];
	    result[8] = matrix[8];
	    result[9] = matrix[9];
	    result[10] = matrix[10];
	    result[11] = matrix[11];
	    result[12] = translation.x;
	    result[13] = translation.y;
	    result[14] = translation.z;
	    result[15] = matrix[15];
	    return result;
	  };
	  Matrix4.getRow = function(matrix, index, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    if (typeof index !== 'number' || index < 0 || index > 3) {
	      throw new DeveloperError('index must be 0, 1, 2, or 3.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var x = matrix[index];
	    var y = matrix[index + 4];
	    var z = matrix[index + 8];
	    var w = matrix[index + 12];
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    result.w = w;
	    return result;
	  };
	  Matrix4.setRow = function(matrix, index, cartesian, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof index !== 'number' || index < 0 || index > 3) {
	      throw new DeveloperError('index must be 0, 1, 2, or 3.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result = Matrix4.clone(matrix, result);
	    result[index] = cartesian.x;
	    result[index + 4] = cartesian.y;
	    result[index + 8] = cartesian.z;
	    result[index + 12] = cartesian.w;
	    return result;
	  };
	  var scratchColumn = new Cartesian3();
	  Matrix4.getScale = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
	    result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn));
	    result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn));
	    return result;
	  };
	  var scratchScale = new Cartesian3();
	  Matrix4.getMaximumScale = function(matrix) {
	    Matrix4.getScale(matrix, scratchScale);
	    return Cartesian3.maximumComponent(scratchScale);
	  };
	  Matrix4.multiply = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var left0 = left[0];
	    var left1 = left[1];
	    var left2 = left[2];
	    var left3 = left[3];
	    var left4 = left[4];
	    var left5 = left[5];
	    var left6 = left[6];
	    var left7 = left[7];
	    var left8 = left[8];
	    var left9 = left[9];
	    var left10 = left[10];
	    var left11 = left[11];
	    var left12 = left[12];
	    var left13 = left[13];
	    var left14 = left[14];
	    var left15 = left[15];
	    var right0 = right[0];
	    var right1 = right[1];
	    var right2 = right[2];
	    var right3 = right[3];
	    var right4 = right[4];
	    var right5 = right[5];
	    var right6 = right[6];
	    var right7 = right[7];
	    var right8 = right[8];
	    var right9 = right[9];
	    var right10 = right[10];
	    var right11 = right[11];
	    var right12 = right[12];
	    var right13 = right[13];
	    var right14 = right[14];
	    var right15 = right[15];
	    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
	    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
	    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
	    var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;
	    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
	    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
	    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
	    var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;
	    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
	    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
	    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
	    var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;
	    var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
	    var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
	    var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
	    var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;
	    result[0] = column0Row0;
	    result[1] = column0Row1;
	    result[2] = column0Row2;
	    result[3] = column0Row3;
	    result[4] = column1Row0;
	    result[5] = column1Row1;
	    result[6] = column1Row2;
	    result[7] = column1Row3;
	    result[8] = column2Row0;
	    result[9] = column2Row1;
	    result[10] = column2Row2;
	    result[11] = column2Row3;
	    result[12] = column3Row0;
	    result[13] = column3Row1;
	    result[14] = column3Row2;
	    result[15] = column3Row3;
	    return result;
	  };
	  Matrix4.add = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = left[0] + right[0];
	    result[1] = left[1] + right[1];
	    result[2] = left[2] + right[2];
	    result[3] = left[3] + right[3];
	    result[4] = left[4] + right[4];
	    result[5] = left[5] + right[5];
	    result[6] = left[6] + right[6];
	    result[7] = left[7] + right[7];
	    result[8] = left[8] + right[8];
	    result[9] = left[9] + right[9];
	    result[10] = left[10] + right[10];
	    result[11] = left[11] + right[11];
	    result[12] = left[12] + right[12];
	    result[13] = left[13] + right[13];
	    result[14] = left[14] + right[14];
	    result[15] = left[15] + right[15];
	    return result;
	  };
	  Matrix4.subtract = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = left[0] - right[0];
	    result[1] = left[1] - right[1];
	    result[2] = left[2] - right[2];
	    result[3] = left[3] - right[3];
	    result[4] = left[4] - right[4];
	    result[5] = left[5] - right[5];
	    result[6] = left[6] - right[6];
	    result[7] = left[7] - right[7];
	    result[8] = left[8] - right[8];
	    result[9] = left[9] - right[9];
	    result[10] = left[10] - right[10];
	    result[11] = left[11] - right[11];
	    result[12] = left[12] - right[12];
	    result[13] = left[13] - right[13];
	    result[14] = left[14] - right[14];
	    result[15] = left[15] - right[15];
	    return result;
	  };
	  Matrix4.multiplyTransformation = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var left0 = left[0];
	    var left1 = left[1];
	    var left2 = left[2];
	    var left4 = left[4];
	    var left5 = left[5];
	    var left6 = left[6];
	    var left8 = left[8];
	    var left9 = left[9];
	    var left10 = left[10];
	    var left12 = left[12];
	    var left13 = left[13];
	    var left14 = left[14];
	    var right0 = right[0];
	    var right1 = right[1];
	    var right2 = right[2];
	    var right4 = right[4];
	    var right5 = right[5];
	    var right6 = right[6];
	    var right8 = right[8];
	    var right9 = right[9];
	    var right10 = right[10];
	    var right12 = right[12];
	    var right13 = right[13];
	    var right14 = right[14];
	    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
	    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
	    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
	    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
	    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
	    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
	    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
	    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
	    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
	    var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12;
	    var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13;
	    var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14;
	    result[0] = column0Row0;
	    result[1] = column0Row1;
	    result[2] = column0Row2;
	    result[3] = 0.0;
	    result[4] = column1Row0;
	    result[5] = column1Row1;
	    result[6] = column1Row2;
	    result[7] = 0.0;
	    result[8] = column2Row0;
	    result[9] = column2Row1;
	    result[10] = column2Row2;
	    result[11] = 0.0;
	    result[12] = column3Row0;
	    result[13] = column3Row1;
	    result[14] = column3Row2;
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.multiplyByMatrix3 = function(matrix, rotation, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(rotation)) {
	      throw new DeveloperError('rotation is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var left0 = matrix[0];
	    var left1 = matrix[1];
	    var left2 = matrix[2];
	    var left4 = matrix[4];
	    var left5 = matrix[5];
	    var left6 = matrix[6];
	    var left8 = matrix[8];
	    var left9 = matrix[9];
	    var left10 = matrix[10];
	    var right0 = rotation[0];
	    var right1 = rotation[1];
	    var right2 = rotation[2];
	    var right4 = rotation[3];
	    var right5 = rotation[4];
	    var right6 = rotation[5];
	    var right8 = rotation[6];
	    var right9 = rotation[7];
	    var right10 = rotation[8];
	    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
	    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
	    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
	    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
	    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
	    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
	    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
	    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
	    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
	    result[0] = column0Row0;
	    result[1] = column0Row1;
	    result[2] = column0Row2;
	    result[3] = 0.0;
	    result[4] = column1Row0;
	    result[5] = column1Row1;
	    result[6] = column1Row2;
	    result[7] = 0.0;
	    result[8] = column2Row0;
	    result[9] = column2Row1;
	    result[10] = column2Row2;
	    result[11] = 0.0;
	    result[12] = matrix[12];
	    result[13] = matrix[13];
	    result[14] = matrix[14];
	    result[15] = matrix[15];
	    return result;
	  };
	  Matrix4.multiplyByTranslation = function(matrix, translation, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(translation)) {
	      throw new DeveloperError('translation is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var x = translation.x;
	    var y = translation.y;
	    var z = translation.z;
	    var tx = (x * matrix[0]) + (y * matrix[4]) + (z * matrix[8]) + matrix[12];
	    var ty = (x * matrix[1]) + (y * matrix[5]) + (z * matrix[9]) + matrix[13];
	    var tz = (x * matrix[2]) + (y * matrix[6]) + (z * matrix[10]) + matrix[14];
	    result[0] = matrix[0];
	    result[1] = matrix[1];
	    result[2] = matrix[2];
	    result[3] = matrix[3];
	    result[4] = matrix[4];
	    result[5] = matrix[5];
	    result[6] = matrix[6];
	    result[7] = matrix[7];
	    result[8] = matrix[8];
	    result[9] = matrix[9];
	    result[10] = matrix[10];
	    result[11] = matrix[11];
	    result[12] = tx;
	    result[13] = ty;
	    result[14] = tz;
	    result[15] = matrix[15];
	    return result;
	  };
	  var uniformScaleScratch = new Cartesian3();
	  Matrix4.multiplyByUniformScale = function(matrix, scale, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (typeof scale !== 'number') {
	      throw new DeveloperError('scale is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    uniformScaleScratch.x = scale;
	    uniformScaleScratch.y = scale;
	    uniformScaleScratch.z = scale;
	    return Matrix4.multiplyByScale(matrix, uniformScaleScratch, result);
	  };
	  Matrix4.multiplyByScale = function(matrix, scale, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(scale)) {
	      throw new DeveloperError('scale is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var scaleX = scale.x;
	    var scaleY = scale.y;
	    var scaleZ = scale.z;
	    if ((scaleX === 1.0) && (scaleY === 1.0) && (scaleZ === 1.0)) {
	      return Matrix4.clone(matrix, result);
	    }
	    result[0] = scaleX * matrix[0];
	    result[1] = scaleX * matrix[1];
	    result[2] = scaleX * matrix[2];
	    result[3] = 0.0;
	    result[4] = scaleY * matrix[4];
	    result[5] = scaleY * matrix[5];
	    result[6] = scaleY * matrix[6];
	    result[7] = 0.0;
	    result[8] = scaleZ * matrix[8];
	    result[9] = scaleZ * matrix[9];
	    result[10] = scaleZ * matrix[10];
	    result[11] = 0.0;
	    result[12] = matrix[12];
	    result[13] = matrix[13];
	    result[14] = matrix[14];
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.multiplyByVector = function(matrix, cartesian, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var vX = cartesian.x;
	    var vY = cartesian.y;
	    var vZ = cartesian.z;
	    var vW = cartesian.w;
	    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
	    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
	    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
	    var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    result.w = w;
	    return result;
	  };
	  Matrix4.multiplyByPointAsVector = function(matrix, cartesian, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var vX = cartesian.x;
	    var vY = cartesian.y;
	    var vZ = cartesian.z;
	    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
	    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
	    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return result;
	  };
	  Matrix4.multiplyByPoint = function(matrix, cartesian, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var vX = cartesian.x;
	    var vY = cartesian.y;
	    var vZ = cartesian.z;
	    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
	    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
	    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return result;
	  };
	  Matrix4.multiplyByScalar = function(matrix, scalar, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar must be a number');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = matrix[0] * scalar;
	    result[1] = matrix[1] * scalar;
	    result[2] = matrix[2] * scalar;
	    result[3] = matrix[3] * scalar;
	    result[4] = matrix[4] * scalar;
	    result[5] = matrix[5] * scalar;
	    result[6] = matrix[6] * scalar;
	    result[7] = matrix[7] * scalar;
	    result[8] = matrix[8] * scalar;
	    result[9] = matrix[9] * scalar;
	    result[10] = matrix[10] * scalar;
	    result[11] = matrix[11] * scalar;
	    result[12] = matrix[12] * scalar;
	    result[13] = matrix[13] * scalar;
	    result[14] = matrix[14] * scalar;
	    result[15] = matrix[15] * scalar;
	    return result;
	  };
	  Matrix4.negate = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = -matrix[0];
	    result[1] = -matrix[1];
	    result[2] = -matrix[2];
	    result[3] = -matrix[3];
	    result[4] = -matrix[4];
	    result[5] = -matrix[5];
	    result[6] = -matrix[6];
	    result[7] = -matrix[7];
	    result[8] = -matrix[8];
	    result[9] = -matrix[9];
	    result[10] = -matrix[10];
	    result[11] = -matrix[11];
	    result[12] = -matrix[12];
	    result[13] = -matrix[13];
	    result[14] = -matrix[14];
	    result[15] = -matrix[15];
	    return result;
	  };
	  Matrix4.transpose = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var matrix1 = matrix[1];
	    var matrix2 = matrix[2];
	    var matrix3 = matrix[3];
	    var matrix6 = matrix[6];
	    var matrix7 = matrix[7];
	    var matrix11 = matrix[11];
	    result[0] = matrix[0];
	    result[1] = matrix[4];
	    result[2] = matrix[8];
	    result[3] = matrix[12];
	    result[4] = matrix1;
	    result[5] = matrix[5];
	    result[6] = matrix[9];
	    result[7] = matrix[13];
	    result[8] = matrix2;
	    result[9] = matrix6;
	    result[10] = matrix[10];
	    result[11] = matrix[14];
	    result[12] = matrix3;
	    result[13] = matrix7;
	    result[14] = matrix11;
	    result[15] = matrix[15];
	    return result;
	  };
	  Matrix4.abs = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = Math.abs(matrix[0]);
	    result[1] = Math.abs(matrix[1]);
	    result[2] = Math.abs(matrix[2]);
	    result[3] = Math.abs(matrix[3]);
	    result[4] = Math.abs(matrix[4]);
	    result[5] = Math.abs(matrix[5]);
	    result[6] = Math.abs(matrix[6]);
	    result[7] = Math.abs(matrix[7]);
	    result[8] = Math.abs(matrix[8]);
	    result[9] = Math.abs(matrix[9]);
	    result[10] = Math.abs(matrix[10]);
	    result[11] = Math.abs(matrix[11]);
	    result[12] = Math.abs(matrix[12]);
	    result[13] = Math.abs(matrix[13]);
	    result[14] = Math.abs(matrix[14]);
	    result[15] = Math.abs(matrix[15]);
	    return result;
	  };
	  Matrix4.equals = function(left, right) {
	    return (left === right) || (defined(left) && defined(right) && left[12] === right[12] && left[13] === right[13] && left[14] === right[14] && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[8] === right[8] && left[9] === right[9] && left[10] === right[10] && left[3] === right[3] && left[7] === right[7] && left[11] === right[11] && left[15] === right[15]);
	  };
	  Matrix4.equalsEpsilon = function(left, right, epsilon) {
	    if (typeof epsilon !== 'number') {
	      throw new DeveloperError('epsilon must be a number');
	    }
	    return (left === right) || (defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon && Math.abs(left[9] - right[9]) <= epsilon && Math.abs(left[10] - right[10]) <= epsilon && Math.abs(left[11] - right[11]) <= epsilon && Math.abs(left[12] - right[12]) <= epsilon && Math.abs(left[13] - right[13]) <= epsilon && Math.abs(left[14] - right[14]) <= epsilon && Math.abs(left[15] - right[15]) <= epsilon);
	  };
	  Matrix4.getTranslation = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = matrix[12];
	    result.y = matrix[13];
	    result.z = matrix[14];
	    return result;
	  };
	  Matrix4.getRotation = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result[0] = matrix[0];
	    result[1] = matrix[1];
	    result[2] = matrix[2];
	    result[3] = matrix[4];
	    result[4] = matrix[5];
	    result[5] = matrix[6];
	    result[6] = matrix[8];
	    result[7] = matrix[9];
	    result[8] = matrix[10];
	    return result;
	  };
	  var scratchInverseRotation = new Matrix3();
	  var scratchMatrix3Zero = new Matrix3();
	  var scratchBottomRow = new Cartesian4();
	  var scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);
	  Matrix4.inverse = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    if (Matrix3.equalsEpsilon(Matrix4.getRotation(matrix, scratchInverseRotation), scratchMatrix3Zero, CesiumMath.EPSILON7) && Cartesian4.equals(Matrix4.getRow(matrix, 3, scratchBottomRow), scratchExpectedBottomRow)) {
	      result[0] = 0.0;
	      result[1] = 0.0;
	      result[2] = 0.0;
	      result[3] = 0.0;
	      result[4] = 0.0;
	      result[5] = 0.0;
	      result[6] = 0.0;
	      result[7] = 0.0;
	      result[8] = 0.0;
	      result[9] = 0.0;
	      result[10] = 0.0;
	      result[11] = 0.0;
	      result[12] = -matrix[12];
	      result[13] = -matrix[13];
	      result[14] = -matrix[14];
	      result[15] = 1.0;
	      return result;
	    }
	    var src0 = matrix[0];
	    var src1 = matrix[4];
	    var src2 = matrix[8];
	    var src3 = matrix[12];
	    var src4 = matrix[1];
	    var src5 = matrix[5];
	    var src6 = matrix[9];
	    var src7 = matrix[13];
	    var src8 = matrix[2];
	    var src9 = matrix[6];
	    var src10 = matrix[10];
	    var src11 = matrix[14];
	    var src12 = matrix[3];
	    var src13 = matrix[7];
	    var src14 = matrix[11];
	    var src15 = matrix[15];
	    var tmp0 = src10 * src15;
	    var tmp1 = src11 * src14;
	    var tmp2 = src9 * src15;
	    var tmp3 = src11 * src13;
	    var tmp4 = src9 * src14;
	    var tmp5 = src10 * src13;
	    var tmp6 = src8 * src15;
	    var tmp7 = src11 * src12;
	    var tmp8 = src8 * src14;
	    var tmp9 = src10 * src12;
	    var tmp10 = src8 * src13;
	    var tmp11 = src9 * src12;
	    var dst0 = (tmp0 * src5 + tmp3 * src6 + tmp4 * src7) - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
	    var dst1 = (tmp1 * src4 + tmp6 * src6 + tmp9 * src7) - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
	    var dst2 = (tmp2 * src4 + tmp7 * src5 + tmp10 * src7) - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
	    var dst3 = (tmp5 * src4 + tmp8 * src5 + tmp11 * src6) - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
	    var dst4 = (tmp1 * src1 + tmp2 * src2 + tmp5 * src3) - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
	    var dst5 = (tmp0 * src0 + tmp7 * src2 + tmp8 * src3) - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
	    var dst6 = (tmp3 * src0 + tmp6 * src1 + tmp11 * src3) - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
	    var dst7 = (tmp4 * src0 + tmp9 * src1 + tmp10 * src2) - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);
	    tmp0 = src2 * src7;
	    tmp1 = src3 * src6;
	    tmp2 = src1 * src7;
	    tmp3 = src3 * src5;
	    tmp4 = src1 * src6;
	    tmp5 = src2 * src5;
	    tmp6 = src0 * src7;
	    tmp7 = src3 * src4;
	    tmp8 = src0 * src6;
	    tmp9 = src2 * src4;
	    tmp10 = src0 * src5;
	    tmp11 = src1 * src4;
	    var dst8 = (tmp0 * src13 + tmp3 * src14 + tmp4 * src15) - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
	    var dst9 = (tmp1 * src12 + tmp6 * src14 + tmp9 * src15) - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
	    var dst10 = (tmp2 * src12 + tmp7 * src13 + tmp10 * src15) - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
	    var dst11 = (tmp5 * src12 + tmp8 * src13 + tmp11 * src14) - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
	    var dst12 = (tmp2 * src10 + tmp5 * src11 + tmp1 * src9) - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
	    var dst13 = (tmp8 * src11 + tmp0 * src8 + tmp7 * src10) - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
	    var dst14 = (tmp6 * src9 + tmp11 * src11 + tmp3 * src8) - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
	    var dst15 = (tmp10 * src10 + tmp4 * src8 + tmp9 * src9) - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);
	    var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;
	    if (Math.abs(det) < CesiumMath.EPSILON20) {
	      throw new RuntimeError('matrix is not invertible because its determinate is zero.');
	    }
	    det = 1.0 / det;
	    result[0] = dst0 * det;
	    result[1] = dst1 * det;
	    result[2] = dst2 * det;
	    result[3] = dst3 * det;
	    result[4] = dst4 * det;
	    result[5] = dst5 * det;
	    result[6] = dst6 * det;
	    result[7] = dst7 * det;
	    result[8] = dst8 * det;
	    result[9] = dst9 * det;
	    result[10] = dst10 * det;
	    result[11] = dst11 * det;
	    result[12] = dst12 * det;
	    result[13] = dst13 * det;
	    result[14] = dst14 * det;
	    result[15] = dst15 * det;
	    return result;
	  };
	  Matrix4.inverseTransformation = function(matrix, result) {
	    if (!defined(matrix)) {
	      throw new DeveloperError('matrix is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var matrix0 = matrix[0];
	    var matrix1 = matrix[1];
	    var matrix2 = matrix[2];
	    var matrix4 = matrix[4];
	    var matrix5 = matrix[5];
	    var matrix6 = matrix[6];
	    var matrix8 = matrix[8];
	    var matrix9 = matrix[9];
	    var matrix10 = matrix[10];
	    var vX = matrix[12];
	    var vY = matrix[13];
	    var vZ = matrix[14];
	    var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
	    var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
	    var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;
	    result[0] = matrix0;
	    result[1] = matrix4;
	    result[2] = matrix8;
	    result[3] = 0.0;
	    result[4] = matrix1;
	    result[5] = matrix5;
	    result[6] = matrix9;
	    result[7] = 0.0;
	    result[8] = matrix2;
	    result[9] = matrix6;
	    result[10] = matrix10;
	    result[11] = 0.0;
	    result[12] = x;
	    result[13] = y;
	    result[14] = z;
	    result[15] = 1.0;
	    return result;
	  };
	  Matrix4.IDENTITY = freezeObject(new Matrix4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0));
	  Matrix4.ZERO = freezeObject(new Matrix4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
	  Matrix4.COLUMN0ROW0 = 0;
	  Matrix4.COLUMN0ROW1 = 1;
	  Matrix4.COLUMN0ROW2 = 2;
	  Matrix4.COLUMN0ROW3 = 3;
	  Matrix4.COLUMN1ROW0 = 4;
	  Matrix4.COLUMN1ROW1 = 5;
	  Matrix4.COLUMN1ROW2 = 6;
	  Matrix4.COLUMN1ROW3 = 7;
	  Matrix4.COLUMN2ROW0 = 8;
	  Matrix4.COLUMN2ROW1 = 9;
	  Matrix4.COLUMN2ROW2 = 10;
	  Matrix4.COLUMN2ROW3 = 11;
	  Matrix4.COLUMN3ROW0 = 12;
	  Matrix4.COLUMN3ROW1 = 13;
	  Matrix4.COLUMN3ROW2 = 14;
	  Matrix4.COLUMN3ROW3 = 15;
	  defineProperties(Matrix4.prototype, {length: {get: function() {
	        return Matrix4.packedLength;
	      }}});
	  Matrix4.prototype.clone = function(result) {
	    return Matrix4.clone(this, result);
	  };
	  Matrix4.prototype.equals = function(right) {
	    return Matrix4.equals(this, right);
	  };
	  Matrix4.equalsArray = function(matrix, array, offset) {
	    return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8] && matrix[9] === array[offset + 9] && matrix[10] === array[offset + 10] && matrix[11] === array[offset + 11] && matrix[12] === array[offset + 12] && matrix[13] === array[offset + 13] && matrix[14] === array[offset + 14] && matrix[15] === array[offset + 15];
	  };
	  Matrix4.prototype.equalsEpsilon = function(right, epsilon) {
	    return Matrix4.equalsEpsilon(this, right, epsilon);
	  };
	  Matrix4.prototype.toString = function() {
	    return '(' + this[0] + ', ' + this[4] + ', ' + this[8] + ', ' + this[12] + ')\n' + '(' + this[1] + ', ' + this[5] + ', ' + this[9] + ', ' + this[13] + ')\n' + '(' + this[2] + ', ' + this[6] + ', ' + this[10] + ', ' + this[14] + ')\n' + '(' + this[3] + ', ' + this[7] + ', ' + this[11] + ', ' + this[15] + ')';
	  };
	  return Matrix4;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("6d", [], function() {
	  var MersenneTwister = function(seed) {
	    if (seed == undefined) {
	      seed = new Date().getTime();
	    }
	    this.N = 624;
	    this.M = 397;
	    this.MATRIX_A = 0x9908b0df;
	    this.UPPER_MASK = 0x80000000;
	    this.LOWER_MASK = 0x7fffffff;
	    this.mt = new Array(this.N);
	    this.mti = this.N + 1;
	    this.init_genrand(seed);
	  };
	  MersenneTwister.prototype.init_genrand = function(s) {
	    this.mt[0] = s >>> 0;
	    for (this.mti = 1; this.mti < this.N; this.mti++) {
	      var s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
	      this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;
	      this.mt[this.mti] >>>= 0;
	    }
	  };
	  MersenneTwister.prototype.genrand_int32 = function() {
	    var y;
	    var mag01 = new Array(0x0, this.MATRIX_A);
	    if (this.mti >= this.N) {
	      var kk;
	      if (this.mti == this.N + 1)
	        this.init_genrand(5489);
	      for (kk = 0; kk < this.N - this.M; kk++) {
	        y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
	        this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
	      }
	      for (; kk < this.N - 1; kk++) {
	        y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
	        this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
	      }
	      y = (this.mt[this.N - 1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK);
	      this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];
	      this.mti = 0;
	    }
	    y = this.mt[this.mti++];
	    y ^= (y >>> 11);
	    y ^= (y << 7) & 0x9d2c5680;
	    y ^= (y << 15) & 0xefc60000;
	    y ^= (y >>> 18);
	    return y >>> 0;
	  };
	  MersenneTwister.prototype.random = function() {
	    return this.genrand_int32() * (1.0 / 4294967296.0);
	  };
	  return MersenneTwister;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("23", ["1f"], function(freezeObject) {
	  'use strict';
	  function defaultValue(a, b) {
	    if (a !== undefined) {
	      return a;
	    }
	    return b;
	  }
	  defaultValue.EMPTY_OBJECT = freezeObject({});
	  return defaultValue;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("27", ["6d", "23", "1a", "1c"], function(MersenneTwister, defaultValue, defined, DeveloperError) {
	  'use strict';
	  var CesiumMath = {};
	  CesiumMath.EPSILON1 = 0.1;
	  CesiumMath.EPSILON2 = 0.01;
	  CesiumMath.EPSILON3 = 0.001;
	  CesiumMath.EPSILON4 = 0.0001;
	  CesiumMath.EPSILON5 = 0.00001;
	  CesiumMath.EPSILON6 = 0.000001;
	  CesiumMath.EPSILON7 = 0.0000001;
	  CesiumMath.EPSILON8 = 0.00000001;
	  CesiumMath.EPSILON9 = 0.000000001;
	  CesiumMath.EPSILON10 = 0.0000000001;
	  CesiumMath.EPSILON11 = 0.00000000001;
	  CesiumMath.EPSILON12 = 0.000000000001;
	  CesiumMath.EPSILON13 = 0.0000000000001;
	  CesiumMath.EPSILON14 = 0.00000000000001;
	  CesiumMath.EPSILON15 = 0.000000000000001;
	  CesiumMath.EPSILON16 = 0.0000000000000001;
	  CesiumMath.EPSILON17 = 0.00000000000000001;
	  CesiumMath.EPSILON18 = 0.000000000000000001;
	  CesiumMath.EPSILON19 = 0.0000000000000000001;
	  CesiumMath.EPSILON20 = 0.00000000000000000001;
	  CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;
	  CesiumMath.SOLAR_RADIUS = 6.955e8;
	  CesiumMath.LUNAR_RADIUS = 1737400.0;
	  CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;
	  CesiumMath.sign = function(value) {
	    if (value > 0) {
	      return 1;
	    }
	    if (value < 0) {
	      return -1;
	    }
	    return 0;
	  };
	  CesiumMath.signNotZero = function(value) {
	    return value < 0.0 ? -1.0 : 1.0;
	  };
	  CesiumMath.toSNorm = function(value) {
	    return Math.round((CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * 255.0);
	  };
	  CesiumMath.fromSNorm = function(value) {
	    return CesiumMath.clamp(value, 0.0, 255.0) / 255.0 * 2.0 - 1.0;
	  };
	  CesiumMath.sinh = function(value) {
	    var part1 = Math.pow(Math.E, value);
	    var part2 = Math.pow(Math.E, -1.0 * value);
	    return (part1 - part2) * 0.5;
	  };
	  CesiumMath.cosh = function(value) {
	    var part1 = Math.pow(Math.E, value);
	    var part2 = Math.pow(Math.E, -1.0 * value);
	    return (part1 + part2) * 0.5;
	  };
	  CesiumMath.lerp = function(p, q, time) {
	    return ((1.0 - time) * p) + (time * q);
	  };
	  CesiumMath.PI = Math.PI;
	  CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;
	  CesiumMath.PI_OVER_TWO = Math.PI * 0.5;
	  CesiumMath.PI_OVER_THREE = Math.PI / 3.0;
	  CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;
	  CesiumMath.PI_OVER_SIX = Math.PI / 6.0;
	  CesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) * 0.5;
	  CesiumMath.TWO_PI = 2.0 * Math.PI;
	  CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);
	  CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;
	  CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;
	  CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;
	  CesiumMath.toRadians = function(degrees) {
	    if (!defined(degrees)) {
	      throw new DeveloperError('degrees is required.');
	    }
	    return degrees * CesiumMath.RADIANS_PER_DEGREE;
	  };
	  CesiumMath.toDegrees = function(radians) {
	    if (!defined(radians)) {
	      throw new DeveloperError('radians is required.');
	    }
	    return radians * CesiumMath.DEGREES_PER_RADIAN;
	  };
	  CesiumMath.convertLongitudeRange = function(angle) {
	    if (!defined(angle)) {
	      throw new DeveloperError('angle is required.');
	    }
	    var twoPi = CesiumMath.TWO_PI;
	    var simplified = angle - Math.floor(angle / twoPi) * twoPi;
	    if (simplified < -Math.PI) {
	      return simplified + twoPi;
	    }
	    if (simplified >= Math.PI) {
	      return simplified - twoPi;
	    }
	    return simplified;
	  };
	  CesiumMath.negativePiToPi = function(x) {
	    if (!defined(x)) {
	      throw new DeveloperError('x is required.');
	    }
	    return CesiumMath.zeroToTwoPi(x + CesiumMath.PI) - CesiumMath.PI;
	  };
	  CesiumMath.zeroToTwoPi = function(x) {
	    if (!defined(x)) {
	      throw new DeveloperError('x is required.');
	    }
	    var mod = CesiumMath.mod(x, CesiumMath.TWO_PI);
	    if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(x) > CesiumMath.EPSILON14) {
	      return CesiumMath.TWO_PI;
	    }
	    return mod;
	  };
	  CesiumMath.mod = function(m, n) {
	    if (!defined(m)) {
	      throw new DeveloperError('m is required.');
	    }
	    if (!defined(n)) {
	      throw new DeveloperError('n is required.');
	    }
	    return ((m % n) + n) % n;
	  };
	  CesiumMath.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required.');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required.');
	    }
	    if (!defined(relativeEpsilon)) {
	      throw new DeveloperError('relativeEpsilon is required.');
	    }
	    absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);
	    var absDiff = Math.abs(left - right);
	    return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));
	  };
	  var factorials = [1];
	  CesiumMath.factorial = function(n) {
	    if (typeof n !== 'number' || n < 0) {
	      throw new DeveloperError('A number greater than or equal to 0 is required.');
	    }
	    var length = factorials.length;
	    if (n >= length) {
	      var sum = factorials[length - 1];
	      for (var i = length; i <= n; i++) {
	        factorials.push(sum * i);
	      }
	    }
	    return factorials[n];
	  };
	  CesiumMath.incrementWrap = function(n, maximumValue, minimumValue) {
	    minimumValue = defaultValue(minimumValue, 0.0);
	    if (!defined(n)) {
	      throw new DeveloperError('n is required.');
	    }
	    if (maximumValue <= minimumValue) {
	      throw new DeveloperError('maximumValue must be greater than minimumValue.');
	    }
	    ++n;
	    if (n > maximumValue) {
	      n = minimumValue;
	    }
	    return n;
	  };
	  CesiumMath.isPowerOfTwo = function(n) {
	    if (typeof n !== 'number' || n < 0) {
	      throw new DeveloperError('A number greater than or equal to 0 is required.');
	    }
	    return (n !== 0) && ((n & (n - 1)) === 0);
	  };
	  CesiumMath.nextPowerOfTwo = function(n) {
	    if (typeof n !== 'number' || n < 0) {
	      throw new DeveloperError('A number greater than or equal to 0 is required.');
	    }
	    --n;
	    n |= n >> 1;
	    n |= n >> 2;
	    n |= n >> 4;
	    n |= n >> 8;
	    n |= n >> 16;
	    ++n;
	    return n;
	  };
	  CesiumMath.clamp = function(value, min, max) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required');
	    }
	    if (!defined(min)) {
	      throw new DeveloperError('min is required.');
	    }
	    if (!defined(max)) {
	      throw new DeveloperError('max is required.');
	    }
	    return value < min ? min : value > max ? max : value;
	  };
	  var randomNumberGenerator = new MersenneTwister();
	  CesiumMath.setRandomNumberSeed = function(seed) {
	    if (!defined(seed)) {
	      throw new DeveloperError('seed is required.');
	    }
	    randomNumberGenerator = new MersenneTwister(seed);
	  };
	  CesiumMath.nextRandomNumber = function() {
	    return randomNumberGenerator.random();
	  };
	  CesiumMath.acosClamped = function(value) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required.');
	    }
	    return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));
	  };
	  CesiumMath.asinClamped = function(value) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required.');
	    }
	    return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));
	  };
	  CesiumMath.chordLength = function(angle, radius) {
	    if (!defined(angle)) {
	      throw new DeveloperError('angle is required.');
	    }
	    if (!defined(radius)) {
	      throw new DeveloperError('radius is required.');
	    }
	    return 2.0 * radius * Math.sin(angle * 0.5);
	  };
	  CesiumMath.logBase = function(number, base) {
	    if (!defined(number)) {
	      throw new DeveloperError('number is required.');
	    }
	    if (!defined(base)) {
	      throw new DeveloperError('base is required.');
	    }
	    return Math.log(number) / Math.log(base);
	  };
	  CesiumMath.fog = function(distanceToCamera, density) {
	    var scalar = distanceToCamera * density;
	    return 1.0 - Math.exp(-(scalar * scalar));
	  };
	  return CesiumMath;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("2c", ["23", "1a", "1c", "1f", "27"], function(defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
	  'use strict';
	  function Cartesian3(x, y, z) {
	    this.x = defaultValue(x, 0.0);
	    this.y = defaultValue(y, 0.0);
	    this.z = defaultValue(z, 0.0);
	  }
	  Cartesian3.fromSpherical = function(spherical, result) {
	    if (!defined(spherical)) {
	      throw new DeveloperError('spherical is required');
	    }
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    var clock = spherical.clock;
	    var cone = spherical.cone;
	    var magnitude = defaultValue(spherical.magnitude, 1.0);
	    var radial = magnitude * Math.sin(cone);
	    result.x = radial * Math.cos(clock);
	    result.y = radial * Math.sin(clock);
	    result.z = magnitude * Math.cos(cone);
	    return result;
	  };
	  Cartesian3.fromElements = function(x, y, z, result) {
	    if (!defined(result)) {
	      return new Cartesian3(x, y, z);
	    }
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return result;
	  };
	  Cartesian3.clone = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      return undefined;
	    }
	    if (!defined(result)) {
	      return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
	    }
	    result.x = cartesian.x;
	    result.y = cartesian.y;
	    result.z = cartesian.z;
	    return result;
	  };
	  Cartesian3.fromCartesian4 = Cartesian3.clone;
	  Cartesian3.packedLength = 3;
	  Cartesian3.pack = function(value, array, startingIndex) {
	    if (!defined(value)) {
	      throw new DeveloperError('value is required');
	    }
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    array[startingIndex++] = value.x;
	    array[startingIndex++] = value.y;
	    array[startingIndex] = value.z;
	  };
	  Cartesian3.unpack = function(array, startingIndex, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    startingIndex = defaultValue(startingIndex, 0);
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    result.x = array[startingIndex++];
	    result.y = array[startingIndex++];
	    result.z = array[startingIndex];
	    return result;
	  };
	  Cartesian3.packArray = function(array, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    var length = array.length;
	    if (!defined(result)) {
	      result = new Array(length * 3);
	    } else {
	      result.length = length * 3;
	    }
	    for (var i = 0; i < length; ++i) {
	      Cartesian3.pack(array[i], result, i * 3);
	    }
	    return result;
	  };
	  Cartesian3.unpackArray = function(array, result) {
	    if (!defined(array)) {
	      throw new DeveloperError('array is required');
	    }
	    var length = array.length;
	    if (!defined(result)) {
	      result = new Array(length / 3);
	    } else {
	      result.length = length / 3;
	    }
	    for (var i = 0; i < length; i += 3) {
	      var index = i / 3;
	      result[index] = Cartesian3.unpack(array, i, result[index]);
	    }
	    return result;
	  };
	  Cartesian3.fromArray = Cartesian3.unpack;
	  Cartesian3.maximumComponent = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return Math.max(cartesian.x, cartesian.y, cartesian.z);
	  };
	  Cartesian3.minimumComponent = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return Math.min(cartesian.x, cartesian.y, cartesian.z);
	  };
	  Cartesian3.minimumByComponent = function(first, second, result) {
	    if (!defined(first)) {
	      throw new DeveloperError('first is required.');
	    }
	    if (!defined(second)) {
	      throw new DeveloperError('second is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    result.x = Math.min(first.x, second.x);
	    result.y = Math.min(first.y, second.y);
	    result.z = Math.min(first.z, second.z);
	    return result;
	  };
	  Cartesian3.maximumByComponent = function(first, second, result) {
	    if (!defined(first)) {
	      throw new DeveloperError('first is required.');
	    }
	    if (!defined(second)) {
	      throw new DeveloperError('second is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    result.x = Math.max(first.x, second.x);
	    result.y = Math.max(first.y, second.y);
	    result.z = Math.max(first.z, second.z);
	    return result;
	  };
	  Cartesian3.magnitudeSquared = function(cartesian) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
	  };
	  Cartesian3.magnitude = function(cartesian) {
	    return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
	  };
	  var distanceScratch = new Cartesian3();
	  Cartesian3.distance = function(left, right) {
	    if (!defined(left) || !defined(right)) {
	      throw new DeveloperError('left and right are required.');
	    }
	    Cartesian3.subtract(left, right, distanceScratch);
	    return Cartesian3.magnitude(distanceScratch);
	  };
	  Cartesian3.distanceSquared = function(left, right) {
	    if (!defined(left) || !defined(right)) {
	      throw new DeveloperError('left and right are required.');
	    }
	    Cartesian3.subtract(left, right, distanceScratch);
	    return Cartesian3.magnitudeSquared(distanceScratch);
	  };
	  Cartesian3.normalize = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var magnitude = Cartesian3.magnitude(cartesian);
	    result.x = cartesian.x / magnitude;
	    result.y = cartesian.y / magnitude;
	    result.z = cartesian.z / magnitude;
	    return result;
	  };
	  Cartesian3.dot = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    return left.x * right.x + left.y * right.y + left.z * right.z;
	  };
	  Cartesian3.multiplyComponents = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x * right.x;
	    result.y = left.y * right.y;
	    result.z = left.z * right.z;
	    return result;
	  };
	  Cartesian3.add = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x + right.x;
	    result.y = left.y + right.y;
	    result.z = left.z + right.z;
	    return result;
	  };
	  Cartesian3.subtract = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = left.x - right.x;
	    result.y = left.y - right.y;
	    result.z = left.z - right.z;
	    return result;
	  };
	  Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = cartesian.x * scalar;
	    result.y = cartesian.y * scalar;
	    result.z = cartesian.z * scalar;
	    return result;
	  };
	  Cartesian3.divideByScalar = function(cartesian, scalar, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (typeof scalar !== 'number') {
	      throw new DeveloperError('scalar is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = cartesian.x / scalar;
	    result.y = cartesian.y / scalar;
	    result.z = cartesian.z / scalar;
	    return result;
	  };
	  Cartesian3.negate = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = -cartesian.x;
	    result.y = -cartesian.y;
	    result.z = -cartesian.z;
	    return result;
	  };
	  Cartesian3.abs = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    result.x = Math.abs(cartesian.x);
	    result.y = Math.abs(cartesian.y);
	    result.z = Math.abs(cartesian.z);
	    return result;
	  };
	  var lerpScratch = new Cartesian3();
	  Cartesian3.lerp = function(start, end, t, result) {
	    if (!defined(start)) {
	      throw new DeveloperError('start is required.');
	    }
	    if (!defined(end)) {
	      throw new DeveloperError('end is required.');
	    }
	    if (typeof t !== 'number') {
	      throw new DeveloperError('t is required and must be a number.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    Cartesian3.multiplyByScalar(end, t, lerpScratch);
	    result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);
	    return Cartesian3.add(lerpScratch, result, result);
	  };
	  var angleBetweenScratch = new Cartesian3();
	  var angleBetweenScratch2 = new Cartesian3();
	  Cartesian3.angleBetween = function(left, right) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    Cartesian3.normalize(left, angleBetweenScratch);
	    Cartesian3.normalize(right, angleBetweenScratch2);
	    var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);
	    var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));
	    return Math.atan2(sine, cosine);
	  };
	  var mostOrthogonalAxisScratch = new Cartesian3();
	  Cartesian3.mostOrthogonalAxis = function(cartesian, result) {
	    if (!defined(cartesian)) {
	      throw new DeveloperError('cartesian is required.');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required.');
	    }
	    var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);
	    Cartesian3.abs(f, f);
	    if (f.x <= f.y) {
	      if (f.x <= f.z) {
	        result = Cartesian3.clone(Cartesian3.UNIT_X, result);
	      } else {
	        result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
	      }
	    } else {
	      if (f.y <= f.z) {
	        result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
	      } else {
	        result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
	      }
	    }
	    return result;
	  };
	  Cartesian3.equals = function(left, right) {
	    return (left === right) || ((defined(left)) && (defined(right)) && (left.x === right.x) && (left.y === right.y) && (left.z === right.z));
	  };
	  Cartesian3.equalsArray = function(cartesian, array, offset) {
	    return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2];
	  };
	  Cartesian3.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
	    return (left === right) || (defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon));
	  };
	  Cartesian3.cross = function(left, right, result) {
	    if (!defined(left)) {
	      throw new DeveloperError('left is required');
	    }
	    if (!defined(right)) {
	      throw new DeveloperError('right is required');
	    }
	    if (!defined(result)) {
	      throw new DeveloperError('result is required');
	    }
	    var leftX = left.x;
	    var leftY = left.y;
	    var leftZ = left.z;
	    var rightX = right.x;
	    var rightY = right.y;
	    var rightZ = right.z;
	    var x = leftY * rightZ - leftZ * rightY;
	    var y = leftZ * rightX - leftX * rightZ;
	    var z = leftX * rightY - leftY * rightX;
	    result.x = x;
	    result.y = y;
	    result.z = z;
	    return result;
	  };
	  Cartesian3.fromDegrees = function(longitude, latitude, height, ellipsoid, result) {
	    if (!defined(longitude)) {
	      throw new DeveloperError('longitude is required');
	    }
	    if (!defined(latitude)) {
	      throw new DeveloperError('latitude is required');
	    }
	    var lon = CesiumMath.toRadians(longitude);
	    var lat = CesiumMath.toRadians(latitude);
	    return Cartesian3.fromRadians(lon, lat, height, ellipsoid, result);
	  };
	  var scratchN = new Cartesian3();
	  var scratchK = new Cartesian3();
	  var wgs84RadiiSquared = new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);
	  Cartesian3.fromRadians = function(longitude, latitude, height, ellipsoid, result) {
	    if (!defined(longitude)) {
	      throw new DeveloperError('longitude is required');
	    }
	    if (!defined(latitude)) {
	      throw new DeveloperError('latitude is required');
	    }
	    height = defaultValue(height, 0.0);
	    var radiiSquared = defined(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;
	    var cosLatitude = Math.cos(latitude);
	    scratchN.x = cosLatitude * Math.cos(longitude);
	    scratchN.y = cosLatitude * Math.sin(longitude);
	    scratchN.z = Math.sin(latitude);
	    scratchN = Cartesian3.normalize(scratchN, scratchN);
	    Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);
	    var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));
	    scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);
	    scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);
	    if (!defined(result)) {
	      result = new Cartesian3();
	    }
	    return Cartesian3.add(scratchK, scratchN, result);
	  };
	  Cartesian3.fromDegreesArray = function(coordinates, ellipsoid, result) {
	    if (!defined(coordinates)) {
	      throw new DeveloperError('positions is required.');
	    }
	    var pos = new Array(coordinates.length);
	    for (var i = 0; i < coordinates.length; i++) {
	      pos[i] = CesiumMath.toRadians(coordinates[i]);
	    }
	    return Cartesian3.fromRadiansArray(pos, ellipsoid, result);
	  };
	  Cartesian3.fromRadiansArray = function(coordinates, ellipsoid, result) {
	    if (!defined(coordinates)) {
	      throw new DeveloperError('positions is required.');
	    }
	    if (coordinates.length < 2) {
	      throw new DeveloperError('positions length cannot be less than 2.');
	    }
	    if (coordinates.length % 2 !== 0) {
	      throw new DeveloperError('positions length must be a multiple of 2.');
	    }
	    var length = coordinates.length;
	    if (!defined(result)) {
	      result = new Array(length / 2);
	    } else {
	      result.length = length / 2;
	    }
	    for (var i = 0; i < length; i += 2) {
	      var lon = coordinates[i];
	      var lat = coordinates[i + 1];
	      result[i / 2] = Cartesian3.fromRadians(lon, lat, 0, ellipsoid, result[i / 2]);
	    }
	    return result;
	  };
	  Cartesian3.fromDegreesArrayHeights = function(coordinates, ellipsoid, result) {
	    if (!defined(coordinates)) {
	      throw new DeveloperError('positions is required.');
	    }
	    if (coordinates.length < 3) {
	      throw new DeveloperError('positions length cannot be less than 3.');
	    }
	    if (coordinates.length % 3 !== 0) {
	      throw new DeveloperError('positions length must be a multiple of 3.');
	    }
	    var pos = new Array(coordinates.length);
	    for (var i = 0; i < coordinates.length; i += 3) {
	      pos[i] = CesiumMath.toRadians(coordinates[i]);
	      pos[i + 1] = CesiumMath.toRadians(coordinates[i + 1]);
	      pos[i + 2] = coordinates[i + 2];
	    }
	    return Cartesian3.fromRadiansArrayHeights(pos, ellipsoid, result);
	  };
	  Cartesian3.fromRadiansArrayHeights = function(coordinates, ellipsoid, result) {
	    if (!defined(coordinates)) {
	      throw new DeveloperError('positions is required.');
	    }
	    if (coordinates.length < 3) {
	      throw new DeveloperError('positions length cannot be less than 3.');
	    }
	    if (coordinates.length % 3 !== 0) {
	      throw new DeveloperError('positions length must be a multiple of 3.');
	    }
	    var length = coordinates.length;
	    if (!defined(result)) {
	      result = new Array(length / 3);
	    } else {
	      result.length = length / 3;
	    }
	    for (var i = 0; i < length; i += 3) {
	      var lon = coordinates[i];
	      var lat = coordinates[i + 1];
	      var alt = coordinates[i + 2];
	      result[i / 3] = Cartesian3.fromRadians(lon, lat, alt, ellipsoid, result[i / 3]);
	    }
	    return result;
	  };
	  Cartesian3.ZERO = freezeObject(new Cartesian3(0.0, 0.0, 0.0));
	  Cartesian3.UNIT_X = freezeObject(new Cartesian3(1.0, 0.0, 0.0));
	  Cartesian3.UNIT_Y = freezeObject(new Cartesian3(0.0, 1.0, 0.0));
	  Cartesian3.UNIT_Z = freezeObject(new Cartesian3(0.0, 0.0, 1.0));
	  Cartesian3.prototype.clone = function(result) {
	    return Cartesian3.clone(this, result);
	  };
	  Cartesian3.prototype.equals = function(right) {
	    return Cartesian3.equals(this, right);
	  };
	  Cartesian3.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
	    return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
	  };
	  Cartesian3.prototype.toString = function() {
	    return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';
	  };
	  return Cartesian3;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("1c", ["1a"], function(defined) {
	  'use strict';
	  function DeveloperError(message) {
	    this.name = 'DeveloperError';
	    this.message = message;
	    var stack;
	    try {
	      throw new Error();
	    } catch (e) {
	      stack = e.stack;
	    }
	    this.stack = stack;
	  }
	  if (defined(Object.create)) {
	    DeveloperError.prototype = Object.create(Error.prototype);
	    DeveloperError.prototype.constructor = DeveloperError;
	  }
	  DeveloperError.prototype.toString = function() {
	    var str = this.name + ': ' + this.message;
	    if (defined(this.stack)) {
	      str += '\n' + this.stack.toString();
	    }
	    return str;
	  };
	  DeveloperError.throwInstantiationError = function() {
	    throw new DeveloperError('This function defines an interface and should not be called directly.');
	  };
	  return DeveloperError;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("1a", [], function() {
	  'use strict';
	  function defined(value) {
	    return value !== undefined && value !== null;
	  }
	  return defined;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("1f", ["1a"], function(defined) {
	  'use strict';
	  var freezeObject = Object.freeze;
	  if (!defined(freezeObject)) {
	    freezeObject = function(o) {
	      return o;
	    };
	  }
	  return freezeObject;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("44", ["2c", "1a", "1c", "1f"], function(Cartesian3, defined, DeveloperError, freezeObject) {
	  'use strict';
	  function Plane(normal, distance) {
	    if (!defined(normal)) {
	      throw new DeveloperError('normal is required.');
	    }
	    if (!defined(distance)) {
	      throw new DeveloperError('distance is required.');
	    }
	    this.normal = Cartesian3.clone(normal);
	    this.distance = distance;
	  }
	  Plane.fromPointNormal = function(point, normal, result) {
	    if (!defined(point)) {
	      throw new DeveloperError('point is required.');
	    }
	    if (!defined(normal)) {
	      throw new DeveloperError('normal is required.');
	    }
	    var distance = -Cartesian3.dot(normal, point);
	    if (!defined(result)) {
	      return new Plane(normal, distance);
	    }
	    Cartesian3.clone(normal, result.normal);
	    result.distance = distance;
	    return result;
	  };
	  var scratchNormal = new Cartesian3();
	  Plane.fromCartesian4 = function(coefficients, result) {
	    if (!defined(coefficients)) {
	      throw new DeveloperError('coefficients is required.');
	    }
	    var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);
	    var distance = coefficients.w;
	    if (!defined(result)) {
	      return new Plane(normal, distance);
	    } else {
	      Cartesian3.clone(normal, result.normal);
	      result.distance = distance;
	      return result;
	    }
	  };
	  Plane.getPointDistance = function(plane, point) {
	    if (!defined(plane)) {
	      throw new DeveloperError('plane is required.');
	    }
	    if (!defined(point)) {
	      throw new DeveloperError('point is required.');
	    }
	    return Cartesian3.dot(plane.normal, point) + plane.distance;
	  };
	  Plane.ORIGIN_XY_PLANE = freezeObject(new Plane(Cartesian3.UNIT_Z, 0.0));
	  Plane.ORIGIN_YZ_PLANE = freezeObject(new Plane(Cartesian3.UNIT_X, 0.0));
	  Plane.ORIGIN_ZX_PLANE = freezeObject(new Plane(Cartesian3.UNIT_Y, 0.0));
	  return Plane;
	});

	})();
	(function() {
	var define = $__System.amdDefine;
	define("6e", ["2c", "3b", "23", "1a", "1c", "3c", "66", "6b", "6c", "27", "33", "44"], function(Cartesian3, Cartographic, defaultValue, defined, DeveloperError, Ellipsoid, EllipsoidGeodesic, IntersectionTests, isArray, CesiumMath, Matrix4, Plane) {
	  'use strict';
	  var PolylinePipeline = {};
	  PolylinePipeline.numberOfPoints = function(p0, p1, minDistance) {
	    var distance = Cartesian3.distance(p0, p1);
	    return Math.ceil(distance / minDistance);
	  };
	  var cartoScratch = new Cartographic();
	  PolylinePipeline.extractHeights = function(positions, ellipsoid) {
	    var length = positions.length;
	    var heights = new Array(length);
	    for (var i = 0; i < length; i++) {
	      var p = positions[i];
	      heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;
	    }
	    return heights;
	  };
	  var wrapLongitudeInversMatrix = new Matrix4();
	  var wrapLongitudeOrigin = new Cartesian3();
	  var wrapLongitudeXZNormal = new Cartesian3();
	  var wrapLongitudeXZPlane = new Plane(Cartesian3.ZERO, 0.0);
	  var wrapLongitudeYZNormal = new Cartesian3();
	  var wrapLongitudeYZPlane = new Plane(Cartesian3.ZERO, 0.0);
	  var wrapLongitudeIntersection = new Cartesian3();
	  var wrapLongitudeOffset = new Cartesian3();
	  var subdivideHeightsScratchArray = [];
	  function subdivideHeights(numPoints, h0, h1) {
	    var heights = subdivideHeightsScratchArray;
	    heights.length = numPoints;
	    var i;
	    if (h0 === h1) {
	      for (i = 0; i < numPoints; i++) {
	        heights[i] = h0;
	      }
	      return heights;
	    }
	    var dHeight = h1 - h0;
	    var heightPerVertex = dHeight / numPoints;
	    for (i = 0; i < numPoints; i++) {
	      var h = h0 + i * heightPerVertex;
	      heights[i] = h;
	    }
	    return heights;
	  }
	  var carto1 = new Cartographic();
	  var carto2 = new Cartographic();
	  var cartesian = new Cartesian3();
	  var scaleFirst = new Cartesian3();
	  var scaleLast = new Cartesian3();
	  var ellipsoidGeodesic = new EllipsoidGeodesic();
	  function generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {
	    var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);
	    var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);
	    var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);
	    var start = ellipsoid.cartesianToCartographic(first, carto1);
	    var end = ellipsoid.cartesianToCartographic(last, carto2);
	    var heights = subdivideHeights(numPoints, h0, h1);
	    ellipsoidGeodesic.setEndPoints(start, end);
	    var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;
	    var index = offset;
	    start.height = h0;
	    var cart = ellipsoid.cartographicToCartesian(start, cartesian);
	    Cartesian3.pack(cart, array, index);
	    index += 3;
	    for (var i = 1; i < numPoints; i++) {
	      var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);
	      carto.height = heights[i];
	      cart = ellipsoid.cartographicToCartesian(carto, cartesian);
	      Cartesian3.pack(cart, array, index);
	      index += 3;
	    }
	    return index;
	  }
	  PolylinePipeline.wrapLongitude = function(positions, modelMatrix) {
	    var cartesians = [];
	    var segments = [];
	    if (defined(positions) && positions.length > 0) {
	      modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);
	      var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);
	      var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);
	      var xzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal);
	      var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);
	      var yzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal);
	      var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);
	      var count = 1;
	      cartesians.push(Cartesian3.clone(positions[0]));
	      var prev = cartesians[0];
	      var length = positions.length;
	      for (var i = 1; i < length; ++i) {
	        var cur = positions[i];
	        if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {
	          var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);
	          if (defined(intersection)) {
	            var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);
	            if (Plane.getPointDistance(xzPlane, prev) < 0.0) {
	              Cartesian3.negate(offset, offset);
	            }
	            cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));
	            segments.push(count + 1);
	            Cartesian3.negate(offset, offset);
	            cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));
	            count = 1;
	          }
	        }
	        cartesians.push(Cartesian3.clone(positions[i]));
	        count++;
	        prev = cur;
	      }
	      segments.push(count);
	    }
	    return {
	      positions: cartesians,
	      lengths: segments
	    };
	  };
	  PolylinePipeline.generateArc = function(options) {
	    if (!defined(options)) {
	      options = {};
	    }
	    var positions = options.positions;
	    if (!defined(positions)) {
	      throw new DeveloperError('options.positions is required.');
	    }
	    var length = positions.length;
	    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
	    var height = defaultValue(options.height, 0);
	    if (length < 1) {
	      return [];
	    } else if (length === 1) {
	      var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);
	      if (height !== 0) {
	        var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);
	        Cartesian3.multiplyByScalar(n, height, n);
	        Cartesian3.add(p, n, p);
	      }
	      return [p.x, p.y, p.z];
	    }
	    var minDistance = options.minDistance;
	    if (!defined(minDistance)) {
	      var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
	      minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
	    }
	    var numPoints = 0;
	    var i;
	    for (i = 0; i < length - 1; i++) {
	      numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance);
	    }
	    var arrayLength = (numPoints + 1) * 3;
	    var newPositions = new Array(arrayLength);
	    var offset = 0;
	    var hasHeightArray = isArray(height);
	    for (i = 0; i < length - 1; i++) {
	      var p0 = positions[i];
	      var p1 = positions[i + 1];
	      var h0 = hasHeightArray ? height[i] : height;
	      var h1 = hasHeightArray ? height[i + 1] : height;
	      offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);
	    }
	    subdivideHeightsScratchArray.length = 0;
	    var lastPoint = positions[length - 1];
	    var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);
	    carto.height = hasHeightArray ? height[length - 1] : height;
	    var cart = ellipsoid.cartographicToCartesian(carto, cartesian);
	    Cartesian3.pack(cart, newPositions, arrayLength - 3);
	    return newPositions;
	  };
	  PolylinePipeline.generateCartesianArc = function(options) {
	    var numberArray = PolylinePipeline.generateArc(options);
	    var size = numberArray.length / 3;
	    var newPositions = new Array(size);
	    for (var i = 0; i < size; i++) {
	      newPositions[i] = Cartesian3.unpack(numberArray, i * 3);
	    }
	    return newPositions;
	  };
	  return PolylinePipeline;
	});

	})();
	// Add functionality for keeping a moving window of samples per SampledProperty,
	// so that the data doesn't accumulate indefinitely
	$__System.register("6f", ["a"], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var cesium_imports_1;
	    var after;
	    function removeBeforeDate(property, time) {
	        var times = property._times;
	        var index = ~cesium_imports_1.binarySearch(times, time, cesium_imports_1.JulianDate.compare);
	        if (index > 0) {
	            times.splice(0, index);
	            property._values.splice(0, index * property._innerType.packedLength);
	            property._updateTableLength = true;
	            property._definitionChanged.raiseEvent(property);
	        }
	    }
	    function removeOldSamples(property, maxNumSamples) {
	        if (maxNumSamples === undefined) return;
	        var removeCount = property._times.length - maxNumSamples;
	        if (removeCount > 0) {
	            property._times.splice(0, removeCount);
	            property._values.splice(0, removeCount * property._innerType.packedLength);
	            property._updateTableLength = true;
	        }
	    }
	    return {
	        setters: [function (cesium_imports_1_1) {
	            cesium_imports_1 = cesium_imports_1_1;
	        }],
	        execute: function () {
	            after = function (fn, after) {
	                return function () {
	                    var result = fn.apply(this, arguments);
	                    after.call(this, result);
	                    return result;
	                };
	            };
	            cesium_imports_1.SampledProperty.prototype.removeSamplesBeforeDate = function (time) {
	                removeBeforeDate(this, time);
	            };
	            cesium_imports_1.SampledPositionProperty.prototype.removeSamplesBeforeDate = function (time) {
	                removeBeforeDate(this._property, time);
	            };
	            cesium_imports_1.SampledProperty.prototype.addSample = after(cesium_imports_1.SampledProperty.prototype.addSample, function () {
	                removeOldSamples(this, this.maxNumSamples);
	            });
	            cesium_imports_1.SampledProperty.prototype.addSamples = after(cesium_imports_1.SampledProperty.prototype.addSamples, function () {
	                removeOldSamples(this, this.maxNumSamples);
	            });
	            cesium_imports_1.SampledProperty.prototype.addSamplesPackedArray = after(cesium_imports_1.SampledProperty.prototype.addSamplesPackedArray, function () {
	                removeOldSamples(this, this.maxNumSamples);
	            });
	            cesium_imports_1.SampledPositionProperty.prototype.addSample = after(cesium_imports_1.SampledPositionProperty.prototype.addSample, function () {
	                removeOldSamples(this._property, this.maxNumSamples);
	            });
	            cesium_imports_1.SampledPositionProperty.prototype.addSamples = after(cesium_imports_1.SampledPositionProperty.prototype.addSamples, function () {
	                removeOldSamples(this._property, this.maxNumSamples);
	            });
	            cesium_imports_1.SampledPositionProperty.prototype.addSamplesPackedArray = after(cesium_imports_1.SampledPositionProperty.prototype.addSamplesPackedArray, function () {
	                removeOldSamples(this._property, this.maxNumSamples);
	            });
	        }
	    };
	});
	$__System.register('a', ['4c', '19', '45', '2c', '43', '21', '22', '25', '2b', '2f', '26', '23', '1a', '1c', '3c', '28', '29', '1d', '4a', '3a', '3d', '24', '27', '32', '33', '3e', '3f', '40', '2e', '36', '34', '46', '2d', '47', '48', '49', '35', '64', '6e', '6f'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    return {
	        setters: [function (binarySearch_1_1) {
	            exports_1({
	                "binarySearch": binarySearch_1_1["default"]
	            });
	        }, function (CallbackProperty_1_1) {
	            exports_1({
	                "CallbackProperty": CallbackProperty_1_1["default"]
	            });
	        }, function (Cartesian2_1_1) {
	            exports_1({
	                "Cartesian2": Cartesian2_1_1["default"]
	            });
	        }, function (Cartesian3_1_1) {
	            exports_1({
	                "Cartesian3": Cartesian3_1_1["default"]
	            });
	        }, function (Cartesian4_1_1) {
	            exports_1({
	                "Cartesian4": Cartesian4_1_1["default"]
	            });
	        }, function (Clock_1_1) {
	            exports_1({
	                "Clock": Clock_1_1["default"]
	            });
	        }, function (ClockStep_1_1) {
	            exports_1({
	                "ClockStep": ClockStep_1_1["default"]
	            });
	        }, function (CompositeEntityCollection_1_1) {
	            exports_1({
	                "CompositeEntityCollection": CompositeEntityCollection_1_1["default"]
	            });
	        }, function (ConstantPositionProperty_1_1) {
	            exports_1({
	                "ConstantPositionProperty": ConstantPositionProperty_1_1["default"]
	            });
	        }, function (ConstantProperty_1_1) {
	            exports_1({
	                "ConstantProperty": ConstantProperty_1_1["default"]
	            });
	        }, function (createGuid_1_1) {
	            exports_1({
	                "createGuid": createGuid_1_1["default"]
	            });
	        }, function (defaultValue_1_1) {
	            exports_1({
	                "defaultValue": defaultValue_1_1["default"]
	            });
	        }, function (defined_1_1) {
	            exports_1({
	                "defined": defined_1_1["default"]
	            });
	        }, function (DeveloperError_1_1) {
	            exports_1({
	                "DeveloperError": DeveloperError_1_1["default"]
	            });
	        }, function (Ellipsoid_1_1) {
	            exports_1({
	                "Ellipsoid": Ellipsoid_1_1["default"]
	            });
	        }, function (Entity_1_1) {
	            exports_1({
	                "Entity": Entity_1_1["default"]
	            });
	        }, function (EntityCollection_1_1) {
	            exports_1({
	                "EntityCollection": EntityCollection_1_1["default"]
	            });
	        }, function (Event_1_1) {
	            exports_1({
	                "Event": Event_1_1["default"]
	            });
	        }, function (ExtrapolationType_1_1) {
	            exports_1({
	                "ExtrapolationType": ExtrapolationType_1_1["default"]
	            });
	        }, function (GeographicProjection_1_1) {
	            exports_1({
	                "GeographicProjection": GeographicProjection_1_1["default"]
	            });
	        }, function (HermitePolynomialApproximation_1_1) {
	            exports_1({
	                "HermitePolynomialApproximation": HermitePolynomialApproximation_1_1["default"]
	            });
	        }, function (JulianDate_1_1) {
	            exports_1({
	                "JulianDate": JulianDate_1_1["default"]
	            });
	        }, function (Math_1_1) {
	            exports_1({
	                "CesiumMath": Math_1_1["default"]
	            });
	        }, function (Matrix3_1_1) {
	            exports_1({
	                "Matrix3": Matrix3_1_1["default"]
	            });
	        }, function (Matrix4_1_1) {
	            exports_1({
	                "Matrix4": Matrix4_1_1["default"]
	            });
	        }, function (OrientationProperty_1_1) {
	            exports_1({
	                "OrientationProperty": OrientationProperty_1_1["default"]
	            });
	        }, function (PerspectiveFrustum_1_1) {
	            exports_1({
	                "PerspectiveFrustum": PerspectiveFrustum_1_1["default"]
	            });
	        }, function (PerspectiveOffCenterFrustum_1_1) {
	            exports_1({
	                "PerspectiveOffCenterFrustum": PerspectiveOffCenterFrustum_1_1["default"]
	            });
	        }, function (PositionProperty_1_1) {
	            exports_1({
	                "PositionProperty": PositionProperty_1_1["default"]
	            });
	        }, function (Property_1_1) {
	            exports_1({
	                "Property": Property_1_1["default"]
	            });
	        }, function (Quaternion_1_1) {
	            exports_1({
	                "Quaternion": Quaternion_1_1["default"]
	            });
	        }, function (ReferenceEntity_1_1) {
	            exports_1({
	                "ReferenceEntity": ReferenceEntity_1_1["default"]
	            });
	        }, function (ReferenceFrame_1_1) {
	            exports_1({
	                "ReferenceFrame": ReferenceFrame_1_1["default"]
	            });
	        }, function (ReferenceProperty_1_1) {
	            exports_1({
	                "ReferenceProperty": ReferenceProperty_1_1["default"]
	            });
	        }, function (SampledPositionProperty_1_1) {
	            exports_1({
	                "SampledPositionProperty": SampledPositionProperty_1_1["default"]
	            });
	        }, function (SampledProperty_1_1) {
	            exports_1({
	                "SampledProperty": SampledProperty_1_1["default"]
	            });
	        }, function (Transforms_1_1) {
	            exports_1({
	                "Transforms": Transforms_1_1["default"]
	            });
	        }, function (Simon1994PlanetaryPositions_1_1) {
	            exports_1({
	                "Simon1994PlanetaryPositions": Simon1994PlanetaryPositions_1_1["default"]
	            });
	        }, function (PolylinePipeline_1_1) {
	            exports_1({
	                "PolylinePipeline": PolylinePipeline_1_1["default"]
	            });
	        }, function (_1) {}],
	        execute: function () {}
	    };
	});
	$__System.register('12', ['1d', 'a'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var Event_1, cesium_imports_1;
	    var Event, CommandQueue, getEntityPosition, getEntityOrientation, urlParser, MessageChannelLike, SynchronousMessageChannel, MessageChannelFactory, scratchPerspectiveOffCenterFrustum, scratchCartesian, scratchOrientation;
	    /**
	     * Get array of ancestor reference frames of a Cesium Entity.
	     * @param frame A Cesium Entity to get ancestor reference frames.
	     * @param frames An array of reference frames of the Cesium Entity.
	     */
	    function getAncestorReferenceFrames(frame) {
	        var frames = [];
	        var f = frame;
	        while (cesium_imports_1.defined(f)) {
	            frames.unshift(f);
	            var position = f.position;
	            f = position && position.referenceFrame;
	        }
	        return frames;
	    }
	    exports_1("getAncestorReferenceFrames", getAncestorReferenceFrames);
	    /**
	     * Get root reference frame of the Cesium Entity.
	     * @param frames An array of reference frames of the Cesium Entity.
	     * @return the first frame from ancestor reference frames array.
	     */
	    function getRootReferenceFrame(frame) {
	        return getAncestorReferenceFrames(frame)[0];
	    }
	    exports_1("getRootReferenceFrame", getRootReferenceFrame);
	    /**
	     * Gets the value of the Position property at the provided time and in the provided reference frame.
	     * @param entity The entity to get position.
	     * @param time The time for which to retrieve the value.
	     * @param referenceFrame The desired referenceFrame of the result.
	     * @param result The object to store the value into.
	     * @return The modified result parameter.
	     */
	    function getEntityPositionInReferenceFrame(entity, time, referenceFrame, result) {
	        return entity.position && entity.position.getValueInReferenceFrame(time, referenceFrame, result);
	    }
	    exports_1("getEntityPositionInReferenceFrame", getEntityPositionInReferenceFrame);
	    /**
	     * Get the value of the Orientation property at the provided time and in the provided reference frame.
	     * @param entity The entity to get position.
	     * @param time The time for which to retrieve the value.
	     * @param referenceFrame The desired referenceFrame of the result.
	     * @param result The object to store the value into.
	     * @return The modified result parameter.
	     */
	    function getEntityOrientationInReferenceFrame(entity, time, referenceFrame, result) {
	        var entityFrame = entity.position && entity.position.referenceFrame;
	        if (!cesium_imports_1.defined(entityFrame)) return undefined;
	        var orientation = entity.orientation && entity.orientation.getValue(time, result);
	        if (!cesium_imports_1.defined(orientation)) return undefined;
	        return cesium_imports_1.OrientationProperty.convertToReferenceFrame(time, orientation, entityFrame, referenceFrame, result);
	    }
	    exports_1("getEntityOrientationInReferenceFrame", getEntityOrientationInReferenceFrame);
	    // const scratchCartesianPositionFIXED = new Cartesian3
	    // const scratchMatrix4 = new Matrix4
	    // const scratchMatrix3 = new Matrix3
	    //  {
	    //         // if no orientation is available, calculate an orientation based on position
	    //         const entityPositionFIXED = getEntityPositionInReferenceFrame(entity, time, ReferenceFrame.FIXED, scratchCartesianPositionFIXED)
	    //         if (!entityPositionFIXED) return Quaternion.clone(Quaternion.IDENTITY, result)
	    //         if (Cartesian3.ZERO.equals(entityPositionFIXED)) throw new Error('invalid cartographic position')
	    //         const transform = Transforms.eastNorthUpToFixedFrame(entityPositionFIXED, Ellipsoid.WGS84, scratchMatrix4);
	    //         const rotation = Matrix4.getRotation(transform, scratchMatrix3);
	    //         const fixedOrientation = Quaternion.fromRotationMatrix(rotation, result);
	    //         return OrientationProperty.convertToReferenceFrame(time, fixedOrientation, ReferenceFrame.FIXED, referenceFrame, result)
	    //     }
	    /**
	     * Create a SerializedEntityPose from a source entity.
	     * @param entity The entity which the serialized pose represents.
	     * @param time The time which to retrieve the pose.
	     * @param referenceFrame The reference frame to use for generating the pose.
	     *  By default, uses the root reference frame of the entity.
	     * @return An EntityPose object with orientation, position and referenceFrame.
	     */
	    function getSerializedEntityPose(entity, time, referenceFrame) {
	        var frame = referenceFrame ? referenceFrame : getRootReferenceFrame(entity);
	        var p = getEntityPositionInReferenceFrame(entity, time, frame, {});
	        if (!p) return undefined;
	        var o = getEntityOrientationInReferenceFrame(entity, time, frame, {});
	        if (!o) return undefined;
	        return {
	            p: cesium_imports_1.Cartesian3.ZERO.equalsEpsilon(p, cesium_imports_1.CesiumMath.EPSILON16) ? 0 : p,
	            o: cesium_imports_1.Quaternion.IDENTITY.equalsEpsilon(o, cesium_imports_1.CesiumMath.EPSILON16) ? 0 : o,
	            r: typeof frame === 'number' ? frame : frame.id
	        };
	    }
	    exports_1("getSerializedEntityPose", getSerializedEntityPose);
	    /**
	     * If urlParser does not have a value, throw error message "resolveURL requires DOM api".
	     * If inURL is undefined, throw error message "expected inURL".
	     * Otherwise, assign value of inURL to urlParser.href.
	     * @param inURL A URL needed to be resolved.
	     * @returns A URL ready to be parsed.
	     */
	    function resolveURL(inURL) {
	        if (!urlParser) throw new Error("resolveURL requires DOM api");
	        if (inURL === undefined) throw new Error('Expected inURL');
	        urlParser.href = '';
	        urlParser.href = inURL;
	        return urlParser.href;
	    }
	    exports_1("resolveURL", resolveURL);
	    /**
	     * Parse URL to an object describing details of the URL with href, protocol,
	     * hostname, port, pathname, search, hash, host.
	     * @param inURL A URL needed to be parsed.
	     * @return An object showing parsed URL with href, protocol,
	     * hostname, port, pathname, search, hash, host.
	     */
	    function parseURL(inURL) {
	        if (!urlParser) throw new Error("parseURL requires DOM api");
	        if (inURL === undefined) throw new Error('Expected inURL');
	        urlParser.href = '';
	        urlParser.href = inURL;
	        return {
	            href: urlParser.href,
	            protocol: urlParser.protocol,
	            hostname: urlParser.hostname,
	            port: urlParser.port,
	            pathname: urlParser.pathname,
	            search: urlParser.search,
	            hash: urlParser.hash,
	            host: urlParser.host
	        };
	    }
	    exports_1("parseURL", parseURL);
	    function decomposePerspectiveOffCenterProjectionMatrix(mat, result) {
	        var m11 = mat[cesium_imports_1.Matrix4.COLUMN0ROW0];
	        // const m12 = mat[Matrix4.COLUMN0ROW1];
	        var m22 = mat[cesium_imports_1.Matrix4.COLUMN1ROW1];
	        var m31 = mat[cesium_imports_1.Matrix4.COLUMN2ROW0];
	        var m32 = mat[cesium_imports_1.Matrix4.COLUMN2ROW1];
	        var m33 = mat[cesium_imports_1.Matrix4.COLUMN2ROW2];
	        var m43 = mat[cesium_imports_1.Matrix4.COLUMN3ROW2];
	        var near = result.near = m43 / (m33 - 1);
	        result.far = m43 / (m33 + 1);
	        result.bottom = near * (m32 - 1) / m22;
	        result.top = near * (m32 + 1) / m22;
	        result.left = near * (m31 - 1) / m11;
	        result.right = near * (m31 + 1) / m11;
	        return result;
	    }
	    exports_1("decomposePerspectiveOffCenterProjectionMatrix", decomposePerspectiveOffCenterProjectionMatrix);
	    function decomposePerspectiveProjectionMatrix(mat, result) {
	        var f = decomposePerspectiveOffCenterProjectionMatrix(mat, scratchPerspectiveOffCenterFrustum);
	        var xOffset = (f.left + f.right) / 2;
	        var yOffset = (f.top + f.bottom) / 2;
	        var near = f.near;
	        var far = f.far;
	        // const left = f.left - xOffset;
	        var right = f.right - xOffset;
	        var top = f.top - yOffset;
	        // const bottom = f.bottom - yOffset;
	        var aspectRatio = right / top;
	        var fovy = 2 * Math.atan(top / near);
	        var fov;
	        if (aspectRatio < 1) {
	            fov = fovy;
	        } else {
	            fov = Math.atan(Math.tan(fovy * 0.5) * aspectRatio) * 2.0;
	        }
	        result.near = near;
	        result.far = far;
	        result.fov = fov;
	        result.aspectRatio = aspectRatio;
	        result.xOffset = xOffset;
	        result.yOffset = yOffset;
	        return result;
	    }
	    exports_1("decomposePerspectiveProjectionMatrix", decomposePerspectiveProjectionMatrix);
	    /**
	     * Convert an Entity's position and orientation properties to a new reference frame.
	     * The properties must be constant properties.
	     * @param entity The entity to convert.
	     * @param time The time which to retrieve the pose up the reference chain.
	     * @param referenceFrame The reference frame to convert the position and oriention to.
	     * @return a boolean indicating success or failure.  Will be false if either property is
	     * not constant, or if either property cannot be converted to the new frame.
	     */
	    function convertEntityReferenceFrame(entity, time, frame) {
	        if (!entity.position || !(entity.position instanceof cesium_imports_1.ConstantPositionProperty) || !entity.orientation || !(entity.orientation instanceof cesium_imports_1.ConstantProperty)) {
	            return false;
	        }
	        if (!getEntityPositionInReferenceFrame(entity, time, frame, scratchCartesian)) {
	            return false;
	        }
	        if (!getEntityOrientationInReferenceFrame(entity, time, frame, scratchOrientation)) {
	            return false;
	        }
	        entity.position.setValue(scratchCartesian, frame);
	        entity.orientation.setValue(scratchOrientation);
	        return true;
	    }
	    exports_1("convertEntityReferenceFrame", convertEntityReferenceFrame);
	    return {
	        setters: [function (Event_1_1) {
	            Event_1 = Event_1_1;
	        }, function (cesium_imports_1_1) {
	            cesium_imports_1 = cesium_imports_1_1;
	        }],
	        execute: function () {
	            /**
	             * Provides the ability raise and subscribe to an event.
	             */
	            Event = function () {
	                function Event() {
	                    this._event = new Event_1.default();
	                }
	                Object.defineProperty(Event.prototype, "numberOfListeners", {
	                    /**
	                     * Get the number of listeners currently subscribed to the event.
	                     * @return Number of listeners currently subscribed to the event.
	                     */
	                    get: function () {
	                        return this._event.numberOfListeners;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                  * Add an event listener.
	                  * @param The function to be executed when the event is raised.
	                  * @return A convenience function which removes this event listener when called
	                  */
	                Event.prototype.addEventListener = function (listener) {
	                    return this._event.addEventListener(listener);
	                };
	                /**
	                 * Remove an event listener.
	                 * @param The function to be unregistered.
	                 * @return True if the listener was removed;
	                 * false if the listener and scope are not registered with the event.
	                 */
	                Event.prototype.removeEventListener = function (listener) {
	                    return this._event.removeEventListener(listener);
	                };
	                /**
	                 * Raises the event by calling each registered listener with all supplied arguments.
	                 * @param This method takes any number of parameters and passes them through to the listener functions.
	                 */
	                Event.prototype.raiseEvent = function (data) {
	                    this._event.raiseEvent(data);
	                };
	                return Event;
	            }();
	            exports_1("Event", Event);
	            /**
	            * TODO.
	            */
	            CommandQueue = function () {
	                /**
	                 * If errorEvent has 1 listener, outputs the error message to the web console.
	                 */
	                function CommandQueue() {
	                    var _this = this;
	                    this._queue = [];
	                    this._paused = true;
	                    /**
	                     * An error event.
	                     */
	                    this.errorEvent = new Event();
	                    this.errorEvent.addEventListener(function (error) {
	                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
	                    });
	                }
	                /**
	                 * Push a command to the command queue.
	                 * @param command Any command ready to be pushed into the command queue.
	                 */
	                CommandQueue.prototype.push = function (command, execute) {
	                    var _this = this;
	                    var result = new Promise(function (resolve, reject) {
	                        _this._queue.push({
	                            command: command,
	                            reject: reject,
	                            execute: function () {
	                                // console.log('CommandQueue: Executing command ' + command.toString());
	                                var result = Promise.resolve().then(command);
	                                // result.then(() => { console.log('CommandQueue: DONE ' + command.toString()) });
	                                resolve(result);
	                                return result;
	                            }
	                        });
	                    });
	                    if (execute) this.execute();
	                    return result;
	                };
	                /**
	                 * Execute the command queue
	                 */
	                CommandQueue.prototype.execute = function () {
	                    var _this = this;
	                    this._paused = false;
	                    Promise.resolve().then(function () {
	                        if (_this._queue.length > 0 && !_this._currentCommandPending) {
	                            _this._executeNextCommand();
	                        }
	                    });
	                };
	                /**
	                 * Puase the command queue (currently executing commands will still complete)
	                 */
	                CommandQueue.prototype.pause = function () {
	                    this._paused = true;
	                };
	                /**
	                 * Clear commandQueue.
	                 */
	                CommandQueue.prototype.clear = function () {
	                    this._queue.forEach(function (item) {
	                        item.reject("Unable to execute.");
	                    });
	                    this._queue = [];
	                };
	                CommandQueue.prototype._executeNextCommand = function () {
	                    var _this = this;
	                    this._currentCommand = undefined;
	                    this._currentCommandPending = undefined;
	                    if (this._paused) return;
	                    var item = this._queue.shift();
	                    if (!item) return;
	                    this._currentCommand = item.command;
	                    this._currentCommandPending = item.execute().then(this._executeNextCommand.bind(this)).catch(function (e) {
	                        _this.errorEvent.raiseEvent(e);
	                        _this._executeNextCommand();
	                    });
	                };
	                return CommandQueue;
	            }();
	            exports_1("CommandQueue", CommandQueue);
	            /**
	             * Alias of getEntityPositionInReferenceFrame
	             */
	            exports_1("getEntityPosition", getEntityPosition = getEntityPositionInReferenceFrame);
	            /**
	             * Alias of getEntityOrientationInReferenceFrame
	             */
	            exports_1("getEntityOrientation", getEntityOrientation = getEntityOrientationInReferenceFrame);
	            urlParser = typeof document !== 'undefined' ? document.createElement("a") : undefined;
	            /**
	             * A MessageChannel pollyfill.
	             */
	            MessageChannelLike = function () {
	                /**
	                 * Create a MessageChannelLike instance.
	                 */
	                function MessageChannelLike() {
	                    var messageChannel = this;
	                    var _portsOpen = true;
	                    var _port1ready;
	                    var _port2ready;
	                    var _port1onmessage;
	                    _port1ready = new Promise(function (resolve) {
	                        messageChannel.port1 = {
	                            set onmessage(func) {
	                                _port1onmessage = func;
	                                resolve();
	                            },
	                            get onmessage() {
	                                return _port1onmessage;
	                            },
	                            postMessage: function (data) {
	                                if (_portsOpen) {
	                                    _port2ready.then(function () {
	                                        if (messageChannel.port2.onmessage) messageChannel.port2.onmessage({ data: data });
	                                    });
	                                }
	                            },
	                            close: function () {
	                                _portsOpen = false;
	                            }
	                        };
	                    });
	                    var _port2onmessage;
	                    _port2ready = new Promise(function (resolve) {
	                        messageChannel.port2 = {
	                            set onmessage(func) {
	                                _port2onmessage = func;
	                                resolve();
	                            },
	                            get onmessage() {
	                                return _port2onmessage;
	                            },
	                            postMessage: function (data) {
	                                if (_portsOpen) {
	                                    _port1ready.then(function () {
	                                        if (messageChannel.port1.onmessage) messageChannel.port1.onmessage({ data: data });
	                                    });
	                                }
	                            },
	                            close: function () {
	                                _portsOpen = false;
	                            }
	                        };
	                    });
	                }
	                return MessageChannelLike;
	            }();
	            exports_1("MessageChannelLike", MessageChannelLike);
	            /**
	             * A synchronous MessageChannel.
	             */
	            SynchronousMessageChannel = function () {
	                /**
	                 * Create a MessageChannelLike instance.
	                 */
	                function SynchronousMessageChannel() {
	                    var messageChannel = this;
	                    var pendingMessages1 = [];
	                    var onmessage1 = function (message) {
	                        pendingMessages1.push(message);
	                    };
	                    messageChannel.port1 = {
	                        get onmessage() {
	                            return onmessage1;
	                        },
	                        set onmessage(func) {
	                            onmessage1 = func;
	                            pendingMessages1.forEach(function (data) {
	                                return func(data);
	                            });
	                            pendingMessages1 = [];
	                        },
	                        postMessage: function (data) {
	                            if (messageChannel.port2.onmessage) messageChannel.port2.onmessage({ data: data });
	                        },
	                        close: function () {
	                            messageChannel.port1.onmessage = undefined;
	                            messageChannel.port2.onmessage = undefined;
	                        }
	                    };
	                    var pendingMessages2 = [];
	                    var onmessage2 = function (message) {
	                        pendingMessages2.push(message);
	                    };
	                    messageChannel.port2 = {
	                        get onmessage() {
	                            return onmessage2;
	                        },
	                        set onmessage(func) {
	                            onmessage2 = func;
	                            pendingMessages2.forEach(function (data) {
	                                return func(data);
	                            });
	                            pendingMessages2 = [];
	                        },
	                        postMessage: function (data) {
	                            if (messageChannel.port1.onmessage) messageChannel.port1.onmessage({ data: data });
	                        },
	                        close: function () {
	                            messageChannel.port1.onmessage = undefined;
	                            messageChannel.port2.onmessage = undefined;
	                        }
	                    };
	                }
	                return SynchronousMessageChannel;
	            }();
	            exports_1("SynchronousMessageChannel", SynchronousMessageChannel);
	            /**
	             * A factory which creates MessageChannel or MessageChannelLike instances, depending on
	             * wheter or not MessageChannel is avaialble in the execution context.
	             */
	            MessageChannelFactory = function () {
	                function MessageChannelFactory() {}
	                /**
	                 * Create a MessageChannel (or MessageChannelLike) instance.
	                 */
	                MessageChannelFactory.prototype.create = function () {
	                    if (typeof MessageChannel !== 'undefined') return new MessageChannel();else return new MessageChannelLike();
	                };
	                /**
	                 * Create a SynchronousMessageChannel instance.
	                 */
	                MessageChannelFactory.prototype.createSynchronous = function () {
	                    return new SynchronousMessageChannel();
	                };
	                return MessageChannelFactory;
	            }();
	            exports_1("MessageChannelFactory", MessageChannelFactory);
	            scratchPerspectiveOffCenterFrustum = new cesium_imports_1.PerspectiveOffCenterFrustum();
	            scratchCartesian = new cesium_imports_1.Cartesian3();
	            scratchOrientation = new cesium_imports_1.Quaternion();
	        }
	    };
	});
	$__System.register('1', ['2', 'c', 'a', '7', '10', 'f', 'b', '9', '14', '11', 'd', '17', '13', 'e', '15', '18', '12'], function (exports_1, context_1) {
	    "use strict";

	    var __moduleName = context_1 && context_1.id;
	    var DI, Cesium, URI, session_1, common_1, context_2, device_1, focus_1, reality_1, timer_1, view_1, vuforia_1, empty_1, live_video_1, hosted_1;
	    var ArgonSystem;
	    /**
	     * Create an ArgonSystem instance.
	     * If we are running within a [[REALITY_MANAGER]],
	     * this function will create an ArgonSystem which has the [[REALITY_AUGMENTOR]] role.
	     * If we are not running within a [[REALITY_MANAGER]],
	     * this function will create an ArgonSystem which has the [[REALITY_MANAGER]] role.
	     * @param initParameters InitParameters
	     */
	    function init(_a) {
	        var _b = _a === void 0 ? {} : _a,
	            configuration = _b.configuration,
	            _c = _b.container,
	            container = _c === void 0 ? new DI.Container() : _c;
	        var role;
	        if (typeof HTMLElement === 'undefined') {
	            role = common_1.Role.REALITY_MANAGER;
	        } else if (navigator.userAgent.indexOf('Argon') > 0 || window.top !== window) {
	            role = common_1.Role.APPLICATION; // TODO: switch to below after next argon-app release
	        } else {
	            role = common_1.Role.REALITY_MANAGER;
	        }
	        var config = Object.assign(configuration || {}, {
	            role: role
	        });
	        container.registerInstance('containerElement', null);
	        return new ArgonSystem(config, container);
	    }
	    exports_1("init", init);
	    /**
	     * Initialize an [[ArgonSystem]] with the [[REALITY_VIEW]] role
	     */
	    function initReality(_a) {
	        var _b = _a === void 0 ? {} : _a,
	            configuration = _b.configuration,
	            _c = _b.container,
	            container = _c === void 0 ? new DI.Container() : _c;
	        var config = Object.assign(configuration || {}, {
	            role: common_1.Role.REALITY_VIEW,
	            'reality.supportsControlPort': true
	        });
	        container.registerInstance('containerElement', null);
	        return new ArgonSystem(config, container);
	    }
	    exports_1("initReality", initReality);
	    /**
	     * Not yet implemented.
	     * @private
	     */
	    function initLocal(_a) {
	        var containerElement = _a.containerElement,
	            configuration = _a.configuration,
	            _b = _a.container,
	            container = _b === void 0 ? new DI.Container() : _b;
	        var config = Object.assign(configuration || {}, {
	            role: common_1.Role.REALITY_MANAGER
	        });
	        container.registerInstance('containerElement', containerElement);
	        return new ArgonSystem(config, container);
	    }
	    exports_1("initLocal", initLocal);
	    var exportedNames_1 = {
	        'ArgonSystem': true,
	        'init': true,
	        'initReality': true,
	        'initLocal': true,
	        'DI': true,
	        'Cesium': true,
	        'URI': true,
	        'EmptyRealityLoader': true,
	        'LiveVideoRealityLoader': true,
	        'HostedRealityLoader': true
	    };
	    function exportStar_1(m) {
	        var exports = {};
	        for (var n in m) {
	            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
	        }
	        exports_1(exports);
	    }
	    return {
	        setters: [function (_1) {}, function (DI_1) {
	            DI = DI_1;
	        }, function (Cesium_1) {
	            Cesium = Cesium_1;
	        }, function (URI_1) {
	            URI = URI_1;
	        }, function (session_1_1) {
	            session_1 = session_1_1;
	            exportStar_1(session_1_1);
	        }, function (common_1_1) {
	            common_1 = common_1_1;
	            exportStar_1(common_1_1);
	        }, function (context_2_1) {
	            context_2 = context_2_1;
	            exportStar_1(context_2_1);
	        }, function (device_1_1) {
	            device_1 = device_1_1;
	            exportStar_1(device_1_1);
	        }, function (focus_1_1) {
	            focus_1 = focus_1_1;
	            exportStar_1(focus_1_1);
	        }, function (reality_1_1) {
	            reality_1 = reality_1_1;
	            exportStar_1(reality_1_1);
	        }, function (timer_1_1) {
	            timer_1 = timer_1_1;
	            exportStar_1(timer_1_1);
	        }, function (view_1_1) {
	            view_1 = view_1_1;
	            exportStar_1(view_1_1);
	        }, function (vuforia_1_1) {
	            vuforia_1 = vuforia_1_1;
	            exportStar_1(vuforia_1_1);
	        }, function (empty_1_1) {
	            empty_1 = empty_1_1;
	        }, function (live_video_1_1) {
	            live_video_1 = live_video_1_1;
	        }, function (hosted_1_1) {
	            hosted_1 = hosted_1_1;
	        }, function (utils_1_1) {
	            exportStar_1(utils_1_1);
	        }],
	        execute: function () {
	            exports_1("DI", DI);
	            exports_1("Cesium", Cesium);
	            exports_1("URI", URI);
	            exports_1("EmptyRealityLoader", empty_1.EmptyRealityLoader);
	            exports_1("LiveVideoRealityLoader", live_video_1.LiveVideoRealityLoader);
	            exports_1("HostedRealityLoader", hosted_1.HostedRealityLoader);
	            /**
	             * A composition root which instantiates the object graph based on a provided configuration.
	             * You generally want to create a new ArgonSystem via the provided [[init]] or [[initReality]] functions:
	             * ```ts
	             * var app = Argon.init(); // app is an instance of ArgonSystem
	             * ```
	             */
	            ArgonSystem = function () {
	                function ArgonSystem(config, container) {
	                    if (container === void 0) {
	                        container = new DI.Container();
	                    }
	                    this.container = container;
	                    if (!ArgonSystem.instance) ArgonSystem.instance = this;
	                    container.registerInstance('config', config);
	                    container.registerInstance(ArgonSystem, this);
	                    if (!container.hasResolver('containerElement')) container.registerInstance('containerElement', null);
	                    if (config.role === common_1.Role.REALITY_MANAGER) {
	                        container.registerSingleton(session_1.ConnectService, session_1.LoopbackConnectService);
	                    } else if (session_1.WKWebViewConnectService.isAvailable()) {
	                        container.registerSingleton(session_1.ConnectService, session_1.WKWebViewConnectService);
	                    } else if (session_1.DOMConnectService.isAvailable()) {
	                        container.registerSingleton(session_1.ConnectService, session_1.DOMConnectService);
	                    } else if (session_1.DebugConnectService.isAvailable()) {
	                        container.registerSingleton(session_1.ConnectService, session_1.DebugConnectService);
	                    }
	                    if (config.role === common_1.Role.REALITY_MANAGER) {
	                        this.reality.registerLoader(container.get(empty_1.EmptyRealityLoader));
	                        this.reality.registerLoader(container.get(live_video_1.LiveVideoRealityLoader));
	                        if (typeof document !== 'undefined') {
	                            this.reality.registerLoader(container.get(hosted_1.HostedRealityLoader));
	                            // enable pinch-zoom
	                            container.get(view_1.PinchZoomService);
	                        }
	                        this.reality.setDefault(common_1.RealityView.EMPTY);
	                    }
	                    // ensure the entire object graph is instantiated before connecting to the manager. 
	                    for (var _i = 0, _a = Object.keys(ArgonSystem.prototype); _i < _a.length; _i++) {
	                        var key = _a[_i];
	                        this[key];
	                    }
	                    this.session.connect();
	                }
	                Object.defineProperty(ArgonSystem.prototype, "context", {
	                    get: function () {
	                        return this.container.get(context_2.ContextService);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "device", {
	                    get: function () {
	                        return this.container.get(device_1.DeviceService);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "focus", {
	                    get: function () {
	                        return this.container.get(focus_1.FocusService);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "reality", {
	                    get: function () {
	                        return this.container.get(reality_1.RealityService);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "session", {
	                    get: function () {
	                        return this.container.get(session_1.SessionService);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "timer", {
	                    get: function () {
	                        return this.container.get(timer_1.TimerService);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "view", {
	                    get: function () {
	                        return this.container.get(view_1.ViewService);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "vuforia", {
	                    get: function () {
	                        return this.container.get(vuforia_1.VuforiaService);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "updateEvent", {
	                    // events
	                    get: function () {
	                        return this.context.updateEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "renderEvent", {
	                    get: function () {
	                        return this.context.renderEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "focusEvent", {
	                    get: function () {
	                        return this.focus.focusEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ArgonSystem.prototype, "blurEvent", {
	                    get: function () {
	                        return this.focus.blurEvent;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                return ArgonSystem;
	            }();
	            exports_1("ArgonSystem", ArgonSystem);
	        }
	    };
	});
	})
	(function(factory) {
	  if (true)
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  else if (typeof module == 'object' && module.exports && typeof require == 'function')
	    module.exports = factory();
	  else
	    Argon = factory();
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./argon": 1,
		"./argon.js": 1,
		"./argon.min": 4,
		"./argon.min.js": 4
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 3;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, process) {!function(e){function t(e,t,i){return 4===arguments.length?r.apply(this,arguments):void n(e,{declarative:!0,deps:t,declare:i})}function r(e,t,r,i){n(e,{declarative:!1,deps:t,executingRequire:r,execute:i})}function n(e,t){t.name=e,e in v||(v[e]=t),t.normalizedDeps=t.deps}function i(e,t){if(t[e.groupIndex]=t[e.groupIndex]||[],-1==p.call(t[e.groupIndex],e)){t[e.groupIndex].push(e);for(var r=0,n=e.normalizedDeps.length;n>r;r++){var a=e.normalizedDeps[r],o=v[a];if(o&&!o.evaluated){var s=e.groupIndex+(o.declarative!=e.declarative);if(void 0===o.groupIndex||o.groupIndex<s){if(void 0!==o.groupIndex&&(t[o.groupIndex].splice(p.call(t[o.groupIndex],o),1),0==t[o.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");o.groupIndex=s}i(o,t)}}}}function a(e){var t=v[e];t.groupIndex=0;var r=[];i(t,r);for(var n=!!t.declarative==r.length%2,a=r.length-1;a>=0;a--){for(var o=r[a],u=0;u<o.length;u++){var c=o[u];n?s(c):f(c)}n=!n}}function o(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function s(t){if(!t.module){var r=t.module=o(t.name),n=t.module.exports,i=t.declare.call(e,function(e,t){if(r.locked=!0,"object"==typeof e)for(var i in e)n[i]=e[i];else n[e]=t;for(var a=0,o=r.importers.length;o>a;a++){var s=r.importers[a];if(!s.locked)for(var u=0;u<s.dependencies.length;++u)s.dependencies[u]===r&&s.setters[u](n)}return r.locked=!1,t},{id:t.name});r.setters=i.setters,r.execute=i.execute;for(var a=0,u=t.normalizedDeps.length;u>a;a++){var f,c=t.normalizedDeps[a],l=v[c],d=y[c];d?f=d.exports:l&&!l.declarative?f=l.esModule:l?(s(l),d=l.module,f=d.exports):f=h(c),d&&d.importers?(d.importers.push(r),r.dependencies.push(d)):r.dependencies.push(null),r.setters[a]&&r.setters[a](f)}}}function u(e){var t,r=v[e];if(r)r.declarative?d(e,[]):r.evaluated||f(r),t=r.module.exports;else if(t=h(e),!t)throw new Error("Unable to load dependency "+e+".");return(!r||r.declarative)&&t&&t.__useDefault?t["default"]:t}function f(t){if(!t.module){var r={},n=t.module={exports:r,id:t.name};if(!t.executingRequire)for(var i=0,a=t.normalizedDeps.length;a>i;i++){var o=t.normalizedDeps[i],s=v[o];s&&f(s)}t.evaluated=!0;var l=t.execute.call(e,function(e){for(var r=0,n=t.deps.length;n>r;r++)if(t.deps[r]==e)return u(t.normalizedDeps[r]);throw new TypeError("Module "+e+" not declared as a dependency.")},r,n);l&&(n.exports=l),r=n.exports,r&&r.__esModule?t.esModule=r:t.esModule=c(r)}}function c(t){var r={};if(("object"==typeof t||"function"==typeof t)&&t!==e)if(m)for(var n in t)"default"!==n&&l(r,t,n);else{var i=t&&t.hasOwnProperty;for(var n in t)"default"===n||i&&!t.hasOwnProperty(n)||(r[n]=t[n])}return r["default"]=t,w(r,"__useDefault",{value:!0}),r}function l(e,t,r){try{var n;(n=Object.getOwnPropertyDescriptor(t,r))&&w(e,r,n)}catch(n){return e[r]=t[r],!1}}function d(t,r){var n=v[t];if(n&&!n.evaluated&&n.declarative){r.push(t);for(var i=0,a=n.normalizedDeps.length;a>i;i++){var o=n.normalizedDeps[i];-1==p.call(r,o)&&(v[o]?d(o,r):h(o))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function h(e){if(S[e])return S[e];if("@node/"==e.substr(0,6))return S[e]=c(g(e.substr(6)));var t=v[e];if(!t)throw"Module "+e+" not present.";return a(e),d(e,[]),v[e]=void 0,t.declarative&&w(t.module.exports,"__esModule",{value:!0}),S[e]=t.declarative?t.module.exports:t.esModule}var v={},p=Array.prototype.indexOf||function(e){for(var t=0,r=this.length;r>t;t++)if(this[t]===e)return t;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(e){m=!1}var w;!function(){try{Object.defineProperty({},"a",{})&&(w=Object.defineProperty)}catch(e){w=function(e,t,r){try{e[t]=r.value||r.get.call(e)}catch(e){}}}}();var y={},g="undefined"!=typeof System&&System._nodeRequire||"undefined"!="function"&&__webpack_require__(3).resolve&&"undefined"!=typeof process&&__webpack_require__(3),S={"@empty":{}};return function(e,n,i,a){return function(o){o(function(o){for(var s={_nodeRequire:g,register:t,registerDynamic:r,get:h,set:function(e,t){S[e]=t},newModule:function(e){return e}},u=0;u<n.length;u++)(function(e,t){t&&t.__esModule?S[e]=t:S[e]=c(t)})(n[u],arguments[u]);a(s);var f=h(e[0]);if(e.length>1)for(var u=1;u<e.length;u++)h(e[u]);return i?f["default"]:f})}}}("undefined"!=typeof self?self:global)(["1"],[],false,function(e){var t=this.require,r=this.exports,n=this.module;!function(t){function r(e,t){e=e.replace(s,"");var r=e.match(c),n=(r[1].split(",")[t]||"require").replace(l,""),i=d[n]||(d[n]=new RegExp(u+n+f,"g"));i.lastIndex=0;for(var a,o=[];a=i.exec(e);)o.push(a[2]||a[3]);return o}function n(e,t,r,i){if("object"==typeof e&&!(e instanceof Array))return n.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof t&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var o=a.get(e);return o.__useDefault?o["default"]:o}throw new TypeError("Invalid require")}for(var s=[],u=0;u<e.length;u++)s.push(a["import"](e[u],i));Promise.all(s).then(function(e){t&&t.apply(null,e)},r)}function i(e,i,s){"string"!=typeof e&&(s=i,i=e,e=null),i instanceof Array||(s=i,i=["require","exports","module"].splice(0,s.length)),"function"!=typeof s&&(s=function(e){return function(){return e}}(s)),void 0===i[i.length-1]&&i.pop();var u,f,c;-1!=(u=o.call(i,"require"))&&(i.splice(u,1),e||(i=i.concat(r(s.toString(),u)))),-1!=(f=o.call(i,"exports"))&&i.splice(f,1),-1!=(c=o.call(i,"module"))&&i.splice(c,1);var l={name:e,deps:i,execute:function(e,r,o){for(var l=[],d=0;d<i.length;d++)l.push(e(i[d]));o.uri=o.id,o.config=function(){},-1!=c&&l.splice(c,0,o),-1!=f&&l.splice(f,0,r),-1!=u&&l.splice(u,0,function(t,r,i){return"string"==typeof t&&"function"!=typeof r?e(t):n.call(a,t,r,i,o.id)});var h=s.apply(-1==f?t:r,l);return"undefined"==typeof h&&o&&(h=o.exports),"undefined"!=typeof h?h:void 0}};if(e)h.anonDefine||h.isBundle?h.anonDefine&&h.anonDefine.name&&(h.anonDefine=null):h.anonDefine=l,h.isBundle=!0,a.registerDynamic(l.name,l.deps,!1,l.execute);else{if(h.anonDefine&&!h.anonDefine.name)throw new Error("Multiple anonymous defines in module "+e);h.anonDefine=l}}var a=e,o=Array.prototype.indexOf||function(e){for(var t=0,r=this.length;r>t;t++)if(this[t]===e)return t;return-1},s=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,u="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",c=/\(([^\)]*)\)/,l=/^\s+|\s+$/g,d={};i.amd={};var h={isBundle:!1,anonDefine:null};a.amdDefine=i,a.amdRequire=n}("undefined"!=typeof self?self:global);(function(){var t=e.amdDefine;t("2",["exports","3"],function(e,t){"use strict";Number.isNaN=Number.isNaN||function(e){return e!==e};Number.isFinite=Number.isFinite||function(e){return typeof e==="number"&&isFinite(e)};if(!String.prototype.endsWith){String.prototype.endsWith=function(e,t){var r=this.toString();if(typeof t!=="number"||!isFinite(t)||Math.floor(t)!==t||t>r.length){t=r.length}t-=e.length;var n=r.indexOf(e,t);return n!==-1&&n===t}}if(!String.prototype.startsWith){String.prototype.startsWith=function(e,t){t=t||0;return this.substr(t,e.length)===e}}if(!Array.from){Array.from=function(){var e=Object.prototype.toString;var t=function t(r){return typeof r==="function"||e.call(r)==="[object Function]"};var r=function e(t){var r=Number(t);if(isNaN(r)){return 0}if(r===0||!isFinite(r)){return r}return(r>0?1:-1)*Math.floor(Math.abs(r))};var n=Math.pow(2,53)-1;var i=function e(t){var i=r(t);return Math.min(Math.max(i,0),n)};return function e(r){var n=this;var a=Object(r);if(r==null){throw new TypeError("Array.from requires an array-like object - not null or undefined")}var o=arguments.length>1?arguments[1]:void undefined;var s;if(typeof o!=="undefined"){if(!t(o)){throw new TypeError("Array.from: when provided, the second argument must be a function")}if(arguments.length>2){s=arguments[2]}}var u=i(a.length);var f=t(n)?Object(new n(u)):new Array(u);var c=0;var l;while(c<u){l=a[c];if(o){f[c]=typeof s==="undefined"?o(l,c):o.call(s,l,c)}else{f[c]=l}c+=1}f.length=u;return f}}()}if(!Array.prototype.find){Array.prototype.find=function(e){if(this===null){throw new TypeError("Array.prototype.find called on null or undefined")}if(typeof e!=="function"){throw new TypeError("predicate must be a function")}var t=Object(this);var r=t.length>>>0;var n=arguments[1];var i;for(var a=0;a<r;a++){i=t[a];if(e.call(n,i,a,t)){return i}}return undefined}}if(!Array.prototype.findIndex){Array.prototype.findIndex=function(e){if(this===null){throw new TypeError("Array.prototype.findIndex called on null or undefined")}if(typeof e!=="function"){throw new TypeError("predicate must be a function")}var t=Object(this);var r=t.length>>>0;var n=arguments[1];var i;for(var a=0;a<r;a++){i=t[a];if(e.call(n,i,a,t)){return a}}return-1}}if(!Array.prototype.includes){Array.prototype.includes=function(e){var t=Object(this);var r=parseInt(t.length)||0;if(r===0){return false}var n=parseInt(arguments[1])||0;var i;if(n>=0){i=n}else{i=r+n;if(i<0){i=0}}var a;while(i<r){a=t[i];if(e===a||e!==e&&a!==a){return true}i++}return false}}if(typeof Object.assign!=="function"){Object.assign=function(e){if(e===undefined||e===null){throw new TypeError("Cannot convert undefined or null to object")}var t=Object(e);for(var r=1;r<arguments.length;r++){var n=arguments[r];if(n!==undefined&&n!==null){for(var i in n){if(n.hasOwnProperty(i)){t[i]=n[i]}}}}return t}}(function(e){var t=undefined;var r=Object.defineProperty;var n=function e(t,r){return t===r||t!==t&&r!==r};if(typeof Map=="undefined"||typeof(new Map).values!=="function"||!(new Map).values().next){e.Map=i({delete:o,has:c,get:s,set:l,keys:v,values:p,entries:m,forEach:S,clear:h})}if(typeof Set=="undefined"||typeof(new Set).values!=="function"||!(new Set).values().next){e.Set=i({has:f,add:d,delete:o,clear:h,keys:p,values:p,entries:w,forEach:S})}function i(e,t){function n(e){if(!this||this.constructor!==n)return new n(e);this._keys=[];this._values=[];this._itp=[];this.objectOnly=t;if(e)a.call(this,e)}if(!t){r(e,"size",{get:g})}e.constructor=n;n.prototype=e;return n}function a(e){var t;if(this.add)e.forEach(this.add,this);else e.forEach(function(e){this.set(e[0],e[1])},this)}function o(e){if(this.has(e)){this._keys.splice(t,1);this._values.splice(t,1);this._itp.forEach(function(e){if(t<e[0])e[0]--})}return-1<t}function s(e){return this.has(e)?this._values[t]:undefined}function u(e,r){if(this.objectOnly&&r!==Object(r))throw new TypeError("Invalid value used as weak collection key");if(r!=r||r===0)for(t=e.length;t--&&!n(e[t],r);){}else t=e.indexOf(r);return-1<t}function f(e){return u.call(this,this._values,e)}function c(e){return u.call(this,this._keys,e)}function l(e,r){this.has(e)?this._values[t]=r:this._values[this._keys.push(e)-1]=r;return this}function d(e){if(!this.has(e))this._values.push(e);return this}function h(){(this._keys||0).length=this._values.length=0}function v(){return y(this._itp,this._keys)}function p(){return y(this._itp,this._values)}function m(){return y(this._itp,this._keys,this._values)}function w(){return y(this._itp,this._values,this._values)}function y(e,t,r){var n=[0],i=false;e.push(n);return{next:function a(){var o,s=n[0];if(!i&&s<t.length){o=r?[t[s],r[s]]:t[s];n[0]++}else{i=true;e.splice(e.indexOf(n),1)}return{done:i,value:o}}}}function g(){return this._values.length}function S(e,t){var r=this.entries();for(;;){var n=r.next();if(n.done)break;e.call(t,n.value[1],n.value[0],this)}}})(t.PLATFORM.global);var r=Object.freeze({});var n="__metadata__";var i=Function.prototype.bind;if(typeof t.PLATFORM.global.Reflect==="undefined"){t.PLATFORM.global.Reflect={}}if(typeof Reflect.getOwnMetadata!=="function"){Reflect.getOwnMetadata=function(e,t,i){return((t[n]||r)[i]||r)[e]}}if(typeof Reflect.defineMetadata!=="function"){Reflect.defineMetadata=function(e,t,r,i){var a=r.hasOwnProperty(n)?r[n]:r[n]={};var o=a[i]||(a[i]={});o[e]=t}}if(typeof Reflect.metadata!=="function"){Reflect.metadata=function(e,t){return function(r,n){Reflect.defineMetadata(e,t,r,n)}}}if(typeof Reflect.construct!=="function"){Reflect.construct=function(e,t){if(t){switch(t.length){case 0:return new e;case 1:return new e(t[0]);case 2:return new e(t[0],t[1]);case 3:return new e(t[0],t[1],t[2]);case 4:return new e(t[0],t[1],t[2],t[3])}}var r=[null];r.push.apply(r,t);return new(i.apply(e,r))}}})})();(function(){var t=e.amdDefine;(function(e){var i=typeof r=="object"&&r&&!r.nodeType&&r;var a=typeof n=="object"&&n&&!n.nodeType&&n;var o=typeof global=="object"&&global;if(o.global===o||o.window===o||o.self===o){e=o}var s,u=2147483647,f=36,c=1,l=26,d=38,h=700,v=72,p=128,m="-",w=/^xn--/,y=/[^\x20-\x7E]/,g=/[\x2E\u3002\uFF0E\uFF61]/g,S={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},b=f-c,T=Math.floor,_=String.fromCharCode,E;function M(e){throw new RangeError(S[e])}function P(e,t){var r=e.length;var n=[];while(r--){n[r]=t(e[r])}return n}function A(e,t){var r=e.split("@");var n="";if(r.length>1){n=r[0]+"@";e=r[1]}e=e.replace(g,".");var i=e.split(".");var a=P(i,t).join(".");return n+a}function C(e){var t=[],r=0,n=e.length,i,a;while(r<n){i=e.charCodeAt(r++);if(i>=55296&&i<=56319&&r<n){a=e.charCodeAt(r++);if((a&64512)==56320){t.push(((i&1023)<<10)+(a&1023)+65536)}else{t.push(i);r--}}else{t.push(i)}}return t}function I(e){return P(e,function(e){var t="";if(e>65535){e-=65536;t+=_(e>>>10&1023|55296);e=56320|e&1023}t+=_(e);return t}).join("")}function x(e){if(e-48<10){return e-22}if(e-65<26){return e-65}if(e-97<26){return e-97}return f}function R(e,t){return e+22+75*(e<26)-((t!=0)<<5)}function O(e,t,r){var n=0;e=r?T(e/h):e>>1;e+=T(e/t);for(;e>b*l>>1;n+=f){e=T(e/b)}return T(n+(b+1)*e/(e+d))}function D(e){var t=[],r=e.length,n,i=0,a=p,o=v,s,d,h,w,y,g,S,b,_;s=e.lastIndexOf(m);if(s<0){s=0}for(d=0;d<s;++d){if(e.charCodeAt(d)>=128){M("not-basic")}t.push(e.charCodeAt(d))}for(h=s>0?s+1:0;h<r;){for(w=i,y=1,g=f;;g+=f){if(h>=r){M("invalid-input")}S=x(e.charCodeAt(h++));if(S>=f||S>T((u-i)/y)){M("overflow")}i+=S*y;b=g<=o?c:g>=o+l?l:g-o;if(S<b){break}_=f-b;if(y>T(u/_)){M("overflow")}y*=_}n=t.length+1;o=O(i-w,n,w==0);if(T(i/n)>u-a){M("overflow")}a+=T(i/n);i%=n;t.splice(i++,0,a)}return I(t)}function q(e){var t,r,n,i,a,o,s,d,h,w,y,g=[],S,b,E,P;e=C(e);S=e.length;t=p;r=0;a=v;for(o=0;o<S;++o){y=e[o];if(y<128){g.push(_(y))}}n=i=g.length;if(i){g.push(m)}while(n<S){for(s=u,o=0;o<S;++o){y=e[o];if(y>=t&&y<s){s=y}}b=n+1;if(s-t>T((u-r)/b)){M("overflow")}r+=(s-t)*b;t=s;for(o=0;o<S;++o){y=e[o];if(y<t&&++r>u){M("overflow")}if(y==t){for(d=r,h=f;;h+=f){w=h<=a?c:h>=a+l?l:h-a;if(d<w){break}P=d-w;E=f-w;g.push(_(R(w+P%E,0)));d=T(P/E)}g.push(_(R(d,0)));a=O(r,b,n==i);r=0;++n}}++r;++t}return g.join("")}function N(e){return A(e,function(e){return w.test(e)?D(e.slice(4).toLowerCase()):e})}function G(e){return A(e,function(e){return y.test(e)?"xn--"+q(e):e})}s={version:"1.3.2",ucs2:{decode:C,encode:I},decode:D,encode:q,toASCII:G,toUnicode:N};if(typeof t=="function"&&typeof t.amd=="object"&&t.amd){t("4",[],function(){return s})&&t("punycode",["4"],function(e){return e})}else if(i&&a){if(n.exports==i){a.exports=s}else{for(E in s){s.hasOwnProperty(E)&&(i[E]=s[E])}}}else{e.punycode=s}})(this)})();(function(){var t=e.amdDefine;(function(e,i){"use strict";if(typeof r==="object"){n.exports=i()}else if(typeof t==="function"&&t.amd){t("5",[],i)}else{e.IPv6=i(e)}})(this,function(e){"use strict";var t=e&&e.IPv6;function r(e){var t=e.toLowerCase();var r=t.split(":");var n=r.length;var i=8;if(r[0]===""&&r[1]===""&&r[2]===""){r.shift();r.shift()}else if(r[0]===""&&r[1]===""){r.shift()}else if(r[n-1]===""&&r[n-2]===""){r.pop()}n=r.length;if(r[n-1].indexOf(".")!==-1){i=7}var a;for(a=0;a<n;a++){if(r[a]===""){break}}if(a<i){r.splice(a,1,"0000");while(r.length<i){r.splice(a,0,"0000")}}var o;for(var s=0;s<i;s++){o=r[s].split("");for(var u=0;u<3;u++){if(o[0]==="0"&&o.length>1){o.splice(0,1)}else{break}}r[s]=o.join("")}var f=-1;var c=0;var l=0;var d=-1;var h=false;for(s=0;s<i;s++){if(h){if(r[s]==="0"){l+=1}else{h=false;if(l>c){f=d;c=l}}}else{if(r[s]==="0"){h=true;d=s;l=1}}}if(l>c){f=d;c=l}if(c>1){r.splice(f,c,"")}n=r.length;var v="";if(r[0]===""){v=":"}for(s=0;s<n;s++){v+=r[s];if(s===n-1){break}v+=":"}if(r[n-1]===""){v+=":"}return v}function n(){if(e.IPv6===this){e.IPv6=t}return this}return{best:r,noConflict:n}})})();(function(){var t=e.amdDefine;(function(e,i){"use strict";if(typeof r==="object"){n.exports=i()}else if(typeof t==="function"&&t.amd){t("6",[],i)}else{e.SecondLevelDomains=i(e)}})(this,function(e){"use strict";var t=e&&e.SecondLevelDomains;var r={list:{ac:" com gov mil net org ",ae:" ac co gov mil name net org pro sch ",af:" com edu gov net org ",al:" com edu gov mil net org ",ao:" co ed gv it og pb ",ar:" com edu gob gov int mil net org tur ",at:" ac co gv or ",au:" asn com csiro edu gov id net org ",ba:" co com edu gov mil net org rs unbi unmo unsa untz unze ",bb:" biz co com edu gov info net org store tv ",bh:" biz cc com edu gov info net org ",bn:" com edu gov net org ",bo:" com edu gob gov int mil net org tv ",br:" adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",bs:" com edu gov net org ",bz:" du et om ov rg ",ca:" ab bc mb nb nf nl ns nt nu on pe qc sk yk ",ck:" biz co edu gen gov info net org ",cn:" ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",co:" com edu gov mil net nom org ",cr:" ac c co ed fi go or sa ",cy:" ac biz com ekloges gov ltd name net org parliament press pro tm ",do:" art com edu gob gov mil net org sld web ",dz:" art asso com edu gov net org pol ",ec:" com edu fin gov info med mil net org pro ",eg:" com edu eun gov mil name net org sci ",er:" com edu gov ind mil net org rochest w ",es:" com edu gob nom org ",et:" biz com edu gov info name net org ",fj:" ac biz com info mil name net org pro ",fk:" ac co gov net nom org ",fr:" asso com f gouv nom prd presse tm ",gg:" co net org ",gh:" com edu gov mil org ",gn:" ac com gov net org ",gr:" com edu gov mil net org ",gt:" com edu gob ind mil net org ",gu:" com edu gov net org ",hk:" com edu gov idv net org ",hu:" 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",id:" ac co go mil net or sch web ",il:" ac co gov idf k12 muni net org ",in:" ac co edu ernet firm gen gov i ind mil net nic org res ",iq:" com edu gov i mil net org ",ir:" ac co dnssec gov i id net org sch ",it:" edu gov ",je:" co net org ",jo:" com edu gov mil name net org sch ",jp:" ac ad co ed go gr lg ne or ",ke:" ac co go info me mobi ne or sc ",kh:" com edu gov mil net org per ",ki:" biz com de edu gov info mob net org tel ",km:" asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",kn:" edu gov net org ",kr:" ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",kw:" com edu gov net org ",ky:" com edu gov net org ",kz:" com edu gov mil net org ",lb:" com edu gov net org ",lk:" assn com edu gov grp hotel int ltd net ngo org sch soc web ",lr:" com edu gov net org ",lv:" asn com conf edu gov id mil net org ",ly:" com edu gov id med net org plc sch ",ma:" ac co gov m net org press ",mc:" asso tm ",me:" ac co edu gov its net org priv ",mg:" com edu gov mil nom org prd tm ",mk:" com edu gov inf name net org pro ",ml:" com edu gov net org presse ",mn:" edu gov org ",mo:" com edu gov net org ",mt:" com edu gov net org ",mv:" aero biz com coop edu gov info int mil museum name net org pro ",mw:" ac co com coop edu gov int museum net org ",mx:" com edu gob net org ",my:" com edu gov mil name net org sch ",nf:" arts com firm info net other per rec store web ",ng:" biz com edu gov mil mobi name net org sch ",ni:" ac co com edu gob mil net nom org ",np:" com edu gov mil net org ",nr:" biz com edu gov info net org ",om:" ac biz co com edu gov med mil museum net org pro sch ",pe:" com edu gob mil net nom org sld ",ph:" com edu gov i mil net ngo org ",pk:" biz com edu fam gob gok gon gop gos gov net org web ",pl:" art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",pr:" ac biz com edu est gov info isla name net org pro prof ",ps:" com edu gov net org plo sec ",pw:" belau co ed go ne or ",ro:" arts com firm info nom nt org rec store tm www ",rs:" ac co edu gov in org ",sb:" com edu gov net org ",sc:" com edu gov net org ",sh:" co com edu gov net nom org ",sl:" com edu gov net org ",st:" co com consulado edu embaixada gov mil net org principe saotome store ",sv:" com edu gob org red ",sz:" ac co org ",tr:" av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",tt:" aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",tw:" club com ebiz edu game gov idv mil net org ",mu:" ac co com gov net or org ",mz:" ac co edu gov org ",na:" co com ",nz:" ac co cri geek gen govt health iwi maori mil net org parliament school ",pa:" abo ac com edu gob ing med net nom org sld ",pt:" com edu gov int net nome org publ ",py:" com edu gov mil net org ",qa:" com edu gov mil net org ",re:" asso com nom ",ru:" ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",rw:" ac co com edu gouv gov int mil net ",sa:" com edu gov med net org pub sch ",sd:" com edu gov info med net org tv ",se:" a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",sg:" com edu gov idn net org per ",sn:" art com edu gouv org perso univ ",sy:" com edu gov mil net news org ",th:" ac co go in mi net or ",tj:" ac biz co com edu go gov info int mil name net nic org test web ",tn:" agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",tz:" ac co go ne or ",ua:" biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",ug:" ac co go ne or org sc ",uk:" ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",us:" dni fed isa kids nsn ",uy:" com edu gub mil net org ",ve:" co com edu gob info mil net org web ",vi:" co com k12 net org ",vn:" ac biz com edu gov health info int name net org pro ",ye:" co com gov ltd me net org plc ",yu:" ac co edu gov org ",za:" ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",zm:" ac co com edu gov net org sch "},has:function(e){var t=e.lastIndexOf(".");if(t<=0||t>=e.length-1){return false}var n=e.lastIndexOf(".",t-1);if(n<=0||n>=t-1){return false}var i=r.list[e.slice(t+1)];if(!i){return false}return i.indexOf(" "+e.slice(n+1,t)+" ")>=0},is:function(e){var t=e.lastIndexOf(".");if(t<=0||t>=e.length-1){return false}var n=e.lastIndexOf(".",t-1);if(n>=0){return false}var i=r.list[e.slice(t+1)];if(!i){return false}return i.indexOf(" "+e.slice(0,t)+" ")>=0},get:function(e){var t=e.lastIndexOf(".");if(t<=0||t>=e.length-1){return null}var n=e.lastIndexOf(".",t-1);if(n<=0||n>=t-1){return null}var i=r.list[e.slice(t+1)];if(!i){return null}if(i.indexOf(" "+e.slice(n+1,t)+" ")<0){return null}return e.slice(n+1)},noConflict:function(){if(e.SecondLevelDomains===this){e.SecondLevelDomains=t}return this}};return r})})();(function(){var i=e.amdDefine;(function(e,a){"use strict";if(typeof r==="object"){n.exports=a(t("./punycode"),t("./IPv6"),t("./SecondLevelDomains"))}else if(typeof i==="function"&&i.amd){i("7",["4","5","6"],a)}else{e.URI=a(e.punycode,e.IPv6,e.SecondLevelDomains,e)}})(this,function(e,t,r,n){"use strict";var i=n&&n.URI;function a(e,t){var r=arguments.length>=1;var n=arguments.length>=2;if(!(this instanceof a)){if(r){if(n){return new a(e,t)}return new a(e)}return new a}if(e===undefined){if(r){throw new TypeError("undefined is not a valid argument for URI")}if(typeof location!=="undefined"){e=location.href+""}else{e=""}}this.href(e);if(t!==undefined){return this.absoluteTo(t)}return this}a.version="1.18.1";var o=a.prototype;var s=Object.prototype.hasOwnProperty;function u(e){return e.replace(/([.*+?^=!:${}()|[\]\/\\])/g,"\\$1")}function f(e){if(e===undefined){return"Undefined"}return String(Object.prototype.toString.call(e)).slice(8,-1)}function c(e){return f(e)==="Array"}function l(e,t){var r={};var n,i;if(f(t)==="RegExp"){r=null}else if(c(t)){for(n=0,i=t.length;n<i;n++){r[t[n]]=true}}else{r[t]=true}for(n=0,i=e.length;n<i;n++){var a=r&&r[e[n]]!==undefined||!r&&t.test(e[n]);if(a){e.splice(n,1);i--;n--}}return e}function d(e,t){var r,n;if(c(t)){for(r=0,n=t.length;r<n;r++){if(!d(e,t[r])){return false}}return true}var i=f(t);for(r=0,n=e.length;r<n;r++){if(i==="RegExp"){if(typeof e[r]==="string"&&e[r].match(t)){return true}}else if(e[r]===t){return true}}return false}function h(e,t){if(!c(e)||!c(t)){return false}if(e.length!==t.length){return false}e.sort();t.sort();for(var r=0,n=e.length;r<n;r++){if(e[r]!==t[r]){return false}}return true}function v(e){var t=/^\/+|\/+$/g;return e.replace(t,"")}a._parts=function(){return{protocol:null,username:null,password:null,hostname:null,urn:null,port:null,path:null,query:null,fragment:null,duplicateQueryParameters:a.duplicateQueryParameters,escapeQuerySpace:a.escapeQuerySpace}};a.duplicateQueryParameters=false;a.escapeQuerySpace=true;a.protocol_expression=/^[a-z][a-z0-9.+-]*$/i;a.idn_expression=/[^a-z0-9\.-]/i;a.punycode_expression=/(xn--)/i;a.ip4_expression=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;a.ip6_expression=/^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;a.find_uri_expression=/\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/gi;a.findUri={start:/\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,end:/[\s\r\n]|$/,trim:/[`!()\[\]{};:'".,<>?«»“”„‘’]+$/};a.defaultPorts={http:"80",https:"443",ftp:"21",gopher:"70",ws:"80",wss:"443"};a.invalid_hostname_characters=/[^a-zA-Z0-9\.-]/;a.domAttributes={a:"href",blockquote:"cite",link:"href",base:"href",script:"src",form:"action",img:"src",area:"href",iframe:"src",embed:"src",source:"src",track:"src",input:"src",audio:"src",video:"src"};a.getDomAttribute=function(e){if(!e||!e.nodeName){return undefined}var t=e.nodeName.toLowerCase();if(t==="input"&&e.type!=="image"){return undefined}return a.domAttributes[t]};function p(e){return escape(e)}function m(e){return encodeURIComponent(e).replace(/[!'()*]/g,p).replace(/\*/g,"%2A")}a.encode=m;a.decode=decodeURIComponent;a.iso8859=function(){a.encode=escape;a.decode=unescape};a.unicode=function(){a.encode=m;a.decode=decodeURIComponent};a.characters={pathname:{encode:{expression:/%(24|26|2B|2C|3B|3D|3A|40)/gi,map:{"%24":"$","%26":"&","%2B":"+","%2C":",","%3B":";","%3D":"=","%3A":":","%40":"@"}},decode:{expression:/[\/\?#]/g,map:{"/":"%2F","?":"%3F","#":"%23"}}},reserved:{encode:{expression:/%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/gi,map:{"%3A":":","%2F":"/","%3F":"?","%23":"#","%5B":"[","%5D":"]","%40":"@","%21":"!","%24":"$","%26":"&","%27":"'","%28":"(","%29":")","%2A":"*","%2B":"+","%2C":",","%3B":";","%3D":"="}}},urnpath:{encode:{expression:/%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/gi,map:{"%21":"!","%24":"$","%27":"'","%28":"(","%29":")","%2A":"*","%2B":"+","%2C":",","%3B":";","%3D":"=","%40":"@"}},decode:{expression:/[\/\?#:]/g,map:{"/":"%2F","?":"%3F","#":"%23",":":"%3A"}}}};a.encodeQuery=function(e,t){var r=a.encode(e+"");if(t===undefined){t=a.escapeQuerySpace}return t?r.replace(/%20/g,"+"):r};a.decodeQuery=function(e,t){e+="";if(t===undefined){t=a.escapeQuerySpace}try{return a.decode(t?e.replace(/\+/g,"%20"):e)}catch(t){return e}};var w={encode:"encode",decode:"decode"};var y;var g=function(e,t){return function(r){try{return a[t](r+"").replace(a.characters[e][t].expression,function(r){return a.characters[e][t].map[r]})}catch(e){return r}}};for(y in w){a[y+"PathSegment"]=g("pathname",w[y]);a[y+"UrnPathSegment"]=g("urnpath",w[y])}var S=function(e,t,r){return function(n){var i;if(!r){i=a[t]}else{i=function(e){return a[t](a[r](e))}}var o=(n+"").split(e);for(var s=0,u=o.length;s<u;s++){o[s]=i(o[s])}return o.join(e)}};a.decodePath=S("/","decodePathSegment");a.decodeUrnPath=S(":","decodeUrnPathSegment");a.recodePath=S("/","encodePathSegment","decode");a.recodeUrnPath=S(":","encodeUrnPathSegment","decode");a.encodeReserved=g("reserved","encode");a.parse=function(e,t){var r;if(!t){t={}}r=e.indexOf("#");if(r>-1){t.fragment=e.substring(r+1)||null;e=e.substring(0,r)}r=e.indexOf("?");if(r>-1){t.query=e.substring(r+1)||null;e=e.substring(0,r)}if(e.substring(0,2)==="//"){t.protocol=null;e=e.substring(2);e=a.parseAuthority(e,t)}else{r=e.indexOf(":");if(r>-1){t.protocol=e.substring(0,r)||null;if(t.protocol&&!t.protocol.match(a.protocol_expression)){t.protocol=undefined}else if(e.substring(r+1,r+3)==="//"){e=e.substring(r+3);e=a.parseAuthority(e,t)}else{e=e.substring(r+1);t.urn=true}}}t.path=e;return t};a.parseHost=function(e,t){e=e.replace(/\\/g,"/");var r=e.indexOf("/");var n;var i;if(r===-1){r=e.length}if(e.charAt(0)==="["){n=e.indexOf("]");t.hostname=e.substring(1,n)||null;t.port=e.substring(n+2,r)||null;if(t.port==="/"){t.port=null}}else{var a=e.indexOf(":");var o=e.indexOf("/");var s=e.indexOf(":",a+1);if(s!==-1&&(o===-1||s<o)){t.hostname=e.substring(0,r)||null;t.port=null}else{i=e.substring(0,r).split(":");t.hostname=i[0]||null;t.port=i[1]||null}}if(t.hostname&&e.substring(r).charAt(0)!=="/"){r++;e="/"+e}return e.substring(r)||"/"};a.parseAuthority=function(e,t){e=a.parseUserinfo(e,t);return a.parseHost(e,t)};a.parseUserinfo=function(e,t){var r=e.indexOf("/");var n=e.lastIndexOf("@",r>-1?r:e.length-1);var i;if(n>-1&&(r===-1||n<r)){i=e.substring(0,n).split(":");
	t.username=i[0]?a.decode(i[0]):null;i.shift();t.password=i[0]?a.decode(i.join(":")):null;e=e.substring(n+1)}else{t.username=null;t.password=null}return e};a.parseQuery=function(e,t){if(!e){return{}}e=e.replace(/&+/g,"&").replace(/^\?*&*|&+$/g,"");if(!e){return{}}var r={};var n=e.split("&");var i=n.length;var o,u,f;for(var c=0;c<i;c++){o=n[c].split("=");u=a.decodeQuery(o.shift(),t);f=o.length?a.decodeQuery(o.join("="),t):null;if(s.call(r,u)){if(typeof r[u]==="string"||r[u]===null){r[u]=[r[u]]}r[u].push(f)}else{r[u]=f}}return r};a.build=function(e){var t="";if(e.protocol){t+=e.protocol+":"}if(!e.urn&&(t||e.hostname)){t+="//"}t+=a.buildAuthority(e)||"";if(typeof e.path==="string"){if(e.path.charAt(0)!=="/"&&typeof e.hostname==="string"){t+="/"}t+=e.path}if(typeof e.query==="string"&&e.query){t+="?"+e.query}if(typeof e.fragment==="string"&&e.fragment){t+="#"+e.fragment}return t};a.buildHost=function(e){var t="";if(!e.hostname){return""}else if(a.ip6_expression.test(e.hostname)){t+="["+e.hostname+"]"}else{t+=e.hostname}if(e.port){t+=":"+e.port}return t};a.buildAuthority=function(e){return a.buildUserinfo(e)+a.buildHost(e)};a.buildUserinfo=function(e){var t="";if(e.username){t+=a.encode(e.username)}if(e.password){t+=":"+a.encode(e.password)}if(t){t+="@"}return t};a.buildQuery=function(e,t,r){var n="";var i,o,u,f;for(o in e){if(s.call(e,o)&&o){if(c(e[o])){i={};for(u=0,f=e[o].length;u<f;u++){if(e[o][u]!==undefined&&i[e[o][u]+""]===undefined){n+="&"+a.buildQueryParameter(o,e[o][u],r);if(t!==true){i[e[o][u]+""]=true}}}}else if(e[o]!==undefined){n+="&"+a.buildQueryParameter(o,e[o],r)}}}return n.substring(1)};a.buildQueryParameter=function(e,t,r){return a.encodeQuery(e,r)+(t!==null?"="+a.encodeQuery(t,r):"")};a.addQuery=function(e,t,r){if(typeof t==="object"){for(var n in t){if(s.call(t,n)){a.addQuery(e,n,t[n])}}}else if(typeof t==="string"){if(e[t]===undefined){e[t]=r;return}else if(typeof e[t]==="string"){e[t]=[e[t]]}if(!c(r)){r=[r]}e[t]=(e[t]||[]).concat(r)}else{throw new TypeError("URI.addQuery() accepts an object, string as the name parameter")}};a.removeQuery=function(e,t,r){var n,i,o;if(c(t)){for(n=0,i=t.length;n<i;n++){e[t[n]]=undefined}}else if(f(t)==="RegExp"){for(o in e){if(t.test(o)){e[o]=undefined}}}else if(typeof t==="object"){for(o in t){if(s.call(t,o)){a.removeQuery(e,o,t[o])}}}else if(typeof t==="string"){if(r!==undefined){if(f(r)==="RegExp"){if(!c(e[t])&&r.test(e[t])){e[t]=undefined}else{e[t]=l(e[t],r)}}else if(e[t]===String(r)&&(!c(r)||r.length===1)){e[t]=undefined}else if(c(e[t])){e[t]=l(e[t],r)}}else{e[t]=undefined}}else{throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter")}};a.hasQuery=function(e,t,r,n){switch(f(t)){case"String":break;case"RegExp":for(var i in e){if(s.call(e,i)){if(t.test(i)&&(r===undefined||a.hasQuery(e,i,r))){return true}}}return false;case"Object":for(var o in t){if(s.call(t,o)){if(!a.hasQuery(e,o,t[o])){return false}}}return true;default:throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter")}switch(f(r)){case"Undefined":return t in e;case"Boolean":var u=Boolean(c(e[t])?e[t].length:e[t]);return r===u;case"Function":return!!r(e[t],t,e);case"Array":if(!c(e[t])){return false}var l=n?d:h;return l(e[t],r);case"RegExp":if(!c(e[t])){return Boolean(e[t]&&e[t].match(r))}if(!n){return false}return d(e[t],r);case"Number":r=String(r);case"String":if(!c(e[t])){return e[t]===r}if(!n){return false}return d(e[t],r);default:throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter")}};a.joinPaths=function(){var e=[];var t=[];var r=0;for(var n=0;n<arguments.length;n++){var i=new a(arguments[n]);e.push(i);var o=i.segment();for(var s=0;s<o.length;s++){if(typeof o[s]==="string"){t.push(o[s])}if(o[s]){r++}}}if(!t.length||!r){return new a("")}var u=new a("").segment(t);if(e[0].path()===""||e[0].path().slice(0,1)==="/"){u.path("/"+u.path())}return u.normalize()};a.commonPath=function(e,t){var r=Math.min(e.length,t.length);var n;for(n=0;n<r;n++){if(e.charAt(n)!==t.charAt(n)){n--;break}}if(n<1){return e.charAt(0)===t.charAt(0)&&e.charAt(0)==="/"?"/":""}if(e.charAt(n)!=="/"||t.charAt(n)!=="/"){n=e.substring(0,n).lastIndexOf("/")}return e.substring(0,n+1)};a.withinString=function(e,t,r){r||(r={});var n=r.start||a.findUri.start;var i=r.end||a.findUri.end;var o=r.trim||a.findUri.trim;var s=/[a-z0-9-]=["']?$/i;n.lastIndex=0;while(true){var u=n.exec(e);if(!u){break}var f=u.index;if(r.ignoreHtml){var c=e.slice(Math.max(f-3,0),f);if(c&&s.test(c)){continue}}var l=f+e.slice(f).search(i);var d=e.slice(f,l).replace(o,"");if(r.ignore&&r.ignore.test(d)){continue}l=f+d.length;var h=t(d,f,l,e);e=e.slice(0,f)+h+e.slice(l);n.lastIndex=f+h.length}n.lastIndex=0;return e};a.ensureValidHostname=function(t){if(t.match(a.invalid_hostname_characters)){if(!e){throw new TypeError('Hostname "'+t+'" contains characters other than [A-Z0-9.-] and Punycode.js is not available')}if(e.toASCII(t).match(a.invalid_hostname_characters)){throw new TypeError('Hostname "'+t+'" contains characters other than [A-Z0-9.-]')}}};a.noConflict=function(e){if(e){var t={URI:this.noConflict()};if(n.URITemplate&&typeof n.URITemplate.noConflict==="function"){t.URITemplate=n.URITemplate.noConflict()}if(n.IPv6&&typeof n.IPv6.noConflict==="function"){t.IPv6=n.IPv6.noConflict()}if(n.SecondLevelDomains&&typeof n.SecondLevelDomains.noConflict==="function"){t.SecondLevelDomains=n.SecondLevelDomains.noConflict()}return t}else if(n.URI===this){n.URI=i}return this};o.build=function(e){if(e===true){this._deferred_build=true}else if(e===undefined||this._deferred_build){this._string=a.build(this._parts);this._deferred_build=false}return this};o.clone=function(){return new a(this)};o.valueOf=o.toString=function(){return this.build(false)._string};function b(e){return function(t,r){if(t===undefined){return this._parts[e]||""}else{this._parts[e]=t||null;this.build(!r);return this}}}function T(e,t){return function(r,n){if(r===undefined){return this._parts[e]||""}else{if(r!==null){r=r+"";if(r.charAt(0)===t){r=r.substring(1)}}this._parts[e]=r;this.build(!n);return this}}}o.protocol=b("protocol");o.username=b("username");o.password=b("password");o.hostname=b("hostname");o.port=b("port");o.query=T("query","?");o.fragment=T("fragment","#");o.search=function(e,t){var r=this.query(e,t);return typeof r==="string"&&r.length?"?"+r:r};o.hash=function(e,t){var r=this.fragment(e,t);return typeof r==="string"&&r.length?"#"+r:r};o.pathname=function(e,t){if(e===undefined||e===true){var r=this._parts.path||(this._parts.hostname?"/":"");return e?(this._parts.urn?a.decodeUrnPath:a.decodePath)(r):r}else{if(this._parts.urn){this._parts.path=e?a.recodeUrnPath(e):""}else{this._parts.path=e?a.recodePath(e):"/"}this.build(!t);return this}};o.path=o.pathname;o.href=function(e,t){var r;if(e===undefined){return this.toString()}this._string="";this._parts=a._parts();var n=e instanceof a;var i=typeof e==="object"&&(e.hostname||e.path||e.pathname);if(e.nodeName){var o=a.getDomAttribute(e);e=e[o]||"";i=false}if(!n&&i&&e.pathname!==undefined){e=e.toString()}if(typeof e==="string"||e instanceof String){this._parts=a.parse(String(e),this._parts)}else if(n||i){var u=n?e._parts:e;for(r in u){if(s.call(this._parts,r)){this._parts[r]=u[r]}}}else{throw new TypeError("invalid input")}this.build(!t);return this};o.is=function(e){var t=false;var n=false;var i=false;var o=false;var s=false;var u=false;var f=false;var c=!this._parts.urn;if(this._parts.hostname){c=false;n=a.ip4_expression.test(this._parts.hostname);i=a.ip6_expression.test(this._parts.hostname);t=n||i;o=!t;s=o&&r&&r.has(this._parts.hostname);u=o&&a.idn_expression.test(this._parts.hostname);f=o&&a.punycode_expression.test(this._parts.hostname)}switch(e.toLowerCase()){case"relative":return c;case"absolute":return!c;case"domain":case"name":return o;case"sld":return s;case"ip":return t;case"ip4":case"ipv4":case"inet4":return n;case"ip6":case"ipv6":case"inet6":return i;case"idn":return u;case"url":return!this._parts.urn;case"urn":return!!this._parts.urn;case"punycode":return f}return null};var _=o.protocol;var E=o.port;var M=o.hostname;o.protocol=function(e,t){if(e!==undefined){if(e){e=e.replace(/:(\/\/)?$/,"");if(!e.match(a.protocol_expression)){throw new TypeError('Protocol "'+e+"\" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]")}}}return _.call(this,e,t)};o.scheme=o.protocol;o.port=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e!==undefined){if(e===0){e=null}if(e){e+="";if(e.charAt(0)===":"){e=e.substring(1)}if(e.match(/[^0-9]/)){throw new TypeError('Port "'+e+'" contains characters other than [0-9]')}}}return E.call(this,e,t)};o.hostname=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e!==undefined){var r={};var n=a.parseHost(e,r);if(n!=="/"){throw new TypeError('Hostname "'+e+'" contains characters other than [A-Z0-9.-]')}e=r.hostname}return M.call(this,e,t)};o.origin=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e===undefined){var r=this.protocol();var n=this.authority();if(!n){return""}return(r?r+"://":"")+this.authority()}else{var i=a(e);this.protocol(i.protocol()).authority(i.authority()).build(!t);return this}};o.host=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e===undefined){return this._parts.hostname?a.buildHost(this._parts):""}else{var r=a.parseHost(e,this._parts);if(r!=="/"){throw new TypeError('Hostname "'+e+'" contains characters other than [A-Z0-9.-]')}this.build(!t);return this}};o.authority=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e===undefined){return this._parts.hostname?a.buildAuthority(this._parts):""}else{var r=a.parseAuthority(e,this._parts);if(r!=="/"){throw new TypeError('Hostname "'+e+'" contains characters other than [A-Z0-9.-]')}this.build(!t);return this}};o.userinfo=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e===undefined){var r=a.buildUserinfo(this._parts);return r?r.substring(0,r.length-1):r}else{if(e[e.length-1]!=="@"){e+="@"}a.parseUserinfo(e,this._parts);this.build(!t);return this}};o.resource=function(e,t){var r;if(e===undefined){return this.path()+this.search()+this.hash()}r=a.parse(e);this._parts.path=r.path;this._parts.query=r.query;this._parts.fragment=r.fragment;this.build(!t);return this};o.subdomain=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e===undefined){if(!this._parts.hostname||this.is("IP")){return""}var r=this._parts.hostname.length-this.domain().length-1;return this._parts.hostname.substring(0,r)||""}else{var n=this._parts.hostname.length-this.domain().length;var i=this._parts.hostname.substring(0,n);var o=new RegExp("^"+u(i));if(e&&e.charAt(e.length-1)!=="."){e+="."}if(e){a.ensureValidHostname(e)}this._parts.hostname=this._parts.hostname.replace(o,e);this.build(!t);return this}};o.domain=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(typeof e==="boolean"){t=e;e=undefined}if(e===undefined){if(!this._parts.hostname||this.is("IP")){return""}var r=this._parts.hostname.match(/\./g);if(r&&r.length<2){return this._parts.hostname}var n=this._parts.hostname.length-this.tld(t).length-1;n=this._parts.hostname.lastIndexOf(".",n-1)+1;return this._parts.hostname.substring(n)||""}else{if(!e){throw new TypeError("cannot set domain empty")}a.ensureValidHostname(e);if(!this._parts.hostname||this.is("IP")){this._parts.hostname=e}else{var i=new RegExp(u(this.domain())+"$");this._parts.hostname=this._parts.hostname.replace(i,e)}this.build(!t);return this}};o.tld=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(typeof e==="boolean"){t=e;e=undefined}if(e===undefined){if(!this._parts.hostname||this.is("IP")){return""}var n=this._parts.hostname.lastIndexOf(".");var i=this._parts.hostname.substring(n+1);if(t!==true&&r&&r.list[i.toLowerCase()]){return r.get(this._parts.hostname)||i}return i}else{var a;if(!e){throw new TypeError("cannot set TLD empty")}else if(e.match(/[^a-zA-Z0-9-]/)){if(r&&r.is(e)){a=new RegExp(u(this.tld())+"$");this._parts.hostname=this._parts.hostname.replace(a,e)}else{throw new TypeError('TLD "'+e+'" contains characters other than [A-Z0-9]')}}else if(!this._parts.hostname||this.is("IP")){throw new ReferenceError("cannot set TLD on non-domain host")}else{a=new RegExp(u(this.tld())+"$");this._parts.hostname=this._parts.hostname.replace(a,e)}this.build(!t);return this}};o.directory=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e===undefined||e===true){if(!this._parts.path&&!this._parts.hostname){return""}if(this._parts.path==="/"){return"/"}var r=this._parts.path.length-this.filename().length-1;var n=this._parts.path.substring(0,r)||(this._parts.hostname?"/":"");return e?a.decodePath(n):n}else{var i=this._parts.path.length-this.filename().length;var o=this._parts.path.substring(0,i);var s=new RegExp("^"+u(o));if(!this.is("relative")){if(!e){e="/"}if(e.charAt(0)!=="/"){e="/"+e}}if(e&&e.charAt(e.length-1)!=="/"){e+="/"}e=a.recodePath(e);this._parts.path=this._parts.path.replace(s,e);this.build(!t);return this}};o.filename=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e===undefined||e===true){if(!this._parts.path||this._parts.path==="/"){return""}var r=this._parts.path.lastIndexOf("/");var n=this._parts.path.substring(r+1);return e?a.decodePathSegment(n):n}else{var i=false;if(e.charAt(0)==="/"){e=e.substring(1)}if(e.match(/\.?\//)){i=true}var o=new RegExp(u(this.filename())+"$");e=a.recodePath(e);this._parts.path=this._parts.path.replace(o,e);if(i){this.normalizePath(t)}else{this.build(!t)}return this}};o.suffix=function(e,t){if(this._parts.urn){return e===undefined?"":this}if(e===undefined||e===true){if(!this._parts.path||this._parts.path==="/"){return""}var r=this.filename();var n=r.lastIndexOf(".");var i,o;if(n===-1){return""}i=r.substring(n+1);o=/^[a-z0-9%]+$/i.test(i)?i:"";return e?a.decodePathSegment(o):o}else{if(e.charAt(0)==="."){e=e.substring(1)}var s=this.suffix();var f;if(!s){if(!e){return this}this._parts.path+="."+a.recodePath(e)}else if(!e){f=new RegExp(u("."+s)+"$")}else{f=new RegExp(u(s)+"$")}if(f){e=a.recodePath(e);this._parts.path=this._parts.path.replace(f,e)}this.build(!t);return this}};o.segment=function(e,t,r){var n=this._parts.urn?":":"/";var i=this.path();var a=i.substring(0,1)==="/";var o=i.split(n);if(e!==undefined&&typeof e!=="number"){r=t;t=e;e=undefined}if(e!==undefined&&typeof e!=="number"){throw new Error('Bad segment "'+e+'", must be 0-based integer')}if(a){o.shift()}if(e<0){e=Math.max(o.length+e,0)}if(t===undefined){return e===undefined?o:o[e]}else if(e===null||o[e]===undefined){if(c(t)){o=[];for(var s=0,u=t.length;s<u;s++){if(!t[s].length&&(!o.length||!o[o.length-1].length)){continue}if(o.length&&!o[o.length-1].length){o.pop()}o.push(v(t[s]))}}else if(t||typeof t==="string"){t=v(t);if(o[o.length-1]===""){o[o.length-1]=t}else{o.push(t)}}}else{if(t){o[e]=v(t)}else{o.splice(e,1)}}if(a){o.unshift("")}return this.path(o.join(n),r)};o.segmentCoded=function(e,t,r){var n,i,o;if(typeof e!=="number"){r=t;t=e;e=undefined}if(t===undefined){n=this.segment(e,t,r);if(!c(n)){n=n!==undefined?a.decode(n):undefined}else{for(i=0,o=n.length;i<o;i++){n[i]=a.decode(n[i])}}return n}if(!c(t)){t=typeof t==="string"||t instanceof String?a.encode(t):t}else{for(i=0,o=t.length;i<o;i++){t[i]=a.encode(t[i])}}return this.segment(e,t,r)};var P=o.query;o.query=function(e,t){if(e===true){return a.parseQuery(this._parts.query,this._parts.escapeQuerySpace)}else if(typeof e==="function"){var r=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);var n=e.call(this,r);this._parts.query=a.buildQuery(n||r,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace);this.build(!t);return this}else if(e!==undefined&&typeof e!=="string"){this._parts.query=a.buildQuery(e,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace);this.build(!t);return this}else{return P.call(this,e,t)}};o.setQuery=function(e,t,r){var n=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);if(typeof e==="string"||e instanceof String){n[e]=t!==undefined?t:null}else if(typeof e==="object"){for(var i in e){if(s.call(e,i)){n[i]=e[i]}}}else{throw new TypeError("URI.addQuery() accepts an object, string as the name parameter")}this._parts.query=a.buildQuery(n,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace);if(typeof e!=="string"){r=t}this.build(!r);return this};o.addQuery=function(e,t,r){var n=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);a.addQuery(n,e,t===undefined?null:t);this._parts.query=a.buildQuery(n,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace);if(typeof e!=="string"){r=t}this.build(!r);return this};o.removeQuery=function(e,t,r){var n=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);a.removeQuery(n,e,t);this._parts.query=a.buildQuery(n,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace);if(typeof e!=="string"){r=t}this.build(!r);return this};o.hasQuery=function(e,t,r){var n=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);return a.hasQuery(n,e,t,r)};o.setSearch=o.setQuery;o.addSearch=o.addQuery;o.removeSearch=o.removeQuery;o.hasSearch=o.hasQuery;o.normalize=function(){if(this._parts.urn){return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build()}return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build()};o.normalizeProtocol=function(e){if(typeof this._parts.protocol==="string"){this._parts.protocol=this._parts.protocol.toLowerCase();this.build(!e)}return this};o.normalizeHostname=function(r){if(this._parts.hostname){if(this.is("IDN")&&e){this._parts.hostname=e.toASCII(this._parts.hostname)}else if(this.is("IPv6")&&t){this._parts.hostname=t.best(this._parts.hostname)}this._parts.hostname=this._parts.hostname.toLowerCase();this.build(!r)}return this};o.normalizePort=function(e){if(typeof this._parts.protocol==="string"&&this._parts.port===a.defaultPorts[this._parts.protocol]){this._parts.port=null;this.build(!e)}return this};o.normalizePath=function(e){var t=this._parts.path;if(!t){return this}if(this._parts.urn){this._parts.path=a.recodeUrnPath(this._parts.path);this.build(!e);return this}if(this._parts.path==="/"){return this}t=a.recodePath(t);var r;var n="";var i,o;if(t.charAt(0)!=="/"){r=true;t="/"+t}if(t.slice(-3)==="/.."||t.slice(-2)==="/."){t+="/"}t=t.replace(/(\/(\.\/)+)|(\/\.$)/g,"/").replace(/\/{2,}/g,"/");if(r){n=t.substring(1).match(/^(\.\.\/)+/)||"";if(n){n=n[0]}}while(true){i=t.search(/\/\.\.(\/|$)/);if(i===-1){break}else if(i===0){t=t.substring(3);continue}o=t.substring(0,i).lastIndexOf("/");if(o===-1){o=i}t=t.substring(0,o)+t.substring(i+3)}if(r&&this.is("relative")){t=n+t.substring(1)}this._parts.path=t;this.build(!e);return this};o.normalizePathname=o.normalizePath;o.normalizeQuery=function(e){if(typeof this._parts.query==="string"){if(!this._parts.query.length){this._parts.query=null}else{this.query(a.parseQuery(this._parts.query,this._parts.escapeQuerySpace))}this.build(!e)}return this};o.normalizeFragment=function(e){if(!this._parts.fragment){this._parts.fragment=null;this.build(!e)}return this};o.normalizeSearch=o.normalizeQuery;o.normalizeHash=o.normalizeFragment;o.iso8859=function(){var e=a.encode;var t=a.decode;a.encode=escape;a.decode=decodeURIComponent;try{this.normalize()}finally{a.encode=e;a.decode=t}return this};o.unicode=function(){var e=a.encode;var t=a.decode;a.encode=m;a.decode=unescape;try{this.normalize()}finally{a.encode=e;a.decode=t}return this};o.readable=function(){var t=this.clone();t.username("").password("").normalize();var r="";if(t._parts.protocol){r+=t._parts.protocol+"://"}if(t._parts.hostname){if(t.is("punycode")&&e){r+=e.toUnicode(t._parts.hostname);if(t._parts.port){r+=":"+t._parts.port}}else{r+=t.host()}}if(t._parts.hostname&&t._parts.path&&t._parts.path.charAt(0)!=="/"){r+="/"}r+=t.path(true);if(t._parts.query){var n="";for(var i=0,o=t._parts.query.split("&"),s=o.length;i<s;i++){var u=(o[i]||"").split("=");n+="&"+a.decodeQuery(u[0],this._parts.escapeQuerySpace).replace(/&/g,"%26");if(u[1]!==undefined){n+="="+a.decodeQuery(u[1],this._parts.escapeQuerySpace).replace(/&/g,"%26")}}r+="?"+n.substring(1)}r+=a.decodeQuery(t.hash(),true);return r};o.absoluteTo=function(e){var t=this.clone();var r=["protocol","username","password","hostname","port"];var n,i,o;if(this._parts.urn){throw new Error("URNs do not have any generally defined hierarchical components")}if(!(e instanceof a)){e=new a(e)}if(!t._parts.protocol){t._parts.protocol=e._parts.protocol}if(this._parts.hostname){return t}for(i=0;o=r[i];i++){t._parts[o]=e._parts[o]}if(!t._parts.path){t._parts.path=e._parts.path;if(!t._parts.query){t._parts.query=e._parts.query}}else if(t._parts.path.substring(-2)===".."){t._parts.path+="/"}if(t.path().charAt(0)!=="/"){n=e.directory();n=n?n:e.path().indexOf("/")===0?"/":"";t._parts.path=(n?n+"/":"")+t._parts.path;t.normalizePath()}t.build();return t};o.relativeTo=function(e){var t=this.clone().normalize();var r,n,i,o,s;if(t._parts.urn){throw new Error("URNs do not have any generally defined hierarchical components")}e=new a(e).normalize();r=t._parts;n=e._parts;o=t.path();s=e.path();if(o.charAt(0)!=="/"){throw new Error("URI is already relative")}if(s.charAt(0)!=="/"){throw new Error("Cannot calculate a URI relative to another relative URI")}if(r.protocol===n.protocol){r.protocol=null}if(r.username!==n.username||r.password!==n.password){return t.build()}if(r.protocol!==null||r.username!==null||r.password!==null){return t.build()}if(r.hostname===n.hostname&&r.port===n.port){r.hostname=null;r.port=null}else{return t.build()}if(o===s){r.path="";return t.build()}i=a.commonPath(o,s);if(!i){return t.build()}var u=n.path.substring(i.length).replace(/[^\/]*$/,"").replace(/.*?\//g,"../");r.path=u+r.path.substring(i.length)||"./";return t.build()};o.equals=function(e){var t=this.clone();var r=new a(e);var n={};var i={};var o={};var u,f,l;t.normalize();r.normalize();if(t.toString()===r.toString()){return true}u=t.query();f=r.query();t.query("");r.query("");if(t.toString()!==r.toString()){return false}if(u.length!==f.length){return false}n=a.parseQuery(u,this._parts.escapeQuerySpace);i=a.parseQuery(f,this._parts.escapeQuerySpace);for(l in n){if(s.call(n,l)){if(!c(n[l])){if(n[l]!==i[l]){return false}}else if(!h(n[l],i[l])){return false}o[l]=true}}for(l in i){if(s.call(i,l)){if(!o[l]){return false}}}return true};o.duplicateQueryParameters=function(e){this._parts.duplicateQueryParameters=!!e;return this};o.escapeQuerySpace=function(e){this._parts.escapeQuerySpace=!!e;return this};return a})})();e.registerDynamic("8",[],true,function(e,t,r){var n,i=this||self,a=i;(function(e,t){e(function(){"use strict";var e={};e.mobileDetectRules={phones:{iPhone:"\\biPhone\\b|\\biPod\\b",BlackBerry:"BlackBerry|\\bBB10\\b|rim[0-9]+",HTC:"HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m",Nexus:"Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",Dell:"Dell.*Streak|Dell.*Aero|Dell.*Venue|DELL.*Venue Pro|Dell Flash|Dell Smoke|Dell Mini 3iX|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",Motorola:"Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b",Samsung:"Samsung|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350",LG:"\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323)",Sony:"SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",Asus:"Asus.*Galaxy|PadFone.*Mobile",Micromax:"Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",Palm:"PalmSource|Palm",Vertu:"Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",Pantech:"PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",Fly:"IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",Wiko:"KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",iMobile:"i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",SimValley:"\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",Wolfgang:"AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",Alcatel:"Alcatel",Nintendo:"Nintendo 3DS",Amoi:"Amoi",INQ:"INQ",GenericPhone:"Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"},tablets:{iPad:"iPad|iPad.*Mobile",NexusTablet:"Android.*Nexus[\\s]+(7|9|10)",SamsungTablet:"SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561",
	Kindle:"Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI)\\b",SurfaceTablet:"Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",HPTablet:"HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",AsusTablet:"^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K017 |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C",BlackBerryTablet:"PlayBook|RIM Tablet",HTCtablet:"HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",MotorolaTablet:"xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",NookTablet:"Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",AcerTablet:"Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b",ToshibaTablet:"Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",LGTablet:"\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",FujitsuTablet:"Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",PrestigioTablet:"PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",LenovoTablet:"Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)",DellTablet:"Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",YarvikTablet:"Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",MedionTablet:"Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",ArnovaTablet:"AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",IntensoTablet:"INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",IRUTablet:"M702pro",MegafonTablet:"MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",EbodaTablet:"E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",AllViewTablet:"Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",ArchosTablet:"\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",AinolTablet:"NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",SonyTablet:"Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP612|SOT31",PhilipsTablet:"\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",CubeTablet:"Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",CobyTablet:"MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",MIDTablet:"M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",MSITablet:"MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",SMiTTablet:"Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",RockChipTablet:"Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",FlyTablet:"IQ310|Fly Vision",bqTablet:"Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris E10)|Maxwell.*Lite|Maxwell.*Plus",HuaweiTablet:"MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim",NecTablet:"\\bN-06D|\\bN-08D",PantechTablet:"Pantech.*P4100",BronchoTablet:"Broncho.*(N701|N708|N802|a710)",VersusTablet:"TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",ZyncTablet:"z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900",PositivoTablet:"TB07STA|TB10STA|TB07FTA|TB10FTA",NabiTablet:"Android.*\\bNabi",KoboTablet:"Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",DanewTablet:"DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",TexetTablet:"NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",PlaystationTablet:"Playstation.*(Portable|Vita)",TrekstorTablet:"ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",PyleAudioTablet:"\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",AdvanTablet:"Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",DanyTechTablet:"Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",GalapadTablet:"Android.*\\bG1\\b",MicromaxTablet:"Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",KarbonnTablet:"Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",AllFineTablet:"Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",PROSCANTablet:"\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",YONESTablet:"BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",ChangJiaTablet:"TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",GUTablet:"TX-A1301|TX-M9002|Q702|kf026",PointOfViewTablet:"TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",OvermaxTablet:"OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)",HCLTablet:"HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",DPSTablet:"DPS Dream 9|DPS Dual 7",VistureTablet:"V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",CrestaTablet:"CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",MediatekTablet:"\\bMT8125|MT8389|MT8135|MT8377\\b",ConcordeTablet:"Concorde([ ]+)?Tab|ConCorde ReadMan",GoCleverTablet:"GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",ModecomTablet:"FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",VoninoTablet:"\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",ECSTablet:"V07OT2|TM105A|S10OT1|TR10CS1",StorexTablet:"eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",VodafoneTablet:"SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7",EssentielBTablet:"Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",RossMoorTablet:"RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",iMobileTablet:"i-mobile i-note",TolinoTablet:"tolino tab [0-9.]+|tolino shine",AudioSonicTablet:"\\bC-22Q|T7-QC|T-17B|T-17P\\b",AMPETablet:"Android.* A78 ",SkkTablet:"Android.* (SKYPAD|PHOENIX|CYCLOPS)",TecnoTablet:"TECNO P9",JXDTablet:"Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",iJoyTablet:"Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",FX2Tablet:"FX2 PAD7|FX2 PAD10",XoroTablet:"KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",ViewsonicTablet:"ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",OdysTablet:"LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",CaptivaTablet:"CAPTIVA PAD",IconbitTablet:"NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",TeclastTablet:"T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",OndaTablet:"\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+",JaytechTablet:"TPC-PA762",BlaupunktTablet:"Endeavour 800NG|Endeavour 1010",DigmaTablet:"\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",EvolioTablet:"ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",LavaTablet:"QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",AocTablet:"MW0811|MW0812|MW0922|MTK8382",MpmanTablet:"MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",CelkonTablet:"CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",WolderTablet:"miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",MiTablet:"\\bMI PAD\\b|\\bHM NOTE 1W\\b",NibiruTablet:"Nibiru M1|Nibiru Jupiter One",NexoTablet:"NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",LeaderTablet:"TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",UbislateTablet:"UbiSlate[\\s]?7C",PocketBookTablet:"Pocketbook",Hudl:"Hudl HT7S3|Hudl 2",TelstraTablet:"T-Hub2",GenericTablet:"Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bJolla\\b|\\bTP750\\b"},oss:{AndroidOS:"Android",BlackBerryOS:"blackberry|\\bBB10\\b|rim tablet os",PalmOS:"PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",SymbianOS:"Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",WindowsMobileOS:"Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;",WindowsPhoneOS:"Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",iOS:"\\biPhone.*Mobile|\\biPod|\\biPad",MeeGoOS:"MeeGo",MaemoOS:"Maemo",JavaOS:"J2ME/|\\bMIDP\\b|\\bCLDC\\b",webOS:"webOS|hpwOS",badaOS:"\\bBada\\b",BREWOS:"BREW"},uas:{Chrome:"\\bCrMo\\b|CriOS|Android.*Chrome/[.0-9]* (Mobile)?",Dolfin:"\\bDolfin\\b",Opera:"Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR/[0-9.]+|Coast/[0-9.]+",Skyfire:"Skyfire",IE:"IEMobile|MSIEMobile",Firefox:"fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile",Bolt:"bolt",TeaShark:"teashark",Blazer:"Blazer",Safari:"Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",Tizen:"Tizen",UCBrowser:"UC.*Browser|UCWEB",baiduboxapp:"baiduboxapp",baidubrowser:"baidubrowser",DiigoBrowser:"DiigoBrowser",Puffin:"Puffin",Mercury:"\\bMercury\\b",ObigoBrowser:"Obigo",NetFront:"NF-Browser",GenericBrowser:"NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger"},props:{Mobile:"Mobile/[VER]",Build:"Build/[VER]",Version:"Version/[VER]",VendorID:"VendorID/[VER]",iPad:"iPad.*CPU[a-z ]+[VER]",iPhone:"iPhone.*CPU[a-z ]+[VER]",iPod:"iPod.*CPU[a-z ]+[VER]",Kindle:"Kindle/[VER]",Chrome:["Chrome/[VER]","CriOS/[VER]","CrMo/[VER]"],Coast:["Coast/[VER]"],Dolfin:"Dolfin/[VER]",Firefox:"Firefox/[VER]",Fennec:"Fennec/[VER]",IE:["IEMobile/[VER];","IEMobile [VER]","MSIE [VER];","Trident/[0-9.]+;.*rv:[VER]"],NetFront:"NetFront/[VER]",NokiaBrowser:"NokiaBrowser/[VER]",Opera:[" OPR/[VER]","Opera Mini/[VER]","Version/[VER]"],"Opera Mini":"Opera Mini/[VER]","Opera Mobi":"Version/[VER]","UC Browser":"UC Browser[VER]",MQQBrowser:"MQQBrowser/[VER]",MicroMessenger:"MicroMessenger/[VER]",baiduboxapp:"baiduboxapp/[VER]",baidubrowser:"baidubrowser/[VER]",Iron:"Iron/[VER]",Safari:["Version/[VER]","Safari/[VER]"],Skyfire:"Skyfire/[VER]",Tizen:"Tizen/[VER]",Webkit:"webkit[ /][VER]",Gecko:"Gecko/[VER]",Trident:"Trident/[VER]",Presto:"Presto/[VER]",iOS:" \\bi?OS\\b [VER][ ;]{1}",Android:"Android [VER]",BlackBerry:["BlackBerry[\\w]+/[VER]","BlackBerry.*Version/[VER]","Version/[VER]"],BREW:"BREW [VER]",Java:"Java/[VER]","Windows Phone OS":["Windows Phone OS [VER]","Windows Phone [VER]"],"Windows Phone":"Windows Phone [VER]","Windows CE":"Windows CE/[VER]","Windows NT":"Windows NT [VER]",Symbian:["SymbianOS/[VER]","Symbian/[VER]"],webOS:["webOS/[VER]","hpwOS/[VER];"]},utils:{Bot:"Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom",MobileBot:"Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker/M1A1-R2D2",DesktopMode:"WPDesktop",TV:"SonyDTV|HbbTV",WebKit:"(webkit)[ /]([\\w.]+)",Console:"\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|PLAYSTATION|Xbox)\\b",Watch:"SM-V700"}};e.detectMobileBrowsers={fullPattern:/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,shortPattern:/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,tabletPattern:/android|ipad|playbook|silk/i};var r=Object.prototype.hasOwnProperty,n;e.FALLBACK_PHONE="UnknownPhone";e.FALLBACK_TABLET="UnknownTablet";e.FALLBACK_MOBILE="UnknownMobile";n="isArray"in Array?Array.isArray:function(e){return Object.prototype.toString.call(e)==="[object Array]"};function i(e,t){return e!=null&&t!=null&&e.toLowerCase()===t.toLowerCase()}function a(e,t){var r,n,i=e.length;if(!i||!t){return false}r=t.toLowerCase();for(n=0;n<i;++n){if(r===e[n].toLowerCase()){return true}}return false}function o(e){for(var t in e){if(r.call(e,t)){e[t]=new RegExp(e[t],"i")}}}(function t(){var i,a,s,u,f,c,l=e.mobileDetectRules;for(i in l.props){if(r.call(l.props,i)){a=l.props[i];if(!n(a)){a=[a]}f=a.length;for(u=0;u<f;++u){s=a[u];c=s.indexOf("[VER]");if(c>=0){s=s.substring(0,c)+"([\\w._\\+]+)"+s.substring(c+5)}a[u]=new RegExp(s,"i")}l.props[i]=a}}o(l.oss);o(l.phones);o(l.tablets);o(l.uas);o(l.utils);l.oss0={WindowsPhoneOS:l.oss.WindowsPhoneOS,WindowsMobileOS:l.oss.WindowsMobileOS}})();e.findMatch=function(e,t){for(var n in e){if(r.call(e,n)){if(e[n].test(t)){return n}}}return null};e.findMatches=function(e,t){var n=[];for(var i in e){if(r.call(e,i)){if(e[i].test(t)){n.push(i)}}}return n};e.getVersionStr=function(t,n){var i=e.mobileDetectRules.props,a,o,s,u;if(r.call(i,t)){a=i[t];s=a.length;for(o=0;o<s;++o){u=a[o].exec(n);if(u!==null){return u[1]}}}return null};e.getVersion=function(t,r){var n=e.getVersionStr(t,r);return n?e.prepareVersionNo(n):NaN};e.prepareVersionNo=function(e){var t;t=e.split(/[a-z._ \/\-]/i);if(t.length===1){e=t[0]}if(t.length>1){e=t[0]+".";t.shift();e+=t.join("")}return Number(e)};e.isMobileFallback=function(t){return e.detectMobileBrowsers.fullPattern.test(t)||e.detectMobileBrowsers.shortPattern.test(t.substr(0,4))};e.isTabletFallback=function(t){return e.detectMobileBrowsers.tabletPattern.test(t)};e.prepareDetectionCache=function(r,n,i){if(r.mobile!==t){return}var a,o,u;o=e.findMatch(e.mobileDetectRules.tablets,n);if(o){r.mobile=r.tablet=o;r.phone=null;return}a=e.findMatch(e.mobileDetectRules.phones,n);if(a){r.mobile=r.phone=a;r.tablet=null;return}if(e.isMobileFallback(n)){u=s.isPhoneSized(i);if(u===t){r.mobile=e.FALLBACK_MOBILE;r.tablet=r.phone=null}else if(u){r.mobile=r.phone=e.FALLBACK_PHONE;r.tablet=null}else{r.mobile=r.tablet=e.FALLBACK_TABLET;r.phone=null}}else if(e.isTabletFallback(n)){r.mobile=r.tablet=e.FALLBACK_TABLET;r.phone=null}else{r.mobile=r.tablet=r.phone=null}};e.mobileGrade=function(e){var t=e.mobile()!==null;if(e.os("iOS")&&e.version("iPad")>=4.3||e.os("iOS")&&e.version("iPhone")>=3.1||e.os("iOS")&&e.version("iPod")>=3.1||e.version("Android")>2.1&&e.is("Webkit")||e.version("Windows Phone OS")>=7||e.is("BlackBerry")&&e.version("BlackBerry")>=6||e.match("Playbook.*Tablet")||e.version("webOS")>=1.4&&e.match("Palm|Pre|Pixi")||e.match("hp.*TouchPad")||e.is("Firefox")&&e.version("Firefox")>=12||e.is("Chrome")&&e.is("AndroidOS")&&e.version("Android")>=4||e.is("Skyfire")&&e.version("Skyfire")>=4.1&&e.is("AndroidOS")&&e.version("Android")>=2.3||e.is("Opera")&&e.version("Opera Mobi")>11&&e.is("AndroidOS")||e.is("MeeGoOS")||e.is("Tizen")||e.is("Dolfin")&&e.version("Bada")>=2||(e.is("UC Browser")||e.is("Dolfin"))&&e.version("Android")>=2.3||(e.match("Kindle Fire")||e.is("Kindle")&&e.version("Kindle")>=3)||e.is("AndroidOS")&&e.is("NookTablet")||e.version("Chrome")>=11&&!t||e.version("Safari")>=5&&!t||e.version("Firefox")>=4&&!t||e.version("MSIE")>=7&&!t||e.version("Opera")>=10&&!t){return"A"}if(e.os("iOS")&&e.version("iPad")<4.3||e.os("iOS")&&e.version("iPhone")<3.1||e.os("iOS")&&e.version("iPod")<3.1||e.is("Blackberry")&&e.version("BlackBerry")>=5&&e.version("BlackBerry")<6||e.version("Opera Mini")>=5&&e.version("Opera Mini")<=6.5&&(e.version("Android")>=2.3||e.is("iOS"))||e.match("NokiaN8|NokiaC7|N97.*Series60|Symbian/3")||e.version("Opera Mobi")>=11&&e.is("SymbianOS")){return"B"}if(e.version("BlackBerry")<5||e.match("MSIEMobile|Windows CE.*Mobile")||e.version("Windows Mobile")<=5.2){return"C"}return"C"};e.detectOS=function(t){return e.findMatch(e.mobileDetectRules.oss0,t)||e.findMatch(e.mobileDetectRules.oss,t)};e.getDeviceSmallerSide=function(){return window.screen.width<window.screen.height?window.screen.width:window.screen.height};function s(e,t){this.ua=e||"";this._cache={};this.maxPhoneWidth=t||600}s.prototype={constructor:s,mobile:function(){e.prepareDetectionCache(this._cache,this.ua,this.maxPhoneWidth);return this._cache.mobile},phone:function(){e.prepareDetectionCache(this._cache,this.ua,this.maxPhoneWidth);return this._cache.phone},tablet:function(){e.prepareDetectionCache(this._cache,this.ua,this.maxPhoneWidth);return this._cache.tablet},userAgent:function(){if(this._cache.userAgent===t){this._cache.userAgent=e.findMatch(e.mobileDetectRules.uas,this.ua)}return this._cache.userAgent},userAgents:function(){if(this._cache.userAgents===t){this._cache.userAgents=e.findMatches(e.mobileDetectRules.uas,this.ua)}return this._cache.userAgents},os:function(){if(this._cache.os===t){this._cache.os=e.detectOS(this.ua)}return this._cache.os},version:function(t){return e.getVersion(t,this.ua)},versionStr:function(t){return e.getVersionStr(t,this.ua)},is:function(t){return a(this.userAgents(),t)||i(t,this.os())||i(t,this.phone())||i(t,this.tablet())||a(e.findMatches(e.mobileDetectRules.utils,this.ua),t)},match:function(e){if(!(e instanceof RegExp)){e=new RegExp(e,"i")}return e.test(this.ua)},isPhoneSized:function(e){return s.isPhoneSized(e||this.maxPhoneWidth)},mobileGrade:function(){if(this._cache.grade===t){this._cache.grade=e.mobileGrade(this)}return this._cache.grade}};if(typeof window!=="undefined"&&window.screen){s.isPhoneSized=function(r){return r<0?t:e.getDeviceSmallerSide()<=r}}else{s.isPhoneSized=function(){}}s._impl=e;return s})})(function(e){if(typeof r!=="undefined"&&r.exports){return function(e){r.exports=e()}}else if(typeof n==="function"&&n.amd){return n}else if(typeof window!=="undefined"){return function(e){window.MobileDetect=e()}}else{throw new Error("unknown environment")}}());return r.exports});e.register("9",["c","a","b","8"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var i,a,o,s;var u;return{setters:[function(e){i=e},function(e){a=e},function(e){o=e},function(e){s=e}],execute:function(){u=function(){function e(e){this.locationUpdatesEnabled=true;this.orientationUpdatesEnabled=true;this.geolocationEntity=new a.Entity({id:"ar.device.geolocation",name:"Device Geolocation"});this.orientationEntity=new a.Entity({id:"ar.device.orientation",name:"Device Orientation"});this.entity=new a.Entity({id:"ar.device",name:"Device"});this.displayEntity=new a.Entity({id:"ar.device.display",name:"Device Display",position:new a.ConstantPositionProperty(a.Cartesian3.ZERO,this.entity),orientation:new a.ConstantProperty(a.Quaternion.IDENTITY)});this._scratchCartesian=new a.Cartesian3;this._scratchQuaternion1=new a.Quaternion;this._scratchQuaternion2=new a.Quaternion;this._x90Rot=a.Quaternion.fromAxisAngle(a.Cartesian3.UNIT_X,a.CesiumMath.PI_OVER_TWO);this._headingDrift=0;e.wellKnownReferenceFrames.add(this.geolocationEntity);e.wellKnownReferenceFrames.add(this.orientationEntity);e.wellKnownReferenceFrames.add(this.entity);e.wellKnownReferenceFrames.add(this.displayEntity);if(typeof navigator!=="undefined"){this._mobileDetect=new s.default(navigator.userAgent)}}e.prototype.onIdle=function(){if(typeof navigator==="undefined")return;if(a.defined(this._geolocationWatchId)){navigator.geolocation.clearWatch(this._geolocationWatchId);this._geolocationWatchId=undefined}if(a.defined(this._deviceorientationListener)){window.removeEventListener("deviceorientation",this._deviceorientationListener);this._deviceorientationListener=undefined;this._alphaOffset=undefined}};e.prototype.onUpdate=function(){var e=this;if(typeof navigator!=="undefined"){var t=this.displayEntity.orientation;var r=a.Quaternion.fromAxisAngle(a.Cartesian3.UNIT_Z,(-window.orientation||0)*a.CesiumMath.RADIANS_PER_DEGREE,this._scratchQuaternion1);if(this._mobileDetect&&!this._mobileDetect.mobile()){r=a.Quaternion.multiply(this._x90Rot,r,r)}t.setValue(r);if(!a.defined(this._geolocationWatchId)&&this.locationUpdatesEnabled){this._geolocationWatchId=navigator.geolocation.watchPosition(function(t){if(e.geolocationEntity.position instanceof a.SampledPositionProperty===false){var r=new a.SampledPositionProperty(a.ReferenceFrame.FIXED);r.forwardExtrapolationType=a.ExtrapolationType.HOLD;r.backwardExtrapolationType=a.ExtrapolationType.HOLD;r.maxNumSamples=10;e.geolocationEntity.position=r}var n=a.JulianDate.fromDate(new Date(t.timestamp));var i=a.Cartesian3.fromDegrees(t.coords.longitude,t.coords.latitude,t.coords.altitude||0,undefined,e._scratchCartesian);e.geolocationEntity.position.addSample(n,i);if(e.geolocationEntity.orientation instanceof a.ConstantProperty===false){e.geolocationEntity.orientation=new a.ConstantProperty}var o=a.Transforms.headingPitchRollQuaternion(i,0,0,0,undefined,e._scratchQuaternion1);e.geolocationEntity.orientation.setValue(o)},function(e){console.error(e)},{enableHighAccuracy:true})}else if(a.defined(this._geolocationWatchId)&&!this.locationUpdatesEnabled){navigator.geolocation.clearWatch(this._geolocationWatchId);this._geolocationWatchId=undefined}if(!a.defined(this._deviceorientationListener)&&this.orientationUpdatesEnabled){this._deviceorientationListener=function(t){var r=t.alpha;if(!a.defined(r)){return}if(t.absolute){e._alphaOffset=0}var n=t["webkitCompassHeading"];var i=+t["webkitCompassAccuracy"];if((!a.defined(e._alphaOffset)||Math.abs(e._headingDrift)>5)&&a.defined(n)&&i>=0&&i<50&&n>=0){if(!a.defined(e._alphaOffset)){e._alphaOffset=-n}else{e._alphaOffset-=e._headingDrift}}var o=e._alphaOffset||-n||0;var s=a.CesiumMath.RADIANS_PER_DEGREE*(t.alpha+o);var u=a.CesiumMath.RADIANS_PER_DEGREE*t.beta;var f=a.CesiumMath.RADIANS_PER_DEGREE*t.gamma;var c=a.Quaternion.fromAxisAngle(a.Cartesian3.UNIT_Z,s,e._scratchQuaternion1);var l=a.Quaternion.fromAxisAngle(a.Cartesian3.UNIT_X,u,e._scratchQuaternion2);var d=a.Quaternion.multiply(c,l,e._scratchQuaternion1);var h=a.Quaternion.fromAxisAngle(a.Cartesian3.UNIT_Y,f,e._scratchQuaternion2);var v=a.Quaternion.multiply(d,h,d);if(e.orientationEntity.position instanceof a.ConstantPositionProperty==false){e.orientationEntity.position=new a.ConstantPositionProperty(a.Cartesian3.ZERO,e.geolocationEntity)}if(e.orientationEntity.orientation instanceof a.ConstantProperty==false){e.orientationEntity.orientation=new a.ConstantProperty}e.orientationEntity.orientation.setValue(v);if(e.entity.position instanceof a.ConstantPositionProperty==false){e.entity.position=new a.ConstantPositionProperty(a.Cartesian3.ZERO,e.orientationEntity)}if(e.entity.orientation instanceof a.ConstantProperty==false){e.entity.orientation=new a.ConstantProperty(a.Quaternion.IDENTITY)}};window.addEventListener("deviceorientation",this._deviceorientationListener)}else if(a.defined(this._deviceorientationListener)&&!this.orientationUpdatesEnabled){window.removeEventListener("deviceorientation",this._deviceorientationListener);this._deviceorientationListener=undefined}}};e.prototype.update=function(){var e=this;if(a.defined(this._idleTimeoutId))clearTimeout(this._idleTimeoutId);this._idleTimeoutId=setTimeout(function(){e.onIdle()},2e3);this.onUpdate()};e=n([i.inject(o.ContextService)],e);
	return e}();e("DeviceService",u)}}});e.register("d",["a"],function(e,t){"use strict";var r=t&&t.id;var n;var i,a;function o(e){var t=Date.now();var r=Math.max(0,16-(t-a));var n=setTimeout(function(){e(t+r)},r);a=t+r;return n}return{setters:[function(e){n=e}],execute:function(){i=function(){function e(){this.frameNumbers=new WeakMap}e.prototype.requestFrame=function(e){var t=this;if(typeof requestAnimationFrame!=="undefined"&&typeof performance!=="undefined"){this.navigationStartDate=this.navigationStartDate||n.JulianDate.fromDate(new Date(performance.timing.navigationStart));requestAnimationFrame(function(r){var i=n.JulianDate.addSeconds(t.navigationStartDate,r/1e3,new n.JulianDate(0,0));e(i,t.getNextFrameNumber(e))})}else{o(function(r){var i=n.JulianDate.fromDate(new Date(r));e(i,t.getNextFrameNumber(e))})}};e.prototype.getNextFrameNumber=function(e){var t=this.frameNumbers.get(e)||0;this.frameNumbers.set(e,t+1);return t};return e}();e("TimerService",i);a=0}}});e.register("e",["c","f","10","9","d","11","12"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__extends||function(e,t){for(var r in t)if(t.hasOwnProperty(r))e[r]=t[r];function n(){this.constructor=e}e.prototype=t===null?Object.create(t):(n.prototype=t.prototype,new n)};var i=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var a,o,s,u,f,c,l;var d;return{setters:[function(e){a=e},function(e){o=e},function(e){s=e},function(e){u=e},function(e){f=e},function(e){c=e},function(e){l=e}],execute:function(){d=function(e){n(t,e);function t(t,r,n){e.call(this);this.sessionService=t;this.deviceService=r;this.timer=n;this.type="empty"}t.prototype.load=function(e,t){var r=this;var n=this.sessionService.addManagedSessionPort(e.uri);var i=this.sessionService.createSessionPort();var a=true;i.on["ar.context.update"]=function(){};i.connectEvent.addEventListener(function(){var e=function(t,n){if(a){r.deviceService.update();var o={time:t,index:n,eye:{pose:l.getSerializedEntityPose(r.deviceService.displayEntity,t)}};i.send("ar.reality.frameState",o);r.timer.requestFrame(e)}};r.timer.requestFrame(e)});i.closeEvent.addEventListener(function(){a=false});t(n);var s=this.sessionService.createSynchronousMessageChannel();n.open(s.port1,this.sessionService.configuration);i.open(s.port2,{role:o.Role.REALITY_VIEW})};t=i([a.inject(s.SessionService,u.DeviceService,f.TimerService)],t);return t}(c.RealityLoader);e("EmptyRealityLoader",d)}}});e.register("13",["c","14","10","12"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__extends||function(e,t){for(var r in t)if(t.hasOwnProperty(r))e[r]=t[r];function n(){this.constructor=e}e.prototype=t===null?Object.create(t):(n.prototype=t.prototype,new n)};var i=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var a,o,s,u;var f,c,l,d,h,v,p,m,w;return{setters:[function(e){a=e},function(e){o=e},function(e){s=e},function(e){u=e}],execute:function(){(function(e){e[e["SUCCESS"]=100]="SUCCESS";e[e["INIT_ERROR"]=-1]="INIT_ERROR";e[e["INIT_DEVICE_NOT_SUPPORTED"]=-2]="INIT_DEVICE_NOT_SUPPORTED";e[e["INIT_NO_CAMERA_ACCESS"]=-3]="INIT_NO_CAMERA_ACCESS";e[e["INIT_LICENSE_ERROR_MISSING_KEY"]=-4]="INIT_LICENSE_ERROR_MISSING_KEY";e[e["INIT_LICENSE_ERROR_INVALID_KEY"]=-5]="INIT_LICENSE_ERROR_INVALID_KEY";e[e["INIT_LICENSE_ERROR_NO_NETWORK_PERMANENT"]=-6]="INIT_LICENSE_ERROR_NO_NETWORK_PERMANENT";e[e["INIT_LICENSE_ERROR_NO_NETWORK_TRANSIENT"]=-7]="INIT_LICENSE_ERROR_NO_NETWORK_TRANSIENT";e[e["INIT_LICENSE_ERROR_CANCELED_KEY"]=-8]="INIT_LICENSE_ERROR_CANCELED_KEY";e[e["INIT_LICENSE_ERROR_PRODUCT_TYPE_MISMATCH"]=-9]="INIT_LICENSE_ERROR_PRODUCT_TYPE_MISMATCH";e[e["INIT_EXTERNAL_DEVICE_NOT_DETECTED"]=-10]="INIT_EXTERNAL_DEVICE_NOT_DETECTED"})(f||(f={}));e("VuforiaInitResult",f);(function(e){e[e["MaxSimultaneousImageTargets"]=0]="MaxSimultaneousImageTargets";e[e["MaxSimultaneousObjectTargets"]=1]="MaxSimultaneousObjectTargets";e[e["DelayedLoadingObjectDatasets"]=2]="DelayedLoadingObjectDatasets"})(c||(c={}));e("VuforiaHint",c);l=function(){function e(){this.stateUpdateEvent=new u.Event}return e}();e("VuforiaServiceDelegateBase",l);d=function(e){n(t,e);function t(){e.apply(this,arguments)}t.prototype.isAvailable=function(){return false};t.prototype.setHint=function(e,t){return true};t.prototype.decryptLicenseKey=function(e,t){return Promise.resolve(undefined)};t.prototype.init=function(e){return Promise.resolve(f.SUCCESS)};t.prototype.deinit=function(){};t.prototype.cameraDeviceInitAndStart=function(){return true};t.prototype.cameraDeviceSetFlashTorchMode=function(e){return true};t.prototype.objectTrackerInit=function(){return true};t.prototype.objectTrackerCreateDataSet=function(e){return""};t.prototype.objectTrackerDestroyDataSet=function(e){return true};t.prototype.objectTrackerActivateDataSet=function(e){return true};t.prototype.objectTrackerDeactivateDataSet=function(e){return true};t.prototype.dataSetFetch=function(e){return Promise.resolve(undefined)};t.prototype.dataSetLoad=function(e){return Promise.resolve()};return t}(l);e("VuforiaServiceDelegate",d);h=function(){function e(e,t,r){var n=this;this.sessionService=e;this.focusService=t;this.delegate=r;this._sessionSwitcherCommandQueue=new u.CommandQueue;this._sessionCommandQueue=new WeakMap;this._sessionInitOptions=new WeakMap;this._sessionInitPromise=new WeakMap;this._sessionIsInitialized=new WeakMap;this._sessionCreatedDataSets=new WeakMap;this._sessionActivatedDataSets=new WeakMap;if(e.isRealityManager){this._sessionSwitcherCommandQueue.errorEvent.addEventListener(function(e){n.sessionService.errorEvent.raiseEvent(e)});e.connectEvent.addEventListener(function(e){var t=new u.CommandQueue;t.errorEvent.addEventListener(function(t){n.sessionService.errorEvent.raiseEvent(t);e.sendError(t)});n._sessionCommandQueue.set(e,t);var i=new Set;n._sessionCreatedDataSets.set(e,i);var a=new Set;n._sessionActivatedDataSets.set(e,a);e.on["ar.vuforia.isAvailable"]=function(){return Promise.resolve({available:r.isAvailable()})};e.on["ar.vuforia.init"]=function(i){if(!r.isAvailable())throw new Error("Vuforia is not supported");if(n._sessionIsInitialized.get(e))throw new Error("Vuforia has already been initialized");if(!i.key&&!i.encryptedLicenseData)throw new Error("Expected `encryptedLicenseData` field. You can encrypt your Vuforia license key at http://docs.argonjs.io/start/vuforia-pgp-encryptor");var a=i.key?Promise.resolve(i.key):r.decryptLicenseKey(i.encryptedLicenseData,e);return a.then(function(r){n._sessionInitOptions.set(e,{key:r});var i=t.push(function(){return n._init(e).then(function(){n._sessionIsInitialized.set(e,true)})},n._controllingSession===e);if(n.focusService.getSession()===e){n._setControllingSession(e)}n._sessionInitPromise.set(e,i);return i})};e.on["ar.vuforia.objectTrackerCreateDataSet"]=function(a){var o=a.url;return t.push(function(){var e=r.objectTrackerCreateDataSet(o);if(e){i.add(e);return Promise.resolve({id:e})}throw new Error("Unable to create DataSet")},n._controllingSession===e)};e.on["ar.vuforia.objectTrackerActivateDataSet"]=function(i){var o=i.id;return t.push(function(){if(r.objectTrackerActivateDataSet(o)){a.add(o);e.send("ar.vuforia.objectTrackerActivateDataSetEvent",{id:o});return}throw new Error("Unable to activate DataSet ("+o+")")},n._controllingSession===e)};e.on["ar.vuforia.objectTrackerDeactivateDataSet"]=function(i){var o=i.id;return t.push(function(){if(r.objectTrackerDeactivateDataSet(o)){a.delete(o);e.send("ar.vuforia.objectTrackerDeactivateDataSetEvent",{id:o});return}throw new Error("Unable to deactivate DataSet ("+o+")")},n._controllingSession===e)};e.on["ar.vuforia.dataSetFetch"]=function(i){var a=i.id;return t.push(function(){return r.dataSetFetch(a)},n._controllingSession===e)};e.on["ar.vuforia.dataSetLoad"]=function(i){var a=i.id;return t.push(function(){return r.dataSetLoad(a)},n._controllingSession===e)};e.closeEvent.addEventListener(function(){if(n._controllingSession===e){t.clear();t.push(function(){n._cleanupSession(e);setTimeout(function(){n._ensureActiveSession()},2e3)},true)}else{n._cleanupSession(e)}})});t.sessionFocusEvent.addEventListener(function(e){var t=e.current;if(t&&n._sessionInitOptions.get(t)){n._setControllingSession(t)}})}}e.prototype.isAvailable=function(){return this.sessionService.manager.request("ar.vuforia.isAvailable").then(function(e){return e.available})};e.prototype.initWithUnencryptedKey=function(e,t){var r=this;if(!t)this.sessionService.ensureIsRealityManager();return this.sessionService.manager.request("ar.vuforia.init",e).then(function(){return new v(r.sessionService.manager)})};e.prototype.init=function(e){var t=this;if(!e.encryptedLicenseData||typeof e.encryptedLicenseData!=="string")throw new Error("options.encryptedLicenseData is required.");return this.sessionService.manager.request("ar.vuforia.init",e).then(function(){return new v(t.sessionService.manager)})};e.prototype._ensureActiveSession=function(){console.log("VuforiaService: Ensuring an active session is in control.");if(this._controllingSession&&this._controllingSession.isConnected)return;this._selectControllingSession()};e.prototype._selectControllingSession=function(){var e=this.focusService.getSession();if(e&&this._sessionInitOptions.get(e)){this._setControllingSession(e);return}for(var t=0,r=this.sessionService.managedSessions;t<r.length;t++){var n=r[t];if(this._sessionInitOptions.get(n)){this._setControllingSession(n);return}}if(this._sessionInitOptions.get(this.sessionService.manager))this._setControllingSession(this.sessionService.manager)};e.prototype._setControllingSession=function(e){var t=this;if(this._controllingSession===e)return;console.log("VuforiaService: Setting controlling session to "+e.uri);this._sessionSwitcherCommandQueue.clear();this._sessionSwitcherCommandQueue.push(function(){return t._pauseSession().then(function(){return t._resumeSession(e)})},true)};e.prototype._resumeSession=function(e){if(this._controllingSession)throw new Error("Attempted to resume a session while a session is still in control");if(e)console.log("VuforiaService: Resuming session "+e.uri);var t=this._sessionInitOptions.get(e);if(!t){throw new Error("Attempted to resume a session without initialization options")}this._controllingSession=e;var r=this._sessionCommandQueue.get(e);if(this._sessionIsInitialized.get(e)){return this._init(e).then(function(){r.execute()}).catch(function(t){e.sendError(t)})}else{r.execute();return this._sessionInitPromise.get(e)}};e.prototype._pauseSession=function(){var e=this;var t=this._controllingSession;if(!t)return Promise.resolve(undefined);console.log("VuforiaService: Pausing session "+t.uri);var r=this._sessionCommandQueue.get(t);return r.push(function(){r.pause();e._controllingSession=undefined;return e._deinit(t)},true)};e.prototype._cleanupSession=function(e){var t=this;if(!this._sessionInitOptions.has(e))return;this._sessionInitOptions.delete(e);var r=this._sessionCreatedDataSets.get(e);console.log("VuforiaService: Deactivating datasets for session "+e.uri);this._sessionActivatedDataSets.get(e).forEach(function(e){t.delegate.objectTrackerDeactivateDataSet(e)});this._sessionActivatedDataSets.delete(e);console.log("VuforiaService: Destroying objects for session "+e.uri);r.forEach(function(e){t.delegate.objectTrackerDestroyDataSet(e)});this._sessionCreatedDataSets.delete(e)};e.prototype._init=function(e){var t=this;console.log("Attempting to initialize vuforia for "+e.uri);var r=this._sessionInitOptions.get(e);return this.delegate.init(r).then(function(r){if(r!==f.SUCCESS){throw new Error("Vuforia init failed: "+f[r])}if(!t.delegate.objectTrackerInit()){throw new Error("Vuforia init failed: Unable to initialize ObjectTracker")}var n=true;t._sessionActivatedDataSets.get(e).forEach(function(r){n=n&&t.delegate.objectTrackerActivateDataSet(r);if(n){e.send("ar.vuforia.objectTrackerActivateDataSetEvent",{id:r})}});if(!n){throw new Error("Vuforia init failed: Unable to restore active datasets")}if(!t.delegate.cameraDeviceInitAndStart()){throw new Error("Vuforia init failed: Unable to complete initialization")}console.log("Vuforia init success")}).catch(function(r){console.log("Vuforia init fail: "+r.message);t._sessionInitOptions.delete(e);t._sessionIsInitialized.set(e,false);t._deinit(e);t._ensureActiveSession();throw r})};e.prototype._deinit=function(e){var t=this;var r=this._sessionActivatedDataSets.get(e);if(r){r.forEach(function(r){t.delegate.objectTrackerDeactivateDataSet(r);e.send("ar.vuforia.objectTrackerDeactivateDataSetEvent",{id:r})})}this.delegate.deinit()};e=i([a.inject(s.SessionService,o.FocusService,d)],e);return e}();e("VuforiaService",h);v=function(){function e(e){this.objectTracker=new m(e)}return e}();e("VuforiaAPI",v);p=function(){function e(){}return e}();e("VuforiaTracker",p);m=function(e){n(t,e);function t(t){var r=this;e.call(this);this.manager=t;this._dataSetMap=new Map;this.dataSetActivateEvent=new u.Event;this.dataSetDeactivateEvent=new u.Event;t.on["ar.vuforia.objectTrackerActivateDataSetEvent"]=function(e){var t=e.id;var n=r._dataSetMap.get(t);n._onActivate();r.dataSetActivateEvent.raiseEvent(n)};t.on["ar.vuforia.objectTrackerDeactivateDataSetEvent"]=function(e){var t=e.id;var n=r._dataSetMap.get(t);n._onDeactivate();r.dataSetDeactivateEvent.raiseEvent(n)}}t.prototype.createDataSet=function(e){var t=this;if(e&&window.document){e=u.resolveURL(e)}return this.manager.request("ar.vuforia.objectTrackerCreateDataSet",{url:e}).then(function(e){var r=new w(e.id,t.manager);t._dataSetMap.set(e.id,r);return r})};t.prototype.activateDataSet=function(e){return this.manager.request("ar.vuforia.objectTrackerActivateDataSet",{id:e.id})};t.prototype.deactivateDataSet=function(e){return this.manager.request("ar.vuforia.objectTrackerDeactivateDataSet",{id:e.id})};return t}(p);e("VuforiaObjectTracker",m);w=function(){function e(e,t){this.id=e;this.manager=t;this._isActive=false}e.prototype._onActivate=function(){this._isActive=true};e.prototype._onDeactivate=function(){this._isActive=false};e.prototype.fetch=function(){return this.manager.request("ar.vuforia.dataSetFetch",{id:this.id}).then(function(){})};e.prototype.load=function(){var e=this;return this.manager.request("ar.vuforia.dataSetLoad",{id:this.id}).then(function(t){e._trackables=t;return t})};e.prototype.isActive=function(){return this._isActive};e.prototype.getTrackables=function(){return this._trackables};return e}();e("VuforiaDataSet",w)}}});e.register("15",["c","f","10","11","13"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__extends||function(e,t){for(var r in t)if(t.hasOwnProperty(r))e[r]=t[r];function n(){this.constructor=e}e.prototype=t===null?Object.create(t):(n.prototype=t.prototype,new n)};var i=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var a,o,s,u,f;var c;return{setters:[function(e){a=e},function(e){o=e},function(e){s=e},function(e){u=e},function(e){f=e}],execute:function(){c=function(e){n(t,e);function t(t,r){e.call(this);this.sessionService=t;this.vuforiaDelegate=r;this.type="live-video"}t.prototype.load=function(e,t){var r=this;var n=this.sessionService.addManagedSessionPort(e.uri);var i=this.sessionService.createSessionPort();i.on["ar.context.update"]=function(){};i.connectEvent.addEventListener(function(){var e=r.vuforiaDelegate.stateUpdateEvent.addEventListener(function(e){i.send("ar.reality.frameState",e)});r.vuforiaDelegate.videoEnabled=true;r.vuforiaDelegate.trackingEnabled=true;i.closeEvent.addEventListener(function(){e();r.vuforiaDelegate.videoEnabled=false;r.vuforiaDelegate.trackingEnabled=false})});t(n);var a=this.sessionService.createSynchronousMessageChannel();n.open(a.port1,this.sessionService.configuration);i.open(a.port2,{role:o.Role.REALITY_VIEW})};t=i([a.inject(s.SessionService,f.VuforiaServiceDelegate)],t);return t}(u.RealityLoader);e("LiveVideoRealityLoader",c)}}});e.register("b",["c","a","10","11","12"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var i,a,o,s,u;var f,c,l,d,h;function v(e){var t=e;return a.defined(t.id)?t.id:""+t}return{setters:[function(e){i=e},function(e){a=e},function(e){o=e},function(e){s=e},function(e){u=e}],execute:function(){(function(e){e[e["KNOWN"]=1]="KNOWN";e[e["FOUND"]=2]="FOUND";e[e["LOST"]=4]="LOST"})(f||(f={}));e("PoseStatus",f);c=new a.Cartesian3(0,0);l=new a.Quaternion(0,0);d=new a.Cartesian3(0,0);h=function(){function e(e,t){var r=this;this.sessionService=e;this.realityService=t;this.updateEvent=new u.Event;this.renderEvent=new u.Event;this.wellKnownReferenceFrames=new a.EntityCollection;this.subscribedEntities=new a.EntityCollection;this.entities=new a.CompositeEntityCollection;this.localOriginChangeEvent=new u.Event;this.user=new a.Entity({id:"ar.user",name:"user",position:new a.ConstantPositionProperty(undefined,a.ReferenceFrame.FIXED),orientation:new a.ConstantProperty(a.Quaternion.IDENTITY)});this.localOriginEastNorthUp=new a.Entity({id:"ar.localENU",name:"localOriginENU",position:new a.ConstantPositionProperty(undefined,a.ReferenceFrame.FIXED),orientation:new a.ConstantProperty(a.Quaternion.IDENTITY)});this.localOriginEastUpSouth=new a.Entity({id:"ar.localEUS",name:"localOriginEUS",position:new a.ConstantPositionProperty(a.Cartesian3.ZERO,this.localOriginEastNorthUp),orientation:new a.ConstantProperty(a.Quaternion.fromAxisAngle(a.Cartesian3.UNIT_X,Math.PI/2))});this.maxDeltaTime=1/3*1e3;this._frame={time:new a.JulianDate(0,0),systemTime:0,deltaTime:0};this._defaultReferenceFrame=this.localOriginEastNorthUp;this._entityPoseCache={};this._entityPoseMap=new Map;this._subscribedEntities=new WeakMap;this._updatingEntities=new Set;this._knownEntities=new Set;this.entities.addCollection(this.wellKnownReferenceFrames);this.entities.addCollection(this.subscribedEntities);this.subscribedEntities.add(this.user);if(this.sessionService.isRealityManager){this.realityService.frameEvent.addEventListener(function(e){r._update(e)});this.sessionService.connectEvent.addEventListener(function(e){r._subscribedEntities.set(e,new Set);e.on["ar.context.subscribe"]=function(t){var n=t.id;var i=r._subscribedEntities.get(e);if(i)i.add(n)}})}else{this.sessionService.manager.on["ar.context.update"]=function(e){r._update(e)}}}Object.defineProperty(e.prototype,"frame",{get:function(){if(!a.defined(this.serializedFrameState))throw new Error("A frame state has not yet been received");return this._frame},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"serializedFrameState",{get:function(){return this._serializedState},enumerable:true,configurable:true});e.prototype.getTime=function(){return this.frame.time};e.prototype.setDefaultReferenceFrame=function(e){this._defaultReferenceFrame=e};e.prototype.getDefaultReferenceFrame=function(){return this._defaultReferenceFrame};e.prototype.subscribeToEntityById=function(e){this.sessionService.manager.send("ar.context.subscribe",{id:e});return this.subscribedEntities.getOrCreateEntity(e)};e.prototype.getEntityPose=function(e,t){if(t===void 0){t=this._defaultReferenceFrame}var r=this.getTime();var n=e.id+"@"+v(t);var i=this._entityPoseMap.get(n);if(!a.defined(i)){i={position:new a.Cartesian3,orientation:new a.Quaternion,time:a.JulianDate.clone(r),poseStatus:0};this._entityPoseMap.set(n,i)}else{a.JulianDate.clone(r,i.time)}var o=u.getEntityPositionInReferenceFrame(e,r,t,i.position);var s=u.getEntityOrientationInReferenceFrame(e,r,t,i.orientation);var c=o&&s;var l=0;var d=i.poseStatus;if(c){l|=f.KNOWN}if(c&&!(d&f.KNOWN)){l|=f.FOUND}else if(!c&&d&f.KNOWN){l|=f.LOST}i.poseStatus=l;return i};e.prototype.getCurrentEntityState=function(e,t){console.warn("getCurrentEntityState is deprecated. Use getEntityPose instead.");return this.getEntityPose(e,t)};e.prototype._update=function(e){var t=this;if(this.sessionService.isRealityManager){delete e.entities[this.user.id];this._entityPoseCache={};for(var r=0,n=this.sessionService.managedSessions;r<n.length;r++){var i=n[r];this._sendUpdateForSession(e,i)}}e.entities[this.user.id]=e.view.pose;this._knownEntities.clear();for(var o in e.entities){this.updateEntityFromFrameState(o,e);this._updatingEntities.add(o);this._knownEntities.add(o)}this._updatingEntities.forEach(function(e){if(!t._knownEntities.has(e)){var r=t.subscribedEntities.getById(e);r.position=undefined;r.orientation=undefined;r=t.entities.getById(e);r.position=undefined;r.orientation=undefined;t._updatingEntities.delete(e)}});this._updateLocalOrigin(e);var s=this._frame;var u=typeof performance!=="undefined"?performance.now():Date.now();s.deltaTime=Math.max(u-s.systemTime,this.maxDeltaTime);s.systemTime=u;a.JulianDate.clone(e.time,s.time);this._serializedState=e;this.updateEvent.raiseEvent(s);this.renderEvent.raiseEvent(s)};e.prototype.updateEntityFromFrameState=function(e,t){var r=t.entities[e];if(!r){if(!this.wellKnownReferenceFrames.getById(e)){this.subscribedEntities.getOrCreateEntity(e)}return}var n;if(a.defined(r.r)){if(typeof r.r==="number"){n=r.r}else{n=this.entities.getById(r.r)}}else{n=a.ReferenceFrame.FIXED}if(!a.defined(n)){this.updateEntityFromFrameState(r.r,t);n=this.entities.getById(r.r)}var i=r.p===0?a.Cartesian3.ZERO:r.p;var o=r.o===0?a.Quaternion.IDENTITY:r.o;var s=this.subscribedEntities.getOrCreateEntity(e);var u=s.position;var f=s.orientation;if(!u||u.referenceFrame!==n){u=new a.ConstantPositionProperty(i,n);s.position=u}else if(u instanceof a.ConstantPositionProperty){u.setValue(i,n)}else if(u instanceof a.SampledPositionProperty){u.addSample(a.JulianDate.clone(t.time),i)}if(!f){f=new a.ConstantProperty(o);s.orientation=f}else if(f instanceof a.ConstantProperty){f.setValue(o)}else if(f instanceof a.SampledProperty){f.addSample(a.JulianDate.clone(t.time),o)}return s};e.prototype.publishEntityState=function(e,t){};e.prototype._updateLocalOrigin=function(e){var t=u.getRootReferenceFrame(this.user);var r=this.user.position&&this.user.position.getValueInReferenceFrame(e.time,t,c);var n=this.localOriginEastNorthUp.position&&this.localOriginEastNorthUp.position.referenceFrame;var i=this.localOriginEastNorthUp.position&&n&&this.localOriginEastNorthUp.position.getValueInReferenceFrame(e.time,n,d);if(r&&(!i||n!==t||a.Cartesian3.magnitudeSquared(a.Cartesian3.subtract(r,i,d))>25e6)){var o=this.localOriginEastNorthUp.position;var s=this.localOriginEastNorthUp.orientation;o.setValue(r,t);if(t===a.ReferenceFrame.FIXED){var f=a.Transforms.headingPitchRollQuaternion(r,0,0,0,undefined,l);s.setValue(f)}else{s.setValue(a.Quaternion.IDENTITY)}this.localOriginChangeEvent.raiseEvent(undefined)}};e.prototype._sendUpdateForSession=function(e,t){var r=this;var n={};for(var i in e.entities){n[i]=e.entities[i]}var o=this._subscribedEntities.get(t);o.forEach(function(t){r._addEntityAndAncestorsToPoseMap(n,t,e.time)});var s={reality:e.reality,index:e.index,time:e.time,view:e.view,entities:n,sendTime:a.JulianDate.now()};t.send("ar.context.update",s)};e.prototype._addEntityAndAncestorsToPoseMap=function(e,t,r){if(!a.defined(this._entityPoseCache[t])){var n=this.subscribedEntities.getById(t);if(!n)return;this._entityPoseCache[t]=u.getSerializedEntityPose(n,r);if(n.position&&n.position.referenceFrame instanceof a.Entity){var i=v(n.position.referenceFrame);this._addEntityAndAncestorsToPoseMap(e,i,r)}}e[t]=this._entityPoseCache[t]};e=n([i.inject(o.SessionService,s.RealityService)],e);return e}();e("ContextService",h)}}});e.register("14",["c","10","12"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var i,a,o;var s;return{setters:[function(e){i=e},function(e){a=e},function(e){o=e}],execute:function(){s=function(){function e(e){var t=this;this.sessionService=e;this.focusEvent=new o.Event;this.blurEvent=new o.Event;this._hasFocus=false;this._sessionFocusEvent=new o.Event;e.manager.on["ar.focus.state"]=function(e){t._setFocus(e.state)};if(e.isRealityManager){e.manager.connectEvent.addEventListener(function(){setTimeout(function(){if(!t._session)t.setSession(t.sessionService.manager)})})}}Object.defineProperty(e.prototype,"hasFocus",{get:function(){return this._hasFocus},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"sessionFocusEvent",{get:function(){this.sessionService.ensureIsRealityManager();return this._sessionFocusEvent},enumerable:true,configurable:true});e.prototype.getSession=function(){this.sessionService.ensureIsRealityManager();return this._session};e.prototype.setSession=function(e){this.sessionService.ensureIsRealityManager();if(e&&!e.isConnected)throw new Error("Only a connected session can be granted focus");var t=this._session;if(t!==e){if(t)t.send("ar.focus.state",{state:false});if(e)e.send("ar.focus.state",{state:true});this._session=e;this.sessionFocusEvent.raiseEvent({previous:t,current:e})}};e.prototype.whenSessionHasFocus=function(e){var t=this;this.sessionService.ensureIsRealityManager();return new Promise(function(r){var n=t.sessionFocusEvent.addEventListener(function(t){var i=t.current;if(i===e){n();r()}})})};e.prototype._setFocus=function(e){if(this._hasFocus!==e){this._hasFocus=e;if(e){this.focusEvent.raiseEvent(undefined)}else{this.blurEvent.raiseEvent(undefined)}}};e=n([i.inject(a.SessionService)],e);return e}();e("FocusService",s)}}});(function(){var t=e.amdDefine;t("16",["exports","3"],function(e,t){"use strict";e.__esModule=true;var r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r){if(Object.prototype.hasOwnProperty.call(r,n)){e[n]=r[n]}}}return e};e.decorators=u;e.deprecated=f;e.mixin=c;e.protocol=m;function n(e,t){if(!(e instanceof t)){throw new TypeError("Cannot call a class as a function")}}var i={resource:"aurelia:resource",paramTypes:"design:paramtypes",properties:"design:properties",get:function e(t,r,n){if(!r){return undefined}var a=i.getOwn(t,r,n);return a===undefined?i.get(t,Object.getPrototypeOf(r),n):a},getOwn:function e(t,r,n){if(!r){return undefined}return Reflect.getOwnMetadata(t,r,n)},define:function e(t,r,n,i){Reflect.defineMetadata(t,r,n,i)},getOrCreateOwn:function e(t,r,n,a){var o=i.getOwn(t,n,a);if(o===undefined){o=new r;Reflect.defineMetadata(t,o,n,a)}return o}};e.metadata=i;var a=new Map;var o=Object.freeze({moduleId:undefined,moduleMember:undefined});var s=function(){function e(t,r){n(this,e);this.moduleId=t;this.moduleMember=r}e.get=function r(n){var i=a.get(n);if(i===undefined){t.PLATFORM.eachModule(function(t,r){for(var o in r){var s=r[o];if(s===n){a.set(n,i=new e(t,o));return true}}if(r===n){a.set(n,i=new e(t,"default"));return true}})}return i||o};e.set=function e(t,r){a.set(t,r)};return e}();e.Origin=s;function u(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++){t[r]=arguments[r]}var n=function e(r,n,i){var a=t.length;if(n){i=i||{value:r[n],writable:true,configurable:true,enumerable:true};while(a--){i=t[a](r,n,i)||i}Object.defineProperty(r,n,i)}else{while(a--){r=t[a](r)||r}}return r};n.on=n;return n}function f(e,t,n){function i(n,i,a){var o=n.constructor.name+"#"+i;var s=t?{}:e||{};var u="DEPRECATION - "+o;if(typeof a.value!=="function"){throw new SyntaxError("Only methods can be marked as deprecated.")}if(s.message){u+=" - "+s.message}return r({},a,{value:function e(){if(s.error){throw new Error(u)}else{console.warn(u)}return a.value.apply(this,arguments)}})}return t?i(e,t,n):i}function c(e){var t=Object.keys(e);function r(r){var n=function r(n){var i=typeof n==="function"?n.prototype:n;for(var a=t,o=Array.isArray(a),s=0,a=o?a:a[Symbol.iterator]();;){var u;if(o){if(s>=a.length)break;u=a[s++]}else{s=a.next();if(s.done)break;u=s.value}var f=u;Object.defineProperty(i,f,{value:e[f],writable:true})}};return r?n(r):n}return r}function l(){return true}function d(){}function h(e){if(e===undefined){e={}}else if(typeof e==="function"){e={validate:e}}if(!e.validate){e.validate=l}if(!e.compose){e.compose=d}return e}function v(e){return function(t){var r=e(t);return r===true}}function p(e,t){return function(r){var n=t(r);if(n!==true){throw new Error(n||e+" was not correctly implemented.")}}}function m(e,t){t=h(t);var r=function r(n){var i=typeof n==="function"?n.prototype:n;t.compose(i);r.assert(i);Object.defineProperty(i,"protocol:"+e,{enumerable:false,configurable:false,writable:false,value:true})};r.validate=v(t.validate);r.assert=p(e,t.validate);return r}m.create=function(e,t){t=h(t);var r="protocol:"+e;var n=function r(n){var i=m(e,t);return n?i(n):i};n.decorates=function(e){return e[r]===true};n.validate=v(t.validate);n.assert=p(e,t.validate);return n}})})();(function(){var t=e.amdDefine;t("3",["exports"],function(e){"use strict";e.__esModule=true;e.AggregateError=t;e.initializePAL=a;function t(e,t,r){if(t){if(t.innerError&&r){return t}if(t.stack){e+="\n------------------------------------------------\ninner error: "+t.stack}}var n=new Error(e);if(t){n.innerError=t}return n}var r={};e.FEATURE=r;var n={noop:function e(){},eachModule:function e(){}};e.PLATFORM=n;n.global=function(){if(typeof self!=="undefined"){return self}if(typeof global!=="undefined"){return global}return new Function("return this")()}();var i={};e.DOM=i;function a(e){if(typeof Object.getPropertyDescriptor!=="function"){Object.getPropertyDescriptor=function(e,t){var r=Object.getOwnPropertyDescriptor(e,t);var n=Object.getPrototypeOf(e);while(typeof r==="undefined"&&n!==null){r=Object.getOwnPropertyDescriptor(n,t);n=Object.getPrototypeOf(n)}return r}}e(n,r,i)}})})();(function(){var t=e.amdDefine;t("c",["exports","16","3"],function(e,t,r){"use strict";e.__esModule=true;var n;var i=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||false;n.configurable=true;if("value"in n)n.writable=true;Object.defineProperty(e,n.key,n)}}return function(t,r,n){if(r)e(t.prototype,r);if(n)e(t,n);return t}}();e.invoker=d;e.factory=h;e.registration=p;e.transient=m;e.singleton=w;e.autoinject=A;e.inject=C;function a(e,t){if(!(e instanceof t)){throw new TypeError("Cannot call a class as a function")}}var o=t.protocol.create("aurelia:resolver",function(e){if(!(typeof e.get==="function")){return"Resolvers must implement: get(container: Container, key: any): any"}return true});e.resolver=o;var s=function(){function e(e){a(this,t);this._key=e}e.prototype.get=function e(t){var r=this;return function(){return t.get(r._key)}};e.of=function t(r){return new e(r)};var t=e;e=o()(e)||e;return e}();e.Lazy=s;var u=function(){function e(e){a(this,t);this._key=e}e.prototype.get=function e(t){return t.getAll(this._key)};e.of=function t(r){return new e(r)};var t=e;e=o()(e)||e;return e}();e.All=u;var f=function(){function e(e){var r=arguments.length<=1||arguments[1]===undefined?false:arguments[1];
	a(this,t);this._key=e;this._checkParent=r}e.prototype.get=function e(t){if(t.hasResolver(this._key,this._checkParent)){return t.get(this._key)}return null};e.of=function t(r){var n=arguments.length<=1||arguments[1]===undefined?false:arguments[1];return new e(r,n)};var t=e;e=o()(e)||e;return e}();e.Optional=f;var c=function(){function e(e){a(this,t);this._key=e}e.prototype.get=function e(t){return t.parent?t.parent.get(this._key):null};e.of=function t(r){return new e(r)};var t=e;e=o()(e)||e;return e}();e.Parent=c;var l=function(){function e(e,r){a(this,t);this.strategy=e;this.state=r}e.prototype.get=function e(t,r){switch(this.strategy){case 0:return this.state;case 1:var n=t.invoke(this.state);this.state=n;this.strategy=0;return n;case 2:return t.invoke(this.state);case 3:return this.state(t,r,this);case 4:return this.state[0].get(t,r);case 5:return t.get(this.state);default:throw new Error("Invalid strategy: "+this.strategy)}};var t=e;e=o()(e)||e;return e}();e.StrategyResolver=l;function d(e){return function(r){t.metadata.define(t.metadata.invoker,e,r)}}function h(e){var r=function e(r){t.metadata.define(t.metadata.invoker,v.instance,r)};return e?r(e):r}var v=function(){function e(){a(this,e)}e.prototype.invoke=function e(t,r,n){var i=n.length;var a=new Array(i);while(i--){a[i]=t.get(n[i])}return r.apply(undefined,a)};e.prototype.invokeWithDynamicDependencies=function e(t,r,n,i){var a=n.length;var o=new Array(a);while(a--){o[a]=t.get(n[a])}if(i!==undefined){o=o.concat(i)}return r.apply(undefined,o)};i(e,null,[{key:"instance",value:new e,enumerable:true}]);return e}();e.FactoryInvoker=v;function p(e){return function(r){t.metadata.define(t.metadata.registration,e,r)}}function m(e){return p(new y(e))}function w(e){var t=arguments.length<=1||arguments[1]===undefined?false:arguments[1];return p(new g(e,t))}var y=function(){function e(t){a(this,e);this._key=t}e.prototype.registerResolver=function e(t,r,n){var i=new l(2,n);t.registerResolver(this._key||r,i);return i};return e}();e.TransientRegistration=y;var g=function(){function e(t){var r=arguments.length<=1||arguments[1]===undefined?false:arguments[1];a(this,e);if(typeof t==="boolean"){this._registerInChild=t}else{this._key=t;this._registerInChild=r}}e.prototype.registerResolver=function e(t,r,n){var i=new l(1,n);if(this._registerInChild){t.registerResolver(this._key||r,i)}else{t.root.registerResolver(this._key||r,i)}return i};return e}();e.SingletonRegistration=g;var S="key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?";var b=Object.freeze([]);e._emptyParameters=b;t.metadata.registration="aurelia:registration";t.metadata.invoker="aurelia:invoker";var T=o.decorates;var _=function(){function e(t,r,n){a(this,e);this.fn=t;this.invoker=r;this.dependencies=n}e.prototype.invoke=function e(t,r){return r!==undefined?this.invoker.invokeWithDynamicDependencies(t,this.fn,this.dependencies,r):this.invoker.invoke(t,this.fn,this.dependencies)};return e}();e.InvocationHandler=_;function E(e,t,r,n){var i=r.length;var a=new Array(i);while(i--){a[i]=e.get(r[i])}if(n!==undefined){a=a.concat(n)}return Reflect.construct(t,a)}var M=(n={},n[0]={invoke:function e(t,r){return new r},invokeWithDynamicDependencies:E},n[1]={invoke:function e(t,r,n){return new r(t.get(n[0]))},invokeWithDynamicDependencies:E},n[2]={invoke:function e(t,r,n){return new r(t.get(n[0]),t.get(n[1]))},invokeWithDynamicDependencies:E},n[3]={invoke:function e(t,r,n){return new r(t.get(n[0]),t.get(n[1]),t.get(n[2]))},invokeWithDynamicDependencies:E},n[4]={invoke:function e(t,r,n){return new r(t.get(n[0]),t.get(n[1]),t.get(n[2]),t.get(n[3]))},invokeWithDynamicDependencies:E},n[5]={invoke:function e(t,r,n){return new r(t.get(n[0]),t.get(n[1]),t.get(n[2]),t.get(n[3]),t.get(n[4]))},invokeWithDynamicDependencies:E},n.fallback={invoke:E,invokeWithDynamicDependencies:E},n);var P=function(){function e(t){a(this,e);if(t===undefined){t={}}this._configuration=t;this._onHandlerCreated=t.onHandlerCreated;this._handlers=t.handlers||(t.handlers=new Map);this._resolvers=new Map;this.root=this;this.parent=null}e.prototype.makeGlobal=function t(){e.instance=this;return this};e.prototype.setHandlerCreatedCallback=function e(t){this._onHandlerCreated=t;this._configuration.onHandlerCreated=t};e.prototype.registerInstance=function e(t,r){this.registerResolver(t,new l(0,r===undefined?t:r))};e.prototype.registerSingleton=function e(t,r){this.registerResolver(t,new l(1,r===undefined?t:r))};e.prototype.registerTransient=function e(t,r){this.registerResolver(t,new l(2,r===undefined?t:r))};e.prototype.registerHandler=function e(t,r){this.registerResolver(t,new l(3,r))};e.prototype.registerAlias=function e(t,r){this.registerResolver(r,new l(5,t))};e.prototype.registerResolver=function e(t,r){if(t===null||t===undefined){throw new Error(S)}var n=this._resolvers;var i=n.get(t);if(i===undefined){n.set(t,r)}else if(i.strategy===4){i.state.push(r)}else{n.set(t,new l(4,[i,r]))}};e.prototype.autoRegister=function e(r,n){var i=undefined;if(typeof r==="function"){var a=t.metadata.get(t.metadata.registration,r);if(a===undefined){i=new l(1,r);this.registerResolver(n===undefined?r:n,i)}else{i=a.registerResolver(this,n===undefined?r:n,r)}}else{i=new l(0,r);this.registerResolver(n===undefined?r:n,i)}return i};e.prototype.autoRegisterAll=function e(t){var r=t.length;while(r--){this.autoRegister(t[r])}};e.prototype.unregister=function e(t){this._resolvers["delete"](t)};e.prototype.hasResolver=function e(t){var r=arguments.length<=1||arguments[1]===undefined?false:arguments[1];if(t===null||t===undefined){throw new Error(S)}return this._resolvers.has(t)||r&&this.parent!==null&&this.parent.hasResolver(t,r)};e.prototype.get=function t(r){if(r===null||r===undefined){throw new Error(S)}if(r===e){return this}if(T(r)){return r.get(this,r)}var n=this._resolvers.get(r);if(n===undefined){if(this.parent===null){return this.autoRegister(r).get(this,r)}return this.parent._get(r)}return n.get(this,r)};e.prototype._get=function e(t){var r=this._resolvers.get(t);if(r===undefined){if(this.parent===null){return this.autoRegister(t).get(this,t)}return this.parent._get(t)}return r.get(this,t)};e.prototype.getAll=function e(t){if(t===null||t===undefined){throw new Error(S)}var r=this._resolvers.get(t);if(r===undefined){if(this.parent===null){return b}return this.parent.getAll(t)}if(r.strategy===4){var n=r.state;var i=n.length;var a=new Array(i);while(i--){a[i]=n[i].get(this,t)}return a}return[r.get(this,t)]};e.prototype.createChild=function t(){var r=new e(this._configuration);r.root=this.root;r.parent=this;return r};e.prototype.invoke=function e(t,n){try{var i=this._handlers.get(t);if(i===undefined){i=this._createInvocationHandler(t);this._handlers.set(t,i)}return i.invoke(this,n)}catch(e){throw new r.AggregateError("Error invoking "+t.name+". Check the inner error for details.",e,true)}};e.prototype._createInvocationHandler=function e(r){var n=undefined;if(typeof r.inject==="function"){n=r.inject()}else if(r.inject===undefined){n=t.metadata.getOwn(t.metadata.paramTypes,r)||b}else{n=r.inject}var i=t.metadata.getOwn(t.metadata.invoker,r)||M[n.length]||M.fallback;var a=new _(r,i,n);return this._onHandlerCreated!==undefined?this._onHandlerCreated(a):a};return e}();e.Container=P;function A(e){var r=function e(r){r.inject=t.metadata.getOwn(t.metadata.paramTypes,r)||b};return e?r(e):r}function C(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++){t[r]=arguments[r]}return function(e,r,n){if(n){var i=n.value;i.inject=t}else{e.inject=t}}}})})();e.register("f",[],function(e,t){"use strict";var r=t&&t.id;var n,i,a;return{setters:[],execute:function(){(function(e){e[e["REALITY_AUGMENTOR"]="RealityAugmentor"]="REALITY_AUGMENTOR";e[e["REALITY_VIEW"]="RealityView"]="REALITY_VIEW";e[e["REALITY_MANAGER"]="RealityManager"]="REALITY_MANAGER";e[e["APPLICATION"]="Application"]="APPLICATION";e[e["MANAGER"]="Manager"]="MANAGER"})(n||(n={}));e("Role",n);(function(e){e[e["SINGULAR"]="Singular"]="SINGULAR";e[e["LEFTEYE"]="LeftEye"]="LEFTEYE";e[e["RIGHTEYE"]="RightEye"]="RIGHTEYE";e[e["OTHER"]="Other"]="OTHER"})(i||(i={}));e("SubviewType",i);a=function(){function e(){}e.getType=function(e){var t=e.uri;var r=t.split(":");if(r[0]==="reality"){return r[1]}return"hosted"};e.EMPTY={uri:"reality:empty",title:"Reality",providedReferenceFrames:["FIXED"]};return e}();e("RealityView",a)}}});e.register("10",["a","c","f","12"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__extends||function(e,t){for(var r in t)if(t.hasOwnProperty(r))e[r]=t[r];function n(){this.constructor=e}e.prototype=t===null?Object.create(t):(n.prototype=t.prototype,new n)};var i=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var a,o,s,u;var f,c,l,d,h,v,p,m;return{setters:[function(e){a=e},function(e){o=e},function(e){s=e},function(e){u=e}],execute:function(){f=function(){function e(t){var r=this;this.uri=t;this._connectEvent=new u.Event;this.closeEvent=new u.Event;this.errorEvent=new u.Event;this.on={};this._isOpened=false;this._isConnected=false;this._isClosed=false;this.on[e.OPEN]=function(e){if(!e)throw new Error("Session did not provide a configuration");if(r._isConnected)throw new Error("Session has already connected!");r.info=e;r._isConnected=true;r._connectEvent.raiseEvent(undefined)};this.on[e.CLOSE]=function(){r._isClosed=true;r._isConnected=false;if(r.messagePort&&r.messagePort.close)r.messagePort.close();r.closeEvent.raiseEvent(undefined)};this.on[e.ERROR]=function(e){var t=new Error("Session Error: "+e.message);if(e.stack)t["stack"]=e.stack;r.errorEvent.raiseEvent(t)};this.errorEvent.addEventListener(function(e){if(r.errorEvent.numberOfListeners===1)console.error(e)})}Object.defineProperty(e.prototype,"connectEvent",{get:function(){if(this._isConnected)throw new Error("The connectEvent only fires once and the session is already connected.");return this._connectEvent},enumerable:true,configurable:true});e.prototype.supportsProtocol=function(e,t){if(!this._isConnected)throw new Error("Session has not yet connected");var r=this.info.protocols;if(!r)return false;var n=false;var i=new Set;r.forEach(function(t){if(t.indexOf(e)!==-1){var r=+t.split("@v")[1]||0;i.add(r)}});if(t){if(Array.isArray(t)){t.forEach(function(e){if(i.has(e)){n=true}})}else{if(i.has(t)){n=true}}}else if(!t){n=true}return n};e.prototype.open=function(t,r){var n=this;if(this._isClosed)return;if(this._isOpened)throw new Error("Session can only be opened once");if(!r)throw new Error("Session options must be provided");this.messagePort=t;this._isOpened=true;this.messagePort.onmessage=function(e){if(n._isClosed)return;var t=e.data[0];var r=e.data[1];var i=e.data[2]||{};var a=e.data[3];var o=n.on[r];if(o&&!a){try{var s=o(i,e);if(s)console.warn("Handler for "+r+" returned an unexpected response")}catch(e){n.sendError(e);n.errorEvent.raiseEvent(e)}}else if(o){var s=new Promise(function(t){return t(o(i,e))});Promise.resolve(s).then(function(e){if(n._isClosed)return;n.send(r+":resolve:"+t,e)}).catch(function(e){if(n._isClosed)return;var i;if(typeof e==="string")i=e;else if(typeof e.message==="string")i=e.message;n.send(r+":reject:"+t,{reason:i})})}else{var u="Unable to handle message "+r;if(a){n.send(r+":reject:"+t,{reason:u})}else{n.sendError({message:u})}n.errorEvent.raiseEvent(new Error("No handlers are available for topic "+r))}};this.send(e.OPEN,r)};e.prototype.send=function(e,t){if(!this._isOpened)throw new Error("Session must be open to send messages");if(this._isClosed)return false;var r=a.createGuid();this.messagePort.postMessage([r,e,t]);return true};e.prototype.sendError=function(t){var r=t;if(r instanceof Error){r={message:r.message,stack:r["stack"]}}return this.send(e.ERROR,r)};e.prototype.request=function(e,t){var r=this;if(!this._isOpened||this._isClosed)throw new Error("Session must be open to make requests");var n=a.createGuid();var i=e+":resolve:"+n;var o=e+":reject:"+n;var s=new Promise(function(t,n){r.on[i]=function(e){delete r.on[i];delete r.on[o];t(e)};r.on[o]=function(t){delete r.on[i];delete r.on[o];console.warn("Request '"+e+"' rejected with reason:\n"+t.reason);n(new Error(t.reason))}});this.messagePort.postMessage([n,e,t||{},true]);return s};e.prototype.close=function(){if(this._isClosed)return;if(this._isOpened){this.send(e.CLOSE)}this._isClosed=true;this._isConnected=false;if(this.messagePort&&this.messagePort.close)this.messagePort.close();this.closeEvent.raiseEvent(undefined)};Object.defineProperty(e.prototype,"isConnected",{get:function(){return this._isConnected},enumerable:true,configurable:true});e.OPEN="ar.session.open";e.CLOSE="ar.session.close";e.ERROR="ar.session.error";return e}();e("SessionPort",f);c=function(){function e(){}e.prototype.create=function(e){return new f(e)};return e}();e("SessionPortFactory",c);l=function(){function e(){}return e}();e("ConnectService",l);d=function(){function e(e,t,r,n){var i=this;this.configuration=e;this.connectService=t;this.sessionPortFactory=r;this.messageChannelFactory=n;this.manager=this.createSessionPort("argon:manager");this.errorEvent=new u.Event;this._connectEvent=new u.Event;this._managedSessions=[];this.errorEvent.addEventListener(function(e){if(i.errorEvent.numberOfListeners===1)console.error(e)});this.manager.errorEvent.addEventListener(function(e){i.errorEvent.raiseEvent(e)});Object.freeze(this)}Object.defineProperty(e.prototype,"connectEvent",{get:function(){return this._connectEvent},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"managedSessions",{get:function(){this.ensureIsRealityManager();return this._managedSessions},enumerable:true,configurable:true});e.prototype.connect=function(){if(this.connectService&&this.connectService.connect){this.connectService.connect(this)}else{console.warn("Argon: Unable to connect to a manager session; a connect service is not available")}};e.prototype.addManagedSessionPort=function(e){var t=this;this.ensureIsRealityManager();var r=this.sessionPortFactory.create(e);r.errorEvent.addEventListener(function(e){t.errorEvent.raiseEvent(e)});r.connectEvent.addEventListener(function(){t.managedSessions.push(r);t.connectEvent.raiseEvent(r)});r.closeEvent.addEventListener(function(){var e=t.managedSessions.indexOf(r);if(e>-1)t.managedSessions.splice(e,1)});return r};e.prototype.createSessionPort=function(e){return this.sessionPortFactory.create(e)};e.prototype.createMessageChannel=function(){return this.messageChannelFactory.create()};e.prototype.createSynchronousMessageChannel=function(){return this.messageChannelFactory.createSynchronous()};Object.defineProperty(e.prototype,"isRealityManager",{get:function(){return this.configuration.role===s.Role.REALITY_MANAGER||this.configuration.role===s.Role.MANAGER},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"isRealityAugmenter",{get:function(){return this.configuration.role===s.Role.REALITY_AUGMENTOR||this.configuration.role===s.Role.APPLICATION},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"isRealityView",{get:function(){return this.configuration.role===s.Role.REALITY_VIEW},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"isManager",{get:function(){console.warn("Deprecated. Use isRealityManager()");return this.isManager},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"isApplication",{get:function(){console.warn("Deprecated. Use isRealityAugmenter()");return this.isRealityAugmenter},enumerable:true,configurable:true});e.prototype.ensureIsRealityManager=function(){if(!this.isRealityManager)throw new Error("An reality-manager only API was accessed from a non reality-manager.")};e.prototype.ensureIsRealityView=function(){if(!this.isRealityView)throw new Error("An reality-view only API was accessed from a non reality-view.")};e.prototype.ensureNotRealityView=function(){if(this.isRealityView)throw new Error("An non-permitted API was accessed from a reality-view.")};e=i([o.inject("config",l,c,u.MessageChannelFactory)],e);return e}();e("SessionService",d);h=function(e){n(t,e);function t(){e.apply(this,arguments)}t.prototype.connect=function(e){var t=e.createSynchronousMessageChannel();var r=t.port1;t.port2.onmessage=function(e){t.port2.postMessage(e.data)};e.manager.connectEvent.addEventListener(function(){e.connectEvent.raiseEvent(e.manager)});e.manager.open(r,e.configuration)};return t}(l);e("LoopbackConnectService",h);v=function(e){n(t,e);function t(){e.apply(this,arguments)}t.isAvailable=function(){return typeof window!=="undefined"&&typeof window.parent!=="undefined"};t.prototype.connect=function(e){var t=e.createMessageChannel();window.parent.postMessage({type:"ARGON_SESSION"},"*",[t.port1]);e.manager.open(t.port2,e.configuration)};return t}(l);e("DOMConnectService",v);p=function(e){n(t,e);function t(){e.apply(this,arguments)}t.isAvailable=function(){return typeof window!=="undefined"&&!!window["__ARGON_DEBUG_PORT__"]};t.prototype.connect=function(e){var t=e.manager,r=e.configuration;t.open(window["__ARGON_DEBUG_PORT__"],r)};return t}(l);e("DebugConnectService",p);m=function(e){n(t,e);function t(){e.apply(this,arguments)}t.isAvailable=function(){return typeof window!=="undefined"&&window["webkit"]&&window["webkit"].messageHandlers};t.prototype.connect=function(e){var t=e.createSynchronousMessageChannel();t.port2.onmessage=function(e){webkit.messageHandlers.argon.postMessage(JSON.stringify(e.data))};window["__ARGON_PORT__"]=t.port2;e.manager.open(t.port1,e.configuration);window.addEventListener("beforeunload",function(){e.manager.close()})};return t}(l);e("WKWebViewConnectService",m)}}});e.register("11",["c","a","f","14","10","12"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var i,a,o,s,u,f;var c,l,d;return{setters:[function(e){i=e},function(e){a=e},function(e){o=e},function(e){s=e},function(e){u=e},function(e){f=e}],execute:function(){c=function(){function e(){}return e}();e("RealityLoader",c);(function(e){e[e["OTHER"]=0]="OTHER";e[e["START"]=1]="START";e[e["CHANGE"]=2]="CHANGE";e[e["END"]=3]="END"})(l||(l={}));e("RealityZoomState",l);d=function(){function e(e,t){var r=this;this.sessionService=e;this.focusService=t;this.realities=new Array;this.connectEvent=new f.Event;this._changeEvent=new f.Event;this._frameEvent=new f.Event;this.desiredRealityMap=new WeakMap;this.desiredRealityMapInverse=new WeakMap;this.sessionDesiredRealityChangeEvent=new f.Event;this._loaders=[];this._defaultFov=Math.PI/2;this._scratchFrustum=new a.PerspectiveFrustum;this._scratchArray=new Array;this._loadID=-1;if(e.isRealityManager){e.manager.connectEvent.addEventListener(function(){setTimeout(function(){if(r._loadID===-1)r._setNextReality(r.onSelectReality())})})}e.connectEvent.addEventListener(function(e){if(e.info.role!==o.Role.REALITY_VIEW){e.on["ar.reality.desired"]=function(t){var n=t.reality;var i=r.desiredRealityMap.get(e);console.log("Session set desired reality: "+JSON.stringify(n));if(n){if(n["type"]){var a=n["type"];n.uri=n.uri||"reality:"+a;if(a==="hosted")n.uri=n["url"];if(!n.title&&n["name"])n.title=n["name"]}if(r.isSupported(n)){r.desiredRealityMap.set(e,n);r.desiredRealityMapInverse.set(n,e)}else{e.sendError({message:'Reality of type "'+n.uri+'" is not available on this platform'});return}}else{r.desiredRealityMap.delete(e)}r._setNextReality(r.onSelectReality());r.sessionDesiredRealityChangeEvent.raiseEvent({session:e,previous:i,current:n})}}});e.manager.on["ar.reality.connect"]=function(e){var t=e.id;var n=r.sessionService.createSessionPort();var i=r.sessionService.createSynchronousMessageChannel();var a="ar.reality.message.route."+t;var o="ar.reality.message.send."+t;var s="ar.reality.close."+t;i.port1.onmessage=function(e){r.sessionService.manager.send(a,e.data)};r.sessionService.manager.on[o]=function(e){i.port1.postMessage(e)};r.sessionService.manager.on[s]=function(){n.close()};n.connectEvent.addEventListener(function(){r.connectEvent.raiseEvent(n)});r.sessionService.manager.closeEvent.addEventListener(function(){n.close();delete r.sessionService.manager.on[o];delete r.sessionService.manager.on[s]});n.open(i.port2,r.sessionService.configuration)};e.manager.on["ar.reality.zoom"]=function(e){r.zoom(e)}}Object.defineProperty(e.prototype,"changeEvent",{get:function(){this.sessionService.ensureIsRealityManager();return this._changeEvent},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"frameEvent",{get:function(){this.sessionService.ensureIsRealityManager();return this._frameEvent},enumerable:true,configurable:true});e.prototype.setDefault=function(e){this._default=e};e.prototype.registerLoader=function(e){this.sessionService.ensureIsRealityManager();this._loaders.push(e)};e.prototype.getCurrent=function(){this.sessionService.ensureIsRealityManager();return this._current};e.prototype.isSupported=function(e){this.sessionService.ensureIsRealityManager();return!!this._getLoader(e)};e.prototype.publishFrame=function(e){this.sessionService.ensureIsRealityView();if(this.sessionService.manager.isConnected){this.sessionService.manager.send("ar.reality.frameState",e)}};e.prototype.setDesired=function(e){this.sessionService.ensureNotRealityView();this._desired=e;if(this.sessionService.isRealityManager){this._setNextReality(e,true)}else{this.sessionService.manager.send("ar.reality.desired",{reality:e})}};e.prototype.getDesired=function(){return this._desired};e.prototype.setOptionalReferenceFrames=function(e){};e.prototype.setRequiredReferenceFrames=function(e){};e.prototype.setDesiredFov=function(e){this._desiredFov=e;this.zoom({fov:e||this._defaultFov,zoom:1,state:l.OTHER})};e.prototype.getDesiredFov=function(){return this._desiredFov};e.prototype.setDefaultFov=function(e){if(a.defined(this._desiredFov)){var t=this._desiredFov/this._defaultFov;this.setDesiredFov(e*t)}this._defaultFov=e};e.prototype.getDefaultFov=function(){return this._defaultFov};e.prototype.getMaximumViewport=function(){if(typeof document!=="undefined"&&document.documentElement){return{x:0,y:0,width:document.documentElement.clientWidth,height:document.documentElement.clientHeight}}throw new Error("Not implemeneted for the current platform")};e.prototype.onSelectReality=function(){this.sessionService.ensureIsRealityManager();var e=this.desiredRealityMap.get(this.sessionService.manager);if(!e){var t=this.focusService.getSession();if(t&&t.isConnected){e=this.desiredRealityMap.get(t)}}if(!e){for(var r=0,n=this.sessionService.managedSessions;r<n.length;r++){var i=n[r];if(!i.isConnected)continue;var a=this.desiredRealityMap.get(i);if(a&&this.isSupported(a)){e=a;break}}}return e};e.prototype.onGenerateViewFromEyeParameters=function(e){var t=e.fov||this._desiredFov||this._defaultFov;var r=e.viewport||this.getMaximumViewport();var n=e.aspect||r.width/r.height;this._scratchFrustum.fov=t;this._scratchFrustum.aspectRatio=n;this._scratchFrustum.near=.01;this._scratchFrustum.far=1e7;return{viewport:r,pose:e.pose,subviews:[{type:o.SubviewType.SINGULAR,frustum:{fov:t,aspectRatio:n},projectionMatrix:a.Matrix4.toArray(this._scratchFrustum.projectionMatrix,this._scratchArray)}]}};e.prototype.zoom=function(e){e.naturalFov=e.naturalFov||this._defaultFov;if(this._realitySession&&this._realitySession.info["reality.handlesZoom"]){this._realitySession.send("ar.reality.zoom",e)}else{var t=this._desiredFov=this.onZoom(e);if(this.sessionService.isRealityView){this.sessionService.manager.send("ar.reality.desiredFov",{fov:t})}}};e.prototype.onZoom=function(e){var t=2*Math.atan(Math.tan(e.fov*.5)/e.zoom);t=Math.max(10*a.CesiumMath.RADIANS_PER_DEGREE,Math.min(t,160*a.CesiumMath.RADIANS_PER_DEGREE));if(e.state===l.END&&Math.abs(t-e.naturalFov)<.05){t=e.naturalFov}return t};e.prototype._setNextReality=function(e,t){var r=this;if(t===void 0){t=false}if(this._current&&e&&this._current===e&&!t)return;if(this._current&&!e&&this._realitySession)return;if(!this._current&&!a.defined(e)){e=this._default}if(a.defined(e)){if(!this.isSupported(e)){this.sessionService.errorEvent.raiseEvent(new Error('Reality of type "'+e.uri+'" is not available on this platform'));return}var n=++this._loadID;this._executeRealityLoader(e,function(t){if(t.isConnected)throw new Error("Expected an unconnected session");if(n!==r._loadID){t.close();return}var i=r._realitySession;r._realitySession=t;r._setCurrent(e);t.on["ar.reality.frameState"]=function(e){var t=e;if(!a.defined(e.view)){if(!a.defined(e.eye))throw new Error("Unable to construct view configuration: missing eye parameters");t.view=r.onGenerateViewFromEyeParameters(e.eye);t.eye=undefined;t.entities=e.entities||{}}t.reality=r.getCurrent();r.frameEvent.raiseEvent(t)};t.on["ar.reality.desiredFov"]=function(e){r._desiredFov=e.fov};t.closeEvent.addEventListener(function(){console.log("Reality session closed: "+JSON.stringify(e));if(r._loadID===n){r._realitySession=undefined;r._current=undefined;r._setNextReality(r.onSelectReality())}});t.connectEvent.addEventListener(function(){if(t.info.role!==o.Role.REALITY_VIEW){t.sendError({message:"Expected a reality session"});t.close();throw new Error('The application "'+t.uri+'" does not support being loaded as a reality')}if(i){i.close()}if(t.info["reality.supportsControlPort"]){var n=r.desiredRealityMapInverse.get(e)||r.sessionService.manager;var s=a.createGuid();var u="ar.reality.message.route."+s;var f="ar.reality.message.send."+s;var c="ar.reality.close."+s;t.on[u]=function(e){n.send(f,e)};n.on[u]=function(e){t.send(f,e)};t.send("ar.reality.connect",{id:s});n.send("ar.reality.connect",{id:s});t.closeEvent.addEventListener(function(){n.send(c)});n.closeEvent.addEventListener(function(){t.send(c);t.close()})}})})}};e.prototype._getLoader=function(e){var t;for(var r=0,n=this._loaders;r<n.length;r++){var i=n[r];if(i.type===o.RealityView.getType(e)){t=i;break}}return t};e.prototype._setCurrent=function(e){if(this._current===undefined||this._current!==e){var t=this._current;this._current=e;this.changeEvent.raiseEvent({previous:t,current:e});console.log("Reality changed to: "+JSON.stringify(e))}};e.prototype._executeRealityLoader=function(e,t){this.sessionService.ensureIsRealityManager();var r=this._getLoader(e);if(!r)throw new Error("Unable to setup unsupported reality type: "+e.uri);r.load(e,t)};e=n([i.inject(u.SessionService,s.FocusService)],e);return e}();e("RealityService",d)}}});e.register("17",["c","a","10","b","12","14","11"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var i,a,o,s,u,f,c;var l,d,h,v;return{setters:[function(e){i=e},function(e){a=e},function(e){o=e},function(e){s=e},function(e){u=e},function(e){f=e},function(e){c=e}],execute:function(){if(typeof document!=="undefined"&&document.createElement){var t=document.querySelector("meta[name=viewport]");if(!t)t=document.createElement("meta");t.name="viewport";t.content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0";document.head.appendChild(t);var r=document.querySelector("meta[name=argon]");if(!r)r=document.createElement("meta");r.name="argon";document.head.appendChild(r);d=new Promise(function(e){var t=function(){var t=document.querySelector("#argon");if(!t)t=document.createElement("div");t.id="argon";t.classList.add("argon-view");document.body.appendChild(t);l=t;e(t)};if(document.readyState=="loading"){document.addEventListener("DOMContentLoaded",t)}else{t()}});var p=document.createElement("style");p.type="text/css";document.head.insertBefore(p,document.head.firstChild);var m=p.sheet;m.insertRule("\n        #argon {\n            position: fixed;\n            left: 0px;\n            bottom: 0px;\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            border: 0;\n            padding: 0;\n        }\n    ",0);m.insertRule("\n        .argon-view > * {\n            position: absolute;\n            pointer-events: none;\n        }\n    ",1)}h=function(){function e(e,t,r,n){var i=this;this.sessionService=t;this.focusService=r;this.contextService=n;this.viewportChangeEvent=new u.Event;this.acquireEvent=new u.Event;this.releaseEvent=new u.Event;this.desiredViewportMap=new WeakMap;this._subviews=[];this._subviewEntities=[];this._frustums=[];if(typeof document!=="undefined"&&document.createElement){var a=this.element=document.createElement("div");a.style.width="100%";a.style.height="100%";a.classList.add("argon-view");this.containingElementPromise=new Promise(function(t){if(e&&e instanceof HTMLElement){e.insertBefore(a,e.firstChild);t(e)}else{l=document.querySelector("#argon");if(l){l.insertBefore(a,l.firstChild);t(l)}else{d.then(function(e){e.insertBefore(a,e.firstChild);t(e)})}i.focusService.focusEvent.addEventListener(function(){d.then(function(e){e.classList.remove("argon-no-focus");e.classList.add("argon-focus")})});i.focusService.blurEvent.addEventListener(function(){d.then(function(e){e.classList.remove("argon-focus");e.classList.add("argon-no-focus")})})}})}if(this.sessionService.isRealityManager){this.sessionService.connectEvent.addEventListener(function(e){e.on["ar.viewport.desired"]=function(t){i.desiredViewportMap.set(e,t)}})}this.contextService.renderEvent.addEventListener(function(){var e=i.contextService.serializedFrameState;var t=i._subviewEntities;t.length=0;e.view.subviews.forEach(function(r,n){var a="ar.view_"+n;e.entities[a]=r.pose||e.view.pose;i.contextService.updateEntityFromFrameState(a,e);delete e.entities[a];t[n]=i.contextService.entities.getById(a)});i._update()})}e.prototype.getSubviews=function(e){var t=this;this._update();var r=this._subviews;r.length=this._current.subviews.length;this._current.subviews.forEach(function(n,i){var o=t._subviewEntities[i];var s=r[i]=r[i]||{};s.index=i;s.type=n.type;s.pose=t.contextService.getEntityPose(o,e);s.viewport=n.viewport||t._current.viewport;s.frustum=t._frustums[i];if(!s.frustum){s.frustum=t._frustums[i]=new a.PerspectiveFrustum;s.frustum.near=.01;s.frustum.far=1e7}s.frustum.fov=n.frustum.fov;s.frustum.aspectRatio=n.frustum.aspectRatio||s.viewport.width/s.viewport.height;s.frustum.xOffset=n.frustum.xOffset||0;s.frustum.yOffset=n.frustum.yOffset||0;s.projectionMatrix=n.projectionMatrix||s.frustum.infiniteProjectionMatrix});return r};e.prototype.getViewport=function(){return this._current.viewport};e.prototype.setDesiredViewport=function(e){this.sessionService.manager.send("ar.view.desiredViewport",e)};e.prototype.requestOwnership=function(){};e.prototype.releaseOwnership=function(){};e.prototype.isOwner=function(){};e.prototype._update=function(){var e=this;var t=this.contextService.serializedFrameState;if(!t)throw new Error("Expected state to be defined");var r=t.view;var n=JSON.stringify(r.viewport);var i=this._current&&this._current.viewport;this._current=r;if(!this._currentViewportJSON||this._currentViewportJSON!==n){this._currentViewportJSON=n;if(this.element){requestAnimationFrame(function(){var t=r.viewport;e.element.style.left=t.x+"px";e.element.style.bottom=t.y+"px";e.element.style.width=t.width+"px";e.element.style.height=t.height+"px"})}this.viewportChangeEvent.raiseEvent({previous:i})}};e=n([i.inject("containerElement",o.SessionService,f.FocusService,s.ContextService)],e);
	return e}();e("ViewService",h);v=function(){function e(e,t,r,n){var i=this;this.viewService=e;this.realityService=t;this.contextService=r;this.sessionService=n;if(this.sessionService.isRealityManager){this.viewService.containingElementPromise.then(function(e){e.style.pointerEvents="auto";var t=-1;if(typeof PointerEvent!=="undefined"){var r=new Array;var n=-1;var a=1;var o=function(e){for(var t=0;t<r.length;t++){if(r[t].pointerId==e.pointerId){r.splice(t,1);break}}};var s=function(e){r.push(e)};var u=function(e){for(var o=0;o<r.length;o++){if(e.pointerId==r[o].pointerId){r[o]=e;break}}var s=i.contextService.serializedFrameState;if(!s)return;if(r.length==2){var u=Math.abs(r[0].clientX-r[1].clientX);var f=Math.abs(r[0].clientY-r[1].clientY);var l=u*u+f*f;if(n==-1){n=l;t=s.view.subviews[0].frustum.fov;a=1;i.realityService.zoom({zoom:a,fov:t,state:c.RealityZoomState.START})}else{a=l/n;i.realityService.zoom({zoom:a,fov:t,state:c.RealityZoomState.CHANGE})}}else{i.realityService.zoom({zoom:a,fov:t,state:c.RealityZoomState.END});n=-1}};var f=function(e){o(e);if(r.length<2)n=-1};e.onpointerdown=s;e.onpointermove=u;e.onpointerup=f;e.onpointercancel=f;e.onpointerout=f;e.onpointerleave=f}else{e.addEventListener("gesturestart",function(e){var r=i.contextService.serializedFrameState;if(r&&r.view.subviews[0]){t=r.view.subviews[0].frustum.fov;i.realityService.zoom({zoom:e.scale,fov:t,state:c.RealityZoomState.START})}});e.addEventListener("gesturechange",function(e){i.realityService.zoom({zoom:e.scale,fov:t,state:c.RealityZoomState.CHANGE})});e.addEventListener("gestureend",function(e){i.realityService.zoom({zoom:e.scale,fov:t,state:c.RealityZoomState.END})})}})}}e=n([i.inject(h,c.RealityService,s.ContextService,o.SessionService)],e);return e}();e("PinchZoomService",v)}}});e.register("18",["c","10","11","17"],function(e,t){"use strict";var r=t&&t.id;var n=this&&this.__extends||function(e,t){for(var r in t)if(t.hasOwnProperty(r))e[r]=t[r];function n(){this.constructor=e}e.prototype=t===null?Object.create(t):(n.prototype=t.prototype,new n)};var i=this&&this.__decorate||function(e,t,r,n){var i=arguments.length,a=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,r):n,o;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")a=Reflect.decorate(e,t,r,n);else for(var s=e.length-1;s>=0;s--)if(o=e[s])a=(i<3?o(a):i>3?o(t,r,a):o(t,r))||a;return i>3&&a&&Object.defineProperty(t,r,a),a};var a,o,s,u;var f;return{setters:[function(e){a=e},function(e){o=e},function(e){s=e},function(e){u=e}],execute:function(){f=function(e){n(t,e);function t(t,r){var n=this;e.call(this);this.sessionService=t;this.viewService=r;this.type="hosted";this.iframeElement=document.createElement("iframe");this.iframeElement.style.border="0";this.iframeElement.width="100%";this.iframeElement.height="100%";r.containingElementPromise.then(function(e){e.insertBefore(n.iframeElement,e.firstChild)})}t.prototype.load=function(e,t){var r=this;this.viewService.containingElementPromise.then(function(n){var i=function(n){if(n.data.type!=="ARGON_SESSION")return;var a=n.ports&&n.ports[0];if(!a)throw new Error("Received an ARGON_SESSION message without a MessagePort object");var o=0;var s;while(o<window.frames.length&&!s){if(window.frames[o]==n.source)s=document.getElementsByTagName("iframe")[o]}if(s!==r.iframeElement)return;window.removeEventListener("message",i);var u=r.sessionService.addManagedSessionPort(e.uri);t(u);u.open(a,r.sessionService.configuration)};window.addEventListener("message",i);r.iframeElement.src="";r.iframeElement.src=e.uri;r.iframeElement.style.pointerEvents="auto"})};t=i([a.inject(o.SessionService,u.ViewService)],t);return t}(s.RealityLoader);e("HostedRealityLoader",f)}}});(function(){var t=e.amdDefine;t("19",["1a","1b","1c","1d"],function(e,t,r,n){"use strict";function i(e,t){this._callback=undefined;this._isConstant=undefined;this._definitionChanged=new n;this.setCallback(e,t)}t(i.prototype,{isConstant:{get:function(){return this._isConstant}},definitionChanged:{get:function(){return this._definitionChanged}}});i.prototype.getValue=function(e,t){return this._callback(e,t)};i.prototype.setCallback=function(t,n){if(!e(t)){throw new r("callback is required.")}if(!e(n)){throw new r("isConstant is required.")}var i=this._callback!==t||this._isConstant!==n;this._callback=t;this._isConstant=n;if(i){this._definitionChanged.raiseEvent(this)}};i.prototype.equals=function(e){return this===e||e instanceof i&&this._callback===e._callback&&this._isConstant===e._isConstant};return i})})();(function(){var t=e.amdDefine;t("1e",["1f"],function(e){"use strict";var t={UNBOUNDED:0,CLAMPED:1,LOOP_STOP:2};return e(t)})})();(function(){var t=e.amdDefine;t("20",["1a"],function(e){"use strict";var t;if(typeof performance!=="undefined"&&e(performance.now)){t=function(){return performance.now()}}else{t=function(){return Date.now()}}return t})})();(function(){var t=e.amdDefine;t("21",["1e","22","23","1a","1c","1d","20","24"],function(e,t,r,n,i,a,o,s){"use strict";function u(u){u=r(u,r.EMPTY_OBJECT);var f=u.startTime;var c=!n(f);var l=u.stopTime;var d=!n(l);var h=u.currentTime;var v=!n(h);if(c&&d&&v){h=s.now();f=s.clone(h);l=s.addDays(h,1,new s)}else if(c&&d){f=s.clone(h);l=s.addDays(h,1,new s)}else if(c&&v){f=s.addDays(l,-1,new s);h=s.clone(f)}else if(v&&d){h=s.clone(f);l=s.addDays(f,1,new s)}else if(v){h=s.clone(f)}else if(d){l=s.addDays(h,1,new s)}else if(c){f=s.clone(h)}if(s.greaterThan(f,l)){throw new i("startTime must come before stopTime.")}this.startTime=f;this.stopTime=l;this.currentTime=h;this.multiplier=r(u.multiplier,1);this.clockStep=r(u.clockStep,t.SYSTEM_CLOCK_MULTIPLIER);this.clockRange=r(u.clockRange,e.UNBOUNDED);this.canAnimate=r(u.canAnimate,true);this.shouldAnimate=r(u.shouldAnimate,true);this.onTick=new a;this._lastSystemTime=o()}u.prototype.tick=function(){var r=o();var n=s.clone(this.currentTime);var i=this.startTime;var a=this.stopTime;var u=this.multiplier;if(this.canAnimate&&this.shouldAnimate){if(this.clockStep===t.SYSTEM_CLOCK){n=s.now(n)}else{if(this.clockStep===t.TICK_DEPENDENT){n=s.addSeconds(n,u,n)}else{var f=r-this._lastSystemTime;n=s.addSeconds(n,u*(f/1e3),n)}if(this.clockRange===e.CLAMPED){if(s.lessThan(n,i)){n=s.clone(i,n)}else if(s.greaterThan(n,a)){n=s.clone(a,n)}}else if(this.clockRange===e.LOOP_STOP){if(s.lessThan(n,i)){n=s.clone(i,n)}while(s.greaterThan(n,a)){n=s.addSeconds(i,s.secondsDifference(n,a),n)}}}}this.currentTime=n;this._lastSystemTime=r;this.onTick.raiseEvent(this);return n};return u})})();(function(){var t=e.amdDefine;t("22",["1f"],function(e){"use strict";var t={TICK_DEPENDENT:0,SYSTEM_CLOCK_MULTIPLIER:1,SYSTEM_CLOCK:2};return e(t)})})();(function(){var t=e.amdDefine;t("25",["26","1a","1b","1c","27","28","29"],function(e,t,r,n,i,a,o){"use strict";var s={id:undefined};var u=new Array(2);function f(e){var t=e.propertyNames;var r=t.length;for(var n=0;n<r;n++){e[t[n]]=undefined}}function c(e,t,r,n){u[0]=r;u[1]=n.id;t[JSON.stringify(u)]=n.definitionChanged.addEventListener(h.prototype._onDefinitionChanged,e)}function l(e,t,r,n){u[0]=r;u[1]=n.id;var i=JSON.stringify(u);t[i]();t[i]=undefined}function d(e){e._shouldRecomposite=true;if(e._suspendCount!==0){return}var r=e._collections;var n=r.length;var i=e._collectionsCopy;var u=i.length;var d;var v;var p;var m;var w;var y=e._composite;var g=new o(e);var S=e._eventHash;var b;for(d=0;d<u;d++){w=i[d];w.collectionChanged.removeEventListener(h.prototype._onCollectionChanged,e);p=w.values;b=w.id;for(m=p.length-1;m>-1;m--){v=p[m];l(e,S,b,v)}}for(d=n-1;d>=0;d--){w=r[d];w.collectionChanged.addEventListener(h.prototype._onCollectionChanged,e);p=w.values;b=w.id;for(m=p.length-1;m>-1;m--){v=p[m];c(e,S,b,v);var T=g.getById(v.id);if(!t(T)){T=y.getById(v.id);if(!t(T)){s.id=v.id;T=new a(s)}else{f(T)}g.add(T)}T.merge(v)}}e._collectionsCopy=r.slice(0);y.suspendEvents();y.removeAll();var _=g.values;for(d=0;d<_.length;d++){y.add(_[d])}y.resumeEvents()}function h(r,n){this._owner=n;this._composite=new o(this);this._suspendCount=0;this._collections=t(r)?r.slice():[];this._collectionsCopy=[];this._id=e();this._eventHash={};d(this);this._shouldRecomposite=false}r(h.prototype,{collectionChanged:{get:function(){return this._composite._collectionChanged}},id:{get:function(){return this._id}},values:{get:function(){return this._composite.values}},owner:{get:function(){return this._owner}}});h.prototype.addCollection=function(e,r){var i=t(r);if(!t(e)){throw new n("collection is required.")}if(i){if(r<0){throw new n("index must be greater than or equal to zero.")}else if(r>this._collections.length){throw new n("index must be less than or equal to the number of collections.")}}if(!i){r=this._collections.length;this._collections.push(e)}else{this._collections.splice(r,0,e)}d(this)};h.prototype.removeCollection=function(e){var t=this._collections.indexOf(e);if(t!==-1){this._collections.splice(t,1);d(this);return true}return false};h.prototype.removeAllCollections=function(){this._collections.length=0;d(this)};h.prototype.containsCollection=function(e){return this._collections.indexOf(e)!==-1};h.prototype.contains=function(e){return this._composite.contains(e)};h.prototype.indexOfCollection=function(e){return this._collections.indexOf(e)};h.prototype.getCollection=function(e){if(!t(e)){throw new n("index is required.","index")}return this._collections[e]};h.prototype.getCollectionsLength=function(){return this._collections.length};function v(e,r){if(!t(r)){throw new n("collection is required.")}var i=e.indexOf(r);if(i===-1){throw new n("collection is not in this composite.")}return i}function p(e,t,r){var n=e._collections;t=i.clamp(t,0,n.length-1);r=i.clamp(r,0,n.length-1);if(t===r){return}var a=n[t];n[t]=n[r];n[r]=a;d(e)}h.prototype.raiseCollection=function(e){var t=v(this._collections,e);p(this,t,t+1)};h.prototype.lowerCollection=function(e){var t=v(this._collections,e);p(this,t,t-1)};h.prototype.raiseCollectionToTop=function(e){var t=v(this._collections,e);if(t===this._collections.length-1){return}this._collections.splice(t,1);this._collections.push(e);d(this)};h.prototype.lowerCollectionToBottom=function(e){var t=v(this._collections,e);if(t===0){return}this._collections.splice(t,1);this._collections.splice(0,0,e);d(this)};h.prototype.suspendEvents=function(){this._suspendCount++;this._composite.suspendEvents()};h.prototype.resumeEvents=function(){if(this._suspendCount===0){throw new n("resumeEvents can not be called before suspendEvents.")}this._suspendCount--;if(this._shouldRecomposite&&this._suspendCount===0){d(this);this._shouldRecomposite=false}this._composite.resumeEvents()};h.prototype.computeAvailability=function(){return this._composite.computeAvailability()};h.prototype.getById=function(e){return this._composite.getById(e)};h.prototype._onCollectionChanged=function(e,r,n){var i=this._collectionsCopy;var o=i.length;var u=this._composite;u.suspendEvents();var d;var h;var v;var p;var m=n.length;var w=this._eventHash;var y=e.id;for(d=0;d<m;d++){var g=n[d];l(this,w,y,g);var S=g.id;for(h=o-1;h>=0;h--){v=i[h].getById(S);if(t(v)){if(!t(p)){p=u.getById(S);f(p)}p.merge(v)}}if(!t(p)){u.removeById(S)}p=undefined}var b=r.length;for(d=0;d<b;d++){var T=r[d];c(this,w,y,T);var _=T.id;for(h=o-1;h>=0;h--){v=i[h].getById(_);if(t(v)){if(!t(p)){p=u.getById(_);if(!t(p)){s.id=_;p=new a(s);u.add(p)}else{f(p)}}p.merge(v)}}p=undefined}u.resumeEvents()};h.prototype._onDefinitionChanged=function(e,r,n,i){var a=this._collections;var o=this._composite;var s=a.length;var u=e.id;var f=o.getById(u);var c=f[r];var l=!t(c);var d=true;for(var h=s-1;h>=0;h--){var v=a[h].getById(e.id);if(t(v)){var p=v[r];if(t(p)){if(d){d=false;if(t(p.merge)&&t(p.clone)){c=p.clone(c)}else{c=p;break}}c.merge(p)}}}if(l&&f.propertyNames.indexOf(r)===-1){f.addProperty(r)}f[r]=c};return h})})();(function(){var t=e.amdDefine;t("2a",["1a","1b","1c"],function(e,t,r){"use strict";function n(){this._array=[];this._hash={}}t(n.prototype,{length:{get:function(){return this._array.length}},values:{get:function(){return this._array}}});n.prototype.contains=function(t){if(typeof t!=="string"&&typeof t!=="number"){throw new r("key is required to be a string or number.")}return e(this._hash[t])};n.prototype.set=function(e,t){if(typeof e!=="string"&&typeof e!=="number"){throw new r("key is required to be a string or number.")}var n=this._hash[e];if(t!==n){this.remove(e);this._hash[e]=t;this._array.push(t)}};n.prototype.get=function(e){if(typeof e!=="string"&&typeof e!=="number"){throw new r("key is required to be a string or number.")}return this._hash[e]};n.prototype.remove=function(t){if(e(t)&&typeof t!=="string"&&typeof t!=="number"){throw new r("key is required to be a string or number.")}var n=this._hash[t];var i=e(n);if(i){var a=this._array;a.splice(a.indexOf(n),1);delete this._hash[t]}return i};n.prototype.removeAll=function(){var e=this._array;if(e.length>0){this._hash={};e.length=0}};return n})})();(function(){var t=e.amdDefine;t("26",[],function(){"use strict";function e(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var t=Math.random()*16|0;var r=e==="x"?t:t&3|8;return r.toString(16)})}return e})})();(function(){var t=e.amdDefine;t("2b",["2c","23","1a","1b","1c","1d","2d","2e"],function(e,t,r,n,i,a,o,s){"use strict";function u(r,n){this._definitionChanged=new a;this._value=e.clone(r);this._referenceFrame=t(n,o.FIXED)}n(u.prototype,{isConstant:{get:function(){return!r(this._value)||this._referenceFrame===o.FIXED}},definitionChanged:{get:function(){return this._definitionChanged}},referenceFrame:{get:function(){return this._referenceFrame}}});u.prototype.getValue=function(e,t){return this.getValueInReferenceFrame(e,o.FIXED,t)};u.prototype.setValue=function(t,n){var i=false;if(!e.equals(this._value,t)){i=true;this._value=e.clone(t)}if(r(n)&&this._referenceFrame!==n){i=true;this._referenceFrame=n}if(i){this._definitionChanged.raiseEvent(this)}};u.prototype.getValueInReferenceFrame=function(e,t,n){if(!r(e)){throw new i("time is required.")}if(!r(t)){throw new i("referenceFrame is required.")}return s.convertToReferenceFrame(e,this._value,this._referenceFrame,t,n)};u.prototype.equals=function(t){return this===t||t instanceof u&&e.equals(this._value,t._value)&&this._referenceFrame===t._referenceFrame};return u})})();(function(){var t=e.amdDefine;t("2f",["23","1a","1b","1c","1d"],function(e,t,r,n,i){"use strict";function a(e){this._value=undefined;this._hasClone=false;this._hasEquals=false;this._definitionChanged=new i;this.setValue(e)}r(a.prototype,{isConstant:{value:true},definitionChanged:{get:function(){return this._definitionChanged}}});a.prototype.getValue=function(e,t){return this._hasClone?this._value.clone(t):this._value};a.prototype.setValue=function(e){var r=this._value;if(r!==e){var n=t(e);var i=n&&typeof e.clone==="function";var a=n&&typeof e.equals==="function";this._hasClone=i;this._hasEquals=a;var o=!a||!e.equals(r);if(o){this._value=!i?e:e.clone();this._definitionChanged.raiseEvent(this)}}};a.prototype.equals=function(e){return this===e||e instanceof a&&(!this._hasEquals&&this._value===e._value||this._hasEquals&&this._value.equals(e._value))};return a})})();(function(){var t=e.amdDefine;t("30",["23","1a","2f"],function(e,t,r){"use strict";function n(e,r,n,i,a){return{configurable:i,get:function(){return this[r]},set:function(i){var o=this[r];var s=this[n];if(t(s)){s();this[n]=undefined}var u=t(i);if(u&&!t(i.getValue)&&t(a)){i=a(i)}if(o!==i){this[r]=i;this._definitionChanged.raiseEvent(this,e,i,o)}if(t(i)&&t(i.definitionChanged)){this[n]=i.definitionChanged.addEventListener(function(){this._definitionChanged.raiseEvent(this,e,i,i)},this)}}}}function i(e){return new r(e)}function a(t,r,a){return n(t,"_"+t.toString(),"_"+t.toString()+"Subscription",e(r,false),e(a,i))}return a})})();(function(){var t=e.amdDefine;t("31",["30"],function(e){"use strict";function t(e){return e}function r(r,n){return e(r,n,t)}return r})})();(function(){var t=e.amdDefine;t("28",["2c","26","23","1a","1b","1c","1d","32","33","34","35","@empty","@empty","2b","@empty","30","31","@empty","@empty","@empty","@empty","@empty","@empty","@empty","@empty","@empty","@empty","36","@empty","@empty"],function(e,t,r,n,i,a,o,s,u,f,c,l,d,h,v,p,m,w,y,g,S,b,T,_,E,M,P,A,C,I){"use strict";function x(e){return new h(e)}function R(e){return p(e,undefined,x)}function O(e,t){return p(e,undefined,function(e){if(e instanceof t){return e}return new t(e)})}function D(e){e=r(e,r.EMPTY_OBJECT);var i=e.id;if(!n(i)){i=t()}this._availability=undefined;this._id=i;this._definitionChanged=new o;this._name=e.name;this._show=r(e.show,true);this._parent=undefined;this._propertyNames=["billboard","box","corridor","cylinder","description","ellipse","ellipsoid","label","model","orientation","path","point","polygon","polyline","polylineVolume","position","rectangle","viewFrom","wall"];this._billboard=undefined;this._billboardSubscription=undefined;this._box=undefined;this._boxSubscription=undefined;this._corridor=undefined;this._corridorSubscription=undefined;this._cylinder=undefined;this._cylinderSubscription=undefined;this._description=undefined;this._descriptionSubscription=undefined;this._ellipse=undefined;this._ellipseSubscription=undefined;this._ellipsoid=undefined;this._ellipsoidSubscription=undefined;this._label=undefined;this._labelSubscription=undefined;this._model=undefined;this._modelSubscription=undefined;this._orientation=undefined;this._orientationSubscription=undefined;this._path=undefined;this._pathSubscription=undefined;this._point=undefined;this._pointSubscription=undefined;this._polygon=undefined;this._polygonSubscription=undefined;this._polyline=undefined;this._polylineSubscription=undefined;this._polylineVolume=undefined;this._polylineVolumeSubscription=undefined;this._position=undefined;this._positionSubscription=undefined;this._rectangle=undefined;this._rectangleSubscription=undefined;this._viewFrom=undefined;this._viewFromSubscription=undefined;this._wall=undefined;this._wallSubscription=undefined;this._children=[];this.entityCollection=undefined;this.parent=e.parent;this.merge(e)}function q(e,t,r){var n=t.length;for(var i=0;i<n;i++){var a=t[i];var o=a._show;var s=!r&&o;var u=r&&o;if(s!==u){q(a,a._children,r)}}e._definitionChanged.raiseEvent(e,"isShowing",r,!r)}i(D.prototype,{availability:m("availability"),id:{get:function(){return this._id}},definitionChanged:{get:function(){return this._definitionChanged}},name:m("name"),show:{get:function(){return this._show},set:function(e){if(!n(e)){throw new a("value is required.")}if(e===this._show){return}var t=this.isShowing;this._show=e;var r=this.isShowing;if(t!==r){q(this,this._children,r)}this._definitionChanged.raiseEvent(this,"show",e,!e)}},isShowing:{get:function(){return this._show&&(!n(this.entityCollection)||this.entityCollection.show)&&(!n(this._parent)||this._parent.isShowing)}},parent:{get:function(){return this._parent},set:function(e){var t=this._parent;if(t===e){return}var r=this.isShowing;if(n(t)){var i=t._children.indexOf(this);t._children.splice(i,1)}this._parent=e;if(n(e)){e._children.push(this)}var a=this.isShowing;if(r!==a){q(this,this._children,a)}this._definitionChanged.raiseEvent(this,"parent",e,t)}},propertyNames:{get:function(){return this._propertyNames}},billboard:O("billboard",l),box:O("box",d),corridor:O("corridor",v),cylinder:O("cylinder",w),description:p("description"),ellipse:O("ellipse",y),ellipsoid:O("ellipsoid",g),label:O("label",S),model:O("model",b),orientation:p("orientation"),path:O("path",T),point:O("point",_),polygon:O("polygon",E),polyline:O("polyline",M),polylineVolume:O("polylineVolume",P),position:R("position"),rectangle:O("rectangle",C),viewFrom:p("viewFrom"),wall:O("wall",I)});D.prototype.isAvailable=function(e){if(!n(e)){throw new a("time is required.")}var t=this._availability;return!n(t)||t.contains(e)};D.prototype.addProperty=function(e){var t=this._propertyNames;if(!n(e)){throw new a("propertyName is required.")}if(t.indexOf(e)!==-1){throw new a(e+" is already a registered property.")}if(e in this){throw new a(e+" is a reserved property name.")}t.push(e);Object.defineProperty(this,e,m(e,true))};D.prototype.removeProperty=function(e){var t=this._propertyNames;var r=t.indexOf(e);if(!n(e)){throw new a("propertyName is required.")}if(r===-1){throw new a(e+" is not a registered property.")}this._propertyNames.splice(r,1);delete this[e]};D.prototype.merge=function(e){if(!n(e)){throw new a("source is required.")}this.name=r(this.name,e.name);this.availability=r(e.availability,this.availability);var t=this._propertyNames;var i=n(e._propertyNames)?e._propertyNames:Object.keys(e);var o=i.length;for(var s=0;s<o;s++){var u=i[s];if(u==="parent"){continue}var f=this[u];var c=e[u];if(!n(f)&&t.indexOf(u)===-1){this.addProperty(u)}if(n(c)){if(n(f)){if(n(f.merge)){f.merge(c)}}else if(n(c.merge)&&n(c.clone)){this[u]=c.clone()}else{this[u]=c}}}};var N=new s;var G=new e;var L=new f;D.prototype._getModelMatrix=function(e,t){var r=A.getValueOrUndefined(this._position,e,G);if(!n(r)){return undefined}var i=A.getValueOrUndefined(this._orientation,e,L);if(!n(i)){t=c.eastNorthUpToFixedFrame(r,undefined,t)}else{t=u.fromRotationTranslation(s.fromQuaternion(i,N),r,t)}return t};return D})})();(function(){var t=e.amdDefine;t("29",["2a","26","1a","1b","1c","1d","37","24","38","39","28"],function(e,t,r,n,i,a,o,s,u,f,c){"use strict";var l={id:undefined};function d(e){if(e._firing){e._refire=true;return}if(e._suspendCount===0){var t=e._addedEntities;var r=e._removedEntities;var n=e._changedEntities;if(n.length!==0||t.length!==0||r.length!==0){e._firing=true;do{e._refire=false;var i=t.values.slice(0);var a=r.values.slice(0);var o=n.values.slice(0);t.removeAll();r.removeAll();n.removeAll();e._collectionChanged.raiseEvent(e,i,a,o)}while(e._refire);e._firing=false}}}function h(r){this._owner=r;this._entities=new e;this._addedEntities=new e;this._removedEntities=new e;this._changedEntities=new e;this._suspendCount=0;this._collectionChanged=new a;this._id=t();this._show=true;this._firing=false;this._refire=false}h.prototype.suspendEvents=function(){this._suspendCount++};h.prototype.resumeEvents=function(){if(this._suspendCount===0){throw new i("resumeEvents can not be called before suspendEvents.")}this._suspendCount--;d(this)};h.collectionChangedEventCallback=undefined;n(h.prototype,{collectionChanged:{get:function(){return this._collectionChanged}},id:{get:function(){return this._id}},values:{get:function(){return this._entities.values}},show:{get:function(){return this._show},set:function(e){if(!r(e)){throw new i("value is required.")}if(e===this._show){return}this.suspendEvents();var t;var n=[];var a=this._entities.values;var o=a.length;for(t=0;t<o;t++){n.push(a[t].isShowing)}this._show=e;for(t=0;t<o;t++){var s=n[t];var u=a[t];if(s!==u.isShowing){u.definitionChanged.raiseEvent(u,"isShowing",u.isShowing,s)}}this.resumeEvents()}},owner:{get:function(){return this._owner}}});h.prototype.computeAvailability=function(){var e=o.MAXIMUM_VALUE;var t=o.MINIMUM_VALUE;var n=this._entities.values;for(var i=0,a=n.length;i<a;i++){var u=n[i];var c=u.availability;if(r(c)){var l=c.start;var d=c.stop;if(s.lessThan(l,e)&&!l.equals(o.MINIMUM_VALUE)){e=l}if(s.greaterThan(d,t)&&!d.equals(o.MAXIMUM_VALUE)){t=d}}}if(o.MAXIMUM_VALUE.equals(e)){e=o.MINIMUM_VALUE}if(o.MINIMUM_VALUE.equals(t)){t=o.MAXIMUM_VALUE}return new f({start:e,stop:t})};h.prototype.add=function(e){if(!r(e)){throw new i("entity is required.")}if(!(e instanceof c)){e=new c(e)}var t=e.id;var n=this._entities;if(n.contains(t)){throw new u("An entity with id "+t+" already exists in this collection.")}e.entityCollection=this;n.set(t,e);if(!this._removedEntities.remove(t)){this._addedEntities.set(t,e)}e.definitionChanged.addEventListener(h.prototype._onEntityDefinitionChanged,this);d(this);return e};h.prototype.remove=function(e){if(!r(e)){return false}return this.removeById(e.id)};h.prototype.contains=function(e){if(!r(e)){throw new i("entity is required")}return this._entities.get(e.id)===e};h.prototype.removeById=function(e){if(!r(e)){return false}var t=this._entities;var n=t.get(e);if(!this._entities.remove(e)){return false}if(!this._addedEntities.remove(e)){this._removedEntities.set(e,n);this._changedEntities.remove(e)}this._entities.remove(e);n.definitionChanged.removeEventListener(h.prototype._onEntityDefinitionChanged,this);d(this);return true};h.prototype.removeAll=function(){var e=this._entities;var t=e.length;var n=e.values;var i=this._addedEntities;var a=this._removedEntities;for(var o=0;o<t;o++){var s=n[o];var u=s.id;var f=i.get(u);if(!r(f)){s.definitionChanged.removeEventListener(h.prototype._onEntityDefinitionChanged,this);a.set(u,s)}}e.removeAll();i.removeAll();this._changedEntities.removeAll();d(this)};h.prototype.getById=function(e){if(!r(e)){throw new i("id is required.")}return this._entities.get(e)};h.prototype.getOrCreateEntity=function(e){if(!r(e)){throw new i("id is required.")}var t=this._entities.get(e);if(!r(t)){l.id=e;t=new c(l);this.add(t)}return t};h.prototype._onEntityDefinitionChanged=function(e){var t=e.id;if(!this._addedEntities.contains(t)){this._changedEntities.set(t,e)}d(this)};return h})})();(function(){var t=e.amdDefine;t("3a",["2c","3b","23","1a","1b","1c","3c"],function(e,t,r,n,i,a,o){"use strict";function s(e){this._ellipsoid=r(e,o.WGS84);this._semimajorAxis=this._ellipsoid.maximumRadius;this._oneOverSemimajorAxis=1/this._semimajorAxis}i(s.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}});s.prototype.project=function(t,r){var i=this._semimajorAxis;var a=t.longitude*i;var o=t.latitude*i;var s=t.height;if(!n(r)){return new e(a,o,s)}r.x=a;r.y=o;r.z=s;return r};s.prototype.unproject=function(e,r){if(!n(e)){throw new a("cartesian is required")}var i=this._oneOverSemimajorAxis;var o=e.x*i;var s=e.y*i;var u=e.z;if(!n(r)){return new t(o,s,u)}r.longitude=o;r.latitude=s;r.height=u;return r};return s})})();(function(){var t=e.amdDefine;t("3d",["23","1a","1c","27"],function(e,t,r,n){"use strict";var i=n.factorial;function a(e,t,r,n,i,o){var s=0;var u;var f;var c;if(n>0){for(f=0;f<i;f++){u=false;for(c=0;c<o.length&&!u;c++){if(f===o[c]){u=true}}if(!u){o.push(f);s+=a(e,t,r,n-1,i,o);o.splice(o.length-1,1)}}return s}s=1;for(f=0;f<i;f++){u=false;for(c=0;c<o.length&&!u;c++){if(f===o[c]){u=true}}if(!u){s*=e-r[t[f]]}}return s}var o={type:"Hermite"};o.getRequiredDataPoints=function(n,i){i=e(i,0);if(!t(n)){throw new r("degree is required.")}if(n<0){throw new r("degree must be 0 or greater.")}if(i<0){throw new r("inputOrder must be 0 or greater.")}return Math.max(Math.floor((n+1)/(i+1)),2)};o.interpolateOrderZero=function(e,r,n,o,s){if(!t(s)){s=new Array(o)}var u;var f;var c;var l;var d;var h;var v=r.length;var p=new Array(o);for(u=0;u<o;u++){s[u]=0;var m=new Array(v);p[u]=m;for(f=0;f<v;f++){m[f]=[]}}var w=v,y=new Array(w);for(u=0;u<w;u++){y[u]=u}var g=v-1;for(l=0;l<o;l++){for(f=0;f<w;f++){h=y[f]*o+l;p[l][0].push(n[h])}for(u=1;u<w;u++){var S=false;for(f=0;f<w-u;f++){var b=r[y[f]];var T=r[y[f+u]];var _;if(T-b<=0){h=y[f]*o+o*u+l;_=n[h];p[l][u].push(_/i(u))}else{_=p[l][u-1][f+1]-p[l][u-1][f];p[l][u].push(_/(T-b))}S=S||_!==0}if(!S){g=u-1}}}for(c=0,d=0;c<=d;c++){for(u=c;u<=g;u++){var E=a(e,y,r,c,u,[]);for(l=0;l<o;l++){var M=p[l][u][0];s[l+c*o]+=M*E}}}return s};var s=[];o.interpolate=function(e,r,n,i,o,f,c){var l=i*(f+1);if(!t(c)){c=new Array(l)}for(var d=0;d<l;d++){c[d]=0}var h=r.length;var v=new Array(h*(o+1));for(var p=0;p<h;p++){for(var m=0;m<o+1;m++){v[p*(o+1)+m]=p}}var w=v.length;var y=s;var g=u(y,v,r,n,i,o);var S=[];var b=w*(w+1)/2;var T=Math.min(g,f);for(var _=0;_<=T;_++){for(p=_;p<=g;p++){S.length=0;var E=a(e,v,r,_,p,S);var M=Math.floor(p*(1-p)/2)+w*p;for(var P=0;P<i;P++){var A=Math.floor(P*b);var C=y[A+M];c[P+_*i]+=C*E}}}return c};function u(e,t,r,i,a,o){var s;var u;var f=-1;var c=t.length;var l=c*(c+1)/2;for(var d=0;d<a;d++){var h=Math.floor(d*l);for(s=0;s<c;s++){u=t[s]*a*(o+1)+d;e[h+s]=i[u]}for(var v=1;v<c;v++){var p=0;var m=Math.floor(v*(1-v)/2)+c*v;var w=false;for(s=0;s<c-v;s++){var y=r[t[s]];var g=r[t[s+v]];var S;var b;if(g-y<=0){u=t[s]*a*(o+1)+a*v+d;S=i[u];b=S/n.factorial(v);e[h+m+p]=b;p++}else{var T=Math.floor((v-1)*(2-v)/2)+c*(v-1);S=e[h+T+s+1]-e[h+T+s];b=S/(g-y);e[h+m+p]=b;p++}w=w||S!==0}if(w){f=Math.max(f,v)}}}return f}return o})})();(function(){var t=e.amdDefine;t("3e",["1a","1b","1c","32","34","2d","35"],function(e,t,r,n,i,a,o){"use strict";var s=function(){r.throwInstantiationError()};t(s.prototype,{isConstant:{get:r.throwInstantiationError},definitionChanged:{get:r.throwInstantiationError}});s.prototype.getValue=r.throwInstantiationError;s.prototype.equals=r.throwInstantiationError;function u(e,t){return e&&e.id?e.id===(t&&t.id):e===t}function f(t){var r=[];while(e(t)){r.unshift(t);t=t.position&&t.position.referenceFrame}return r}function c(e,t){if(!u(e[0],t[0])){return-1}var r=Math.min(e.length,t.length);for(var n=0;n<=r;n++){if(!u(e[n],t[n])){return n-1}}return-1}var l=new n;var d=new i;function h(t){var r=o.computeIcrfToFixedMatrix(t,l);if(!e(r)){r=o.computeTemeToPseudoFixedMatrix(t,l)}return i.fromRotationMatrix(r,d)}var v=new i;s.convertToReferenceFrame=function(t,r,n,o,s){if(!e(r)){return r}if(!e(s)){s=new i}if(n===o){return i.clone(r,s)}if(!e(n)||!e(o)){return undefined}var u=f(n);var l=f(o);var d=c(u,l);var p=u[d];var m=function(r,n){if(!e(r)){return r}var a=n.orientation;if(!e(a)){return undefined}var o=a.getValue(t,v);if(!e(o)){return undefined}return i.multiply(o,r,r)};var w=function(r,n){if(!e(r)){return r}var a=n.orientation;if(!e(a)){return undefined}var o=a.getValue(t,v);if(!e(o)){return undefined}i.conjugate(o,o);return i.multiply(o,r,r)};if(e(p)){u=u.slice(d+1);l=l.slice(d+1);var y=u.reduceRight(m,i.clone(r,s));if(!e(y)){return undefined}return l.reduce(w,y)}var g=u.shift();var S=l.shift();var b,T;if(g===a.INERTIAL&&S===a.FIXED){T=u.reduceRight(m,i.clone(r,s));if(!e(T)){return undefined}b=i.multiply(h(t),T,s);return l.reduce(w,b)}if(g===a.FIXED&&S===a.INERTIAL){b=u.reduceRight(m,i.clone(r,s));if(!e(b)){return undefined}var _=i.conjugate(h(t),v);T=i.multiply(_,b,s);return l.reduce(w,T)}return undefined};return s})})();(function(){var t=e.amdDefine;t("3f",["1a","1b","1c","40"],function(e,t,r,n){"use strict";function i(){this._offCenterFrustum=new n;this.fov=undefined;this._fov=undefined;this._fovy=undefined;this._sseDenominator=undefined;this.aspectRatio=undefined;this._aspectRatio=undefined;this.near=1;this._near=this.near;this.far=5e8;this._far=this.far;this.xOffset=0;this._xOffset=this.xOffset;this.yOffset=0;this._yOffset=this.yOffset}function a(t){if(!e(t.fov)||!e(t.aspectRatio)||!e(t.near)||!e(t.far)){throw new r("fov, aspectRatio, near, or far parameters are not set.")}var n=t._offCenterFrustum;if(t.fov!==t._fov||t.aspectRatio!==t._aspectRatio||t.near!==t._near||t.far!==t._far||t.xOffset!==t._xOffset||t.yOffset!==t._yOffset){if(t.fov<0||t.fov>=Math.PI){throw new r("fov must be in the range [0, PI).")}if(t.aspectRatio<0){throw new r("aspectRatio must be positive.")}if(t.near<0||t.near>t.far){throw new r("near must be greater than zero and less than far.")}t._aspectRatio=t.aspectRatio;t._fov=t.fov;t._fovy=t.aspectRatio<=1?t.fov:Math.atan(Math.tan(t.fov*.5)/t.aspectRatio)*2;t._near=t.near;t._far=t.far;t._sseDenominator=2*Math.tan(.5*t._fovy);t._xOffset=t.xOffset;t._yOffset=t.yOffset;n.top=t.near*Math.tan(.5*t._fovy);n.bottom=-n.top;n.right=t.aspectRatio*n.top;n.left=-n.right;n.near=t.near;n.far=t.far;n.right+=t.xOffset;n.left+=t.xOffset;n.top+=t.yOffset;n.bottom+=t.yOffset}}t(i.prototype,{projectionMatrix:{get:function(){a(this);return this._offCenterFrustum.projectionMatrix}},infiniteProjectionMatrix:{get:function(){a(this);return this._offCenterFrustum.infiniteProjectionMatrix}},fovy:{get:function(){a(this);return this._fovy}},sseDenominator:{get:function(){a(this);return this._sseDenominator}}});i.prototype.computeCullingVolume=function(e,t,r){a(this);return this._offCenterFrustum.computeCullingVolume(e,t,r)};i.prototype.getPixelDimensions=function(e,t,r,n){a(this);return this._offCenterFrustum.getPixelDimensions(e,t,r,n);
	};i.prototype.clone=function(t){if(!e(t)){t=new i}t.aspectRatio=this.aspectRatio;t.fov=this.fov;t.near=this.near;t.far=this.far;t._aspectRatio=undefined;t._fov=undefined;t._near=undefined;t._far=undefined;this._offCenterFrustum.clone(t._offCenterFrustum);return t};i.prototype.equals=function(t){if(!e(t)){return false}a(this);a(t);return this.fov===t.fov&&this.aspectRatio===t.aspectRatio&&this.near===t.near&&this.far===t.far&&this._offCenterFrustum.equals(t._offCenterFrustum)};return i})})();(function(){var t=e.amdDefine;t("41",["1f"],function(e){"use strict";var t={OUTSIDE:-1,INTERSECTING:0,INSIDE:1};return e(t)})})();(function(){var t=e.amdDefine;t("42",["2c","43","23","1a","1c","41","44"],function(e,t,r,n,i,a,o){"use strict";function s(e){this.planes=r(e,[])}var u=[new e,new e,new e];e.clone(e.UNIT_X,u[0]);e.clone(e.UNIT_Y,u[1]);e.clone(e.UNIT_Z,u[2]);var f=new e;var c=new e;var l=new o(new e,0);s.fromBoundingSphere=function(r,a){if(!n(r)){throw new i("boundingSphere is required.")}if(!n(a)){a=new s}var o=u.length;var l=a.planes;l.length=2*o;var d=r.center;var h=r.radius;var v=0;for(var p=0;p<o;++p){var m=u[p];var w=l[v];var y=l[v+1];if(!n(w)){w=l[v]=new t}if(!n(y)){y=l[v+1]=new t}e.multiplyByScalar(m,-h,f);e.add(d,f,f);w.x=m.x;w.y=m.y;w.z=m.z;w.w=-e.dot(m,f);e.multiplyByScalar(m,h,f);e.add(d,f,f);y.x=-m.x;y.y=-m.y;y.z=-m.z;y.w=-e.dot(e.negate(m,c),f);v+=2}return a};s.prototype.computeVisibility=function(e){if(!n(e)){throw new i("boundingVolume is required.")}var t=this.planes;var r=false;for(var s=0,u=t.length;s<u;++s){var f=e.intersectPlane(o.fromCartesian4(t[s],l));if(f===a.OUTSIDE){return a.OUTSIDE}else if(f===a.INTERSECTING){r=true}}return r?a.INTERSECTING:a.INSIDE};s.prototype.computeVisibilityWithPlaneMask=function(e,t){if(!n(e)){throw new i("boundingVolume is required.")}if(!n(t)){throw new i("parentPlaneMask is required.")}if(t===s.MASK_OUTSIDE||t===s.MASK_INSIDE){return t}var r=s.MASK_INSIDE;var u=this.planes;for(var f=0,c=u.length;f<c;++f){var d=f<31?1<<f:0;if(f<31&&(t&d)===0){continue}var h=e.intersectPlane(o.fromCartesian4(u[f],l));if(h===a.OUTSIDE){return s.MASK_OUTSIDE}else if(h===a.INTERSECTING){r|=d}}return r};s.MASK_OUTSIDE=4294967295;s.MASK_INSIDE=0;s.MASK_INDETERMINATE=2147483647;return s})})();(function(){var t=e.amdDefine;t("40",["45","2c","43","23","1a","1b","1c","33","42"],function(e,t,r,n,i,a,o,s,u){"use strict";function f(){this.left=undefined;this._left=undefined;this.right=undefined;this._right=undefined;this.top=undefined;this._top=undefined;this.bottom=undefined;this._bottom=undefined;this.near=1;this._near=this.near;this.far=5e8;this._far=this.far;this._cullingVolume=new u;this._perspectiveMatrix=new s;this._infinitePerspective=new s}function c(e){if(!i(e.right)||!i(e.left)||!i(e.top)||!i(e.bottom)||!i(e.near)||!i(e.far)){throw new o("right, left, top, bottom, near, or far parameters are not set.")}var t=e.top;var r=e.bottom;var n=e.right;var a=e.left;var u=e.near;var f=e.far;if(t!==e._top||r!==e._bottom||a!==e._left||n!==e._right||u!==e._near||f!==e._far){if(e.near<=0||e.near>e.far){throw new o("near must be greater than zero and less than far.")}e._left=a;e._right=n;e._top=t;e._bottom=r;e._near=u;e._far=f;e._perspectiveMatrix=s.computePerspectiveOffCenter(a,n,r,t,u,f,e._perspectiveMatrix);e._infinitePerspective=s.computeInfinitePerspectiveOffCenter(a,n,r,t,u,e._infinitePerspective)}}a(f.prototype,{projectionMatrix:{get:function(){c(this);return this._perspectiveMatrix}},infiniteProjectionMatrix:{get:function(){c(this);return this._infinitePerspective}}});var l=new t;var d=new t;var h=new t;var v=new t;f.prototype.computeCullingVolume=function(e,n,a){if(!i(e)){throw new o("position is required.")}if(!i(n)){throw new o("direction is required.")}if(!i(a)){throw new o("up is required.")}var s=this._cullingVolume.planes;var u=this.top;var f=this.bottom;var c=this.right;var p=this.left;var m=this.near;var w=this.far;var y=t.cross(n,a,l);var g=d;t.multiplyByScalar(n,m,g);t.add(e,g,g);var S=h;t.multiplyByScalar(n,w,S);t.add(e,S,S);var b=v;t.multiplyByScalar(y,p,b);t.add(g,b,b);t.subtract(b,e,b);t.normalize(b,b);t.cross(b,a,b);var T=s[0];if(!i(T)){T=s[0]=new r}T.x=b.x;T.y=b.y;T.z=b.z;T.w=-t.dot(b,e);t.multiplyByScalar(y,c,b);t.add(g,b,b);t.subtract(b,e,b);t.normalize(b,b);t.cross(a,b,b);T=s[1];if(!i(T)){T=s[1]=new r}T.x=b.x;T.y=b.y;T.z=b.z;T.w=-t.dot(b,e);t.multiplyByScalar(a,f,b);t.add(g,b,b);t.subtract(b,e,b);t.normalize(b,b);t.cross(y,b,b);T=s[2];if(!i(T)){T=s[2]=new r}T.x=b.x;T.y=b.y;T.z=b.z;T.w=-t.dot(b,e);t.multiplyByScalar(a,u,b);t.add(g,b,b);t.subtract(b,e,b);t.normalize(b,b);t.cross(b,y,b);T=s[3];if(!i(T)){T=s[3]=new r}T.x=b.x;T.y=b.y;T.z=b.z;T.w=-t.dot(b,e);T=s[4];if(!i(T)){T=s[4]=new r}T.x=n.x;T.y=n.y;T.z=n.z;T.w=-t.dot(n,g);t.negate(n,b);T=s[5];if(!i(T)){T=s[5]=new r}T.x=b.x;T.y=b.y;T.z=b.z;T.w=-t.dot(b,S);return this._cullingVolume};f.prototype.getPixelDimensions=function(e,t,r,n){c(this);if(!i(e)||!i(t)){throw new o("Both drawingBufferWidth and drawingBufferHeight are required.")}if(e<=0){throw new o("drawingBufferWidth must be greater than zero.")}if(t<=0){throw new o("drawingBufferHeight must be greater than zero.")}if(!i(r)){throw new o("distance is required.")}if(!i(n)){throw new o("A result object is required.")}var a=1/this.near;var s=this.top*a;var u=2*r*s/t;s=this.right*a;var f=2*r*s/e;n.x=f;n.y=u;return n};f.prototype.clone=function(e){if(!i(e)){e=new f}e.right=this.right;e.left=this.left;e.top=this.top;e.bottom=this.bottom;e.near=this.near;e.far=this.far;e._left=undefined;e._right=undefined;e._top=undefined;e._bottom=undefined;e._near=undefined;e._far=undefined;return e};f.prototype.equals=function(e){return i(e)&&this.right===e.right&&this.left===e.left&&this.top===e.top&&this.bottom===e.bottom&&this.near===e.near&&this.far===e.far};return f})})();(function(){var t=e.amdDefine;t("46",["1a","1b","1c","1d","36"],function(e,t,r,n,i){"use strict";function a(t){var r=t._targetEntity;if(t._resolveEntity){r=t._targetCollection.getById(t._targetId);if(e(r)){t._targetEntity=r;t._resolveEntity=false}}return r}var o=function(t,i){if(!e(t)){throw new r("targetCollection is required.")}if(!e(i)||i===""){throw new r("targetId is required.")}this._targetCollection=t;this._targetId=i;this._targetEntity=undefined;this._definitionChanged=new n;this._resolveEntity=true;t.collectionChanged.addEventListener(o.prototype._onCollectionChanged,this)};t(o.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},id:{get:function(){return this._targetId}},position:{get:function(){var t=a(this);return e(t)?t.position:undefined}},orientation:{get:function(){var t=a(this);return e(t)?t.orientation:undefined}},targetId:{get:function(){return this._targetId}},targetCollection:{get:function(){return this._targetCollection}},resolvedEntity:{get:function(){return a(this)}}});o.prototype._onCollectionChanged=function(t,r,n){var i=this._targetEntity;if(e(i)){if(n.indexOf(i)!==-1){this._resolveEntity=true}else if(this._resolveEntity){a(this);if(!this._resolveEntity){this._definitionChanged.raiseEvent(this)}}}};return o})})();(function(){var t=e.amdDefine;t("47",["1a","1b","1c","1d","38","36"],function(e,t,r,n,i,a){"use strict";function o(t){var r=true;if(t._resolveEntity){var n=t._targetCollection.getById(t._targetId);if(e(n)){n.definitionChanged.addEventListener(u.prototype._onTargetEntityDefinitionChanged,t);t._targetEntity=n;t._resolveEntity=false}else{n=t._targetEntity;r=false}if(!e(n)){throw new i('target entity "'+t._targetId+'" could not be resolved.')}}return r}function s(t){var r=t._targetProperty;if(t._resolveProperty){var n=o(t);var a=t._targetPropertyNames;r=t._targetEntity;var s=a.length;for(var u=0;u<s&&e(r);u++){r=r[a[u]]}if(e(r)){t._targetProperty=r;t._resolveProperty=!n}else if(!e(t._targetProperty)){throw new i('targetProperty "'+t._targetId+"."+a.join(".")+'" could not be resolved.')}}return r}function u(t,i,a){if(!e(t)){throw new r("targetCollection is required.")}if(!e(i)||i===""){throw new r("targetId is required.")}if(!e(a)||a.length===0){throw new r("targetPropertyNames is required.")}for(var o=0;o<a.length;o++){var s=a[o];if(!e(s)||s===""){throw new r("reference contains invalid properties.")}}this._targetCollection=t;this._targetId=i;this._targetPropertyNames=a;this._targetProperty=undefined;this._targetEntity=undefined;this._definitionChanged=new n;this._resolveEntity=true;this._resolveProperty=true;t.collectionChanged.addEventListener(u.prototype._onCollectionChanged,this)}t(u.prototype,{isConstant:{get:function(){return a.isConstant(s(this))}},definitionChanged:{get:function(){return this._definitionChanged}},referenceFrame:{get:function(){return s(this).referenceFrame}},targetId:{get:function(){return this._targetId}},targetCollection:{get:function(){return this._targetCollection}},targetPropertyNames:{get:function(){return this._targetPropertyNames}},resolvedProperty:{get:function(){return s(this)}}});u.fromString=function(t,n){if(!e(t)){throw new r("targetCollection is required.")}if(!e(n)){throw new r("referenceString is required.")}var i;var a=[];var o=true;var s=false;var f="";for(var c=0;c<n.length;++c){var l=n.charAt(c);if(s){f+=l;s=false}else if(l==="\\"){s=true}else if(o&&l==="#"){i=f;o=false;f=""}else if(!o&&l==="."){a.push(f);f=""}else{f+=l}}a.push(f);return new u(t,i,a)};u.prototype.getValue=function(e,t){return s(this).getValue(e,t)};u.prototype.getValueInReferenceFrame=function(e,t,r){return s(this).getValueInReferenceFrame(e,t,r)};u.prototype.getType=function(e){return s(this).getType(e)};u.prototype.equals=function(e){if(this===e){return true}var t=this._targetPropertyNames;var r=e._targetPropertyNames;if(this._targetCollection!==e._targetCollection||this._targetId!==e._targetId||t.length!==r.length){return false}var n=this._targetPropertyNames.length;for(var i=0;i<n;i++){if(t[i]!==r[i]){return false}}return true};u.prototype._onTargetEntityDefinitionChanged=function(e,t,r,n){if(this._targetPropertyNames[0]===t){this._resolveProperty=true;this._definitionChanged.raiseEvent(this)}};u.prototype._onCollectionChanged=function(t,r,n){var i=this._targetEntity;if(e(i)){if(n.indexOf(i)!==-1){i.definitionChanged.removeEventListener(u.prototype._onTargetEntityDefinitionChanged,this);this._resolveEntity=true;this._resolveProperty=true}else if(this._resolveEntity){s(this);if(!this._resolveEntity){this._definitionChanged.raiseEvent(this)}}}};return u})})();(function(){var t=e.amdDefine;t("2d",["1f"],function(e){"use strict";var t={FIXED:0,INERTIAL:1};return e(t)})})();(function(){var t=e.amdDefine;t("2e",["2c","1a","1b","1c","32","33","34","2d","35"],function(e,t,r,n,i,a,o,s,u){"use strict";function f(){n.throwInstantiationError()}r(f.prototype,{isConstant:{get:n.throwInstantiationError},definitionChanged:{get:n.throwInstantiationError},referenceFrame:{get:n.throwInstantiationError}});f.prototype.getValue=n.throwInstantiationError;f.prototype.getValueInReferenceFrame=n.throwInstantiationError;f.prototype.equals=n.throwInstantiationError;function c(e,t){return e&&e.id?e.id===(t&&t.id):e===t}function l(e){var r=[];while(t(e)){r.unshift(e);e=e.position&&e.position.referenceFrame}return r}function d(e,t){if(!c(e[0],t[0])){return-1}var r=Math.min(e.length,t.length);for(var n=0;n<=r;n++){if(!c(e[n],t[n])){return n-1}}return-1}var h=new i;function v(e){var r=u.computeIcrfToFixedMatrix(e,h);if(!t(r)){r=u.computeTemeToPseudoFixedMatrix(e,h)}return r}var p=new i;var m=new e;var w=new o;f.convertToReferenceFrame=function(r,n,a,u,f){if(!t(n)){return n}if(!t(f)){f=new e}if(a===u){return e.clone(n,f)}if(!t(a)||!t(u)){return undefined}var c=l(a);var h=l(u);var y=d(c,h);var g=c[y];var S=function(n,a){if(!t(n)){return n}var o=a.position;if(!t(o)){return undefined}var s=o.referenceFrame;var u=o.getValueInReferenceFrame(r,s,m);if(!t(u)){return undefined}var f=a.orientation;if(t(f)){var c=f.getValue(r,w);if(!t(c)){return undefined}i.fromQuaternion(c,p);i.multiplyByVector(p,n,n);return e.add(u,n,n)}return e.add(u,n,n)};var b=function(n,a){if(!t(n)){return n}var s=a.position;if(!t(s)){return undefined}var u=s.referenceFrame;var f=s.getValueInReferenceFrame(r,u,m);if(!t(f)){return undefined}n=e.subtract(n,f,n);var c=a.orientation;if(t(c)){var l=c.getValue(r,w);if(!t(l)){return undefined}o.conjugate(l,l);i.fromQuaternion(l,p);i.multiplyByVector(p,n,n)}return n};if(t(g)){c=c.slice(y+1);h=h.slice(y+1);var T=c.reduceRight(S,e.clone(n,f));if(!t(T)){return undefined}return h.reduce(b,T)}var _=c.shift();var E=h.shift();var M,P;if(_===s.INERTIAL&&E===s.FIXED){P=c.reduceRight(S,e.clone(n,f));if(!t(P)){return undefined}M=i.multiplyByVector(v(r),P,f);return h.reduce(b,M)}if(_===s.FIXED&&E===s.INERTIAL){M=c.reduceRight(S,e.clone(n,f));if(!t(M)){return undefined}var A=i.transpose(v(r),p);P=i.multiplyByVector(A,M,f);return h.reduce(b,P)}return undefined};return f})})();(function(){var t=e.amdDefine;t("39",["23","1a","1b","1c","1f","24"],function(e,t,r,n,i,a){"use strict";function o(r){r=e(r,e.EMPTY_OBJECT);this.start=t(r.start)?a.clone(r.start):new a;this.stop=t(r.stop)?a.clone(r.stop):new a;this.data=r.data;this.isStartIncluded=e(r.isStartIncluded,true);this.isStopIncluded=e(r.isStopIncluded,true)}r(o.prototype,{isEmpty:{get:function(){var e=a.compare(this.stop,this.start);return e<0||e===0&&(!this.isStartIncluded||!this.isStopIncluded)}}});var s={start:undefined,stop:undefined,isStartIncluded:undefined,isStopIncluded:undefined,data:undefined};o.fromIso8601=function(r,i){if(!t(r)){throw new n("options is required.")}if(!t(r.iso8601)){throw new n("options.iso8601 is required.")}var u=r.iso8601.split("/");var f=a.fromIso8601(u[0]);var c=a.fromIso8601(u[1]);var l=e(r.isStartIncluded,true);var d=e(r.isStopIncluded,true);var h=r.data;if(!t(i)){s.start=f;s.stop=c;s.isStartIncluded=l;s.isStopIncluded=d;s.data=h;return new o(s)}i.start=f;i.stop=c;i.isStartIncluded=l;i.isStopIncluded=d;i.data=h;return i};o.toIso8601=function(e,r){if(!t(e)){throw new n("timeInterval is required.")}return a.toIso8601(e.start,r)+"/"+a.toIso8601(e.stop,r)};o.clone=function(e,r){if(!t(e)){return undefined}if(!t(r)){return new o(e)}r.start=e.start;r.stop=e.stop;r.isStartIncluded=e.isStartIncluded;r.isStopIncluded=e.isStopIncluded;r.data=e.data;return r};o.equals=function(e,r,n){return e===r||t(e)&&t(r)&&(e.isEmpty&&r.isEmpty||e.isStartIncluded===r.isStartIncluded&&e.isStopIncluded===r.isStopIncluded&&a.equals(e.start,r.start)&&a.equals(e.stop,r.stop)&&(e.data===r.data||t(n)&&n(e.data,r.data)))};o.equalsEpsilon=function(e,r,i,o){if(typeof i!=="number"){throw new n("epsilon is required and must be a number.")}return e===r||t(e)&&t(r)&&(e.isEmpty&&r.isEmpty||e.isStartIncluded===r.isStartIncluded&&e.isStopIncluded===r.isStopIncluded&&a.equalsEpsilon(e.start,r.start,i)&&a.equalsEpsilon(e.stop,r.stop,i)&&(e.data===r.data||t(o)&&o(e.data,r.data)))};o.intersect=function(e,r,i,s){if(!t(e)){throw new n("left is required.")}if(!t(i)){throw new n("result is required.")}if(!t(r)){return o.clone(o.EMPTY,i)}var u=e.start;var f=e.stop;var c=r.start;var l=r.stop;var d=a.greaterThanOrEquals(c,u)&&a.greaterThanOrEquals(f,c);var h=!d&&a.lessThanOrEquals(c,u)&&a.lessThanOrEquals(u,l);if(!d&&!h){return o.clone(o.EMPTY,i)}var v=e.isStartIncluded;var p=e.isStopIncluded;var m=r.isStartIncluded;var w=r.isStopIncluded;var y=a.lessThan(f,l);i.start=d?c:u;i.isStartIncluded=v&&m||!a.equals(c,u)&&(d&&m||h&&v);i.stop=y?f:l;i.isStopIncluded=y?p:p&&w||!a.equals(l,f)&&w;i.data=t(s)?s(e.data,r.data):e.data;return i};o.contains=function(e,r){if(!t(e)){throw new n("timeInterval is required.")}if(!t(r)){throw new n("julianDate is required.")}if(e.isEmpty){return false}var i=a.compare(e.start,r);if(i===0){return e.isStartIncluded}var o=a.compare(r,e.stop);if(o===0){return e.isStopIncluded}return i<0&&o<0};o.prototype.clone=function(e){return o.clone(this,e)};o.prototype.equals=function(e,t){return o.equals(this,e,t)};o.prototype.equalsEpsilon=function(e,t,r){return o.equalsEpsilon(this,e,t,r)};o.prototype.toString=function(){return o.toIso8601(this)};o.EMPTY=i(new o({start:new a,stop:new a,isStartIncluded:false,isStopIncluded:false}));return o})})();(function(){var t=e.amdDefine;t("37",["1f","24","39"],function(e,t,r){"use strict";var n=e(t.fromIso8601("0000-01-01T00:00:00Z"));var i=e(t.fromIso8601("9999-12-31T24:00:00Z"));var a=e(new r({start:n,stop:i}));var o={MINIMUM_VALUE:n,MAXIMUM_VALUE:i,MAXIMUM_INTERVAL:a};return o})})();(function(){var t=e.amdDefine;t("36",["23","1a","1b","1c","37"],function(e,t,r,n,i){"use strict";function a(){n.throwInstantiationError()}r(a.prototype,{isConstant:{get:n.throwInstantiationError},definitionChanged:{get:n.throwInstantiationError}});a.prototype.getValue=n.throwInstantiationError;a.prototype.equals=n.throwInstantiationError;a.equals=function(e,r){return e===r||t(e)&&e.equals(r)};a.arrayEquals=function(e,r){if(e===r){return true}if(!t(e)||!t(r)||e.length!==r.length){return false}var n=e.length;for(var i=0;i<n;i++){if(!a.equals(e[i],r[i])){return false}}return true};a.isConstant=function(e){return!t(e)||e.isConstant};a.getValueOrUndefined=function(e,r,n){return t(e)?e.getValue(r,n):undefined};a.getValueOrDefault=function(r,n,i,a){return t(r)?e(r.getValue(n,a),i):i};a.getValueOrClonedDefault=function(e,r,n,i){var a;if(t(e)){a=e.getValue(r,i)}if(!t(a)){a=n.clone(a)}return a};return a})})();(function(){var t=e.amdDefine;t("48",["2c","23","1a","1b","1c","1d","2d","2e","36","49"],function(e,t,r,n,i,a,o,s,u,f){"use strict";function c(r,n){n=t(n,0);var i;if(n>0){i=new Array(n);for(var s=0;s<n;s++){i[s]=e}}this._numberOfDerivatives=n;this._property=new f(e,i);this._definitionChanged=new a;this._referenceFrame=t(r,o.FIXED);this._property._definitionChanged.addEventListener(function(){this._definitionChanged.raiseEvent(this)},this)}n(c.prototype,{isConstant:{get:function(){return this._property.isConstant}},definitionChanged:{get:function(){return this._definitionChanged}},referenceFrame:{get:function(){return this._referenceFrame}},interpolationDegree:{get:function(){return this._property.interpolationDegree}},interpolationAlgorithm:{get:function(){return this._property.interpolationAlgorithm}},numberOfDerivatives:{get:function(){return this._numberOfDerivatives}},forwardExtrapolationType:{get:function(){return this._property.forwardExtrapolationType},set:function(e){this._property.forwardExtrapolationType=e}},forwardExtrapolationDuration:{get:function(){return this._property.forwardExtrapolationDuration},set:function(e){this._property.forwardExtrapolationDuration=e}},backwardExtrapolationType:{get:function(){return this._property.backwardExtrapolationType},set:function(e){this._property.backwardExtrapolationType=e}},backwardExtrapolationDuration:{get:function(){return this._property.backwardExtrapolationDuration},set:function(e){this._property.backwardExtrapolationDuration=e}}});c.prototype.getValue=function(e,t){return this.getValueInReferenceFrame(e,o.FIXED,t)};c.prototype.getValueInReferenceFrame=function(e,t,n){if(!r(e)){throw new i("time is required.")}if(!r(t)){throw new i("referenceFrame is required.")}n=this._property.getValue(e,n);if(r(n)){return s.convertToReferenceFrame(e,n,this._referenceFrame,t,n)}return undefined};c.prototype.setInterpolationOptions=function(e){this._property.setInterpolationOptions(e)};c.prototype.addSample=function(e,t,n){var a=this._numberOfDerivatives;if(a>0&&(!r(n)||n.length!==a)){throw new i("derivatives length must be equal to the number of derivatives.")}this._property.addSample(e,t,n)};c.prototype.addSamples=function(e,t,r){this._property.addSamples(e,t,r)};c.prototype.addSamplesPackedArray=function(e,t){this._property.addSamplesPackedArray(e,t)};c.prototype.equals=function(e){return this===e||e instanceof c&&u.equals(this._property,e._property)&&this._referenceFrame===e._referenceFrame};return c})})();(function(){var t=e.amdDefine;t("1d",["1a","1b","1c"],function(e,t,r){"use strict";function n(){this._listeners=[];this._scopes=[];this._toRemove=[];this._insideRaiseEvent=false}t(n.prototype,{numberOfListeners:{get:function(){return this._listeners.length-this._toRemove.length}}});n.prototype.addEventListener=function(e,t){if(typeof e!=="function"){throw new r("listener is required and must be a function.")}this._listeners.push(e);this._scopes.push(t);var n=this;return function(){n.removeEventListener(e,t)}};n.prototype.removeEventListener=function(e,t){if(typeof e!=="function"){throw new r("listener is required and must be a function.")}var n=this._listeners;var i=this._scopes;var a=-1;for(var o=0;o<n.length;o++){if(n[o]===e&&i[o]===t){a=o;break}}if(a!==-1){if(this._insideRaiseEvent){this._toRemove.push(a);n[a]=undefined;i[a]=undefined}else{n.splice(a,1);i.splice(a,1)}return true}return false};n.prototype.raiseEvent=function(){this._insideRaiseEvent=true;var t;var r=this._listeners;var n=this._scopes;var i=r.length;for(t=0;t<i;t++){var a=r[t];if(e(a)){r[t].apply(n[t],arguments)}}var o=this._toRemove;i=o.length;for(t=0;t<i;t++){var s=o[t];r.splice(s,1);n.splice(s,1)}o.length=0;this._insideRaiseEvent=false};return n})})();(function(){var t=e.amdDefine;t("4a",["1f"],function(e){"use strict";var t={NONE:0,HOLD:1,EXTRAPOLATE:2};return e(t)})})();(function(){var t=e.amdDefine;t("4b",["1a","1c"],function(e,t){"use strict";var r={type:"Linear"};r.getRequiredDataPoints=function(e){return 2};r.interpolateOrderZero=function(r,n,i,a,o){if(n.length!==2){throw new t("The xTable provided to the linear interpolator must have exactly two elements.")}else if(a<=0){throw new t("There must be at least 1 dependent variable for each independent variable.")}if(!e(o)){o=new Array(a)}var s;var u;var f;var c=n[0];var l=n[1];if(c===l){throw new t("Divide by zero error: xTable[0] and xTable[1] are equal")}for(s=0;s<a;s++){u=i[s];f=i[s+a];o[s]=((f-u)*r+l*u-c*f)/(l-c)}return o};return r})})();(function(){var t=e.amdDefine;t("49",["4c","23","1a","1b","1c","1d","4a","24","4b"],function(e,t,r,n,i,a,o,s,u){"use strict";var f={packedLength:1,pack:function(e,r,n){n=t(n,0);r[n]=e},unpack:function(e,r,n){r=t(r,0);return e[r]}};function c(e,t,r){var n;var i=e.length;var a=r.length;var o=i+a;e.length=o;if(i!==t){var s=i-1;for(n=o-1;n>=t;n--){e[n]=e[s--]}}for(n=0;n<a;n++){e[t++]=r[n]}}function l(e,t){if(e instanceof s){return e}if(typeof e==="string"){return s.fromIso8601(e)}return s.addSeconds(t,e,new s)}var d=[];var h=[];function v(t,n,i,a,o){var u=0;var f;var v;var p;var m;var w;var y;while(u<a.length){w=l(a[u],t);p=e(n,w,s.compare);var g=0;var S=0;if(p<0){p=~p;m=p*o;v=undefined;y=n[p];while(u<a.length){w=l(a[u],t);if(r(v)&&s.compare(v,w)>=0||r(y)&&s.compare(w,y)>=0){break}d[g++]=w;u=u+1;for(f=0;f<o;f++){h[S++]=a[u];u=u+1}v=w}if(g>0){h.length=S;c(i,m,h);d.length=g;c(n,p,d)}}else{for(f=0;f<o;f++){u++;i[p*o+f]=a[u]}u++}}}function p(e,n){if(!r(e)){throw new i("type is required.")}var s=e;if(s===Number){s=f}var c=s.packedLength;var l=t(s.packedInterpolationLength,c);var d=0;var h;if(r(n)){var v=n.length;h=new Array(v);for(var p=0;p<v;p++){var m=n[p];if(m===Number){m=f}var w=m.packedLength;c+=w;l+=t(m.packedInterpolationLength,w);h[p]=m}d=v}this._type=e;this._innerType=s;this._interpolationDegree=1;this._interpolationAlgorithm=u;this._numberOfPoints=0;this._times=[];this._values=[];this._xTable=[];this._yTable=[];this._packedLength=c;this._packedInterpolationLength=l;this._updateTableLength=true;this._interpolationResult=new Array(l);this._definitionChanged=new a;this._derivativeTypes=n;this._innerDerivativeTypes=h;this._inputOrder=d;this._forwardExtrapolationType=o.NONE;this._forwardExtrapolationDuration=0;this._backwardExtrapolationType=o.NONE;this._backwardExtrapolationDuration=0}n(p.prototype,{isConstant:{get:function(){return this._values.length===0}},definitionChanged:{get:function(){return this._definitionChanged}},type:{get:function(){return this._type}},derivativeTypes:{get:function(){return this._derivativeTypes}},interpolationDegree:{get:function(){return this._interpolationDegree}},interpolationAlgorithm:{get:function(){return this._interpolationAlgorithm}},forwardExtrapolationType:{get:function(){return this._forwardExtrapolationType},set:function(e){if(this._forwardExtrapolationType!==e){this._forwardExtrapolationType=e;this._definitionChanged.raiseEvent(this)}}},forwardExtrapolationDuration:{get:function(){return this._forwardExtrapolationDuration},set:function(e){if(this._forwardExtrapolationDuration!==e){this._forwardExtrapolationDuration=e;this._definitionChanged.raiseEvent(this)}}},backwardExtrapolationType:{get:function(){return this._backwardExtrapolationType},set:function(e){if(this._backwardExtrapolationType!==e){this._backwardExtrapolationType=e;this._definitionChanged.raiseEvent(this)}}},backwardExtrapolationDuration:{get:function(){return this._backwardExtrapolationDuration},set:function(e){if(this._backwardExtrapolationDuration!==e){this._backwardExtrapolationDuration=e;this._definitionChanged.raiseEvent(this)}}}});p.prototype.getValue=function(t,n){if(!r(t)){throw new i("time is required.")}var a=this._times;var u=a.length;if(u===0){return undefined}var f;var c=this._innerType;var l=this._values;var d=e(a,t,s.compare);if(d<0){d=~d;if(d===0){var h=a[d];f=this._backwardExtrapolationDuration;if(this._backwardExtrapolationType===o.NONE||f!==0&&s.secondsDifference(h,t)>f){return undefined}if(this._backwardExtrapolationType===o.HOLD){return c.unpack(l,0,n)}}if(d>=u){d=u-1;var v=a[d];f=this._forwardExtrapolationDuration;if(this._forwardExtrapolationType===o.NONE||f!==0&&s.secondsDifference(t,v)>f){return undefined}if(this._forwardExtrapolationType===o.HOLD){d=u-1;return c.unpack(l,d*c.packedLength,n)}}var p=this._xTable;var m=this._yTable;var w=this._interpolationAlgorithm;var y=this._packedInterpolationLength;var g=this._inputOrder;if(this._updateTableLength){this._updateTableLength=false;var S=Math.min(w.getRequiredDataPoints(this._interpolationDegree,g),u);if(S!==this._numberOfPoints){this._numberOfPoints=S;p.length=S;m.length=S*y}}var b=this._numberOfPoints-1;if(b<1){return undefined}var T=0;var _=u-1;var E=_-T+1;if(E>=b+1){var M=d-(b/2|0)-1;if(M<T){M=T}var P=M+b;if(P>_){P=_;M=P-b;if(M<T){M=T}}T=M;_=P}var A=_-T+1;for(var C=0;C<A;++C){p[C]=s.secondsDifference(a[T+C],a[_])}if(!r(c.convertPackedArrayForInterpolation)){var I=0;var x=this._packedLength;var R=T*x;var O=(_+1)*x;while(R<O){m[I]=l[R];R++;I++}}else{c.convertPackedArrayForInterpolation(l,T,_,m)}var D=s.secondsDifference(t,a[_]);var q;if(g===0||!r(w.interpolate)){q=w.interpolateOrderZero(D,p,m,y,this._interpolationResult)}else{var N=Math.floor(y/(g+1));q=w.interpolate(D,p,m,N,g,g,this._interpolationResult)}if(!r(c.unpackInterpolationResult)){return c.unpack(q,0,n)}return c.unpackInterpolationResult(q,l,T,_,n)}return c.unpack(l,d*this._packedLength,n)};p.prototype.setInterpolationOptions=function(e){if(!r(e)){throw new i("options is required.")}var t=false;var n=e.interpolationAlgorithm;var a=e.interpolationDegree;if(this._interpolationAlgorithm!==n){this._interpolationAlgorithm=n;t=true}if(this._interpolationDegree!==a){this._interpolationDegree=a;t=true}if(t){this._updateTableLength=true;this._definitionChanged.raiseEvent(this)}};p.prototype.addSample=function(e,t,n){var a=this._innerDerivativeTypes;var o=r(a);if(!r(e)){throw new i("time is required.")}if(!r(t)){throw new i("value is required.")}if(o&&!r(n)){throw new i("derivatives is required.")}var s=this._innerType;var u=[];u.push(e);s.pack(t,u,u.length);if(o){var f=a.length;for(var c=0;c<f;c++){a[c].pack(n[c],u,u.length)}}v(undefined,this._times,this._values,u,this._packedLength);this._updateTableLength=true;this._definitionChanged.raiseEvent(this)};p.prototype.addSamples=function(e,t,n){var a=this._innerDerivativeTypes;var o=r(a);if(!r(e)){throw new i("times is required.")}if(!r(t)){throw new i("values is required.")}if(e.length!==t.length){throw new i("times and values must be the same length.")}if(o&&(!r(n)||n.length!==e.length)){throw new i("times and derivativeValues must be the same length.")}var s=this._innerType;var u=e.length;var f=[];for(var c=0;c<u;c++){f.push(e[c]);s.pack(t[c],f,f.length);if(o){var l=n[c];var d=a.length;for(var h=0;h<d;h++){a[h].pack(l[h],f,f.length)}}}v(undefined,this._times,this._values,f,this._packedLength);this._updateTableLength=true;this._definitionChanged.raiseEvent(this)};p.prototype.addSamplesPackedArray=function(e,t){if(!r(e)){throw new i("packedSamples is required.")}v(t,this._times,this._values,e,this._packedLength);this._updateTableLength=true;this._definitionChanged.raiseEvent(this)};p.prototype.equals=function(e){if(this===e){return true}if(!r(e)){return false}if(this._type!==e._type||this._interpolationDegree!==e._interpolationDegree||this._interpolationAlgorithm!==e._interpolationAlgorithm){return false}var t=this._derivativeTypes;var n=r(t);var i=e._derivativeTypes;var a=r(i);if(n!==a){return false}var o;var u;if(n){u=t.length;if(u!==i.length){return false}for(o=0;o<u;o++){if(t[o]!==i[o]){return false}}}var f=this._times;var c=e._times;u=f.length;if(u!==c.length){return false}for(o=0;o<u;o++){if(!s.equals(f[o],c[o])){return false}}var l=this._values;var d=e._values;for(o=0;o<u;o++){if(l[o]!==d[o]){return false}}return true};p._mergeNewSamples=v;return p})})();(function(){var t=e.amdDefine;t("45",["23","1a","1c","1f","27"],function(e,t,r,n,i){"use strict";function a(t,r){this.x=e(t,0);this.y=e(r,0)}a.fromElements=function(e,r,n){if(!t(n)){return new a(e,r)}n.x=e;n.y=r;return n};a.clone=function(e,r){if(!t(e)){return undefined}if(!t(r)){return new a(e.x,e.y)}r.x=e.x;r.y=e.y;return r};a.fromCartesian3=a.clone;a.fromCartesian4=a.clone;a.packedLength=2;a.pack=function(n,i,a){if(!t(n)){throw new r("value is required")}if(!t(i)){throw new r("array is required")}a=e(a,0);i[a++]=n.x;i[a]=n.y};a.unpack=function(n,i,o){if(!t(n)){throw new r("array is required")}i=e(i,0);if(!t(o)){o=new a}o.x=n[i++];o.y=n[i];return o};a.packArray=function(e,n){if(!t(e)){throw new r("array is required")}var i=e.length;if(!t(n)){n=new Array(i*2)}else{n.length=i*2}for(var o=0;o<i;++o){a.pack(e[o],n,o*2)}return n};a.unpackArray=function(e,n){if(!t(e)){throw new r("array is required")}var i=e.length;if(!t(n)){n=new Array(i/2)}else{n.length=i/2}for(var o=0;o<i;o+=2){var s=o/2;n[s]=a.unpack(e,o,n[s])}return n};a.fromArray=a.unpack;a.maximumComponent=function(e){if(!t(e)){throw new r("cartesian is required")}return Math.max(e.x,e.y)};a.minimumComponent=function(e){if(!t(e)){throw new r("cartesian is required")}return Math.min(e.x,e.y)};a.minimumByComponent=function(e,n,i){if(!t(e)){throw new r("first is required.")}if(!t(n)){throw new r("second is required.")}if(!t(i)){throw new r("result is required.")}i.x=Math.min(e.x,n.x);i.y=Math.min(e.y,n.y);return i};a.maximumByComponent=function(e,n,i){if(!t(e)){throw new r("first is required.")}if(!t(n)){throw new r("second is required.")}if(!t(i)){throw new r("result is required.")}i.x=Math.max(e.x,n.x);i.y=Math.max(e.y,n.y);return i};a.magnitudeSquared=function(e){if(!t(e)){throw new r("cartesian is required")}return e.x*e.x+e.y*e.y};a.magnitude=function(e){return Math.sqrt(a.magnitudeSquared(e))};var o=new a;a.distance=function(e,n){if(!t(e)||!t(n)){throw new r("left and right are required.")}a.subtract(e,n,o);return a.magnitude(o)};a.distanceSquared=function(e,n){if(!t(e)||!t(n)){throw new r("left and right are required.")}a.subtract(e,n,o);return a.magnitudeSquared(o)};a.normalize=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}var i=a.magnitude(e);n.x=e.x/i;n.y=e.y/i;return n};a.dot=function(e,n){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}return e.x*n.x+e.y*n.y};a.multiplyComponents=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}i.x=e.x*n.x;i.y=e.y*n.y;return i};a.add=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required");
	}i.x=e.x+n.x;i.y=e.y+n.y;return i};a.subtract=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}i.x=e.x-n.x;i.y=e.y-n.y;return i};a.multiplyByScalar=function(e,n,i){if(!t(e)){throw new r("cartesian is required")}if(typeof n!=="number"){throw new r("scalar is required and must be a number.")}if(!t(i)){throw new r("result is required")}i.x=e.x*n;i.y=e.y*n;return i};a.divideByScalar=function(e,n,i){if(!t(e)){throw new r("cartesian is required")}if(typeof n!=="number"){throw new r("scalar is required and must be a number.")}if(!t(i)){throw new r("result is required")}i.x=e.x/n;i.y=e.y/n;return i};a.negate=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}n.x=-e.x;n.y=-e.y;return n};a.abs=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}n.x=Math.abs(e.x);n.y=Math.abs(e.y);return n};var s=new a;a.lerp=function(e,n,i,o){if(!t(e)){throw new r("start is required.")}if(!t(n)){throw new r("end is required.")}if(typeof i!=="number"){throw new r("t is required and must be a number.")}if(!t(o)){throw new r("result is required.")}a.multiplyByScalar(n,i,s);o=a.multiplyByScalar(e,1-i,o);return a.add(s,o,o)};var u=new a;var f=new a;a.angleBetween=function(e,n){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}a.normalize(e,u);a.normalize(n,f);return i.acosClamped(a.dot(u,f))};var c=new a;a.mostOrthogonalAxis=function(e,n){if(!t(e)){throw new r("cartesian is required.")}if(!t(n)){throw new r("result is required.")}var i=a.normalize(e,c);a.abs(i,i);if(i.x<=i.y){n=a.clone(a.UNIT_X,n)}else{n=a.clone(a.UNIT_Y,n)}return n};a.equals=function(e,r){return e===r||t(e)&&t(r)&&e.x===r.x&&e.y===r.y};a.equalsArray=function(e,t,r){return e.x===t[r]&&e.y===t[r+1]};a.equalsEpsilon=function(e,r,n,a){return e===r||t(e)&&t(r)&&i.equalsEpsilon(e.x,r.x,n,a)&&i.equalsEpsilon(e.y,r.y,n,a)};a.ZERO=n(new a(0,0));a.UNIT_X=n(new a(1,0));a.UNIT_Y=n(new a(0,1));a.prototype.clone=function(e){return a.clone(this,e)};a.prototype.equals=function(e){return a.equals(this,e)};a.prototype.equalsEpsilon=function(e,t,r){return a.equalsEpsilon(this,e,t,r)};a.prototype.toString=function(){return"("+this.x+", "+this.y+")"};return a})})();(function(){var t=e.amdDefine;t("4d",["4e","4c","23","1a","4f","1f","24","50","51","38","52","53"],function(e,t,r,n,i,a,o,s,u,f,c,l){"use strict";function d(t){t=r(t,r.EMPTY_OBJECT);this._dates=undefined;this._samples=undefined;this._dateColumn=-1;this._xPoleWanderRadiansColumn=-1;this._yPoleWanderRadiansColumn=-1;this._ut1MinusUtcSecondsColumn=-1;this._xCelestialPoleOffsetRadiansColumn=-1;this._yCelestialPoleOffsetRadiansColumn=-1;this._taiMinusUtcSecondsColumn=-1;this._columnCount=0;this._lastIndex=-1;this._downloadPromise=undefined;this._dataError=undefined;this._addNewLeapSeconds=r(t.addNewLeapSeconds,true);if(n(t.data)){v(this,t.data)}else if(n(t.url)){var i=this;this._downloadPromise=e(u(t.url),function(e){v(i,e)},function(){i._dataError="An error occurred while retrieving the EOP data from the URL "+t.url+"."})}else{v(this,{columnNames:["dateIso8601","modifiedJulianDateUtc","xPoleWanderRadians","yPoleWanderRadians","ut1MinusUtcSeconds","lengthOfDayCorrectionSeconds","xCelestialPoleOffsetRadians","yCelestialPoleOffsetRadians","taiMinusUtcSeconds"],samples:[]})}}d.NONE=a({getPromiseToLoad:function(){return e()},compute:function(e,t){if(!n(t)){t=new i(0,0,0,0,0)}else{t.xPoleWander=0;t.yPoleWander=0;t.xPoleOffset=0;t.yPoleOffset=0;t.ut1MinusUtc=0}return t}});d.prototype.getPromiseToLoad=function(){return e(this._downloadPromise)};d.prototype.compute=function(e,r){if(!n(this._samples)){if(n(this._dataError)){throw new f(this._dataError)}return undefined}if(!n(r)){r=new i(0,0,0,0,0)}if(this._samples.length===0){r.xPoleWander=0;r.yPoleWander=0;r.xPoleOffset=0;r.yPoleOffset=0;r.ut1MinusUtc=0;return r}var a=this._dates;var s=this._lastIndex;var u=0;var c=0;if(n(s)){var l=a[s];var d=a[s+1];var h=o.lessThanOrEquals(l,e);var v=!n(d);var p=v||o.greaterThanOrEquals(d,e);if(h&&p){u=s;if(!v&&d.equals(e)){++u}c=u+1;w(this,a,this._samples,e,u,c,r);return r}}var m=t(a,e,o.compare,this._dateColumn);if(m>=0){if(m<a.length-1&&a[m+1].equals(e)){++m}u=m;c=m}else{c=~m;u=c-1;if(u<0){u=0}}this._lastIndex=u;w(this,a,this._samples,e,u,c,r);return r};function h(e,t){return o.compare(e.julianDate,t)}function v(e,r){if(!n(r.columnNames)){e._dataError="Error in loaded EOP data: The columnNames property is required.";return}if(!n(r.samples)){e._dataError="Error in loaded EOP data: The samples property is required.";return}var i=r.columnNames.indexOf("modifiedJulianDateUtc");var a=r.columnNames.indexOf("xPoleWanderRadians");var u=r.columnNames.indexOf("yPoleWanderRadians");var f=r.columnNames.indexOf("ut1MinusUtcSeconds");var d=r.columnNames.indexOf("xCelestialPoleOffsetRadians");var v=r.columnNames.indexOf("yCelestialPoleOffsetRadians");var p=r.columnNames.indexOf("taiMinusUtcSeconds");if(i<0||a<0||u<0||f<0||d<0||v<0||p<0){e._dataError="Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns";return}var m=e._samples=r.samples;var w=e._dates=[];e._dateColumn=i;e._xPoleWanderRadiansColumn=a;e._yPoleWanderRadiansColumn=u;e._ut1MinusUtcSecondsColumn=f;e._xCelestialPoleOffsetRadiansColumn=d;e._yCelestialPoleOffsetRadiansColumn=v;e._taiMinusUtcSecondsColumn=p;e._columnCount=r.columnNames.length;e._lastIndex=undefined;var y;var g=e._addNewLeapSeconds;for(var S=0,b=m.length;S<b;S+=e._columnCount){var T=m[S+i];var _=m[S+p];var E=T+c.MODIFIED_JULIAN_DATE_DIFFERENCE;var M=new o(E,_,l.TAI);w.push(M);if(g){if(_!==y&&n(y)){var P=o.leapSeconds;var A=t(P,M,h);if(A<0){var C=new s(M,_);P.splice(~A,0,C)}}y=_}}}function p(e,t,r,n,i){var a=r*n;i.xPoleWander=t[a+e._xPoleWanderRadiansColumn];i.yPoleWander=t[a+e._yPoleWanderRadiansColumn];i.xPoleOffset=t[a+e._xCelestialPoleOffsetRadiansColumn];i.yPoleOffset=t[a+e._yCelestialPoleOffsetRadiansColumn];i.ut1MinusUtc=t[a+e._ut1MinusUtcSecondsColumn]}function m(e,t,r){return t+e*(r-t)}function w(e,t,r,n,i,a,s){var u=e._columnCount;if(a>t.length-1){s.xPoleWander=0;s.yPoleWander=0;s.xPoleOffset=0;s.yPoleOffset=0;s.ut1MinusUtc=0;return s}var f=t[i];var c=t[a];if(f.equals(c)||n.equals(f)){p(e,r,i,u,s);return s}else if(n.equals(c)){p(e,r,a,u,s);return s}var l=o.secondsDifference(n,f)/o.secondsDifference(c,f);var d=i*u;var h=a*u;var v=r[d+e._ut1MinusUtcSecondsColumn];var w=r[h+e._ut1MinusUtcSecondsColumn];var y=w-v;if(y>.5||y<-.5){var g=r[d+e._taiMinusUtcSecondsColumn];var S=r[h+e._taiMinusUtcSecondsColumn];if(g!==S){if(c.equals(n)){v=w}else{w-=S-g}}}s.xPoleWander=m(l,r[d+e._xPoleWanderRadiansColumn],r[h+e._xPoleWanderRadiansColumn]);s.yPoleWander=m(l,r[d+e._yPoleWanderRadiansColumn],r[h+e._yPoleWanderRadiansColumn]);s.xPoleOffset=m(l,r[d+e._xCelestialPoleOffsetRadiansColumn],r[h+e._xCelestialPoleOffsetRadiansColumn]);s.yPoleOffset=m(l,r[d+e._yCelestialPoleOffsetRadiansColumn],r[h+e._yCelestialPoleOffsetRadiansColumn]);s.ut1MinusUtc=m(l,v,w);return s}return d})})();(function(){var t=e.amdDefine;t("4f",[],function(){"use strict";function e(e,t,r,n,i){this.xPoleWander=e;this.yPoleWander=t;this.xPoleOffset=r;this.yPoleOffset=n;this.ut1MinusUtc=i}return e})})();(function(){var t=e.amdDefine;t("54",["55","23","1a","1c"],function(e,t,r,n){"use strict";function i(i,a){if(!r(i)){throw new n("relative uri is required.")}a=t(a,document.location.href);var o=new e(a);var s=new e(i);return s.resolve(o).toString()}return i})})();(function(){var t=e.amdDefine;t("55",[],function(){function e(r){if(r instanceof e){this.scheme=r.scheme;this.authority=r.authority;this.path=r.path;this.query=r.query;this.fragment=r.fragment}else if(r){var n=t.exec(r);this.scheme=n[1];this.authority=n[2];this.path=n[3];this.query=n[4];this.fragment=n[5]}}e.prototype.scheme=null;e.prototype.authority=null;e.prototype.path="";e.prototype.query=null;e.prototype.fragment=null;var t=new RegExp("^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$");e.prototype.getScheme=function(){return this.scheme};e.prototype.getAuthority=function(){return this.authority};e.prototype.getPath=function(){return this.path};e.prototype.getQuery=function(){return this.query};e.prototype.getFragment=function(){return this.fragment};e.prototype.isAbsolute=function(){return!!this.scheme&&!this.fragment};e.prototype.isSameDocumentAs=function(e){return e.scheme==this.scheme&&e.authority==this.authority&&e.path==this.path&&e.query==this.query};e.prototype.equals=function(e){return this.isSameDocumentAs(e)&&e.fragment==this.fragment};e.prototype.normalize=function(){this.removeDotSegments();if(this.scheme)this.scheme=this.scheme.toLowerCase();if(this.authority)this.authority=this.authority.replace(i,o).replace(r,a);if(this.path)this.path=this.path.replace(r,a);if(this.query)this.query=this.query.replace(r,a);if(this.fragment)this.fragment=this.fragment.replace(r,a)};var r=/%[0-9a-z]{2}/gi;var n=/[a-zA-Z0-9\-\._~]/;var i=/(.*@)?([^@:]*)(:.*)?/;function a(e){var t=unescape(e);return n.test(t)?t:e.toUpperCase()}function o(e,t,r,n){return(t||"")+r.toLowerCase()+(n||"")}e.prototype.resolve=function(t){var r=new e;if(this.scheme){r.scheme=this.scheme;r.authority=this.authority;r.path=this.path;r.query=this.query}else{r.scheme=t.scheme;if(this.authority){r.authority=this.authority;r.path=this.path;r.query=this.query}else{r.authority=t.authority;if(this.path==""){r.path=t.path;r.query=this.query||t.query}else{if(this.path.charAt(0)=="/"){r.path=this.path;r.removeDotSegments()}else{if(t.authority&&t.path==""){r.path="/"+this.path}else{r.path=t.path.substring(0,t.path.lastIndexOf("/")+1)+this.path}r.removeDotSegments()}r.query=this.query}}}r.fragment=this.fragment;return r};e.prototype.removeDotSegments=function(){var e=this.path.split("/"),t=[],r,n=e[0]=="";if(n)e.shift();var i=e[0]==""?e.shift():null;while(e.length){r=e.shift();if(r==".."){t.pop()}else if(r!="."){t.push(r)}}if(r=="."||r=="..")t.push("");if(n)t.unshift("");this.path=t.join("/")};e.prototype.toString=function(){var e="";if(this.scheme)e+=this.scheme+":";if(this.authority)e+="//"+this.authority;e+=this.path;if(this.query)e+="?"+this.query;if(this.fragment)e+="#"+this.fragment;return e};return e})})();(function(){var t=e.amdDefine;t("56",["55","23","1a","1c"],function(e,t,r,n){"use strict";function i(i,a,o){if(!r(i)){throw new n("first is required")}if(!r(a)){throw new n("second is required")}o=t(o,true);if(!(i instanceof e)){i=new e(i)}if(!(a instanceof e)){a=new e(a)}if(r(a.authority)&&!r(a.scheme)){if(typeof document!=="undefined"&&r(document.location)&&r(document.location.href)){a.scheme=new e(document.location.href).scheme}else{a.scheme=i.scheme}}var s=i;if(a.isAbsolute()){s=a}var u="";if(r(s.scheme)){u+=s.scheme+":"}if(r(s.authority)){u+="//"+s.authority;if(s.path!==""&&s.path!=="/"){u=u.replace(/\/?$/,"/");s.path=s.path.replace(/^\/?/g,"")}}if(s===i){if(o){u+=i.path.replace(/\/?$/,"/")+a.path.replace(/^\/?/g,"")}else{u+=i.path+a.path}}else{u+=a.path}var f=r(i.query);var c=r(a.query);if(f&&c){u+="?"+i.query+"&"+a.query}else if(f&&!c){u+="?"+i.query}else if(!f&&c){u+="?"+a.query}var l=r(a.fragment);if(r(i.fragment)&&!l){u+="#"+i.fragment}else if(l){u+="#"+a.fragment}return u}return i})})();(function(){var t=e.amdDefine;t("57",["55","1a","1c","54","56","require"],function(e,t,r,n,i,a){"use strict";var o=/((?:.*\/)|^)cesium[\w-]*\.js(?:\W|$)/i;function s(){var e=document.getElementsByTagName("script");for(var t=0,r=e.length;t<r;++t){var n=e[t].getAttribute("src");var i=o.exec(n);if(i!==null){return i[1]}}return undefined}var u;function f(){if(t(u)){return u}var i;if(typeof CESIUM_BASE_URL!=="undefined"){i=CESIUM_BASE_URL}else{i=s()}if(!t(i)){throw new r("Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.")}u=new e(n(i));return u}function c(e){return a.toUrl("../"+e)}function l(e){return i(f(),e)}var d;var h;function v(e){if(!t(d)){if(t(a.toUrl)){d=c}else{d=l}}if(!t(h)){h=document.createElement("a")}var r=d(e);h.href=r;h.href=h.href;return h.href}v._cesiumScriptRegex=o;v.setBaseUrl=function(t){u=new e(t).resolve(new e(document.location.href))};return v})})();(function(){var t=e.amdDefine;t("58",["23"],function(e){"use strict";function t(r,n){if(r===null||typeof r!=="object"){return r}n=e(n,false);var i=new r.constructor;for(var a in r){if(r.hasOwnProperty(a)){var o=r[a];if(n){o=t(o,n)}i[a]=o}}return i}return t})})();(function(){var t=e.amdDefine;(function(e){"use strict";e("4e",[],function(){var e,t,r;n.defer=f;n.resolve=i;n.reject=a;n.join=v;n.all=h;n.map=p;n.reduce=m;n.any=d;n.some=l;n.chain=w;n.isPromise=c;function n(e,t,r,n){return i(e).then(t,r,n)}function i(e){var t,r;if(e instanceof o){t=e}else{if(c(e)){r=f();e.then(function(e){r.resolve(e)},function(e){r.reject(e)},function(e){r.progress(e)});t=r.promise}else{t=s(e)}}return t}function a(e){return n(e,u)}function o(e){this.then=e}o.prototype={always:function(e,t){return this.then(e,e,t)},otherwise:function(e){return this.then(r,e)},yield:function(e){return this.then(function(){return e})},spread:function(e){return this.then(function(t){return h(t,function(t){return e.apply(r,t)})})}};function s(e){var t=new o(function(t){try{return i(t?t(e):e)}catch(e){return u(e)}});return t}function u(e){var t=new o(function(t,r){try{return r?i(r(e)):u(e)}catch(e){return u(e)}});return t}function f(){var e,t,n,a,s,c,l;t=new o(d);e={then:d,resolve:h,reject:v,progress:p,promise:t,resolver:{resolve:h,reject:v,progress:p}};n=[];a=[];s=function(e,t,r){var i,o;i=f();o=typeof r==="function"?function(e){try{i.progress(r(e))}catch(e){i.progress(e)}}:function(e){i.progress(e)};n.push(function(r){r.then(e,t).then(i.resolve,i.reject,o)});a.push(o);return i.promise};c=function(e){y(a,e);return e};l=function(e){e=i(e);s=e.then;l=i;c=S;y(n,e);a=n=r;return e};return e;function d(e,t,r){return s(e,t,r)}function h(e){return l(e)}function v(e){return l(u(e))}function p(e){return c(e)}}function c(e){return e&&typeof e.then==="function"}function l(e,t,r,i,a){g(2,arguments);return n(e,function(e){var o,s,u,c,l,d,h,v,p,m;p=e.length>>>0;o=Math.max(0,Math.min(t,p));u=[];s=p-o+1;c=[];l=f();if(!o){l.resolve(u)}else{v=l.progress;h=function(e){c.push(e);if(!--s){d=h=S;l.reject(c)}};d=function(e){u.push(e);if(!--o){d=h=S;l.resolve(u)}};for(m=0;m<p;++m){if(m in e){n(e[m],y,w,v)}}}return l.then(r,i,a);function w(e){h(e)}function y(e){d(e)}})}function d(e,t,r,n){function i(e){return t?t(e[0]):e[0]}return l(e,1,i,r,n)}function h(e,t,r,n){g(1,arguments);return p(e,b).then(t,r,n)}function v(){return p(arguments,b)}function p(e,t){return n(e,function(e){var r,i,a,o,s,u;a=i=e.length>>>0;r=[];u=f();if(!a){u.resolve(r)}else{o=function e(i,o){n(i,t).then(function(e){r[o]=e;if(!--a){u.resolve(r)}},u.reject)};for(s=0;s<i;s++){if(s in e){o(e[s],s)}else{--a}}}return u.promise})}function m(r,i){var a=t.call(arguments,1);return n(r,function(t){var r;r=t.length;a[0]=function(e,t,a){return n(e,function(e){return n(t,function(t){return i(e,t,a,r)})})};return e.apply(t,a)})}function w(e,t,r){var i=arguments.length>2;return n(e,function(e){e=i?r:e;t.resolve(e);return e},function(e){t.reject(e);return u(e)},t.progress)}function y(e,t){var r,n=0;while(r=e[n++]){r(t)}}function g(e,t){var r,n=t.length;while(n>e){r=t[--n];if(r!=null&&typeof r!="function"){throw new Error("arg "+n+" must be a function")}}}function S(){}t=[].slice;e=[].reduce||function(e){var t,r,n,i,a;a=0;t=Object(this);i=t.length>>>0;r=arguments;if(r.length<=1){for(;;){if(a in t){n=t[a++];break}if(++a>=i){throw new TypeError}}}else{n=r[1]}for(;a<i;++a){if(a in t){n=e(n,t[a],a,t)}}return n};function b(e){return e}return n})})(typeof t=="function"&&t.amd?t:function(e){typeof r==="object"?n.exports=e():this.when=e()})})();(function(){var t=e.amdDefine;t("59",[],function(){"use strict";function e(e){var t={};if(!e){return t}var r=e.split("\r\n");for(var n=0;n<r.length;++n){var i=r[n];var a=i.indexOf(": ");if(a>0){var o=i.substring(0,a);var s=i.substring(a+2);t[o]=s}}return t}return e})})();(function(){var t=e.amdDefine;t("5a",["1a","59"],function(e,t){"use strict";function r(e,r,n){this.statusCode=e;this.response=r;this.responseHeaders=n;if(typeof this.responseHeaders==="string"){this.responseHeaders=t(this.responseHeaders)}}r.prototype.toString=function(){var t="Request has failed.";if(e(this.statusCode)){t+=" Status Code: "+this.statusCode}return t};return r})})();(function(){var t=e.amdDefine;t("5b",["4e","23","1a","1c","5a","38"],function(e,t,r,n,i,a){"use strict";function o(i){i=t(i,t.EMPTY_OBJECT);if(!r(i.url)){throw new n("options.url is required.")}var a=i.responseType;var s=t(i.method,"GET");var u=i.data;var f=i.headers;var c=i.overrideMimeType;return e(i.url,function(t){var r=e.defer();o.load(t,a,s,u,f,r,c);return r.promise})}var s=/^data:(.*?)(;base64)?,(.*)$/;function u(e,t){var r=decodeURIComponent(t);if(e){return atob(r)}return r}function f(e,t){var r=u(e,t);var n=new ArrayBuffer(r.length);var i=new Uint8Array(n);for(var a=0;a<r.length;a++){i[a]=r.charCodeAt(a)}return n}function c(e,r){r=t(r,"");var i=e[1];var a=!!e[2];var o=e[3];switch(r){case"":case"text":return u(a,o);case"arraybuffer":return f(a,o);case"blob":var s=f(a,o);return new Blob([s],{type:i});case"document":var c=new DOMParser;return c.parseFromString(u(a,o),i);case"json":return JSON.parse(u(a,o));default:throw new n("Unhandled responseType: "+r)}}o.load=function(e,t,n,o,u,f,l){var d=s.exec(e);if(d!==null){f.resolve(c(d,t));return}var h=new XMLHttpRequest;if(r(l)&&r(h.overrideMimeType)){h.overrideMimeType(l)}h.open(n,e,true);if(r(u)){for(var v in u){if(u.hasOwnProperty(v)){h.setRequestHeader(v,u[v])}}}if(r(t)){h.responseType=t}h.onload=function(){if(h.status>=200&&h.status<300){if(r(h.response)){f.resolve(h.response)}else{if(r(h.responseXML)&&h.responseXML.hasChildNodes()){f.resolve(h.responseXML)}else if(r(h.responseText)){f.resolve(h.responseText)}else{f.reject(new a("unknown XMLHttpRequest response type."))}}}else{f.reject(new i(h.status,h.response,h.getAllResponseHeaders()))}};h.onerror=function(e){f.reject(new i)};h.send(o)};o.defaultLoad=o.load;return o})})();(function(){var t=e.amdDefine;t("5c",["5b"],function(e){"use strict";function t(t,r){return e({url:t,headers:r})}return t})})();(function(){var t=e.amdDefine;t("51",["58","1a","1c","5c"],function(e,t,r,n){"use strict";var i={Accept:"application/json,*/*;q=0.01"};function a(a,o){if(!t(a)){throw new r("url is required.")}if(!t(o)){o=i}else if(!t(o.Accept)){o=e(o);o.Accept=i.Accept}return n(a,o).then(function(e){return JSON.parse(e)})}return a})})();(function(){var t=e.amdDefine;t("5d",["4e","57","23","1a","5e","24","51","53"],function(e,t,r,n,i,a,o,s){"use strict";function u(e){e=r(e,r.EMPTY_OBJECT);this._xysFileUrlTemplate=e.xysFileUrlTemplate;this._interpolationOrder=r(e.interpolationOrder,9);this._sampleZeroJulianEphemerisDate=r(e.sampleZeroJulianEphemerisDate,2442396.5);this._sampleZeroDateTT=new a(this._sampleZeroJulianEphemerisDate,0,s.TAI);this._stepSizeDays=r(e.stepSizeDays,1);this._samplesPerXysFile=r(e.samplesPerXysFile,1e3);this._totalSamples=r(e.totalSamples,27426);this._samples=new Array(this._totalSamples*3);this._chunkDownloadsInProgress=[];var t=this._interpolationOrder;var n=this._denominators=new Array(t+1);var i=this._xTable=new Array(t+1);var o=Math.pow(this._stepSizeDays,t);for(var u=0;u<=t;++u){n[u]=o;i[u]=u*this._stepSizeDays;for(var f=0;f<=t;++f){if(f!==u){n[u]*=u-f}}n[u]=1/n[u]}this._work=new Array(t+1);this._coef=new Array(t+1)}var f=new a(0,0,s.TAI);function c(e,t,r){var n=f;n.dayNumber=t;n.secondsOfDay=r;return a.daysDifference(n,e._sampleZeroDateTT)}u.prototype.preload=function(t,r,n,i){var a=c(this,t,r);var o=c(this,n,i);var s=a/this._stepSizeDays-this._interpolationOrder/2|0;if(s<0){s=0}var u=o/this._stepSizeDays-this._interpolationOrder/2|0+this._interpolationOrder;if(u>=this._totalSamples){u=this._totalSamples-1}var f=s/this._samplesPerXysFile|0;var d=u/this._samplesPerXysFile|0;var h=[];for(var v=f;v<=d;++v){h.push(l(this,v))}return e.all(h)};u.prototype.computeXysRadians=function(e,t,r){var a=c(this,e,t);if(a<0){return undefined}var o=a/this._stepSizeDays|0;if(o>=this._totalSamples){return undefined}var s=this._interpolationOrder;var u=o-(s/2|0);if(u<0){u=0}var f=u+s;if(f>=this._totalSamples){f=this._totalSamples-1;u=f-s;if(u<0){u=0}}var d=false;var h=this._samples;if(!n(h[u*3])){l(this,u/this._samplesPerXysFile|0);d=true}if(!n(h[f*3])){l(this,f/this._samplesPerXysFile|0);d=true}if(d){return undefined}if(!n(r)){r=new i(0,0,0)}else{r.x=0;r.y=0;r.s=0}var v=a-u*this._stepSizeDays;var p=this._work;var m=this._denominators;var w=this._coef;var y=this._xTable;var g,S;for(g=0;g<=s;++g){p[g]=v-y[g]}for(g=0;g<=s;++g){w[g]=1;for(S=0;S<=s;++S){if(S!==g){w[g]*=p[S]}}w[g]*=m[g];var b=(u+g)*3;r.x+=w[g]*h[b++];r.y+=w[g]*h[b++];r.s+=w[g]*h[b]}return r};function l(r,i){if(r._chunkDownloadsInProgress[i]){return r._chunkDownloadsInProgress[i]}var a=e.defer();r._chunkDownloadsInProgress[i]=a;var s;var u=r._xysFileUrlTemplate;if(n(u)){s=u.replace("{0}",i)}else{s=t("Assets/IAU2006_XYS/IAU2006_XYS_"+i+".json")}e(o(s),function(e){r._chunkDownloadsInProgress[i]=false;var t=r._samples;var n=e.samples;var o=i*r._samplesPerXysFile*3;for(var s=0,u=n.length;s<u;++s){t[o+s]=n[s]}a.resolve()});return a.promise}return u})})();(function(){var t=e.amdDefine;t("5e",[],function(){"use strict";function e(e,t,r){this.x=e;this.y=t;this.s=r}return e})})();(function(){var t=e.amdDefine;t("5f",["1a","1b"],function(e,t){"use strict";var r;var n={requestFullscreen:undefined,exitFullscreen:undefined,fullscreenEnabled:undefined,fullscreenElement:undefined,fullscreenchange:undefined,fullscreenerror:undefined};var i={};t(i,{element:{get:function(){if(!i.supportsFullscreen()){return undefined}return document[n.fullscreenElement]}},changeEventName:{get:function(){if(!i.supportsFullscreen()){return undefined}return n.fullscreenchange}},errorEventName:{get:function(){if(!i.supportsFullscreen()){return undefined}return n.fullscreenerror}},enabled:{get:function(){if(!i.supportsFullscreen()){return undefined}return document[n.fullscreenEnabled]}},fullscreen:{get:function(){if(!i.supportsFullscreen()){return undefined}return i.element!==null}}});i.supportsFullscreen=function(){if(e(r)){return r}r=false;var t=document.body;if(typeof t.requestFullscreen==="function"){n.requestFullscreen="requestFullscreen";n.exitFullscreen="exitFullscreen";n.fullscreenEnabled="fullscreenEnabled";n.fullscreenElement="fullscreenElement";n.fullscreenchange="fullscreenchange";n.fullscreenerror="fullscreenerror";r=true;return r}var i=["webkit","moz","o","ms","khtml"];var a;for(var o=0,s=i.length;o<s;++o){var u=i[o];a=u+"RequestFullscreen";if(typeof t[a]==="function"){n.requestFullscreen=a;r=true}else{a=u+"RequestFullScreen";if(typeof t[a]==="function"){n.requestFullscreen=a;r=true}}a=u+"ExitFullscreen";if(typeof document[a]==="function"){n.exitFullscreen=a}else{a=u+"CancelFullScreen";if(typeof document[a]==="function"){n.exitFullscreen=a}}a=u+"FullscreenEnabled";if(document[a]!==undefined){n.fullscreenEnabled=a}else{a=u+"FullScreenEnabled";if(document[a]!==undefined){n.fullscreenEnabled=a}}a=u+"FullscreenElement";if(document[a]!==undefined){n.fullscreenElement=a}else{a=u+"FullScreenElement";if(document[a]!==undefined){n.fullscreenElement=a}}a=u+"fullscreenchange";if(document["on"+a]!==undefined){if(u==="ms"){a="MSFullscreenChange"}n.fullscreenchange=a}a=u+"fullscreenerror";if(document["on"+a]!==undefined){if(u==="ms"){a="MSFullscreenError"}n.fullscreenerror=a}}return r};i.requestFullscreen=function(e,t){if(!i.supportsFullscreen()){return}e[n.requestFullscreen]({vrDisplay:t})};i.exitFullscreen=function(){if(!i.supportsFullscreen()){return}document[n.exitFullscreen]()};return i})})();(function(){var t=e.amdDefine;t("60",["23","1a","5f"],function(e,t,r){"use strict";var n;if(typeof navigator!=="undefined"){n=navigator}else{n={}}function i(e){var t=e.split(".");for(var r=0,n=t.length;r<n;++r){t[r]=parseInt(t[r],10)}return t}var a;var o;function s(){if(!t(a)){a=false;var e=/ Chrome\/([\.0-9]+)/.exec(n.userAgent);if(e!==null){a=true;o=i(e[1])}}return a}function u(){return s()&&o}var f;var c;function l(){if(!t(f)){f=false;if(!s()&&/ Safari\/[\.0-9]+/.test(n.userAgent)){var e=/ Version\/([\.0-9]+)/.exec(n.userAgent);if(e!==null){f=true;c=i(e[1])}}}return f}function d(){return l()&&c}var h;var v;function p(){if(!t(h)){h=false;var e=/ AppleWebKit\/([\.0-9]+)(\+?)/.exec(n.userAgent);if(e!==null){h=true;v=i(e[1]);v.isNightly=!!e[2]}}return h}function m(){return p()&&v}var w;var y;function g(){if(!t(w)){w=false;var e;if(n.appName==="Microsoft Internet Explorer"){e=/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(n.userAgent);if(e!==null){w=true;y=i(e[1])}}else if(n.appName==="Netscape"){e=/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(n.userAgent);if(e!==null){w=true;y=i(e[1])}}}return w}function S(){return g()&&y}var b;var T;function _(){if(!t(b)){b=false;var e=/Firefox\/([\.0-9]+)/.exec(n.userAgent);if(e!==null){b=true;T=i(e[1])}}return b}var E;function M(){if(!t(E)){E=/Windows/i.test(n.appVersion)}return E}function P(){return _()&&T}var A;function C(){if(!t(A)){A=typeof PointerEvent!=="undefined"&&(!t(n.pointerEnabled)||n.pointerEnabled)}return A}var I;var x;function R(){if(!t(x)){var e=document.createElement("canvas");e.setAttribute("style","image-rendering: -moz-crisp-edges;"+"image-rendering: pixelated;");var r=e.style.imageRendering;x=t(r)&&r!=="";if(x){I=r}}return x}function O(){return R()?I:undefined}var D={isChrome:s,chromeVersion:u,isSafari:l,safariVersion:d,isWebkit:p,webkitVersion:m,isInternetExplorer:g,internetExplorerVersion:S,isFirefox:_,firefoxVersion:P,isWindows:M,hardwareConcurrency:e(n.hardwareConcurrency,3),supportsPointerEvents:C,supportsImageRenderingPixelated:R,imageRenderingValue:O};D.supportsFullscreen=function(){return r.supportsFullscreen()};D.supportsTypedArrays=function(){return typeof ArrayBuffer!=="undefined"};D.supportsWebWorkers=function(){return typeof Worker!=="undefined"};return D})})();(function(){var t=e.amdDefine;t("34",["2c","23","1a","1c","60","1f","27","32"],function(e,t,r,n,i,a,o,s){"use strict";function u(e,r,n,i){this.x=t(e,0);this.y=t(r,0);this.z=t(n,0);this.w=t(i,0)}var f=new e;u.fromAxisAngle=function(t,i,a){if(!r(t)){throw new n("axis is required.")}if(typeof i!=="number"){throw new n("angle is required and must be a number.")}var o=i/2;var s=Math.sin(o);f=e.normalize(t,f);var c=f.x*s;var l=f.y*s;var d=f.z*s;var h=Math.cos(o);if(!r(a)){return new u(c,l,d,h)}a.x=c;a.y=l;a.z=d;a.w=h;return a};var c=[1,2,0];var l=new Array(3);u.fromRotationMatrix=function(e,t){if(!r(e)){throw new n("matrix is required.")}var i;var a;var o;var f;var d;var h=e[s.COLUMN0ROW0];var v=e[s.COLUMN1ROW1];var p=e[s.COLUMN2ROW2];var m=h+v+p;if(m>0){i=Math.sqrt(m+1);d=.5*i;i=.5/i;a=(e[s.COLUMN1ROW2]-e[s.COLUMN2ROW1])*i;o=(e[s.COLUMN2ROW0]-e[s.COLUMN0ROW2])*i;f=(e[s.COLUMN0ROW1]-e[s.COLUMN1ROW0])*i}else{var w=c;var y=0;if(v>h){y=1}if(p>h&&p>v){y=2}var g=w[y];var S=w[g];i=Math.sqrt(e[s.getElementIndex(y,y)]-e[s.getElementIndex(g,g)]-e[s.getElementIndex(S,S)]+1);var b=l;b[y]=.5*i;i=.5/i;d=(e[s.getElementIndex(S,g)]-e[s.getElementIndex(g,S)])*i;b[g]=(e[s.getElementIndex(g,y)]+e[s.getElementIndex(y,g)])*i;b[S]=(e[s.getElementIndex(S,y)]+e[s.getElementIndex(y,S)])*i;a=-b[0];o=-b[1];f=-b[2]}if(!r(t)){return new u(a,o,f,d)}t.x=a;t.y=o;t.z=f;t.w=d;return t};var d=new u;u.fromHeadingPitchRoll=function(t,i,a,o){if(!r(t)){throw new n("heading is required.")}if(!r(i)){throw new n("pitch is required.")}if(!r(a)){throw new n("roll is required.")}var s=u.fromAxisAngle(e.UNIT_X,a,d);var f=u.fromAxisAngle(e.UNIT_Y,-i,o);o=u.multiply(f,s,f);var c=u.fromAxisAngle(e.UNIT_Z,-t,d);return u.multiply(c,o,o)};var h=new e;var v=new e;var p=new u;var m=new u;var w=new u;u.packedLength=4;u.pack=function(e,i,a){if(!r(e)){throw new n("value is required")}if(!r(i)){throw new n("array is required")}a=t(a,0);i[a++]=e.x;i[a++]=e.y;i[a++]=e.z;i[a]=e.w};u.unpack=function(e,i,a){if(!r(e)){throw new n("array is required")}i=t(i,0);if(!r(a)){a=new u}a.x=e[i];a.y=e[i+1];a.z=e[i+2];a.w=e[i+3];return a};u.packedInterpolationLength=3;u.convertPackedArrayForInterpolation=function(e,t,r,n){u.unpack(e,r*4,w);u.conjugate(w,w);for(var i=0,a=r-t+1;i<a;i++){var o=i*3;u.unpack(e,(t+i)*4,p);u.multiply(p,w,p);if(p.w<0){u.negate(p,p)}u.computeAxis(p,h);var s=u.computeAngle(p);n[o]=h.x*s;n[o+1]=h.y*s;n[o+2]=h.z*s}};u.unpackInterpolationResult=function(t,n,i,a,o){if(!r(o)){o=new u}e.fromArray(t,0,v);var s=e.magnitude(v);u.unpack(n,a*4,m);if(s===0){u.clone(u.IDENTITY,p)}else{u.fromAxisAngle(v,s,p)}return u.multiply(p,m,o)};u.clone=function(e,t){if(!r(e)){return undefined}if(!r(t)){return new u(e.x,e.y,e.z,e.w)}t.x=e.x;t.y=e.y;t.z=e.z;t.w=e.w;return t};u.conjugate=function(e,t){if(!r(e)){throw new n("quaternion is required")}if(!r(t)){throw new n("result is required")}t.x=-e.x;t.y=-e.y;t.z=-e.z;t.w=e.w;return t};u.magnitudeSquared=function(e){if(!r(e)){throw new n("quaternion is required")}return e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w};u.magnitude=function(e){return Math.sqrt(u.magnitudeSquared(e))};u.normalize=function(e,t){if(!r(t)){throw new n("result is required")}var i=1/u.magnitude(e);var a=e.x*i;var o=e.y*i;var s=e.z*i;var f=e.w*i;t.x=a;t.y=o;t.z=s;t.w=f;return t};u.inverse=function(e,t){if(!r(t)){throw new n("result is required")}var i=u.magnitudeSquared(e);t=u.conjugate(e,t);return u.multiplyByScalar(t,1/i,t)};u.add=function(e,t,i){if(!r(e)){throw new n("left is required")}if(!r(t)){throw new n("right is required")}if(!r(i)){throw new n("result is required")}i.x=e.x+t.x;i.y=e.y+t.y;i.z=e.z+t.z;i.w=e.w+t.w;return i};u.subtract=function(e,t,i){if(!r(e)){throw new n("left is required")}if(!r(t)){throw new n("right is required")}if(!r(i)){throw new n("result is required")}i.x=e.x-t.x;i.y=e.y-t.y;i.z=e.z-t.z;i.w=e.w-t.w;return i};u.negate=function(e,t){if(!r(e)){throw new n("quaternion is required")}if(!r(t)){throw new n("result is required")}t.x=-e.x;t.y=-e.y;t.z=-e.z;t.w=-e.w;return t};u.dot=function(e,t){if(!r(e)){throw new n("left is required")}if(!r(t)){throw new n("right is required")}return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w};u.multiply=function(e,t,i){if(!r(e)){throw new n("left is required")}if(!r(t)){throw new n("right is required")}if(!r(i)){throw new n("result is required")}var a=e.x;var o=e.y;var s=e.z;var u=e.w;var f=t.x;var c=t.y;var l=t.z;var d=t.w;var h=u*f+a*d+o*l-s*c;var v=u*c-a*l+o*d+s*f;var p=u*l+a*c-o*f+s*d;var m=u*d-a*f-o*c-s*l;i.x=h;i.y=v;i.z=p;i.w=m;return i};u.multiplyByScalar=function(e,t,i){if(!r(e)){throw new n("quaternion is required")}if(typeof t!=="number"){throw new n("scalar is required and must be a number.")}if(!r(i)){throw new n("result is required")}i.x=e.x*t;i.y=e.y*t;i.z=e.z*t;i.w=e.w*t;return i};u.divideByScalar=function(e,t,i){if(!r(e)){throw new n("quaternion is required")}if(typeof t!=="number"){throw new n("scalar is required and must be a number.")}if(!r(i)){throw new n("result is required")}i.x=e.x/t;i.y=e.y/t;i.z=e.z/t;i.w=e.w/t;return i};u.computeAxis=function(e,t){if(!r(e)){throw new n("quaternion is required")}if(!r(t)){throw new n("result is required")}var i=e.w;if(Math.abs(i-1)<o.EPSILON6){t.x=t.y=t.z=0;return t}var a=1/Math.sqrt(1-i*i);t.x=e.x*a;t.y=e.y*a;t.z=e.z*a;return t};u.computeAngle=function(e){if(!r(e)){throw new n("quaternion is required")}if(Math.abs(e.w-1)<o.EPSILON6){return 0}return 2*Math.acos(e.w)};var y=new u;u.lerp=function(e,t,i,a){if(!r(e)){throw new n("start is required.")}if(!r(t)){throw new n("end is required.")}if(typeof i!=="number"){throw new n("t is required and must be a number.")}if(!r(a)){throw new n("result is required")}y=u.multiplyByScalar(t,i,y);a=u.multiplyByScalar(e,1-i,a);return u.add(y,a,a)};var g=new u;
	var S=new u;var b=new u;u.slerp=function(e,t,i,a){if(!r(e)){throw new n("start is required.")}if(!r(t)){throw new n("end is required.")}if(typeof i!=="number"){throw new n("t is required and must be a number.")}if(!r(a)){throw new n("result is required")}var s=u.dot(e,t);var f=t;if(s<0){s=-s;f=g=u.negate(t,g)}if(1-s<o.EPSILON6){return u.lerp(e,f,i,a)}var c=Math.acos(s);S=u.multiplyByScalar(e,Math.sin((1-i)*c),S);b=u.multiplyByScalar(f,Math.sin(i*c),b);a=u.add(S,b,a);return u.multiplyByScalar(a,1/Math.sin(c),a)};u.log=function(t,i){if(!r(t)){throw new n("quaternion is required.")}if(!r(i)){throw new n("result is required")}var a=o.acosClamped(t.w);var s=0;if(a!==0){s=a/Math.sin(a)}return e.multiplyByScalar(t,s,i)};u.exp=function(t,i){if(!r(t)){throw new n("cartesian is required.")}if(!r(i)){throw new n("result is required")}var a=e.magnitude(t);var o=0;if(a!==0){o=Math.sin(a)/a}i.x=t.x*o;i.y=t.y*o;i.z=t.z*o;i.w=Math.cos(a);return i};var T=new e;var _=new e;var E=new u;var M=new u;u.computeInnerQuadrangle=function(t,i,a,o){if(!r(t)||!r(i)||!r(a)){throw new n("q0, q1, and q2 are required.")}if(!r(o)){throw new n("result is required")}var s=u.conjugate(i,E);u.multiply(s,a,M);var f=u.log(M,T);u.multiply(s,t,M);var c=u.log(M,_);e.add(f,c,f);e.multiplyByScalar(f,.25,f);e.negate(f,f);u.exp(f,E);return u.multiply(i,E,o)};u.squad=function(e,t,i,a,o,s){if(!r(e)||!r(t)||!r(i)||!r(a)){throw new n("q0, q1, s0, and s1 are required.")}if(typeof o!=="number"){throw new n("t is required and must be a number.")}if(!r(s)){throw new n("result is required")}var f=u.slerp(e,t,o,E);var c=u.slerp(i,a,o,M);return u.slerp(f,c,2*o*(1-o),s)};var P=new u;var A=1.9011074535173003;var C=i.supportsTypedArrays()?new Float32Array(8):[];var I=i.supportsTypedArrays()?new Float32Array(8):[];var x=i.supportsTypedArrays()?new Float32Array(8):[];var R=i.supportsTypedArrays()?new Float32Array(8):[];for(var O=0;O<7;++O){var D=O+1;var q=2*D+1;C[O]=1/(D*q);I[O]=D/q}C[7]=A/(8*17);I[7]=A*8/17;u.fastSlerp=function(e,t,i,a){if(!r(e)){throw new n("start is required.")}if(!r(t)){throw new n("end is required.")}if(typeof i!=="number"){throw new n("t is required and must be a number.")}if(!r(a)){throw new n("result is required")}var o=u.dot(e,t);var s;if(o>=0){s=1}else{s=-1;o=-o}var f=o-1;var c=1-i;var l=i*i;var d=c*c;for(var h=7;h>=0;--h){x[h]=(C[h]*l-I[h])*f;R[h]=(C[h]*d-I[h])*f}var v=s*i*(1+x[0]*(1+x[1]*(1+x[2]*(1+x[3]*(1+x[4]*(1+x[5]*(1+x[6]*(1+x[7]))))))));var p=c*(1+R[0]*(1+R[1]*(1+R[2]*(1+R[3]*(1+R[4]*(1+R[5]*(1+R[6]*(1+R[7]))))))));var m=u.multiplyByScalar(e,p,P);u.multiplyByScalar(t,v,a);return u.add(m,a,a)};u.fastSquad=function(e,t,i,a,o,s){if(!r(e)||!r(t)||!r(i)||!r(a)){throw new n("q0, q1, s0, and s1 are required.")}if(typeof o!=="number"){throw new n("t is required and must be a number.")}if(!r(s)){throw new n("result is required")}var f=u.fastSlerp(e,t,o,E);var c=u.fastSlerp(i,a,o,M);return u.fastSlerp(f,c,2*o*(1-o),s)};u.equals=function(e,t){return e===t||r(e)&&r(t)&&e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w};u.equalsEpsilon=function(e,t,i){if(typeof i!=="number"){throw new n("epsilon is required and must be a number.")}return e===t||r(e)&&r(t)&&Math.abs(e.x-t.x)<=i&&Math.abs(e.y-t.y)<=i&&Math.abs(e.z-t.z)<=i&&Math.abs(e.w-t.w)<=i};u.ZERO=a(new u(0,0,0,0));u.IDENTITY=a(new u(0,0,0,1));u.prototype.clone=function(e){return u.clone(this,e)};u.prototype.equals=function(e){return u.equals(this,e)};u.prototype.equalsEpsilon=function(e,t){return u.equalsEpsilon(this,e,t)};u.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+", "+this.w+")"};return u})})();(function(){var t=e.amdDefine;t("35",["4e","45","2c","43","3b","23","1a","1c","4d","4f","3c","5d","5e","24","27","32","33","34","52"],function(e,t,r,n,i,a,o,s,u,f,c,l,d,h,v,p,m,w,y){"use strict";var g={};var S=new r;var b=new r;var T=new r;g.eastNorthUpToFixedFrame=function(e,t,n){if(!o(e)){throw new s("origin is required.")}if(v.equalsEpsilon(e.x,0,v.EPSILON14)&&v.equalsEpsilon(e.y,0,v.EPSILON14)){var i=v.sign(e.z);if(!o(n)){return new m(0,-i,0,e.x,1,0,0,e.y,0,0,i,e.z,0,0,0,1)}n[0]=0;n[1]=1;n[2]=0;n[3]=0;n[4]=-i;n[5]=0;n[6]=0;n[7]=0;n[8]=0;n[9]=0;n[10]=i;n[11]=0;n[12]=e.x;n[13]=e.y;n[14]=e.z;n[15]=1;return n}var u=S;var f=b;var l=T;t=a(t,c.WGS84);t.geodeticSurfaceNormal(e,u);f.x=-e.y;f.y=e.x;f.z=0;r.normalize(f,f);r.cross(u,f,l);if(!o(n)){return new m(f.x,l.x,u.x,e.x,f.y,l.y,u.y,e.y,f.z,l.z,u.z,e.z,0,0,0,1)}n[0]=f.x;n[1]=f.y;n[2]=f.z;n[3]=0;n[4]=l.x;n[5]=l.y;n[6]=l.z;n[7]=0;n[8]=u.x;n[9]=u.y;n[10]=u.z;n[11]=0;n[12]=e.x;n[13]=e.y;n[14]=e.z;n[15]=1;return n};var _=new r;var E=new r;var M=new r;g.northEastDownToFixedFrame=function(e,t,n){if(!o(e)){throw new s("origin is required.")}if(v.equalsEpsilon(e.x,0,v.EPSILON14)&&v.equalsEpsilon(e.y,0,v.EPSILON14)){var i=v.sign(e.z);if(!o(n)){return new m(-i,0,0,e.x,0,1,0,e.y,0,0,-i,e.z,0,0,0,1)}n[0]=-i;n[1]=0;n[2]=0;n[3]=0;n[4]=0;n[5]=1;n[6]=0;n[7]=0;n[8]=0;n[9]=0;n[10]=-i;n[11]=0;n[12]=e.x;n[13]=e.y;n[14]=e.z;n[15]=1;return n}var u=_;var f=E;var l=M;t=a(t,c.WGS84);t.geodeticSurfaceNormal(e,u);f.x=-e.y;f.y=e.x;f.z=0;r.normalize(f,f);r.cross(u,f,l);if(!o(n)){return new m(l.x,f.x,-u.x,e.x,l.y,f.y,-u.y,e.y,l.z,f.z,-u.z,e.z,0,0,0,1)}n[0]=l.x;n[1]=l.y;n[2]=l.z;n[3]=0;n[4]=f.x;n[5]=f.y;n[6]=f.z;n[7]=0;n[8]=-u.x;n[9]=-u.y;n[10]=-u.z;n[11]=0;n[12]=e.x;n[13]=e.y;n[14]=e.z;n[15]=1;return n};g.northUpEastToFixedFrame=function(e,t,n){if(!o(e)){throw new s("origin is required.")}if(v.equalsEpsilon(e.x,0,v.EPSILON14)&&v.equalsEpsilon(e.y,0,v.EPSILON14)){var i=v.sign(e.z);if(!o(n)){return new m(-i,0,0,e.x,0,0,1,e.y,0,i,0,e.z,0,0,0,1)}n[0]=-i;n[1]=0;n[2]=0;n[3]=0;n[4]=0;n[5]=0;n[6]=i;n[7]=0;n[8]=0;n[9]=1;n[10]=0;n[11]=0;n[12]=e.x;n[13]=e.y;n[14]=e.z;n[15]=1;return n}var u=S;var f=b;var l=T;t=a(t,c.WGS84);t.geodeticSurfaceNormal(e,u);f.x=-e.y;f.y=e.x;f.z=0;r.normalize(f,f);r.cross(u,f,l);if(!o(n)){return new m(l.x,u.x,f.x,e.x,l.y,u.y,f.y,e.y,l.z,u.z,f.z,e.z,0,0,0,1)}n[0]=l.x;n[1]=l.y;n[2]=l.z;n[3]=0;n[4]=u.x;n[5]=u.y;n[6]=u.z;n[7]=0;n[8]=f.x;n[9]=f.y;n[10]=f.z;n[11]=0;n[12]=e.x;n[13]=e.y;n[14]=e.z;n[15]=1;return n};var P=new w;var A=new r(1,1,1);var C=new m;g.headingPitchRollToFixedFrame=function(e,t,n,i,a,o){var s=w.fromHeadingPitchRoll(t,n,i,P);var u=m.fromTranslationQuaternionRotationScale(r.ZERO,s,A,C);o=g.eastNorthUpToFixedFrame(e,a,o);return m.multiply(o,u,o)};var I=new m;var x=new p;g.headingPitchRollQuaternion=function(e,t,r,n,i,a){var o=g.headingPitchRollToFixedFrame(e,t,r,n,i,I);var s=m.getRotation(o,x);return w.fromRotationMatrix(s,a)};var R=6*3600+41*60+50.54841;var O=8640184.812866;var D=.093104;var q=-62e-7;var N=1.1772758384668e-19;var G=72921158553e-15;var L=v.TWO_PI/86400;var B=new h;g.computeTemeToPseudoFixedMatrix=function(e,t){if(!o(e)){throw new s("date is required.")}B=h.addSeconds(e,-h.computeTaiMinusUtc(e),B);var r=B.dayNumber;var n=B.secondsOfDay;var i;var a=r-2451545;if(n>=43200){i=(a+.5)/y.DAYS_PER_JULIAN_CENTURY}else{i=(a-.5)/y.DAYS_PER_JULIAN_CENTURY}var u=R+i*(O+i*(D+i*q));var f=u*L%v.TWO_PI;var c=G+N*(r-2451545.5);var l=(n+y.SECONDS_PER_DAY*.5)%y.SECONDS_PER_DAY;var d=f+c*l;var m=Math.cos(d);var w=Math.sin(d);if(!o(t)){return new p(m,w,0,-w,m,0,0,0,1)}t[0]=m;t[1]=-w;t[2]=0;t[3]=w;t[4]=m;t[5]=0;t[6]=0;t[7]=0;t[8]=1;return t};g.iau2006XysData=new l;g.earthOrientationParameters=u.NONE;var H=32.184;var k=2451545;g.preloadIcrfFixed=function(t){var r=t.start.dayNumber;var n=t.start.secondsOfDay+H;var i=t.stop.dayNumber;var a=t.stop.secondsOfDay+H;var o=g.iau2006XysData.preload(r,n,i,a);var s=g.earthOrientationParameters.getPromiseToLoad();return e.all([o,s])};g.computeIcrfToFixedMatrix=function(e,t){if(!o(e)){throw new s("date is required.")}if(!o(t)){t=new p}var r=g.computeFixedToIcrfMatrix(e,t);if(!o(r)){return undefined}return p.transpose(r,t)};var z=new d(0,0,0);var F=new f(0,0,0,0,0,0);var U=new p;var V=new p;g.computeFixedToIcrfMatrix=function(e,t){if(!o(e)){throw new s("date is required.")}if(!o(t)){t=new p}var r=g.earthOrientationParameters.compute(e,F);if(!o(r)){return undefined}var n=e.dayNumber;var i=e.secondsOfDay+H;var a=g.iau2006XysData.computeXysRadians(n,i,z);if(!o(a)){return undefined}var u=a.x+r.xPoleOffset;var f=a.y+r.yPoleOffset;var c=1/(1+Math.sqrt(1-u*u-f*f));var l=U;l[0]=1-c*u*u;l[3]=-c*u*f;l[6]=u;l[1]=-c*u*f;l[4]=1-c*f*f;l[7]=f;l[2]=-u;l[5]=-f;l[8]=1-c*(u*u+f*f);var d=p.fromRotationZ(-a.s,V);var m=p.multiply(l,d,U);var w=e.dayNumber;var S=e.secondsOfDay-h.computeTaiMinusUtc(e)+r.ut1MinusUtc;var b=w-2451545;var T=S/y.SECONDS_PER_DAY;var _=.779057273264+T+.00273781191135448*(b+T);_=_%1*v.TWO_PI;var E=p.fromRotationZ(_,V);var M=p.multiply(m,E,U);var P=Math.cos(r.xPoleWander);var A=Math.cos(r.yPoleWander);var C=Math.sin(r.xPoleWander);var I=Math.sin(r.yPoleWander);var x=n-k+i/y.SECONDS_PER_DAY;x/=36525;var R=-47e-6*x*v.RADIANS_PER_DEGREE/3600;var O=Math.cos(R);var D=Math.sin(R);var q=V;q[0]=P*O;q[1]=P*D;q[2]=C;q[3]=-A*D+I*C*O;q[4]=A*O+I*C*D;q[5]=-I*P;q[6]=-I*D-A*C*O;q[7]=I*O-A*C*D;q[8]=A*P;return p.multiply(M,q,t)};var j=new n;g.pointToWindowCoordinates=function(e,t,r,n){n=g.pointToGLWindowCoordinates(e,t,r,n);n.y=2*t[5]-n.y;return n};g.pointToGLWindowCoordinates=function(e,r,i,a){if(!o(e)){throw new s("modelViewProjectionMatrix is required.")}if(!o(r)){throw new s("viewportTransformation is required.")}if(!o(i)){throw new s("point is required.")}if(!o(a)){a=new t}var u=j;m.multiplyByVector(e,n.fromElements(i.x,i.y,i.z,1,u),u);n.multiplyByScalar(u,1/u.w,u);m.multiplyByVector(r,u,u);return t.fromCartesian4(u,a)};var W=new r;var X=new r;var Q=new r;g.rotationMatrixFromPositionVelocity=function(e,t,n,i){if(!o(e)){throw new s("position is required.")}if(!o(t)){throw new s("velocity is required.")}var u=a(n,c.WGS84).geodeticSurfaceNormal(e,W);var f=r.cross(t,u,X);if(r.equalsEpsilon(f,r.ZERO,v.EPSILON6)){f=r.clone(r.UNIT_X,f)}var l=r.cross(f,t,Q);r.cross(t,l,f);r.negate(f,f);if(!o(i)){i=new p}i[0]=t.x;i[1]=t.y;i[2]=t.z;i[3]=f.x;i[4]=f.y;i[5]=f.z;i[6]=l.x;i[7]=l.y;i[8]=l.z;return i};var K=new i;var Y=new r;var Z=new r;var J=new n;var $=new n;var ee=new n;var te=new n;var re=new n;var ne=new m;var ie=new m;g.basisTo2D=function(e,t,i){if(!o(e)){throw new s("projection is required.")}if(!o(t)){throw new s("matrix is required.")}if(!o(i)){throw new s("result is required.")}var a=e.ellipsoid;var u=m.getColumn(t,3,J);var f=a.cartesianToCartographic(u,K);var c=g.eastNorthUpToFixedFrame(u,a,ne);var l=m.inverseTransformation(c,ie);var d=e.project(f,Y);var h=$;h.x=d.z;h.y=d.x;h.z=d.y;h.w=1;var v=m.getColumn(t,0,Z);var p=r.magnitude(v);var w=m.multiplyByVector(l,v,ee);n.fromElements(w.z,w.x,w.y,0,w);var y=m.getColumn(t,1,Z);var S=r.magnitude(y);var b=m.multiplyByVector(l,y,te);n.fromElements(b.z,b.x,b.y,0,b);var T=m.getColumn(t,2,Z);var _=r.magnitude(T);var E=re;r.cross(w,b,E);r.normalize(E,E);r.cross(b,E,w);r.normalize(w,w);r.cross(E,w,b);r.normalize(b,b);r.multiplyByScalar(w,p,w);r.multiplyByScalar(b,S,b);r.multiplyByScalar(E,_,E);m.setColumn(i,0,w,i);m.setColumn(i,1,b,i);m.setColumn(i,2,E,i);m.setColumn(i,3,h,i);return i};return g})})();(function(){var t=e.amdDefine;t("61",[],function(){function e(){var e=/%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;var t=arguments,r=0,n=t[r++];var i=function(e,t,r,n){if(!r){r=" "}var i=e.length>=t?"":Array(1+t-e.length>>>0).join(r);return n?e+i:i+e};var a=function(e,t,r,n,a,o){var s=n-e.length;if(s>0){if(r||!a){e=i(e,n,o,r)}else{e=e.slice(0,t.length)+i("",s,"0",true)+e.slice(t.length)}}return e};var o=function(e,t,r,n,o,s,u){var f=e>>>0;r=r&&f&&{2:"0b",8:"0",16:"0x"}[t]||"";e=r+i(f.toString(t),s||0,"0",false);return a(e,r,n,o,u)};var s=function(e,t,r,n,i,o){if(n!=null){e=e.slice(0,n)}return a(e,"",t,r,i,o)};var u=function(e,n,u,f,c,l,d){var h;var v;var p;var m;var w;if(e=="%%"){return"%"}var y=false,g="",S=false,b=false,T=" ";var _=u.length;for(var E=0;u&&E<_;E++){switch(u.charAt(E)){case" ":g=" ";break;case"+":g="+";break;case"-":y=true;break;case"'":T=u.charAt(E+1);break;case"0":S=true;break;case"#":b=true;break}}if(!f){f=0}else if(f=="*"){f=+t[r++]}else if(f.charAt(0)=="*"){f=+t[f.slice(1,-1)]}else{f=+f}if(f<0){f=-f;y=true}if(!isFinite(f)){throw new Error("sprintf: (minimum-)width must be finite")}if(!l){l="fFeE".indexOf(d)>-1?6:d=="d"?0:undefined}else if(l=="*"){l=+t[r++]}else if(l.charAt(0)=="*"){l=+t[l.slice(1,-1)]}else{l=+l}w=n?t[n.slice(0,-1)]:t[r++];switch(d){case"s":return s(String(w),y,f,l,S,T);case"c":return s(String.fromCharCode(+w),y,f,l,S);case"b":return o(w,2,b,y,f,l,S);case"o":return o(w,8,b,y,f,l,S);case"x":return o(w,16,b,y,f,l,S);case"X":return o(w,16,b,y,f,l,S).toUpperCase();case"u":return o(w,10,b,y,f,l,S);case"i":case"d":h=+w||0;h=Math.round(h-h%1);v=h<0?"-":g;w=v+i(String(Math.abs(h)),l,"0",false);return a(w,v,y,f,S);case"e":case"E":case"f":case"F":case"g":case"G":h=+w;v=h<0?"-":g;p=["toExponential","toFixed","toPrecision"]["efg".indexOf(d.toLowerCase())];m=["toString","toUpperCase"]["eEfFgG".indexOf(d)%2];w=v+Math.abs(h)[p](l);return a(w,v,y,f,S)[m]();default:return e}};return n.replace(e,u)}return e})})();(function(){var t=e.amdDefine;t("4c",["1a","1c"],function(e,t){"use strict";function r(r,n,i){if(!e(r)){throw new t("array is required.")}if(!e(n)){throw new t("itemToFind is required.")}if(!e(i)){throw new t("comparator is required.")}var a=0;var o=r.length-1;var s;var u;while(a<=o){s=~~((a+o)/2);u=i(r[s],n);if(u<0){a=s+1;continue}if(u>0){o=s-1;continue}return s}return~(o+1)}return r})})();(function(){var t=e.amdDefine;t("62",[],function(){"use strict";function e(e,t,r,n,i,a,o,s){this.year=e;this.month=t;this.day=r;this.hour=n;this.minute=i;this.second=a;this.millisecond=o;this.isLeapSecond=s}return e})})();(function(){var t=e.amdDefine;t("63",["1c"],function(e){"use strict";function t(t){if(t===null||isNaN(t)){throw new e("year is required and must be a number.")}return t%4===0&&t%100!==0||t%400===0}return t})})();(function(){var t=e.amdDefine;t("50",[],function(){"use strict";function e(e,t){this.julianDate=e;this.offset=t}return e})})();(function(){var t=e.amdDefine;t("24",["61","4c","23","1a","1c","62","63","50","52","53"],function(e,t,r,n,i,a,o,s,u,f){"use strict";var c=new a;var l=[31,28,31,30,31,30,31,31,30,31,30,31];var d=29;function h(e,t){return I.compare(e.julianDate,t.julianDate)}var v=new s;function p(e){v.julianDate=e;var r=I.leapSeconds;var n=t(r,v,h);if(n<0){n=~n}if(n>=r.length){n=r.length-1}var i=r[n].offset;if(n>0){var a=I.secondsDifference(r[n].julianDate,e);if(a>i){n--;i=r[n].offset}}I.addSeconds(e,i,e)}function m(e,r){v.julianDate=e;var n=I.leapSeconds;var i=t(n,v,h);if(i<0){i=~i}if(i===0){return I.addSeconds(e,-n[0].offset,r)}if(i>=n.length){return I.addSeconds(e,-n[i-1].offset,r)}var a=I.secondsDifference(n[i].julianDate,e);if(a===0){return I.addSeconds(e,-n[i].offset,r)}if(a<=1){return undefined}return I.addSeconds(e,-n[--i].offset,r)}function w(e,t,r){var n=t/u.SECONDS_PER_DAY|0;e+=n;t-=u.SECONDS_PER_DAY*n;if(t<0){e--;t+=u.SECONDS_PER_DAY}r.dayNumber=e;r.secondsOfDay=t;return r}function y(e,t,r,n,i,a,o){var s=(t-14)/12|0;var f=e+4800+s;var c=(1461*f/4|0)+(367*(t-2-12*s)/12|0)-(3*((f+100)/100|0)/4|0)+r-32075;n=n-12;if(n<0){n+=24}var l=a+(n*u.SECONDS_PER_HOUR+i*u.SECONDS_PER_MINUTE+o*u.SECONDS_PER_MILLISECOND);if(l>=43200){c-=1}return[c,l]}var g=/^(\d{4})$/;var S=/^(\d{4})-(\d{2})$/;var b=/^(\d{4})-?(\d{3})$/;var T=/^(\d{4})-?W(\d{2})-?(\d{1})?$/;var _=/^(\d{4})-?(\d{2})-?(\d{2})$/;var E=/([Z+\-])?(\d{2})?:?(\d{2})?$/;var M=/^(\d{2})(\.\d+)?/.source+E.source;var P=/^(\d{2}):?(\d{2})(\.\d+)?/.source+E.source;var A=/^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source+E.source;var C="Invalid ISO 8601 date.";function I(e,t,n){this.dayNumber=undefined;this.secondsOfDay=undefined;e=r(e,0);t=r(t,0);n=r(n,f.UTC);var i=e|0;t=t+(e-i)*u.SECONDS_PER_DAY;w(i,t,this);if(n===f.UTC){p(this)}}I.fromDate=function(e,t){if(!(e instanceof Date)||isNaN(e.getTime())){throw new i("date must be a valid JavaScript Date.")}var r=y(e.getUTCFullYear(),e.getUTCMonth()+1,e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds(),e.getUTCMilliseconds());if(!n(t)){return new I(r[0],r[1],f.UTC)}w(r[0],r[1],t);p(t);return t};I.fromIso8601=function(e,t){if(typeof e!=="string"){throw new i(C)}e=e.replace(",",".");var r=e.split("T");var a;var s=1;var u=1;var c=0;var h=0;var v=0;var m=0;var E=r[0];var x=r[1];var R;var O;if(!n(E)){throw new i(C)}var D;r=E.match(_);if(r!==null){D=E.split("-").length-1;if(D>0&&D!==2){throw new i(C)}a=+r[1];s=+r[2];u=+r[3]}else{r=E.match(S);if(r!==null){a=+r[1];s=+r[2]}else{r=E.match(g);if(r!==null){a=+r[1]}else{var q;r=E.match(b);if(r!==null){a=+r[1];q=+r[2];O=o(a);if(q<1||O&&q>366||!O&&q>365){throw new i(C)}}else{r=E.match(T);if(r!==null){a=+r[1];var N=+r[2];var G=+r[3]||0;D=E.split("-").length-1;if(D>0&&(!n(r[3])&&D!==1||n(r[3])&&D!==2)){throw new i(C)}var L=new Date(Date.UTC(a,0,4));q=N*7+G-L.getUTCDay()-3}else{throw new i(C)}}R=new Date(Date.UTC(a,0,1));R.setUTCDate(q);s=R.getUTCMonth()+1;u=R.getUTCDate()}}}O=o(a);if(s<1||s>12||u<1||(s!==2||!O)&&u>l[s-1]||O&&s===2&&u>d){throw new i(C)}var B;if(n(x)){r=x.match(A);if(r!==null){D=x.split(":").length-1;if(D>0&&D!==2&&D!==3){throw new i(C)}c=+r[1];h=+r[2];v=+r[3];m=+(r[4]||0)*1e3;B=5}else{r=x.match(P);if(r!==null){D=x.split(":").length-1;if(D>2){throw new i(C)}c=+r[1];h=+r[2];v=+(r[3]||0)*60;B=4}else{r=x.match(M);if(r!==null){c=+r[1];h=+(r[2]||0)*60;B=3}else{throw new i(C)}}}if(h>=60||v>=61||c>24||c===24&&(h>0||v>0||m>0)){throw new i(C)}var H=r[B];var k=+r[B+1];var z=+(r[B+2]||0);switch(H){case"+":c=c-k;h=h-z;break;case"-":c=c+k;h=h+z;break;case"Z":break;default:h=h+new Date(Date.UTC(a,s-1,u,c,h)).getTimezoneOffset();break}}else{h=h+new Date(a,s-1,u).getTimezoneOffset()}var F=v===60;if(F){v--}while(h>=60){h-=60;c++}while(c>=24){c-=24;u++}R=O&&s===2?d:l[s-1];while(u>R){u-=R;s++;if(s>12){s-=12;a++}R=O&&s===2?d:l[s-1]}while(h<0){h+=60;c--}while(c<0){c+=24;u--}while(u<1){s--;if(s<1){s+=12;a--}R=O&&s===2?d:l[s-1];u+=R}var U=y(a,s,u,c,h,v,m);if(!n(t)){t=new I(U[0],U[1],f.UTC)}else{w(U[0],U[1],t);p(t)}if(F){I.addSeconds(t,1,t)}return t};I.now=function(e){return I.fromDate(new Date,e)};var x=new I(0,0,f.TAI);I.toGregorianDate=function(e,t){if(!n(e)){throw new i("julianDate is required.")}var r=false;var o=m(e,x);if(!n(o)){I.addSeconds(e,-1,x);o=m(x,x);r=true}var s=o.dayNumber;var f=o.secondsOfDay;if(f>=43200){s+=1}var c=s+68569|0;var l=4*c/146097|0;c=c-((146097*l+3)/4|0)|0;var d=4e3*(c+1)/1461001|0;c=c-(1461*d/4|0)+31|0;var h=80*c/2447|0;var v=c-(2447*h/80|0)|0;c=h/11|0;var p=h+2-12*c|0;var w=100*(l-49)+d+c|0;var y=f/u.SECONDS_PER_HOUR|0;var g=f-y*u.SECONDS_PER_HOUR;var S=g/u.SECONDS_PER_MINUTE|0;g=g-S*u.SECONDS_PER_MINUTE;var b=g|0;var T=(g-b)/u.SECONDS_PER_MILLISECOND;y+=12;if(y>23){y-=24}if(r){b+=1}if(!n(t)){return new a(w,p,v,y,S,b,T,r)}t.year=w;t.month=p;t.day=v;t.hour=y;t.minute=S;t.second=b;t.millisecond=T;t.isLeapSecond=r;return t};I.toDate=function(e){if(!n(e)){throw new i("julianDate is required.")}var t=I.toGregorianDate(e,c);var r=t.second;if(t.isLeapSecond){r-=1}return new Date(Date.UTC(t.year,t.month-1,t.day,t.hour,t.minute,r,t.millisecond))};I.toIso8601=function(t,r){if(!n(t)){throw new i("julianDate is required.")}var a=I.toGregorianDate(t,a);var o;if(!n(r)&&a.millisecond!==0){o=(a.millisecond*.01).toString().replace(".","");return e("%04d-%02d-%02dT%02d:%02d:%02d.%sZ",a.year,a.month,a.day,a.hour,a.minute,a.second,o)}if(!n(r)||r===0){return e("%04d-%02d-%02dT%02d:%02d:%02dZ",a.year,a.month,a.day,a.hour,a.minute,a.second)}o=(a.millisecond*.01).toFixed(r).replace(".","").slice(0,r);return e("%04d-%02d-%02dT%02d:%02d:%02d.%sZ",a.year,a.month,a.day,a.hour,a.minute,a.second,o)};I.clone=function(e,t){if(!n(e)){return undefined}if(!n(t)){return new I(e.dayNumber,e.secondsOfDay,f.TAI)}t.dayNumber=e.dayNumber;t.secondsOfDay=e.secondsOfDay;return t};I.compare=function(e,t){if(!n(e)){throw new i("left is required.")}if(!n(t)){throw new i("right is required.")}var r=e.dayNumber-t.dayNumber;if(r!==0){return r}return e.secondsOfDay-t.secondsOfDay};I.equals=function(e,t){return e===t||n(e)&&n(t)&&e.dayNumber===t.dayNumber&&e.secondsOfDay===t.secondsOfDay};I.equalsEpsilon=function(e,t,r){if(!n(r)){throw new i("epsilon is required.")}return e===t||n(e)&&n(t)&&Math.abs(I.secondsDifference(e,t))<=r};I.totalDays=function(e){if(!n(e)){throw new i("julianDate is required.")}return e.dayNumber+e.secondsOfDay/u.SECONDS_PER_DAY};I.secondsDifference=function(e,t){if(!n(e)){throw new i("left is required.")}if(!n(t)){throw new i("right is required.")}var r=(e.dayNumber-t.dayNumber)*u.SECONDS_PER_DAY;return r+(e.secondsOfDay-t.secondsOfDay)};I.daysDifference=function(e,t){if(!n(e)){throw new i("left is required.")}if(!n(t)){throw new i("right is required.")}var r=e.dayNumber-t.dayNumber;var a=(e.secondsOfDay-t.secondsOfDay)/u.SECONDS_PER_DAY;return r+a};I.computeTaiMinusUtc=function(e){v.julianDate=e;var r=I.leapSeconds;var n=t(r,v,h);if(n<0){n=~n;--n;if(n<0){n=0}}return r[n].offset};I.addSeconds=function(e,t,r){if(!n(e)){throw new i("julianDate is required.")}if(!n(t)){throw new i("seconds is required.")}if(!n(r)){throw new i("result is required.")}return w(e.dayNumber,e.secondsOfDay+t,r)};I.addMinutes=function(e,t,r){if(!n(e)){throw new i("julianDate is required.")}if(!n(t)){throw new i("minutes is required.")}if(!n(r)){throw new i("result is required.")}var a=e.secondsOfDay+t*u.SECONDS_PER_MINUTE;return w(e.dayNumber,a,r)};I.addHours=function(e,t,r){if(!n(e)){throw new i("julianDate is required.")}if(!n(t)){throw new i("hours is required.")}if(!n(r)){throw new i("result is required.")}var a=e.secondsOfDay+t*u.SECONDS_PER_HOUR;return w(e.dayNumber,a,r)};I.addDays=function(e,t,r){if(!n(e)){throw new i("julianDate is required.")}if(!n(t)){throw new i("days is required.")}if(!n(r)){throw new i("result is required.")}var a=e.dayNumber+t;return w(a,e.secondsOfDay,r)};I.lessThan=function(e,t){return I.compare(e,t)<0};I.lessThanOrEquals=function(e,t){return I.compare(e,t)<=0};I.greaterThan=function(e,t){return I.compare(e,t)>0};I.greaterThanOrEquals=function(e,t){return I.compare(e,t)>=0};I.prototype.clone=function(e){return I.clone(this,e)};I.prototype.equals=function(e){return I.equals(this,e)};I.prototype.equalsEpsilon=function(e,t){return I.equalsEpsilon(this,e,t)};I.prototype.toString=function(){return I.toIso8601(this)};I.leapSeconds=[new s(new I(2441317,43210,f.TAI),10),new s(new I(2441499,43211,f.TAI),11),new s(new I(2441683,43212,f.TAI),12),new s(new I(2442048,43213,f.TAI),13),new s(new I(2442413,43214,f.TAI),14),new s(new I(2442778,43215,f.TAI),15),new s(new I(2443144,43216,f.TAI),16),new s(new I(2443509,43217,f.TAI),17),new s(new I(2443874,43218,f.TAI),18),new s(new I(2444239,43219,f.TAI),19),new s(new I(2444786,43220,f.TAI),20),new s(new I(2445151,43221,f.TAI),21),new s(new I(2445516,43222,f.TAI),22),new s(new I(2446247,43223,f.TAI),23),new s(new I(2447161,43224,f.TAI),24),new s(new I(2447892,43225,f.TAI),25),new s(new I(2448257,43226,f.TAI),26),new s(new I(2448804,43227,f.TAI),27),new s(new I(2449169,43228,f.TAI),28),new s(new I(2449534,43229,f.TAI),29),new s(new I(2450083,43230,f.TAI),30),new s(new I(2450630,43231,f.TAI),31),new s(new I(2451179,43232,f.TAI),32),new s(new I(2453736,43233,f.TAI),33),new s(new I(2454832,43234,f.TAI),34),new s(new I(2456109,43235,f.TAI),35),new s(new I(2457204,43236,f.TAI),36)];return I})})();(function(){var t=e.amdDefine;t("52",["1f"],function(e){"use strict";var t={SECONDS_PER_MILLISECOND:.001,SECONDS_PER_MINUTE:60,MINUTES_PER_HOUR:60,HOURS_PER_DAY:24,SECONDS_PER_HOUR:3600,MINUTES_PER_DAY:1440,SECONDS_PER_DAY:86400,DAYS_PER_JULIAN_CENTURY:36525,PICOSECOND:1e-9,MODIFIED_JULIAN_DATE_DIFFERENCE:2400000.5};return e(t)})})();(function(){var t=e.amdDefine;t("53",["1f"],function(e){"use strict";var t={UTC:0,TAI:1};return e(t)})})();(function(){var t=e.amdDefine;t("64",["2c","1a","1c","24","27","32","52","53"],function(e,t,r,n,i,a,o,s){"use strict";var u={};function f(e){var t=6.239996+.0172019696544*e;return.001657*Math.sin(t+.01671*Math.sin(t))}var c=32.184;var l=2451545;function d(e,t){t=n.addSeconds(e,c,t);var r=n.totalDays(t)-l;t=n.addSeconds(t,f(r),t);return t}var h=new n(2451545,0,s.TAI);var v=398600435e6;var p=v*(1+.012300034)*328900.56;var m=1e3;var w=i.RADIANS_PER_DEGREE;var y=i.RADIANS_PER_ARCSECOND;var g=14959787e4;var S=new a;function b(n,o,s,u,f,c,l,d){if(s<0){s=-s;f+=i.PI}if(s<0||s>i.PI){throw new r("The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.")}var h=n*(1-o);var v=u-f;var p=f;var m=_(c-u,o);var w=T(o,0);if(w==="Hyperbolic"&&Math.abs(i.negativePiToPi(m))>=Math.acos(-1/o)){throw new r("The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.")}C(v,s,p,S);var y=h*(1+o);var g=Math.cos(m);var b=Math.sin(m);var E=1+o*g;if(E<=i.Epsilon10){throw new r("elements cannot be converted to cartesian")}var M=y/E;if(!t(d)){d=new e(M*g,M*b,0)}else{d.x=M*g;d.y=M*b;d.z=0}return a.multiplyByVector(S,d,d)}function T(e,t){if(e<0){throw new r("eccentricity cannot be negative.")}else if(e<=t){return"Circular"}else if(e<1-t){return"Elliptical"}else if(e<=1+t){return"Parabolic"}else{return"Hyperbolic"}}function _(e,t){if(t<0||t>=1){throw new r("eccentricity out of range.")}var n=P(e,t);return A(n,t)}var E=50;var M=i.EPSILON8;function P(e,t){if(t<0||t>=1){throw new r("eccentricity out of range.")}var n=Math.floor(e/i.TWO_PI);e-=n*i.TWO_PI;var a=e+t*Math.sin(e)/(1-Math.sin(e+t)+Math.sin(e));var o=Number.MAX_VALUE;var s;for(s=0;s<E&&Math.abs(o-a)>M;++s){o=a;var u=o-t*Math.sin(o)-e;var f=1-t*Math.cos(o);a=o-u/f}if(s>=E){throw new r("Kepler equation did not converge")}o=a+n*i.TWO_PI;return o}function A(e,t){if(t<0||t>=1){throw new r("eccentricity out of range.")}var n=Math.floor(e/i.TWO_PI);e-=n*i.TWO_PI;var a=Math.cos(e)-t;var o=Math.sin(e)*Math.sqrt(1-t*t);var s=Math.atan2(o,a);s=i.zeroToTwoPi(s);if(e<0){s-=i.TWO_PI}s+=n*i.TWO_PI;return s}function C(e,n,o,s){if(n<0||n>i.PI){throw new r("inclination out of range")}var u=Math.cos(e);var f=Math.sin(e);var c=Math.cos(n);var l=Math.sin(n);var d=Math.cos(o);var h=Math.sin(o);if(!t(s)){s=new a(d*u-h*f*c,-d*f-h*u*c,h*l,h*u+d*f*c,-h*f+d*u*c,-d*l,f*l,u*l,c)}else{s[0]=d*u-h*f*c;s[1]=h*u+d*f*c;s[2]=f*l;s[3]=-d*f-h*u*c;s[4]=-h*f+d*u*c;s[5]=u*l;s[6]=h*l;s[7]=-d*l;s[8]=c}return s}var I=1.0000010178*g;var x=100.46645683*w;var R=1295977422.83429*y;var O=16002;var D=21863;var q=32004;var N=10931;var G=14529;var L=16368;var B=15318;var H=32794;var k=64*1e-7*g;var z=-152*1e-7*g;var F=62*1e-7*g;var U=-8*1e-7*g;var V=32*1e-7*g;var j=-41*1e-7*g;var W=19*1e-7*g;var X=-11*1e-7*g;var Q=-150*1e-7*g;var K=-46*1e-7*g;var Y=68*1e-7*g;var Z=54*1e-7*g;var J=14*1e-7*g;var $=24*1e-7*g;var ee=-28*1e-7*g;var te=22*1e-7*g;var re=10;var ne=16002;var ie=21863;var ae=10931;var oe=1473;var se=32004;var ue=4387;var fe=73;var ce=-325*1e-7;var le=-322*1e-7;var de=-79*1e-7;var he=232*1e-7;var ve=-52*1e-7;var pe=97*1e-7;var me=55*1e-7;var we=-41*1e-7;var ye=-105*1e-7;var ge=-137*1e-7;var Se=258*1e-7;var be=35*1e-7;var Te=-116*1e-7;var _e=-88*1e-7;var Ee=-112*1e-7;var Me=-80*1e-7;var Pe=new n(0,0,s.TAI);function Ae(e,t){d(e,Pe);var r=Pe.dayNumber-h.dayNumber+(Pe.secondsOfDay-h.secondsOfDay)/o.SECONDS_PER_DAY;var n=r/(o.DAYS_PER_JULIAN_CENTURY*10);var i=.3595362*n;var a=I+k*Math.cos(O*i)+Q*Math.sin(O*i)+z*Math.cos(D*i)+K*Math.sin(D*i)+F*Math.cos(q*i)+Y*Math.sin(q*i)+U*Math.cos(N*i)+Z*Math.sin(N*i)+V*Math.cos(G*i)+J*Math.sin(G*i)+j*Math.cos(L*i)+$*Math.sin(L*i)+W*Math.cos(B*i)+ee*Math.sin(B*i)+X*Math.cos(H*i)+te*Math.sin(H*i);var s=x+R*n+ce*Math.cos(re*i)+ye*Math.sin(re*i)+le*Math.cos(ne*i)+ge*Math.sin(ne*i)+de*Math.cos(ie*i)+Se*Math.sin(ie*i)+he*Math.cos(ae*i)+be*Math.sin(ae*i)+ve*Math.cos(oe*i)+Te*Math.sin(oe*i)+pe*Math.cos(se*i)+_e*Math.sin(se*i)+me*Math.cos(ue*i)+Ee*Math.sin(ue*i)+we*Math.cos(fe*i)+Me*Math.sin(fe*i);var u=.0167086342-.0004203654*n;var f=102.93734808*w+11612.3529*y*n;var c=469.97289*y*n;var l=174.87317577*w-8679.27034*y*n;return b(a,u,c,f,l,s,p,t)}function Ce(e,t){d(e,Pe);var r=Pe.dayNumber-h.dayNumber+(Pe.secondsOfDay-h.secondsOfDay)/o.SECONDS_PER_DAY;var n=r/o.DAYS_PER_JULIAN_CENTURY;var i=n*n;var a=i*n;var s=a*n;var u=383397.7725+.004*n;var f=.055545526-1.6e-8*n;var c=5.15668983*w;var l=-8e-5*n+.02966*i-42e-6*a-1.3e-7*s;var p=83.35324312*w;var g=14643420.2669*n-38.2702*i-.045047*a+21301e-8*s;var S=125.04455501*w;var T=-6967919.3631*n+6.3602*i+.007625*a-3586e-8*s;var _=218.31664563*w;var E=1732559343.4847*n-6.391*i+.006588*a-3169e-8*s;var M=297.85019547*w+y*(1602961601.209*n-6.3706*i+.006593*a-3169e-8*s);var P=93.27209062*w+y*(1739527262.8478*n-12.7512*i-.001037*a+417e-8*s);var A=134.96340251*w+y*(1717915923.2178*n+31.8792*i+.051635*a-2447e-7*s);var C=357.52910918*w+y*(129596581.0481*n-.5532*i+136e-6*a-1149e-8*s);var I=310.17137918*w-y*(6967051.436*n+6.2068*i+.007618*a-3219e-8*s);var x=2*M;var R=4*M;var O=6*M;var D=2*A;var q=3*A;var N=4*A;var G=2*P;u+=3400.4*Math.cos(x)-635.6*Math.cos(x-A)-235.6*Math.cos(A)+218.1*Math.cos(x-C)+181*Math.cos(x+A);f+=.014216*Math.cos(x-A)+.008551*Math.cos(x-D)-.001383*Math.cos(A)+.001356*Math.cos(x+A)-.001147*Math.cos(R-q)-914e-6*Math.cos(R-D)+869e-6*Math.cos(x-C-A)-627e-6*Math.cos(x)-394e-6*Math.cos(R-N)+282e-6*Math.cos(x-C-D)-279e-6*Math.cos(M-A)-236e-6*Math.cos(D)+231e-6*Math.cos(R)+229e-6*Math.cos(O-N)-201e-6*Math.cos(D-G);l+=486.26*Math.cos(x-G)-40.13*Math.cos(x)+37.51*Math.cos(G)+25.73*Math.cos(D-G)+19.97*Math.cos(x-C-G);g+=-55609*Math.sin(x-A)-34711*Math.sin(x-D)-9792*Math.sin(A)+9385*Math.sin(R-q)+7505*Math.sin(R-D)+5318*Math.sin(x+A)+3484*Math.sin(R-N)-3417*Math.sin(x-C-A)-2530*Math.sin(O-N)-2376*Math.sin(x)-2075*Math.sin(x-q)-1883*Math.sin(D)-1736*Math.sin(O-5*A)+1626*Math.sin(C)-1370*Math.sin(O-q);T+=-5392*Math.sin(x-G)-540*Math.sin(C)-441*Math.sin(x)+423*Math.sin(G)-288*Math.sin(D-G);E+=-3332.9*Math.sin(x)+1197.4*Math.sin(x-A)-662.5*Math.sin(C)+396.3*Math.sin(A)-218*Math.sin(x-C);var L=2*I;var B=3*I;l+=46.997*Math.cos(I)*n-.614*Math.cos(x-G+I)*n+.614*Math.cos(x-G-I)*n-.0297*Math.cos(L)*i-.0335*Math.cos(I)*i+.0012*Math.cos(x-G+L)*i-16e-5*Math.cos(I)*a+4e-5*Math.cos(B)*a+4e-5*Math.cos(L)*a;var H=2.116*Math.sin(I)*n-.111*Math.sin(x-G-I)*n-.0015*Math.sin(I)*i;g+=H;E+=H;T+=-520.77*Math.sin(I)*n+13.66*Math.sin(x-G+I)*n+1.12*Math.sin(x-I)*n-1.06*Math.sin(G-I)*n+.66*Math.sin(L)*i+.371*Math.sin(I)*i-.035*Math.sin(x-G+L)*i-.015*Math.sin(x-G+I)*i+.0014*Math.sin(I)*a-.0011*Math.sin(B)*a-9e-4*Math.sin(L)*a;u*=m;var k=c+l*y;var z=p+g*y;var F=_+E*y;var U=S+T*y;return b(u,f,k,z,U,F,v,t)}var Ie=.012300034;var xe=Ie/(Ie+1)*-1;function Re(t,r){r=Ce(t,r);return e.multiplyByScalar(r,xe,r)}var Oe=new a(1.0000000000000002,5.619723173785822e-16,4.690511510146299e-19,-5.154129427414611e-16,.9174820620691819,-.39777715593191376,-2.23970096136568e-16,.39777715593191376,.9174820620691819);var De=new e;u.computeSunPositionInEarthInertialFrame=function(r,i){if(!t(r)){r=n.now()}if(!t(i)){i=new e}De=Ae(r,De);i=e.negate(De,i);Re(r,De);e.subtract(i,De,i);a.multiplyByVector(Oe,i,i);return i};u.computeMoonPositionInEarthInertialFrame=function(e,r){if(!t(e)){e=n.now()}r=Ce(e,r);a.multiplyByVector(Oe,r,r);return r};return u})})();(function(){var t=e.amdDefine;t("3c",["2c","3b","23","1a","1b","1c","1f","27","65"],function(e,t,r,n,i,a,o,s,u){"use strict";function f(t,n,i,o){n=r(n,0);i=r(i,0);o=r(o,0);if(n<0||i<0||o<0){throw new a("All radii components must be greater than or equal to zero.")}t._radii=new e(n,i,o);t._radiiSquared=new e(n*n,i*i,o*o);t._radiiToTheFourth=new e(n*n*n*n,i*i*i*i,o*o*o*o);t._oneOverRadii=new e(n===0?0:1/n,i===0?0:1/i,o===0?0:1/o);t._oneOverRadiiSquared=new e(n===0?0:1/(n*n),i===0?0:1/(i*i),o===0?0:1/(o*o));t._minimumRadius=Math.min(n,i,o);t._maximumRadius=Math.max(n,i,o);t._centerToleranceSquared=s.EPSILON1}function c(e,t,r){this._radii=undefined;this._radiiSquared=undefined;this._radiiToTheFourth=undefined;this._oneOverRadii=undefined;this._oneOverRadiiSquared=undefined;this._minimumRadius=undefined;this._maximumRadius=undefined;this._centerToleranceSquared=undefined;f(this,e,t,r);
	}i(c.prototype,{radii:{get:function(){return this._radii}},radiiSquared:{get:function(){return this._radiiSquared}},radiiToTheFourth:{get:function(){return this._radiiToTheFourth}},oneOverRadii:{get:function(){return this._oneOverRadii}},oneOverRadiiSquared:{get:function(){return this._oneOverRadiiSquared}},minimumRadius:{get:function(){return this._minimumRadius}},maximumRadius:{get:function(){return this._maximumRadius}}});c.clone=function(t,r){if(!n(t)){return undefined}var i=t._radii;if(!n(r)){return new c(i.x,i.y,i.z)}e.clone(i,r._radii);e.clone(t._radiiSquared,r._radiiSquared);e.clone(t._radiiToTheFourth,r._radiiToTheFourth);e.clone(t._oneOverRadii,r._oneOverRadii);e.clone(t._oneOverRadiiSquared,r._oneOverRadiiSquared);r._minimumRadius=t._minimumRadius;r._maximumRadius=t._maximumRadius;r._centerToleranceSquared=t._centerToleranceSquared;return r};c.fromCartesian3=function(e,t){if(!n(t)){t=new c}if(!n(e)){return t}f(t,e.x,e.y,e.z);return t};c.WGS84=o(new c(6378137,6378137,6356752.314245179));c.UNIT_SPHERE=o(new c(1,1,1));c.MOON=o(new c(s.LUNAR_RADIUS,s.LUNAR_RADIUS,s.LUNAR_RADIUS));c.prototype.clone=function(e){return c.clone(this,e)};c.packedLength=e.packedLength;c.pack=function(t,i,o){if(!n(t)){throw new a("value is required")}if(!n(i)){throw new a("array is required")}o=r(o,0);e.pack(t._radii,i,o)};c.unpack=function(t,i,o){if(!n(t)){throw new a("array is required")}i=r(i,0);var s=e.unpack(t,i);return c.fromCartesian3(s,o)};c.prototype.geocentricSurfaceNormal=e.normalize;c.prototype.geodeticSurfaceNormalCartographic=function(t,r){if(!n(t)){throw new a("cartographic is required.")}var i=t.longitude;var o=t.latitude;var s=Math.cos(o);var u=s*Math.cos(i);var f=s*Math.sin(i);var c=Math.sin(o);if(!n(r)){r=new e}r.x=u;r.y=f;r.z=c;return e.normalize(r,r)};c.prototype.geodeticSurfaceNormal=function(t,r){if(!n(r)){r=new e}r=e.multiplyComponents(t,this._oneOverRadiiSquared,r);return e.normalize(r,r)};var l=new e;var d=new e;c.prototype.cartographicToCartesian=function(t,r){var i=l;var a=d;this.geodeticSurfaceNormalCartographic(t,i);e.multiplyComponents(this._radiiSquared,i,a);var o=Math.sqrt(e.dot(i,a));e.divideByScalar(a,o,a);e.multiplyByScalar(i,t.height,i);if(!n(r)){r=new e}return e.add(a,i,r)};c.prototype.cartographicArrayToCartesianArray=function(e,t){if(!n(e)){throw new a("cartographics is required.")}var r=e.length;if(!n(t)){t=new Array(r)}else{t.length=r}for(var i=0;i<r;i++){t[i]=this.cartographicToCartesian(e[i],t[i])}return t};var h=new e;var v=new e;var p=new e;c.prototype.cartesianToCartographic=function(r,i){var a=this.scaleToGeodeticSurface(r,v);if(!n(a)){return undefined}var o=this.geodeticSurfaceNormal(a,h);var u=e.subtract(r,a,p);var f=Math.atan2(o.y,o.x);var c=Math.asin(o.z);var l=s.sign(e.dot(u,r))*e.magnitude(u);if(!n(i)){return new t(f,c,l)}i.longitude=f;i.latitude=c;i.height=l;return i};c.prototype.cartesianArrayToCartographicArray=function(e,t){if(!n(e)){throw new a("cartesians is required.")}var r=e.length;if(!n(t)){t=new Array(r)}else{t.length=r}for(var i=0;i<r;++i){t[i]=this.cartesianToCartographic(e[i],t[i])}return t};c.prototype.scaleToGeodeticSurface=function(e,t){return u(e,this._oneOverRadii,this._oneOverRadiiSquared,this._centerToleranceSquared,t)};c.prototype.scaleToGeocentricSurface=function(t,r){if(!n(t)){throw new a("cartesian is required.")}if(!n(r)){r=new e}var i=t.x;var o=t.y;var s=t.z;var u=this._oneOverRadiiSquared;var f=1/Math.sqrt(i*i*u.x+o*o*u.y+s*s*u.z);return e.multiplyByScalar(t,f,r)};c.prototype.transformPositionToScaledSpace=function(t,r){if(!n(r)){r=new e}return e.multiplyComponents(t,this._oneOverRadii,r)};c.prototype.transformPositionFromScaledSpace=function(t,r){if(!n(r)){r=new e}return e.multiplyComponents(t,this._radii,r)};c.prototype.equals=function(t){return this===t||n(t)&&e.equals(this._radii,t._radii)};c.prototype.toString=function(){return this._radii.toString()};return c})})();(function(){var t=e.amdDefine;t("66",["2c","3b","23","1a","1b","1c","3c","27"],function(e,t,r,n,i,a,o,s){"use strict";function u(e){var t=e._uSquared;var r=e._ellipsoid.maximumRadius;var n=e._ellipsoid.minimumRadius;var i=(r-n)/r;var a=Math.cos(e._startHeading);var o=Math.sin(e._startHeading);var s=(1-i)*Math.tan(e._start.latitude);var u=1/Math.sqrt(1+s*s);var f=u*s;var c=Math.atan2(s,a);var l=u*o;var d=l*l;var h=1-d;var v=Math.sqrt(h);var p=t/4;var m=p*p;var w=m*p;var y=m*m;var g=1+p-3*m/4+5*w/4-175*y/64;var S=1-p+15*m/8-35*w/8;var b=1-3*p+35*m/4;var T=1-5*p;var _=g*c-S*Math.sin(2*c)*p/2-b*Math.sin(4*c)*m/16-T*Math.sin(6*c)*w/48-Math.sin(8*c)*5*y/512;var E=e._constants;E.a=r;E.b=n;E.f=i;E.cosineHeading=a;E.sineHeading=o;E.tanU=s;E.cosineU=u;E.sineU=f;E.sigma=c;E.sineAlpha=l;E.sineSquaredAlpha=d;E.cosineSquaredAlpha=h;E.cosineAlpha=v;E.u2Over4=p;E.u4Over16=m;E.u6Over64=w;E.u8Over256=y;E.a0=g;E.a1=S;E.a2=b;E.a3=T;E.distanceRatio=_}function f(e,t){return e*t*(4+e*(4-3*t))/16}function c(e,t,r,n,i,a,o){var s=f(e,r);return(1-s)*e*t*(n+s*i*(o+s*a*(2*o*o-1)))}function l(e,t,r,n,i,a,o){var u=(t-r)/t;var f=a-n;var l=Math.atan((1-u)*Math.tan(i));var d=Math.atan((1-u)*Math.tan(o));var h=Math.cos(l);var v=Math.sin(l);var p=Math.cos(d);var m=Math.sin(d);var w=h*p;var y=h*m;var g=v*m;var S=v*p;var b=f;var T=s.TWO_PI;var _=Math.cos(b);var E=Math.sin(b);var M;var P;var A;var C;var I;do{_=Math.cos(b);E=Math.sin(b);var x=y-S*_;A=Math.sqrt(p*p*E*E+x*x);P=g+w*_;M=Math.atan2(A,P);var R;if(A===0){R=0;C=1}else{R=w*E/A;C=1-R*R}T=b;I=P-2*g/C;if(isNaN(I)){I=0}b=f+c(u,R,C,M,A,P,I)}while(Math.abs(b-T)>s.EPSILON12);var O=C*(t*t-r*r)/(r*r);var D=1+O*(4096+O*(O*(320-175*O)-768))/16384;var q=O*(256+O*(O*(74-47*O)-128))/1024;var N=I*I;var G=q*A*(I+q*(P*(2*N-1)-q*I*(4*A*A-3)*(4*N-3)/6)/4);var L=r*D*(M-G);var B=Math.atan2(p*E,y-S*_);var H=Math.atan2(h*E,y*_-S);e._distance=L;e._startHeading=B;e._endHeading=H;e._uSquared=O}function d(r,n,i,o){var s=e.normalize(o.cartographicToCartesian(n,v),h);var f=e.normalize(o.cartographicToCartesian(i,v),v);if(Math.abs(Math.abs(e.angleBetween(s,f))-Math.PI)<.0125){throw new a("geodesic position is not unique")}l(r,o.maximumRadius,o.minimumRadius,n.longitude,n.latitude,i.longitude,i.latitude);r._start=t.clone(n,r._start);r._end=t.clone(i,r._end);r._start.height=0;r._end.height=0;u(r)}var h=new e;var v=new e;function p(e,i,a){var s=r(a,o.WGS84);this._ellipsoid=s;this._start=new t;this._end=new t;this._constants={};this._startHeading=undefined;this._endHeading=undefined;this._distance=undefined;this._uSquared=undefined;if(n(e)&&n(i)){d(this,e,i,s)}}i(p.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){if(!n(this._distance)){throw new a("set end positions before getting surfaceDistance")}return this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},startHeading:{get:function(){if(!n(this._distance)){throw new a("set end positions before getting startHeading")}return this._startHeading}},endHeading:{get:function(){if(!n(this._distance)){throw new a("set end positions before getting endHeading")}return this._endHeading}}});p.prototype.setEndPoints=function(e,t){if(!n(e)){throw new a("start cartographic position is required")}if(!n(t)){throw new a("end cartgraphic position is required")}d(this,e,t,this._ellipsoid)};p.prototype.interpolateUsingFraction=function(e,t){return this.interpolateUsingSurfaceDistance(this._distance*e,t)};p.prototype.interpolateUsingSurfaceDistance=function(e,r){if(!n(this._distance)){throw new a("start and end must be set before calling funciton interpolateUsingSurfaceDistance")}var i=this._constants;var o=i.distanceRatio+e/i.b;var s=Math.cos(2*o);var u=Math.cos(4*o);var f=Math.cos(6*o);var l=Math.sin(2*o);var d=Math.sin(4*o);var h=Math.sin(6*o);var v=Math.sin(8*o);var p=o*o;var m=o*p;var w=i.u8Over256;var y=i.u2Over4;var g=i.u6Over64;var S=i.u4Over16;var b=2*m*w*s/3+o*(1-y+7*S/4-15*g/4+579*w/64-(S-15*g/4+187*w/16)*s-(5*g/4-115*w/16)*u-29*w*f/16)+(y/2-S+71*g/32-85*w/16)*l+(5*S/16-5*g/4+383*w/96)*d-p*((g-11*w/2)*l+5*w*d/2)+(29*g/96-29*w/16)*h+539*w*v/1536;var T=Math.asin(Math.sin(b)*i.cosineAlpha);var _=Math.atan(i.a/i.b*Math.tan(T));b=b-i.sigma;var E=Math.cos(2*i.sigma+b);var M=Math.sin(b);var P=Math.cos(b);var A=i.cosineU*P;var C=i.sineU*M;var I=Math.atan2(M*i.sineHeading,A-C*i.cosineHeading);var x=I-c(i.f,i.sineAlpha,i.cosineSquaredAlpha,b,M,P,E);if(n(r)){r.longitude=this._start.longitude+x;r.latitude=_;r.height=0;return r}return new t(this._start.longitude+x,_,0)};return p})})();(function(){var t=e.amdDefine;t("65",["2c","1a","1c","27"],function(e,t,r,n){"use strict";var i=new e;var a=new e;function o(o,s,u,f,c){if(!t(o)){throw new r("cartesian is required.")}if(!t(s)){throw new r("oneOverRadii is required.")}if(!t(u)){throw new r("oneOverRadiiSquared is required.")}if(!t(f)){throw new r("centerToleranceSquared is required.")}var l=o.x;var d=o.y;var h=o.z;var v=s.x;var p=s.y;var m=s.z;var w=l*l*v*v;var y=d*d*p*p;var g=h*h*m*m;var S=w+y+g;var b=Math.sqrt(1/S);var T=e.multiplyByScalar(o,b,i);if(S<f){return!isFinite(b)?undefined:e.clone(T,c)}var _=u.x;var E=u.y;var M=u.z;var P=a;P.x=T.x*_*2;P.y=T.y*E*2;P.z=T.z*M*2;var A=(1-b)*e.magnitude(o)/(.5*e.magnitude(P));var C=0;var I;var x;var R;var O;var D;var q;var N;var G;var L;var B;var H;do{A-=C;R=1/(1+A*_);O=1/(1+A*E);D=1/(1+A*M);q=R*R;N=O*O;G=D*D;L=q*R;B=N*O;H=G*D;I=w*q+y*N+g*G-1;x=w*L*_+y*B*E+g*H*M;var k=-2*x;C=I/k}while(Math.abs(I)>n.EPSILON12);if(!t(c)){return new e(l*R,d*O,h*D)}c.x=l*R;c.y=d*O;c.z=h*D;return c}return o})})();(function(){var t=e.amdDefine;t("3b",["2c","23","1a","1c","1f","27","65"],function(e,t,r,n,i,a,o){"use strict";function s(e,r,n){this.longitude=t(e,0);this.latitude=t(r,0);this.height=t(n,0)}s.fromRadians=function(e,i,a,o){if(!r(e)){throw new n("longitude is required.")}if(!r(i)){throw new n("latitude is required.")}a=t(a,0);if(!r(o)){return new s(e,i,a)}o.longitude=e;o.latitude=i;o.height=a;return o};s.fromDegrees=function(e,t,i,o){if(!r(e)){throw new n("longitude is required.")}if(!r(t)){throw new n("latitude is required.")}e=a.toRadians(e);t=a.toRadians(t);return s.fromRadians(e,t,i,o)};var u=new e;var f=new e;var c=new e;var l=new e(1/6378137,1/6378137,1/6356752.314245179);var d=new e(1/(6378137*6378137),1/(6378137*6378137),1/(6356752.314245179*6356752.314245179));var h=a.EPSILON1;s.fromCartesian=function(t,n,i){var v=r(n)?n.oneOverRadii:l;var p=r(n)?n.oneOverRadiiSquared:d;var m=r(n)?n._centerToleranceSquared:h;var w=o(t,v,p,m,f);if(!r(w)){return undefined}var y=e.multiplyComponents(t,p,u);y=e.normalize(y,y);var g=e.subtract(t,w,c);var S=Math.atan2(y.y,y.x);var b=Math.asin(y.z);var T=a.sign(e.dot(g,t))*e.magnitude(g);if(!r(i)){return new s(S,b,T)}i.longitude=S;i.latitude=b;i.height=T;return i};s.clone=function(e,t){if(!r(e)){return undefined}if(!r(t)){return new s(e.longitude,e.latitude,e.height)}t.longitude=e.longitude;t.latitude=e.latitude;t.height=e.height;return t};s.equals=function(e,t){return e===t||r(e)&&r(t)&&e.longitude===t.longitude&&e.latitude===t.latitude&&e.height===t.height};s.equalsEpsilon=function(e,t,i){if(typeof i!=="number"){throw new n("epsilon is required and must be a number.")}return e===t||r(e)&&r(t)&&Math.abs(e.longitude-t.longitude)<=i&&Math.abs(e.latitude-t.latitude)<=i&&Math.abs(e.height-t.height)<=i};s.ZERO=i(new s(0,0,0));s.prototype.clone=function(e){return s.clone(this,e)};s.prototype.equals=function(e){return s.equals(this,e)};s.prototype.equalsEpsilon=function(e,t){return s.equalsEpsilon(this,e,t)};s.prototype.toString=function(){return"("+this.longitude+", "+this.latitude+", "+this.height+")"};return s})})();(function(){var t=e.amdDefine;t("67",["1c","68"],function(e,t){"use strict";var r={};r.computeDiscriminant=function(t,r,n,i){if(typeof t!=="number"){throw new e("a is a required number.")}if(typeof r!=="number"){throw new e("b is a required number.")}if(typeof n!=="number"){throw new e("c is a required number.")}if(typeof i!=="number"){throw new e("d is a required number.")}var a=t*t;var o=r*r;var s=n*n;var u=i*i;var f=18*t*r*n*i+o*s-27*a*u-4*(t*s*n+o*r*i);return f};function n(e,t,r,n){var i=e;var a=t/3;var o=r/3;var s=n;var u=i*o;var f=a*s;var c=a*a;var l=o*o;var d=i*o-c;var h=i*s-a*o;var v=a*s-l;var p=4*d*v-h*h;var m;var w;if(p<0){var y;var g;var S;if(c*f>=u*l){y=i;g=d;S=-2*a*d+i*h}else{y=s;g=v;S=-s*h+2*o*v}var b=S<0?-1:1;var T=-b*Math.abs(y)*Math.sqrt(-p);w=-S+T;var _=w/2;var E=_<0?-Math.pow(-_,1/3):Math.pow(_,1/3);var M=w===T?-E:-g/E;m=g<=0?E+M:-S/(E*E+M*M+g);if(c*f>=u*l){return[(m-a)/i]}return[-s/(m+o)]}var P=d;var A=-2*a*d+i*h;var C=v;var I=-s*h+2*o*v;var x=Math.sqrt(p);var R=Math.sqrt(3)/2;var O=Math.abs(Math.atan2(i*x,-A)/3);m=2*Math.sqrt(-P);var D=Math.cos(O);w=m*D;var q=m*(-D/2-R*Math.sin(O));var N=w+q>2*a?w-a:q-a;var G=i;var L=N/G;O=Math.abs(Math.atan2(s*x,-I)/3);m=2*Math.sqrt(-C);D=Math.cos(O);w=m*D;q=m*(-D/2-R*Math.sin(O));var B=-s;var H=w+q<2*o?w+o:q+o;var k=B/H;var z=G*H;var F=-N*H-G*B;var U=N*B;var V=(o*F-a*U)/(-a*F+o*z);if(L<=V){if(L<=k){if(V<=k){return[L,V,k]}return[L,k,V]}return[k,L,V]}if(L<=k){return[V,L,k]}if(V<=k){return[V,k,L]}return[k,V,L]}r.computeRealRoots=function(r,i,a,o){if(typeof r!=="number"){throw new e("a is a required number.")}if(typeof i!=="number"){throw new e("b is a required number.")}if(typeof a!=="number"){throw new e("c is a required number.")}if(typeof o!=="number"){throw new e("d is a required number.")}var s;var u;if(r===0){return t.computeRealRoots(i,a,o)}else if(i===0){if(a===0){if(o===0){return[0,0,0]}u=-o/r;var f=u<0?-Math.pow(-u,1/3):Math.pow(u,1/3);return[f,f,f]}else if(o===0){s=t.computeRealRoots(r,0,a);if(s.Length===0){return[0]}return[s[0],0,s[1]]}return n(r,0,a,o)}else if(a===0){if(o===0){u=-i/r;if(u<0){return[u,0,0]}return[0,0,u]}return n(r,i,0,o)}else if(o===0){s=t.computeRealRoots(r,i,a);if(s.length===0){return[0]}else if(s[1]<=0){return[s[0],s[1],0]}else if(s[0]>=0){return[0,s[0],s[1]]}return[s[0],0,s[1]]}return n(r,i,a,o)};return r})})();(function(){var t=e.amdDefine;t("68",["1c","27"],function(e,t){"use strict";var r={};r.computeDiscriminant=function(t,r,n){if(typeof t!=="number"){throw new e("a is a required number.")}if(typeof r!=="number"){throw new e("b is a required number.")}if(typeof n!=="number"){throw new e("c is a required number.")}var i=r*r-4*t*n;return i};function n(e,r,n){var i=e+r;if(t.sign(e)!==t.sign(r)&&Math.abs(i/Math.max(Math.abs(e),Math.abs(r)))<n){return 0}return i}r.computeRealRoots=function(r,i,a){if(typeof r!=="number"){throw new e("a is a required number.")}if(typeof i!=="number"){throw new e("b is a required number.")}if(typeof a!=="number"){throw new e("c is a required number.")}var o;if(r===0){if(i===0){return[]}return[-a/i]}else if(i===0){if(a===0){return[0,0]}var s=Math.abs(a);var u=Math.abs(r);if(s<u&&s/u<t.EPSILON14){return[0,0]}else if(s>u&&u/s<t.EPSILON14){return[]}o=-a/r;if(o<0){return[]}var f=Math.sqrt(o);return[-f,f]}else if(a===0){o=-i/r;if(o<0){return[o,0]}return[0,o]}var c=i*i;var l=4*r*a;var d=n(c,-l,t.EPSILON14);if(d<0){return[]}var h=-.5*n(i,t.sign(i)*Math.sqrt(d),t.EPSILON14);if(i>0){return[h/r,a/h]}return[a/h,h/r]};return r})})();(function(){var t=e.amdDefine;t("69",["67","1c","27","68"],function(e,t,r,n){"use strict";var i={};i.computeDiscriminant=function(e,r,n,i,a){if(typeof e!=="number"){throw new t("a is a required number.")}if(typeof r!=="number"){throw new t("b is a required number.")}if(typeof n!=="number"){throw new t("c is a required number.")}if(typeof i!=="number"){throw new t("d is a required number.")}if(typeof a!=="number"){throw new t("e is a required number.")}var o=e*e;var s=o*e;var u=r*r;var f=u*r;var c=n*n;var l=c*n;var d=i*i;var h=d*i;var v=a*a;var p=v*a;var m=u*c*d-4*f*h-4*e*l*d+18*e*r*n*h-27*o*d*d+256*s*p+a*(18*f*n*i-4*u*l+16*e*c*c-80*e*r*c*i-6*e*u*d+144*o*n*d)+v*(144*e*u*n-27*u*u-128*o*c-192*o*r*i);return m};function a(t,i,a,o){var s=t*t;var u=i-3*s/8;var f=a-i*t/2+s*t/8;var c=o-a*t/4+i*s/16-3*s*s/256;var l=e.computeRealRoots(1,2*u,u*u-4*c,-f*f);if(l.length>0){var d=-t/4;var h=l[l.length-1];if(Math.abs(h)<r.EPSILON14){var v=n.computeRealRoots(1,u,c);if(v.length===2){var p=v[0];var m=v[1];var w;if(p>=0&&m>=0){var y=Math.sqrt(p);var g=Math.sqrt(m);return[d-g,d-y,d+y,d+g]}else if(p>=0&&m<0){w=Math.sqrt(p);return[d-w,d+w]}else if(p<0&&m>=0){w=Math.sqrt(m);return[d-w,d+w]}}return[]}else if(h>0){var S=Math.sqrt(h);var b=(u+h-f/S)/2;var T=(u+h+f/S)/2;var _=n.computeRealRoots(1,S,b);var E=n.computeRealRoots(1,-S,T);if(_.length!==0){_[0]+=d;_[1]+=d;if(E.length!==0){E[0]+=d;E[1]+=d;if(_[1]<=E[0]){return[_[0],_[1],E[0],E[1]]}else if(E[1]<=_[0]){return[E[0],E[1],_[0],_[1]]}else if(_[0]>=E[0]&&_[1]<=E[1]){return[E[0],_[0],_[1],E[1]]}else if(E[0]>=_[0]&&E[1]<=_[1]){return[_[0],E[0],E[1],_[1]]}else if(_[0]>E[0]&&_[0]<E[1]){return[E[0],_[0],E[1],_[1]]}return[_[0],E[0],_[1],E[1]]}return _}if(E.length!==0){E[0]+=d;E[1]+=d;return E}return[]}}return[]}function o(t,i,a,o){var s=a*a;var u=i*i;var f=t*t;var c=-2*i;var l=a*t+u-4*o;var d=f*o-a*i*t+s;var h=e.computeRealRoots(1,c,l,d);if(h.length>0){var v=h[0];var p=i-v;var m=p*p;var w=t/2;var y=p/2;var g=m-4*o;var S=m+4*Math.abs(o);var b=f-4*v;var T=f+4*Math.abs(v);var _;var E;if(v<0||g*T<b*S){var M=Math.sqrt(b);_=M/2;E=M===0?0:(t*y-a)/M}else{var P=Math.sqrt(g);_=P===0?0:(t*y-a)/P;E=P/2}var A;var C;if(w===0&&_===0){A=0;C=0}else if(r.sign(w)===r.sign(_)){A=w+_;C=v/A}else{C=w-_;A=v/C}var I;var x;if(y===0&&E===0){I=0;x=0}else if(r.sign(y)===r.sign(E)){I=y+E;x=o/I}else{x=y-E;I=o/x}var R=n.computeRealRoots(1,A,I);var O=n.computeRealRoots(1,C,x);if(R.length!==0){if(O.length!==0){if(R[1]<=O[0]){return[R[0],R[1],O[0],O[1]]}else if(O[1]<=R[0]){return[O[0],O[1],R[0],R[1]]}else if(R[0]>=O[0]&&R[1]<=O[1]){return[O[0],R[0],R[1],O[1]]}else if(O[0]>=R[0]&&O[1]<=R[1]){return[R[0],O[0],O[1],R[1]]}else if(R[0]>O[0]&&R[0]<O[1]){return[O[0],R[0],O[1],R[1]]}else{return[R[0],O[0],R[1],O[1]]}}return R}if(O.length!==0){return O}}return[]}i.computeRealRoots=function(n,i,s,u,f){if(typeof n!=="number"){throw new t("a is a required number.")}if(typeof i!=="number"){throw new t("b is a required number.")}if(typeof s!=="number"){throw new t("c is a required number.")}if(typeof u!=="number"){throw new t("d is a required number.")}if(typeof f!=="number"){throw new t("e is a required number.")}if(Math.abs(n)<r.EPSILON15){return e.computeRealRoots(i,s,u,f)}var c=i/n;var l=s/n;var d=u/n;var h=f/n;var v=c<0?1:0;v+=l<0?v+1:v;v+=d<0?v+1:v;v+=h<0?v+1:v;switch(v){case 0:return a(c,l,d,h);case 1:return o(c,l,d,h);case 2:return o(c,l,d,h);case 3:return a(c,l,d,h);case 4:return a(c,l,d,h);case 5:return o(c,l,d,h);case 6:return a(c,l,d,h);case 7:return a(c,l,d,h);case 8:return o(c,l,d,h);case 9:return a(c,l,d,h);case 10:return a(c,l,d,h);case 11:return o(c,l,d,h);case 12:return a(c,l,d,h);case 13:return a(c,l,d,h);case 14:return a(c,l,d,h);case 15:return a(c,l,d,h);default:return undefined}};return i})})();(function(){var t=e.amdDefine;t("6a",["2c","23","1a","1c"],function(e,t,r,n){"use strict";function i(r,n){n=e.clone(t(n,e.ZERO));if(!e.equals(n,e.ZERO)){e.normalize(n,n)}this.origin=e.clone(t(r,e.ZERO));this.direction=n}i.getPoint=function(t,i,a){if(!r(t)){throw new n("ray is requred")}if(typeof i!=="number"){throw new n("t is a required number")}if(!r(a)){a=new e}a=e.multiplyByScalar(t.direction,i,a);return e.add(t.origin,a,a)};return i})})();(function(){var t=e.amdDefine;t("6b",["2c","3b","23","1a","1c","27","32","68","69","6a"],function(e,t,r,n,i,a,o,s,u,f){"use strict";var c={};c.rayPlane=function(t,r,o){if(!n(t)){throw new i("ray is required.")}if(!n(r)){throw new i("plane is required.")}if(!n(o)){o=new e}var s=t.origin;var u=t.direction;var f=r.normal;var c=e.dot(f,u);if(Math.abs(c)<a.EPSILON15){return undefined}var l=(-r.distance-e.dot(f,s))/c;if(l<0){return undefined}o=e.multiplyByScalar(u,l,o);return e.add(s,o,o)};var l=new e;var d=new e;var h=new e;var v=new e;var p=new e;function m(t,o,s,u,f){if(!n(t)){throw new i("ray is required.")}if(!n(o)){throw new i("p0 is required.")}if(!n(s)){throw new i("p1 is required.")}if(!n(u)){throw new i("p2 is required.")}f=r(f,false);var c=t.origin;var m=t.direction;var w=e.subtract(s,o,l);var y=e.subtract(u,o,d);var g=e.cross(m,y,h);var S=e.dot(w,g);var b;var T;var _;var E;var M;if(f){if(S<a.EPSILON6){return undefined}b=e.subtract(c,o,v);_=e.dot(b,g);if(_<0||_>S){return undefined}T=e.cross(b,w,p);E=e.dot(m,T);if(E<0||_+E>S){return undefined}M=e.dot(y,T)/S}else{if(Math.abs(S)<a.EPSILON6){return undefined}var P=1/S;b=e.subtract(c,o,v);_=e.dot(b,g)*P;if(_<0||_>1){return undefined}T=e.cross(b,w,p);E=e.dot(m,T)*P;if(E<0||_+E>1){return undefined}M=e.dot(y,T)*P}return M}c.rayTriangle=function(t,r,i,a,o,s){var u=m(t,r,i,a,o);if(!n(u)||u<0){return undefined}if(!n(s)){s=new e}e.multiplyByScalar(t.direction,u,s);return e.add(t.origin,s,s)};var w=new f;c.lineSegmentTriangle=function(t,r,a,o,s,u,f){if(!n(t)){throw new i("v0 is required.")}if(!n(r)){throw new i("v1 is required.")}var c=w;e.clone(t,c.origin);e.subtract(r,t,c.direction);e.normalize(c.direction,c.direction);var l=m(c,a,o,s,u);if(!n(l)||l<0||l>e.distance(t,r)){return undefined}if(!n(f)){f=new e}e.multiplyByScalar(c.direction,l,f);return e.add(c.origin,f,f)};function y(e,t,r,n){var i=t*t-4*e*r;if(i<0){return undefined}else if(i>0){var a=1/(2*e);var o=Math.sqrt(i);var s=(-t+o)*a;var u=(-t-o)*a;if(s<u){n.root0=s;n.root1=u}else{n.root0=u;n.root1=s}return n}var f=-t/(2*e);if(f===0){return undefined}n.root0=n.root1=f;return n}var g={root0:0,root1:0};function S(t,r,i){if(!n(i)){i={}}var a=t.origin;var o=t.direction;var s=r.center;var u=r.radius*r.radius;var f=e.subtract(a,s,h);var c=e.dot(o,o);var l=2*e.dot(o,f);var d=e.magnitudeSquared(f)-u;var v=y(c,l,d,g);if(!n(v)){return undefined}i.start=v.root0;i.stop=v.root1;return i}c.raySphere=function(e,t,r){if(!n(e)){throw new i("ray is required.")}if(!n(t)){throw new i("sphere is required.")}r=S(e,t,r);if(!n(r)||r.stop<0){return undefined}r.start=Math.max(r.start,0);return r};var b=new f;c.lineSegmentSphere=function(t,r,a,o){if(!n(t)){throw new i("p0 is required.")}if(!n(r)){throw new i("p1 is required.")}if(!n(a)){throw new i("sphere is required.")}var s=b;e.clone(t,s.origin);var u=e.subtract(r,t,s.direction);var f=e.magnitude(u);e.normalize(u,u);o=S(s,a,o);if(!n(o)||o.stop<0||o.start>f){return undefined}o.start=Math.max(o.start,0);o.stop=Math.min(o.stop,f);return o};var T=new e;var _=new e;c.rayEllipsoid=function(t,r){if(!n(t)){throw new i("ray is required.")}if(!n(r)){throw new i("ellipsoid is required.")}var a=r.oneOverRadii;var o=e.multiplyComponents(a,t.origin,T);var s=e.multiplyComponents(a,t.direction,_);var u=e.magnitudeSquared(o);var f=e.dot(o,s);var c,l,d,h,v;if(u>1){if(f>=0){return undefined}var p=f*f;c=u-1;l=e.magnitudeSquared(s);d=l*c;if(p<d){return undefined}else if(p>d){h=f*f-d;v=-f+Math.sqrt(h);var m=v/l;var w=c/v;if(m<w){return{start:m,stop:w}}return{start:w,stop:m}}else{var y=Math.sqrt(c/l);return{start:y,stop:y}}}else if(u<1){c=u-1;l=e.magnitudeSquared(s);d=l*c;h=f*f-d;v=-f+Math.sqrt(h);return{start:0,stop:v/l}}else{if(f<0){l=e.magnitudeSquared(s);return{start:0,stop:-f/l}}return undefined}};function E(e,t,r){var n=e+t;if(a.sign(e)!==a.sign(t)&&Math.abs(n/Math.max(Math.abs(e),Math.abs(t)))<r){return 0}return n}function M(t,r,n,i,f){var c=i*i;var l=f*f;var d=(t[o.COLUMN1ROW1]-t[o.COLUMN2ROW2])*l;var h=f*(i*E(t[o.COLUMN1ROW0],t[o.COLUMN0ROW1],a.EPSILON15)+r.y);var v=t[o.COLUMN0ROW0]*c+t[o.COLUMN2ROW2]*l+i*r.x+n;var p=l*E(t[o.COLUMN2ROW1],t[o.COLUMN1ROW2],a.EPSILON15);var m=f*(i*E(t[o.COLUMN2ROW0],t[o.COLUMN0ROW2])+r.z);var w;var y=[];if(m===0&&p===0){w=s.computeRealRoots(d,h,v);if(w.length===0){return y}var g=w[0];var S=Math.sqrt(Math.max(1-g*g,0));y.push(new e(i,f*g,f*-S));y.push(new e(i,f*g,f*S));if(w.length===2){var b=w[1];var T=Math.sqrt(Math.max(1-b*b,0));y.push(new e(i,f*b,f*-T));y.push(new e(i,f*b,f*T))}return y}var _=m*m;var M=p*p;var P=d*d;var A=m*p;var C=P+M;var I=2*(h*d+A);var x=2*v*d+h*h-M+_;var R=2*(v*h-A);var O=v*v-_;if(C===0&&I===0&&x===0&&R===0){return y}w=u.computeRealRoots(C,I,x,R,O);var D=w.length;if(D===0){return y}for(var q=0;q<D;++q){var N=w[q];var G=N*N;var L=Math.max(1-G,0);var B=Math.sqrt(L);var H;if(a.sign(d)===a.sign(v)){H=E(d*G+v,h*N,a.EPSILON12)}else if(a.sign(v)===a.sign(h*N)){H=E(d*G,h*N+v,a.EPSILON12)}else{H=E(d*G+h*N,v,a.EPSILON12)}var k=E(p*N,m,a.EPSILON15);var z=H*k;if(z<0){y.push(new e(i,f*N,f*B))}else if(z>0){y.push(new e(i,f*N,f*-B))}else if(B!==0){y.push(new e(i,f*N,f*-B));y.push(new e(i,f*N,f*B));++q}else{y.push(new e(i,f*N,f*B))}}return y}var P=new e;var A=new e;var C=new e;var I=new e;var x=new e;var R=new o;var O=new o;var D=new o;var q=new o;var N=new o;var G=new o;var L=new o;var B=new e;var H=new e;var k=new t;c.grazingAltitudeLocation=function(t,r){if(!n(t)){throw new i("ray is required.")}if(!n(r)){throw new i("ellipsoid is required.")}var s=t.origin;var u=t.direction;var f=r.geodeticSurfaceNormal(s,P);if(e.dot(u,f)>=0){return s}var c=n(this.rayEllipsoid(t,r));var l=r.transformPositionToScaledSpace(u,P);var d=e.normalize(l,l);var h=e.mostOrthogonalAxis(l,I);var v=e.normalize(e.cross(h,d,A),A);var p=e.normalize(e.cross(d,v,C),C);var m=R;m[0]=d.x;m[1]=d.y;m[2]=d.z;m[3]=v.x;m[4]=v.y;m[5]=v.z;m[6]=p.x;m[7]=p.y;m[8]=p.z;var w=o.transpose(m,O);var y=o.fromScale(r.radii,D);var g=o.fromScale(r.oneOverRadii,q);var S=N;S[0]=0;S[1]=-u.z;S[2]=u.y;S[3]=u.z;S[4]=0;S[5]=-u.x;S[6]=-u.y;S[7]=u.x;S[8]=0;var b=o.multiply(o.multiply(w,g,G),S,G);var T=o.multiply(o.multiply(b,y,L),m,L);var _=o.multiplyByVector(b,s,x);var E=M(T,e.negate(_,P),0,0,1);var z;var F;var U=E.length;if(U>0){var V=e.clone(e.ZERO,H);var j=Number.NEGATIVE_INFINITY;for(var W=0;W<U;++W){z=o.multiplyByVector(y,o.multiplyByVector(m,E[W],B),B);var X=e.normalize(e.subtract(z,s,I),I);var Q=e.dot(X,u);if(Q>j){j=Q;V=e.clone(z,V)}}var K=r.cartesianToCartographic(V,k);j=a.clamp(j,0,1);F=e.magnitude(e.subtract(V,s,I))*Math.sqrt(1-j*j);F=c?-F:F;K.height=F;return r.cartographicToCartesian(K,new e)}return undefined};var z=new e;c.lineSegmentPlane=function(t,r,o,s){if(!n(t)){throw new i("endPoint0 is required.")}if(!n(r)){throw new i("endPoint1 is required.")}if(!n(o)){throw new i("plane is required.")}if(!n(s)){s=new e}var u=e.subtract(r,t,z);var f=o.normal;var c=e.dot(f,u);if(Math.abs(c)<a.EPSILON6){return undefined}var l=e.dot(f,t);var d=-(o.distance+l)/c;if(d<0||d>1){return undefined}e.multiplyByScalar(u,d,s);e.add(t,s,s);return s};c.trianglePlaneIntersection=function(t,r,a,o){if(!n(t)||!n(r)||!n(a)||!n(o)){throw new i("p0, p1, p2, and plane are required.")}var s=o.normal;var u=o.distance;var f=e.dot(s,t)+u<0;var l=e.dot(s,r)+u<0;var d=e.dot(s,a)+u<0;var h=0;h+=f?1:0;h+=l?1:0;h+=d?1:0;var v,p;if(h===1||h===2){v=new e;p=new e}if(h===1){if(f){c.lineSegmentPlane(t,r,o,v);c.lineSegmentPlane(t,a,o,p);return{positions:[t,r,a,v,p],indices:[0,3,4,1,2,4,1,4,3]}}else if(l){c.lineSegmentPlane(r,a,o,v);c.lineSegmentPlane(r,t,o,p);return{positions:[t,r,a,v,p],indices:[1,3,4,2,0,4,2,4,3]}}else if(d){c.lineSegmentPlane(a,t,o,v);c.lineSegmentPlane(a,r,o,p);return{positions:[t,r,a,v,p],indices:[2,3,4,0,1,4,0,4,3]}}}else if(h===2){if(!f){c.lineSegmentPlane(r,t,o,v);c.lineSegmentPlane(a,t,o,p);return{positions:[t,r,a,v,p],indices:[1,2,4,1,4,3,0,3,4]}}else if(!l){c.lineSegmentPlane(a,r,o,v);c.lineSegmentPlane(t,r,o,p);return{positions:[t,r,a,v,p],indices:[2,0,4,2,4,3,1,3,4]}}else if(!d){c.lineSegmentPlane(t,a,o,v);c.lineSegmentPlane(r,a,o,p);return{positions:[t,r,a,v,p],indices:[0,1,4,0,4,3,2,3,4]}}}return undefined};return c})})();(function(){var t=e.amdDefine;t("6c",["1a"],function(e){"use strict";var t=Array.isArray;if(!e(t)){t=function(e){return Object.prototype.toString.call(e)==="[object Array]"}}return t})})();(function(){var t=e.amdDefine;t("43",["23","1a","1c","1f","27"],function(e,t,r,n,i){"use strict";function a(t,r,n,i){this.x=e(t,0);this.y=e(r,0);this.z=e(n,0);this.w=e(i,0)}a.fromElements=function(e,r,n,i,o){if(!t(o)){return new a(e,r,n,i)}o.x=e;o.y=r;o.z=n;o.w=i;return o};a.fromColor=function(e,n){if(!t(e)){throw new r("color is required")}if(!t(n)){return new a(e.red,e.green,e.blue,e.alpha)}n.x=e.red;n.y=e.green;n.z=e.blue;n.w=e.alpha;return n};a.clone=function(e,r){if(!t(e)){return undefined}if(!t(r)){return new a(e.x,e.y,e.z,e.w)}r.x=e.x;r.y=e.y;r.z=e.z;r.w=e.w;return r};a.packedLength=4;a.pack=function(n,i,a){if(!t(n)){throw new r("value is required")}if(!t(i)){throw new r("array is required")}a=e(a,0);i[a++]=n.x;i[a++]=n.y;i[a++]=n.z;i[a]=n.w};a.unpack=function(n,i,o){if(!t(n)){throw new r("array is required")}i=e(i,0);if(!t(o)){o=new a}o.x=n[i++];o.y=n[i++];o.z=n[i++];o.w=n[i];return o};a.packArray=function(e,n){if(!t(e)){throw new r("array is required")}var i=e.length;if(!t(n)){n=new Array(i*4)}else{n.length=i*4}for(var o=0;o<i;++o){a.pack(e[o],n,o*4)}return n};a.unpackArray=function(e,n){if(!t(e)){throw new r("array is required")}var i=e.length;if(!t(n)){n=new Array(i/4)}else{n.length=i/4}for(var o=0;o<i;o+=4){var s=o/4;n[s]=a.unpack(e,o,n[s])}return n};a.fromArray=a.unpack;a.maximumComponent=function(e){if(!t(e)){throw new r("cartesian is required")}return Math.max(e.x,e.y,e.z,e.w)};a.minimumComponent=function(e){if(!t(e)){throw new r("cartesian is required")}return Math.min(e.x,e.y,e.z,e.w)};a.minimumByComponent=function(e,n,i){if(!t(e)){throw new r("first is required.")}if(!t(n)){throw new r("second is required.")}if(!t(i)){throw new r("result is required.")}i.x=Math.min(e.x,n.x);i.y=Math.min(e.y,n.y);i.z=Math.min(e.z,n.z);i.w=Math.min(e.w,n.w);return i};a.maximumByComponent=function(e,n,i){if(!t(e)){throw new r("first is required.")}if(!t(n)){throw new r("second is required.")}if(!t(i)){throw new r("result is required.")}i.x=Math.max(e.x,n.x);i.y=Math.max(e.y,n.y);i.z=Math.max(e.z,n.z);i.w=Math.max(e.w,n.w);return i};a.magnitudeSquared=function(e){if(!t(e)){throw new r("cartesian is required")}return e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w};a.magnitude=function(e){return Math.sqrt(a.magnitudeSquared(e))};var o=new a;a.distance=function(e,n){if(!t(e)||!t(n)){throw new r("left and right are required.")}a.subtract(e,n,o);return a.magnitude(o)};a.distanceSquared=function(e,n){if(!t(e)||!t(n)){throw new r("left and right are required.")}a.subtract(e,n,o);return a.magnitudeSquared(o)};a.normalize=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}var i=a.magnitude(e);n.x=e.x/i;n.y=e.y/i;n.z=e.z/i;n.w=e.w/i;return n};a.dot=function(e,n){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}return e.x*n.x+e.y*n.y+e.z*n.z+e.w*n.w};a.multiplyComponents=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}i.x=e.x*n.x;i.y=e.y*n.y;i.z=e.z*n.z;i.w=e.w*n.w;return i};a.add=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}i.x=e.x+n.x;i.y=e.y+n.y;i.z=e.z+n.z;i.w=e.w+n.w;return i};a.subtract=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}i.x=e.x-n.x;i.y=e.y-n.y;i.z=e.z-n.z;i.w=e.w-n.w;return i};a.multiplyByScalar=function(e,n,i){if(!t(e)){throw new r("cartesian is required")}if(typeof n!=="number"){throw new r("scalar is required and must be a number.")}if(!t(i)){throw new r("result is required")}i.x=e.x*n;i.y=e.y*n;i.z=e.z*n;i.w=e.w*n;return i};a.divideByScalar=function(e,n,i){if(!t(e)){throw new r("cartesian is required")}if(typeof n!=="number"){throw new r("scalar is required and must be a number.")}if(!t(i)){throw new r("result is required")}i.x=e.x/n;i.y=e.y/n;i.z=e.z/n;i.w=e.w/n;return i};a.negate=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}n.x=-e.x;n.y=-e.y;n.z=-e.z;n.w=-e.w;return n};a.abs=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}n.x=Math.abs(e.x);n.y=Math.abs(e.y);n.z=Math.abs(e.z);n.w=Math.abs(e.w);return n;
	};var s=new a;a.lerp=function(e,n,i,o){if(!t(e)){throw new r("start is required.")}if(!t(n)){throw new r("end is required.")}if(typeof i!=="number"){throw new r("t is required and must be a number.")}if(!t(o)){throw new r("result is required.")}a.multiplyByScalar(n,i,s);o=a.multiplyByScalar(e,1-i,o);return a.add(s,o,o)};var u=new a;a.mostOrthogonalAxis=function(e,n){if(!t(e)){throw new r("cartesian is required.")}if(!t(n)){throw new r("result is required.")}var i=a.normalize(e,u);a.abs(i,i);if(i.x<=i.y){if(i.x<=i.z){if(i.x<=i.w){n=a.clone(a.UNIT_X,n)}else{n=a.clone(a.UNIT_W,n)}}else if(i.z<=i.w){n=a.clone(a.UNIT_Z,n)}else{n=a.clone(a.UNIT_W,n)}}else if(i.y<=i.z){if(i.y<=i.w){n=a.clone(a.UNIT_Y,n)}else{n=a.clone(a.UNIT_W,n)}}else if(i.z<=i.w){n=a.clone(a.UNIT_Z,n)}else{n=a.clone(a.UNIT_W,n)}return n};a.equals=function(e,r){return e===r||t(e)&&t(r)&&e.x===r.x&&e.y===r.y&&e.z===r.z&&e.w===r.w};a.equalsArray=function(e,t,r){return e.x===t[r]&&e.y===t[r+1]&&e.z===t[r+2]&&e.w===t[r+3]};a.equalsEpsilon=function(e,r,n,a){return e===r||t(e)&&t(r)&&i.equalsEpsilon(e.x,r.x,n,a)&&i.equalsEpsilon(e.y,r.y,n,a)&&i.equalsEpsilon(e.z,r.z,n,a)&&i.equalsEpsilon(e.w,r.w,n,a)};a.ZERO=n(new a(0,0,0,0));a.UNIT_X=n(new a(1,0,0,0));a.UNIT_Y=n(new a(0,1,0,0));a.UNIT_Z=n(new a(0,0,1,0));a.UNIT_W=n(new a(0,0,0,1));a.prototype.clone=function(e){return a.clone(this,e)};a.prototype.equals=function(e){return a.equals(this,e)};a.prototype.equalsEpsilon=function(e,t,r){return a.equalsEpsilon(this,e,t,r)};a.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+", "+this.w+")"};return a})})();(function(){var t=e.amdDefine;t("1b",["1a"],function(e){"use strict";var t=function(){try{return"x"in Object.defineProperty({},"x",{})}catch(e){return false}}();var r=Object.defineProperties;if(!t||!e(r)){r=function(e){return e}}return r})})();(function(){var t=e.amdDefine;t("32",["2c","23","1a","1b","1c","1f","27"],function(e,t,r,n,i,a,o){"use strict";function s(e,r,n,i,a,o,s,u,f){this[0]=t(e,0);this[1]=t(i,0);this[2]=t(s,0);this[3]=t(r,0);this[4]=t(a,0);this[5]=t(u,0);this[6]=t(n,0);this[7]=t(o,0);this[8]=t(f,0)}s.packedLength=9;s.pack=function(e,n,a){if(!r(e)){throw new i("value is required")}if(!r(n)){throw new i("array is required")}a=t(a,0);n[a++]=e[0];n[a++]=e[1];n[a++]=e[2];n[a++]=e[3];n[a++]=e[4];n[a++]=e[5];n[a++]=e[6];n[a++]=e[7];n[a++]=e[8]};s.unpack=function(e,n,a){if(!r(e)){throw new i("array is required")}n=t(n,0);if(!r(a)){a=new s}a[0]=e[n++];a[1]=e[n++];a[2]=e[n++];a[3]=e[n++];a[4]=e[n++];a[5]=e[n++];a[6]=e[n++];a[7]=e[n++];a[8]=e[n++];return a};s.clone=function(e,t){if(!r(e)){return undefined}if(!r(t)){return new s(e[0],e[3],e[6],e[1],e[4],e[7],e[2],e[5],e[8])}t[0]=e[0];t[1]=e[1];t[2]=e[2];t[3]=e[3];t[4]=e[4];t[5]=e[5];t[6]=e[6];t[7]=e[7];t[8]=e[8];return t};s.fromArray=function(e,n,a){if(!r(e)){throw new i("array is required")}n=t(n,0);if(!r(a)){a=new s}a[0]=e[n];a[1]=e[n+1];a[2]=e[n+2];a[3]=e[n+3];a[4]=e[n+4];a[5]=e[n+5];a[6]=e[n+6];a[7]=e[n+7];a[8]=e[n+8];return a};s.fromColumnMajorArray=function(e,t){if(!r(e)){throw new i("values parameter is required")}return s.clone(e,t)};s.fromRowMajorArray=function(e,t){if(!r(e)){throw new i("values is required.")}if(!r(t)){return new s(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}t[0]=e[0];t[1]=e[3];t[2]=e[6];t[3]=e[1];t[4]=e[4];t[5]=e[7];t[6]=e[2];t[7]=e[5];t[8]=e[8];return t};s.fromQuaternion=function(e,t){if(!r(e)){throw new i("quaternion is required")}var n=e.x*e.x;var a=e.x*e.y;var o=e.x*e.z;var u=e.x*e.w;var f=e.y*e.y;var c=e.y*e.z;var l=e.y*e.w;var d=e.z*e.z;var h=e.z*e.w;var v=e.w*e.w;var p=n-f-d+v;var m=2*(a-h);var w=2*(o+l);var y=2*(a+h);var g=-n+f-d+v;var S=2*(c-u);var b=2*(o-l);var T=2*(c+u);var _=-n-f+d+v;if(!r(t)){return new s(p,m,w,y,g,S,b,T,_)}t[0]=p;t[1]=y;t[2]=b;t[3]=m;t[4]=g;t[5]=T;t[6]=w;t[7]=S;t[8]=_;return t};s.fromScale=function(e,t){if(!r(e)){throw new i("scale is required.")}if(!r(t)){return new s(e.x,0,0,0,e.y,0,0,0,e.z)}t[0]=e.x;t[1]=0;t[2]=0;t[3]=0;t[4]=e.y;t[5]=0;t[6]=0;t[7]=0;t[8]=e.z;return t};s.fromUniformScale=function(e,t){if(typeof e!=="number"){throw new i("scale is required.")}if(!r(t)){return new s(e,0,0,0,e,0,0,0,e)}t[0]=e;t[1]=0;t[2]=0;t[3]=0;t[4]=e;t[5]=0;t[6]=0;t[7]=0;t[8]=e;return t};s.fromCrossProduct=function(e,t){if(!r(e)){throw new i("vector is required.")}if(!r(t)){return new s(0,-e.z,e.y,e.z,0,-e.x,-e.y,e.x,0)}t[0]=0;t[1]=e.z;t[2]=-e.y;t[3]=-e.z;t[4]=0;t[5]=e.x;t[6]=e.y;t[7]=-e.x;t[8]=0;return t};s.fromRotationX=function(e,t){if(!r(e)){throw new i("angle is required.")}var n=Math.cos(e);var a=Math.sin(e);if(!r(t)){return new s(1,0,0,0,n,-a,0,a,n)}t[0]=1;t[1]=0;t[2]=0;t[3]=0;t[4]=n;t[5]=a;t[6]=0;t[7]=-a;t[8]=n;return t};s.fromRotationY=function(e,t){if(!r(e)){throw new i("angle is required.")}var n=Math.cos(e);var a=Math.sin(e);if(!r(t)){return new s(n,0,a,0,1,0,-a,0,n)}t[0]=n;t[1]=0;t[2]=-a;t[3]=0;t[4]=1;t[5]=0;t[6]=a;t[7]=0;t[8]=n;return t};s.fromRotationZ=function(e,t){if(!r(e)){throw new i("angle is required.")}var n=Math.cos(e);var a=Math.sin(e);if(!r(t)){return new s(n,-a,0,a,n,0,0,0,1)}t[0]=n;t[1]=a;t[2]=0;t[3]=-a;t[4]=n;t[5]=0;t[6]=0;t[7]=0;t[8]=1;return t};s.toArray=function(e,t){if(!r(e)){throw new i("matrix is required")}if(!r(t)){return[e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8]]}t[0]=e[0];t[1]=e[1];t[2]=e[2];t[3]=e[3];t[4]=e[4];t[5]=e[5];t[6]=e[6];t[7]=e[7];t[8]=e[8];return t};s.getElementIndex=function(e,t){if(typeof t!=="number"||t<0||t>2){throw new i("row must be 0, 1, or 2.")}if(typeof e!=="number"||e<0||e>2){throw new i("column must be 0, 1, or 2.")}return e*3+t};s.getColumn=function(e,t,n){if(!r(e)){throw new i("matrix is required.")}if(typeof t!=="number"||t<0||t>2){throw new i("index must be 0, 1, or 2.")}if(!r(n)){throw new i("result is required")}var a=t*3;var o=e[a];var s=e[a+1];var u=e[a+2];n.x=o;n.y=s;n.z=u;return n};s.setColumn=function(e,t,n,a){if(!r(e)){throw new i("matrix is required")}if(!r(n)){throw new i("cartesian is required")}if(typeof t!=="number"||t<0||t>2){throw new i("index must be 0, 1, or 2.")}if(!r(a)){throw new i("result is required")}a=s.clone(e,a);var o=t*3;a[o]=n.x;a[o+1]=n.y;a[o+2]=n.z;return a};s.getRow=function(e,t,n){if(!r(e)){throw new i("matrix is required.")}if(typeof t!=="number"||t<0||t>2){throw new i("index must be 0, 1, or 2.")}if(!r(n)){throw new i("result is required")}var a=e[t];var o=e[t+3];var s=e[t+6];n.x=a;n.y=o;n.z=s;return n};s.setRow=function(e,t,n,a){if(!r(e)){throw new i("matrix is required")}if(!r(n)){throw new i("cartesian is required")}if(typeof t!=="number"||t<0||t>2){throw new i("index must be 0, 1, or 2.")}if(!r(a)){throw new i("result is required")}a=s.clone(e,a);a[t]=n.x;a[t+3]=n.y;a[t+6]=n.z;return a};var u=new e;s.getScale=function(t,n){if(!r(t)){throw new i("matrix is required.")}if(!r(n)){throw new i("result is required")}n.x=e.magnitude(e.fromElements(t[0],t[1],t[2],u));n.y=e.magnitude(e.fromElements(t[3],t[4],t[5],u));n.z=e.magnitude(e.fromElements(t[6],t[7],t[8],u));return n};var f=new e;s.getMaximumScale=function(t){s.getScale(t,f);return e.maximumComponent(f)};s.multiply=function(e,t,n){if(!r(e)){throw new i("left is required")}if(!r(t)){throw new i("right is required")}if(!r(n)){throw new i("result is required")}var a=e[0]*t[0]+e[3]*t[1]+e[6]*t[2];var o=e[1]*t[0]+e[4]*t[1]+e[7]*t[2];var s=e[2]*t[0]+e[5]*t[1]+e[8]*t[2];var u=e[0]*t[3]+e[3]*t[4]+e[6]*t[5];var f=e[1]*t[3]+e[4]*t[4]+e[7]*t[5];var c=e[2]*t[3]+e[5]*t[4]+e[8]*t[5];var l=e[0]*t[6]+e[3]*t[7]+e[6]*t[8];var d=e[1]*t[6]+e[4]*t[7]+e[7]*t[8];var h=e[2]*t[6]+e[5]*t[7]+e[8]*t[8];n[0]=a;n[1]=o;n[2]=s;n[3]=u;n[4]=f;n[5]=c;n[6]=l;n[7]=d;n[8]=h;return n};s.add=function(e,t,n){if(!r(e)){throw new i("left is required")}if(!r(t)){throw new i("right is required")}if(!r(n)){throw new i("result is required")}n[0]=e[0]+t[0];n[1]=e[1]+t[1];n[2]=e[2]+t[2];n[3]=e[3]+t[3];n[4]=e[4]+t[4];n[5]=e[5]+t[5];n[6]=e[6]+t[6];n[7]=e[7]+t[7];n[8]=e[8]+t[8];return n};s.subtract=function(e,t,n){if(!r(e)){throw new i("left is required")}if(!r(t)){throw new i("right is required")}if(!r(n)){throw new i("result is required")}n[0]=e[0]-t[0];n[1]=e[1]-t[1];n[2]=e[2]-t[2];n[3]=e[3]-t[3];n[4]=e[4]-t[4];n[5]=e[5]-t[5];n[6]=e[6]-t[6];n[7]=e[7]-t[7];n[8]=e[8]-t[8];return n};s.multiplyByVector=function(e,t,n){if(!r(e)){throw new i("matrix is required")}if(!r(t)){throw new i("cartesian is required")}if(!r(n)){throw new i("result is required")}var a=t.x;var o=t.y;var s=t.z;var u=e[0]*a+e[3]*o+e[6]*s;var f=e[1]*a+e[4]*o+e[7]*s;var c=e[2]*a+e[5]*o+e[8]*s;n.x=u;n.y=f;n.z=c;return n};s.multiplyByScalar=function(e,t,n){if(!r(e)){throw new i("matrix is required")}if(typeof t!=="number"){throw new i("scalar must be a number")}if(!r(n)){throw new i("result is required")}n[0]=e[0]*t;n[1]=e[1]*t;n[2]=e[2]*t;n[3]=e[3]*t;n[4]=e[4]*t;n[5]=e[5]*t;n[6]=e[6]*t;n[7]=e[7]*t;n[8]=e[8]*t;return n};s.multiplyByScale=function(e,t,n){if(!r(e)){throw new i("matrix is required")}if(!r(t)){throw new i("scale is required")}if(!r(n)){throw new i("result is required")}n[0]=e[0]*t.x;n[1]=e[1]*t.x;n[2]=e[2]*t.x;n[3]=e[3]*t.y;n[4]=e[4]*t.y;n[5]=e[5]*t.y;n[6]=e[6]*t.z;n[7]=e[7]*t.z;n[8]=e[8]*t.z;return n};s.negate=function(e,t){if(!r(e)){throw new i("matrix is required")}if(!r(t)){throw new i("result is required")}t[0]=-e[0];t[1]=-e[1];t[2]=-e[2];t[3]=-e[3];t[4]=-e[4];t[5]=-e[5];t[6]=-e[6];t[7]=-e[7];t[8]=-e[8];return t};s.transpose=function(e,t){if(!r(e)){throw new i("matrix is required")}if(!r(t)){throw new i("result is required")}var n=e[0];var a=e[3];var o=e[6];var s=e[1];var u=e[4];var f=e[7];var c=e[2];var l=e[5];var d=e[8];t[0]=n;t[1]=a;t[2]=o;t[3]=s;t[4]=u;t[5]=f;t[6]=c;t[7]=l;t[8]=d;return t};function c(e){var t=0;for(var r=0;r<9;++r){var n=e[r];t+=n*n}return Math.sqrt(t)}var l=[1,0,0];var d=[2,2,1];function h(e){var t=0;for(var r=0;r<3;++r){var n=e[s.getElementIndex(d[r],l[r])];t+=2*n*n}return Math.sqrt(t)}function v(e,t){var r=o.EPSILON15;var n=0;var i=1;for(var a=0;a<3;++a){var u=Math.abs(e[s.getElementIndex(d[a],l[a])]);if(u>n){i=a;n=u}}var f=1;var c=0;var h=l[i];var v=d[i];if(Math.abs(e[s.getElementIndex(v,h)])>r){var p=e[s.getElementIndex(v,v)];var m=e[s.getElementIndex(h,h)];var w=e[s.getElementIndex(v,h)];var y=(p-m)/2/w;var g;if(y<0){g=-1/(-y+Math.sqrt(1+y*y))}else{g=1/(y+Math.sqrt(1+y*y))}f=1/Math.sqrt(1+g*g);c=g*f}t=s.clone(s.IDENTITY,t);t[s.getElementIndex(h,h)]=t[s.getElementIndex(v,v)]=f;t[s.getElementIndex(v,h)]=c;t[s.getElementIndex(h,v)]=-c;return t}var p=new s;var m=new s;s.computeEigenDecomposition=function(e,t){if(!r(e)){throw new i("matrix is required.")}var n=o.EPSILON20;var a=10;var u=0;var f=0;if(!r(t)){t={}}var l=t.unitary=s.clone(s.IDENTITY,t.unitary);var d=t.diagonal=s.clone(e,t.diagonal);var w=n*c(d);while(f<a&&h(d)>w){v(d,p);s.transpose(p,m);s.multiply(d,p,d);s.multiply(m,d,d);s.multiply(l,p,l);if(++u>2){++f;u=0}}return t};s.abs=function(e,t){if(!r(e)){throw new i("matrix is required")}if(!r(t)){throw new i("result is required")}t[0]=Math.abs(e[0]);t[1]=Math.abs(e[1]);t[2]=Math.abs(e[2]);t[3]=Math.abs(e[3]);t[4]=Math.abs(e[4]);t[5]=Math.abs(e[5]);t[6]=Math.abs(e[6]);t[7]=Math.abs(e[7]);t[8]=Math.abs(e[8]);return t};s.determinant=function(e){if(!r(e)){throw new i("matrix is required")}var t=e[0];var n=e[3];var a=e[6];var o=e[1];var s=e[4];var u=e[7];var f=e[2];var c=e[5];var l=e[8];return t*(s*l-c*u)+o*(c*a-n*l)+f*(n*u-s*a)};s.inverse=function(e,t){if(!r(e)){throw new i("matrix is required")}if(!r(t)){throw new i("result is required")}var n=e[0];var a=e[1];var u=e[2];var f=e[3];var c=e[4];var l=e[5];var d=e[6];var h=e[7];var v=e[8];var p=s.determinant(e);if(Math.abs(p)<=o.EPSILON15){throw new i("matrix is not invertible")}t[0]=c*v-h*l;t[1]=h*u-a*v;t[2]=a*l-c*u;t[3]=d*l-f*v;t[4]=n*v-d*u;t[5]=f*u-n*l;t[6]=f*h-d*c;t[7]=d*a-n*h;t[8]=n*c-f*a;var m=1/p;return s.multiplyByScalar(t,m,t)};s.equals=function(e,t){return e===t||r(e)&&r(t)&&e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]};s.equalsEpsilon=function(e,t,n){if(typeof n!=="number"){throw new i("epsilon must be a number")}return e===t||r(e)&&r(t)&&Math.abs(e[0]-t[0])<=n&&Math.abs(e[1]-t[1])<=n&&Math.abs(e[2]-t[2])<=n&&Math.abs(e[3]-t[3])<=n&&Math.abs(e[4]-t[4])<=n&&Math.abs(e[5]-t[5])<=n&&Math.abs(e[6]-t[6])<=n&&Math.abs(e[7]-t[7])<=n&&Math.abs(e[8]-t[8])<=n};s.IDENTITY=a(new s(1,0,0,0,1,0,0,0,1));s.ZERO=a(new s(0,0,0,0,0,0,0,0,0));s.COLUMN0ROW0=0;s.COLUMN0ROW1=1;s.COLUMN0ROW2=2;s.COLUMN1ROW0=3;s.COLUMN1ROW1=4;s.COLUMN1ROW2=5;s.COLUMN2ROW0=6;s.COLUMN2ROW1=7;s.COLUMN2ROW2=8;n(s.prototype,{length:{get:function(){return s.packedLength}}});s.prototype.clone=function(e){return s.clone(this,e)};s.prototype.equals=function(e){return s.equals(this,e)};s.equalsArray=function(e,t,r){return e[0]===t[r]&&e[1]===t[r+1]&&e[2]===t[r+2]&&e[3]===t[r+3]&&e[4]===t[r+4]&&e[5]===t[r+5]&&e[6]===t[r+6]&&e[7]===t[r+7]&&e[8]===t[r+8]};s.prototype.equalsEpsilon=function(e,t){return s.equalsEpsilon(this,e,t)};s.prototype.toString=function(){return"("+this[0]+", "+this[3]+", "+this[6]+")\n"+"("+this[1]+", "+this[4]+", "+this[7]+")\n"+"("+this[2]+", "+this[5]+", "+this[8]+")"};return s})})();(function(){var t=e.amdDefine;t("38",["1a"],function(e){"use strict";function t(e){this.name="RuntimeError";this.message=e;var t;try{throw new Error}catch(e){t=e.stack}this.stack=t}if(e(Object.create)){t.prototype=Object.create(Error.prototype);t.prototype.constructor=t}t.prototype.toString=function(){var t=this.name+": "+this.message;if(e(this.stack)){t+="\n"+this.stack.toString()}return t};return t})})();(function(){var t=e.amdDefine;t("33",["2c","43","23","1a","1b","1c","1f","27","32","38"],function(e,t,r,n,i,a,o,s,u,f){"use strict";function c(e,t,n,i,a,o,s,u,f,c,l,d,h,v,p,m){this[0]=r(e,0);this[1]=r(a,0);this[2]=r(f,0);this[3]=r(h,0);this[4]=r(t,0);this[5]=r(o,0);this[6]=r(c,0);this[7]=r(v,0);this[8]=r(n,0);this[9]=r(s,0);this[10]=r(l,0);this[11]=r(p,0);this[12]=r(i,0);this[13]=r(u,0);this[14]=r(d,0);this[15]=r(m,0)}c.packedLength=16;c.pack=function(e,t,i){if(!n(e)){throw new a("value is required")}if(!n(t)){throw new a("array is required")}i=r(i,0);t[i++]=e[0];t[i++]=e[1];t[i++]=e[2];t[i++]=e[3];t[i++]=e[4];t[i++]=e[5];t[i++]=e[6];t[i++]=e[7];t[i++]=e[8];t[i++]=e[9];t[i++]=e[10];t[i++]=e[11];t[i++]=e[12];t[i++]=e[13];t[i++]=e[14];t[i]=e[15]};c.unpack=function(e,t,i){if(!n(e)){throw new a("array is required")}t=r(t,0);if(!n(i)){i=new c}i[0]=e[t++];i[1]=e[t++];i[2]=e[t++];i[3]=e[t++];i[4]=e[t++];i[5]=e[t++];i[6]=e[t++];i[7]=e[t++];i[8]=e[t++];i[9]=e[t++];i[10]=e[t++];i[11]=e[t++];i[12]=e[t++];i[13]=e[t++];i[14]=e[t++];i[15]=e[t];return i};c.clone=function(e,t){if(!n(e)){return undefined}if(!n(t)){return new c(e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15])}t[0]=e[0];t[1]=e[1];t[2]=e[2];t[3]=e[3];t[4]=e[4];t[5]=e[5];t[6]=e[6];t[7]=e[7];t[8]=e[8];t[9]=e[9];t[10]=e[10];t[11]=e[11];t[12]=e[12];t[13]=e[13];t[14]=e[14];t[15]=e[15];return t};c.fromArray=c.unpack;c.fromColumnMajorArray=function(e,t){if(!n(e)){throw new a("values is required")}return c.clone(e,t)};c.fromRowMajorArray=function(e,t){if(!n(e)){throw new a("values is required.")}if(!n(t)){return new c(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}t[0]=e[0];t[1]=e[4];t[2]=e[8];t[3]=e[12];t[4]=e[1];t[5]=e[5];t[6]=e[9];t[7]=e[13];t[8]=e[2];t[9]=e[6];t[10]=e[10];t[11]=e[14];t[12]=e[3];t[13]=e[7];t[14]=e[11];t[15]=e[15];return t};c.fromRotationTranslation=function(t,i,o){if(!n(t)){throw new a("rotation is required.")}i=r(i,e.ZERO);if(!n(o)){return new c(t[0],t[3],t[6],i.x,t[1],t[4],t[7],i.y,t[2],t[5],t[8],i.z,0,0,0,1)}o[0]=t[0];o[1]=t[1];o[2]=t[2];o[3]=0;o[4]=t[3];o[5]=t[4];o[6]=t[5];o[7]=0;o[8]=t[6];o[9]=t[7];o[10]=t[8];o[11]=0;o[12]=i.x;o[13]=i.y;o[14]=i.z;o[15]=1;return o};c.fromTranslationQuaternionRotationScale=function(e,t,r,i){if(!n(e)){throw new a("translation is required.")}if(!n(t)){throw new a("rotation is required.")}if(!n(r)){throw new a("scale is required.")}if(!n(i)){i=new c}var o=r.x;var s=r.y;var u=r.z;var f=t.x*t.x;var l=t.x*t.y;var d=t.x*t.z;var h=t.x*t.w;var v=t.y*t.y;var p=t.y*t.z;var m=t.y*t.w;var w=t.z*t.z;var y=t.z*t.w;var g=t.w*t.w;var S=f-v-w+g;var b=2*(l-y);var T=2*(d+m);var _=2*(l+y);var E=-f+v-w+g;var M=2*(p-h);var P=2*(d-m);var A=2*(p+h);var C=-f-v+w+g;i[0]=S*o;i[1]=_*o;i[2]=P*o;i[3]=0;i[4]=b*s;i[5]=E*s;i[6]=A*s;i[7]=0;i[8]=T*u;i[9]=M*u;i[10]=C*u;i[11]=0;i[12]=e.x;i[13]=e.y;i[14]=e.z;i[15]=1;return i};c.fromTranslationRotationScale=function(e,t){if(!n(e)){throw new a("translationRotationScale is required.")}return c.fromTranslationQuaternionRotationScale(e.translation,e.rotation,e.scale,t)};c.fromTranslation=function(e,t){if(!n(e)){throw new a("translation is required.")}return c.fromRotationTranslation(u.IDENTITY,e,t)};c.fromScale=function(e,t){if(!n(e)){throw new a("scale is required.")}if(!n(t)){return new c(e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1)}t[0]=e.x;t[1]=0;t[2]=0;t[3]=0;t[4]=0;t[5]=e.y;t[6]=0;t[7]=0;t[8]=0;t[9]=0;t[10]=e.z;t[11]=0;t[12]=0;t[13]=0;t[14]=0;t[15]=1;return t};c.fromUniformScale=function(e,t){if(typeof e!=="number"){throw new a("scale is required.")}if(!n(t)){return new c(e,0,0,0,0,e,0,0,0,0,e,0,0,0,0,1)}t[0]=e;t[1]=0;t[2]=0;t[3]=0;t[4]=0;t[5]=e;t[6]=0;t[7]=0;t[8]=0;t[9]=0;t[10]=e;t[11]=0;t[12]=0;t[13]=0;t[14]=0;t[15]=1;return t};var l=new e;var d=new e;var h=new e;c.fromCamera=function(t,r){if(!n(t)){throw new a("camera is required.")}var i=t.position;var o=t.direction;var s=t.up;if(!n(i)){throw new a("camera.position is required.")}if(!n(o)){throw new a("camera.direction is required.")}if(!n(s)){throw new a("camera.up is required.")}e.normalize(o,l);e.normalize(e.cross(l,s,d),d);e.normalize(e.cross(d,l,h),h);var u=d.x;var f=d.y;var v=d.z;var p=l.x;var m=l.y;var w=l.z;var y=h.x;var g=h.y;var S=h.z;var b=i.x;var T=i.y;var _=i.z;var E=u*-b+f*-T+v*-_;var M=y*-b+g*-T+S*-_;var P=p*b+m*T+w*_;if(!n(r)){return new c(u,f,v,E,y,g,S,M,-p,-m,-w,P,0,0,0,1)}r[0]=u;r[1]=y;r[2]=-p;r[3]=0;r[4]=f;r[5]=g;r[6]=-m;r[7]=0;r[8]=v;r[9]=S;r[10]=-w;r[11]=0;r[12]=E;r[13]=M;r[14]=P;r[15]=1;return r};c.computePerspectiveFieldOfView=function(e,t,r,i,o){if(e<=0||e>Math.PI){throw new a("fovY must be in [0, PI).")}if(t<=0){throw new a("aspectRatio must be greater than zero.")}if(r<=0){throw new a("near must be greater than zero.")}if(i<=0){throw new a("far must be greater than zero.")}if(!n(o)){throw new a("result is required")}var s=Math.tan(e*.5);var u=1/s;var f=u/t;var c=(i+r)/(r-i);var l=2*i*r/(r-i);o[0]=f;o[1]=0;o[2]=0;o[3]=0;o[4]=0;o[5]=u;o[6]=0;o[7]=0;o[8]=0;o[9]=0;o[10]=c;o[11]=-1;o[12]=0;o[13]=0;o[14]=l;o[15]=0;return o};c.computeOrthographicOffCenter=function(e,t,r,i,o,s,u){if(!n(e)){throw new a("left is required.")}if(!n(t)){throw new a("right is required.")}if(!n(r)){throw new a("bottom is required.")}if(!n(i)){throw new a("top is required.")}if(!n(o)){throw new a("near is required.")}if(!n(s)){throw new a("far is required.")}if(!n(u)){throw new a("result is required")}var f=1/(t-e);var c=1/(i-r);var l=1/(s-o);var d=-(t+e)*f;var h=-(i+r)*c;var v=-(s+o)*l;f*=2;c*=2;l*=-2;u[0]=f;u[1]=0;u[2]=0;u[3]=0;u[4]=0;u[5]=c;u[6]=0;u[7]=0;u[8]=0;u[9]=0;u[10]=l;u[11]=0;u[12]=d;u[13]=h;u[14]=v;u[15]=1;return u};c.computePerspectiveOffCenter=function(e,t,r,i,o,s,u){if(!n(e)){throw new a("left is required.")}if(!n(t)){throw new a("right is required.")}if(!n(r)){throw new a("bottom is required.")}if(!n(i)){throw new a("top is required.")}if(!n(o)){throw new a("near is required.")}if(!n(s)){throw new a("far is required.")}if(!n(u)){throw new a("result is required")}var f=2*o/(t-e);var c=2*o/(i-r);var l=(t+e)/(t-e);var d=(i+r)/(i-r);var h=-(s+o)/(s-o);var v=-1;var p=-2*s*o/(s-o);u[0]=f;u[1]=0;u[2]=0;u[3]=0;u[4]=0;u[5]=c;u[6]=0;u[7]=0;u[8]=l;u[9]=d;u[10]=h;u[11]=v;u[12]=0;u[13]=0;u[14]=p;u[15]=0;return u};c.computeInfinitePerspectiveOffCenter=function(e,t,r,i,o,s){if(!n(e)){throw new a("left is required.")}if(!n(t)){throw new a("right is required.")}if(!n(r)){throw new a("bottom is required.")}if(!n(i)){throw new a("top is required.")}if(!n(o)){throw new a("near is required.")}if(!n(s)){throw new a("result is required")}var u=2*o/(t-e);var f=2*o/(i-r);var c=(t+e)/(t-e);var l=(i+r)/(i-r);var d=-1;var h=-1;var v=-2*o;s[0]=u;s[1]=0;s[2]=0;s[3]=0;s[4]=0;s[5]=f;s[6]=0;s[7]=0;s[8]=c;s[9]=l;s[10]=d;s[11]=h;s[12]=0;s[13]=0;s[14]=v;s[15]=0;return s};c.computeViewportTransformation=function(e,t,i,o){if(!n(o)){throw new a("result is required")}e=r(e,r.EMPTY_OBJECT);var s=r(e.x,0);var u=r(e.y,0);var f=r(e.width,0);var c=r(e.height,0);t=r(t,0);i=r(i,1);var l=f*.5;var d=c*.5;var h=(i-t)*.5;var v=l;var p=d;var m=h;var w=s+l;var y=u+d;var g=t+h;var S=1;o[0]=v;o[1]=0;o[2]=0;o[3]=0;o[4]=0;o[5]=p;o[6]=0;o[7]=0;o[8]=0;o[9]=0;o[10]=m;o[11]=0;o[12]=w;o[13]=y;o[14]=g;o[15]=S;return o};c.computeView=function(t,r,i,o,s){if(!n(t)){throw new a("position is required")}if(!n(r)){throw new a("direction is required")}if(!n(i)){throw new a("up is required")}if(!n(o)){throw new a("right is required")}if(!n(s)){throw new a("result is required")}s[0]=o.x;s[1]=i.x;s[2]=-r.x;s[3]=0;s[4]=o.y;s[5]=i.y;s[6]=-r.y;s[7]=0;s[8]=o.z;s[9]=i.z;s[10]=-r.z;s[11]=0;s[12]=-e.dot(o,t);s[13]=-e.dot(i,t);s[14]=e.dot(r,t);s[15]=1;return s};c.toArray=function(e,t){if(!n(e)){throw new a("matrix is required")}if(!n(t)){return[e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15]]}t[0]=e[0];t[1]=e[1];t[2]=e[2];t[3]=e[3];t[4]=e[4];t[5]=e[5];t[6]=e[6];t[7]=e[7];t[8]=e[8];t[9]=e[9];t[10]=e[10];t[11]=e[11];t[12]=e[12];t[13]=e[13];t[14]=e[14];t[15]=e[15];return t};c.getElementIndex=function(e,t){if(typeof t!=="number"||t<0||t>3){throw new a("row must be 0, 1, 2, or 3.")}if(typeof e!=="number"||e<0||e>3){throw new a("column must be 0, 1, 2, or 3.")}return e*4+t};c.getColumn=function(e,t,r){if(!n(e)){throw new a("matrix is required.")}if(typeof t!=="number"||t<0||t>3){throw new a("index must be 0, 1, 2, or 3.")}if(!n(r)){throw new a("result is required")}var i=t*4;var o=e[i];var s=e[i+1];var u=e[i+2];var f=e[i+3];r.x=o;r.y=s;r.z=u;r.w=f;return r};c.setColumn=function(e,t,r,i){if(!n(e)){throw new a("matrix is required")}if(!n(r)){throw new a("cartesian is required")}if(typeof t!=="number"||t<0||t>3){throw new a("index must be 0, 1, 2, or 3.")}if(!n(i)){throw new a("result is required")}i=c.clone(e,i);var o=t*4;i[o]=r.x;i[o+1]=r.y;i[o+2]=r.z;i[o+3]=r.w;return i};c.setTranslation=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("translation is required")}if(!n(r)){throw new a("result is required")}r[0]=e[0];r[1]=e[1];r[2]=e[2];r[3]=e[3];r[4]=e[4];r[5]=e[5];r[6]=e[6];r[7]=e[7];r[8]=e[8];r[9]=e[9];r[10]=e[10];r[11]=e[11];r[12]=t.x;r[13]=t.y;r[14]=t.z;r[15]=e[15];return r};c.getRow=function(e,t,r){if(!n(e)){throw new a("matrix is required.")}if(typeof t!=="number"||t<0||t>3){throw new a("index must be 0, 1, 2, or 3.")}if(!n(r)){throw new a("result is required")}var i=e[t];var o=e[t+4];var s=e[t+8];var u=e[t+12];r.x=i;r.y=o;r.z=s;r.w=u;return r};c.setRow=function(e,t,r,i){if(!n(e)){throw new a("matrix is required")}if(!n(r)){throw new a("cartesian is required")}if(typeof t!=="number"||t<0||t>3){throw new a("index must be 0, 1, 2, or 3.")}if(!n(i)){throw new a("result is required")}i=c.clone(e,i);i[t]=r.x;i[t+4]=r.y;i[t+8]=r.z;i[t+12]=r.w;return i};var v=new e;c.getScale=function(t,r){if(!n(t)){throw new a("matrix is required.")}if(!n(r)){throw new a("result is required")}r.x=e.magnitude(e.fromElements(t[0],t[1],t[2],v));r.y=e.magnitude(e.fromElements(t[4],t[5],t[6],v));r.z=e.magnitude(e.fromElements(t[8],t[9],t[10],v));return r};var p=new e;c.getMaximumScale=function(t){c.getScale(t,p);return e.maximumComponent(p)};c.multiply=function(e,t,r){if(!n(e)){throw new a("left is required")}if(!n(t)){throw new a("right is required")}if(!n(r)){throw new a("result is required")}var i=e[0];var o=e[1];var s=e[2];var u=e[3];var f=e[4];var c=e[5];var l=e[6];var d=e[7];var h=e[8];var v=e[9];var p=e[10];var m=e[11];var w=e[12];var y=e[13];var g=e[14];var S=e[15];var b=t[0];var T=t[1];var _=t[2];var E=t[3];var M=t[4];var P=t[5];var A=t[6];var C=t[7];var I=t[8];var x=t[9];var R=t[10];var O=t[11];var D=t[12];var q=t[13];var N=t[14];var G=t[15];var L=i*b+f*T+h*_+w*E;var B=o*b+c*T+v*_+y*E;var H=s*b+l*T+p*_+g*E;var k=u*b+d*T+m*_+S*E;var z=i*M+f*P+h*A+w*C;var F=o*M+c*P+v*A+y*C;var U=s*M+l*P+p*A+g*C;var V=u*M+d*P+m*A+S*C;var j=i*I+f*x+h*R+w*O;var W=o*I+c*x+v*R+y*O;var X=s*I+l*x+p*R+g*O;var Q=u*I+d*x+m*R+S*O;var K=i*D+f*q+h*N+w*G;var Y=o*D+c*q+v*N+y*G;var Z=s*D+l*q+p*N+g*G;var J=u*D+d*q+m*N+S*G;r[0]=L;r[1]=B;r[2]=H;r[3]=k;r[4]=z;r[5]=F;r[6]=U;r[7]=V;r[8]=j;r[9]=W;r[10]=X;r[11]=Q;r[12]=K;r[13]=Y;r[14]=Z;r[15]=J;return r};c.add=function(e,t,r){if(!n(e)){throw new a("left is required")}if(!n(t)){throw new a("right is required")}if(!n(r)){throw new a("result is required")}r[0]=e[0]+t[0];r[1]=e[1]+t[1];r[2]=e[2]+t[2];r[3]=e[3]+t[3];r[4]=e[4]+t[4];r[5]=e[5]+t[5];r[6]=e[6]+t[6];r[7]=e[7]+t[7];r[8]=e[8]+t[8];r[9]=e[9]+t[9];r[10]=e[10]+t[10];r[11]=e[11]+t[11];r[12]=e[12]+t[12];r[13]=e[13]+t[13];r[14]=e[14]+t[14];r[15]=e[15]+t[15];return r};c.subtract=function(e,t,r){if(!n(e)){throw new a("left is required")}if(!n(t)){throw new a("right is required")}if(!n(r)){throw new a("result is required")}r[0]=e[0]-t[0];r[1]=e[1]-t[1];r[2]=e[2]-t[2];r[3]=e[3]-t[3];r[4]=e[4]-t[4];r[5]=e[5]-t[5];r[6]=e[6]-t[6];r[7]=e[7]-t[7];r[8]=e[8]-t[8];r[9]=e[9]-t[9];r[10]=e[10]-t[10];r[11]=e[11]-t[11];r[12]=e[12]-t[12];r[13]=e[13]-t[13];r[14]=e[14]-t[14];r[15]=e[15]-t[15];return r};c.multiplyTransformation=function(e,t,r){if(!n(e)){throw new a("left is required")}if(!n(t)){throw new a("right is required")}if(!n(r)){throw new a("result is required")}var i=e[0];var o=e[1];var s=e[2];var u=e[4];var f=e[5];var c=e[6];var l=e[8];var d=e[9];var h=e[10];var v=e[12];var p=e[13];var m=e[14];var w=t[0];var y=t[1];var g=t[2];var S=t[4];var b=t[5];var T=t[6];var _=t[8];var E=t[9];var M=t[10];var P=t[12];var A=t[13];var C=t[14];var I=i*w+u*y+l*g;var x=o*w+f*y+d*g;var R=s*w+c*y+h*g;var O=i*S+u*b+l*T;var D=o*S+f*b+d*T;var q=s*S+c*b+h*T;var N=i*_+u*E+l*M;var G=o*_+f*E+d*M;var L=s*_+c*E+h*M;var B=i*P+u*A+l*C+v;var H=o*P+f*A+d*C+p;var k=s*P+c*A+h*C+m;r[0]=I;r[1]=x;r[2]=R;r[3]=0;r[4]=O;r[5]=D;r[6]=q;r[7]=0;r[8]=N;r[9]=G;r[10]=L;r[11]=0;r[12]=B;r[13]=H;r[14]=k;r[15]=1;return r};c.multiplyByMatrix3=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("rotation is required")}if(!n(r)){throw new a("result is required")}var i=e[0];var o=e[1];var s=e[2];var u=e[4];var f=e[5];var c=e[6];var l=e[8];var d=e[9];var h=e[10];var v=t[0];var p=t[1];var m=t[2];var w=t[3];var y=t[4];var g=t[5];var S=t[6];var b=t[7];var T=t[8];var _=i*v+u*p+l*m;var E=o*v+f*p+d*m;var M=s*v+c*p+h*m;var P=i*w+u*y+l*g;var A=o*w+f*y+d*g;var C=s*w+c*y+h*g;var I=i*S+u*b+l*T;var x=o*S+f*b+d*T;var R=s*S+c*b+h*T;r[0]=_;r[1]=E;r[2]=M;r[3]=0;r[4]=P;r[5]=A;r[6]=C;r[7]=0;r[8]=I;r[9]=x;r[10]=R;r[11]=0;r[12]=e[12];r[13]=e[13];r[14]=e[14];r[15]=e[15];return r};c.multiplyByTranslation=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("translation is required")}if(!n(r)){throw new a("result is required")}var i=t.x;var o=t.y;var s=t.z;var u=i*e[0]+o*e[4]+s*e[8]+e[12];var f=i*e[1]+o*e[5]+s*e[9]+e[13];var c=i*e[2]+o*e[6]+s*e[10]+e[14];r[0]=e[0];r[1]=e[1];r[2]=e[2];r[3]=e[3];r[4]=e[4];r[5]=e[5];r[6]=e[6];r[7]=e[7];r[8]=e[8];r[9]=e[9];r[10]=e[10];r[11]=e[11];r[12]=u;r[13]=f;r[14]=c;r[15]=e[15];return r};var m=new e;c.multiplyByUniformScale=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(typeof t!=="number"){throw new a("scale is required")}if(!n(r)){throw new a("result is required")}m.x=t;m.y=t;m.z=t;return c.multiplyByScale(e,m,r)};c.multiplyByScale=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("scale is required")}if(!n(r)){throw new a("result is required")}var i=t.x;var o=t.y;var s=t.z;if(i===1&&o===1&&s===1){return c.clone(e,r)}r[0]=i*e[0];r[1]=i*e[1];r[2]=i*e[2];r[3]=0;r[4]=o*e[4];r[5]=o*e[5];r[6]=o*e[6];r[7]=0;r[8]=s*e[8];r[9]=s*e[9];r[10]=s*e[10];r[11]=0;r[12]=e[12];r[13]=e[13];r[14]=e[14];r[15]=1;return r};c.multiplyByVector=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("cartesian is required")}if(!n(r)){throw new a("result is required")}var i=t.x;var o=t.y;var s=t.z;var u=t.w;var f=e[0]*i+e[4]*o+e[8]*s+e[12]*u;var c=e[1]*i+e[5]*o+e[9]*s+e[13]*u;var l=e[2]*i+e[6]*o+e[10]*s+e[14]*u;var d=e[3]*i+e[7]*o+e[11]*s+e[15]*u;r.x=f;r.y=c;r.z=l;r.w=d;return r};c.multiplyByPointAsVector=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("cartesian is required")}if(!n(r)){throw new a("result is required")}var i=t.x;var o=t.y;var s=t.z;var u=e[0]*i+e[4]*o+e[8]*s;var f=e[1]*i+e[5]*o+e[9]*s;var c=e[2]*i+e[6]*o+e[10]*s;r.x=u;r.y=f;r.z=c;return r};c.multiplyByPoint=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("cartesian is required")}if(!n(r)){throw new a("result is required")}var i=t.x;var o=t.y;var s=t.z;var u=e[0]*i+e[4]*o+e[8]*s+e[12];var f=e[1]*i+e[5]*o+e[9]*s+e[13];var c=e[2]*i+e[6]*o+e[10]*s+e[14];r.x=u;r.y=f;r.z=c;return r};c.multiplyByScalar=function(e,t,r){if(!n(e)){throw new a("matrix is required")}if(typeof t!=="number"){throw new a("scalar must be a number")}if(!n(r)){throw new a("result is required")}r[0]=e[0]*t;r[1]=e[1]*t;r[2]=e[2]*t;r[3]=e[3]*t;r[4]=e[4]*t;r[5]=e[5]*t;r[6]=e[6]*t;r[7]=e[7]*t;r[8]=e[8]*t;r[9]=e[9]*t;r[10]=e[10]*t;r[11]=e[11]*t;r[12]=e[12]*t;r[13]=e[13]*t;r[14]=e[14]*t;r[15]=e[15]*t;return r};c.negate=function(e,t){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("result is required")}t[0]=-e[0];t[1]=-e[1];t[2]=-e[2];t[3]=-e[3];t[4]=-e[4];t[5]=-e[5];t[6]=-e[6];t[7]=-e[7];t[8]=-e[8];t[9]=-e[9];t[10]=-e[10];t[11]=-e[11];t[12]=-e[12];t[13]=-e[13];t[14]=-e[14];t[15]=-e[15];return t};c.transpose=function(e,t){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("result is required")}var r=e[1];var i=e[2];var o=e[3];var s=e[6];var u=e[7];var f=e[11];t[0]=e[0];t[1]=e[4];t[2]=e[8];t[3]=e[12];t[4]=r;t[5]=e[5];t[6]=e[9];t[7]=e[13];t[8]=i;t[9]=s;t[10]=e[10];t[11]=e[14];t[12]=o;t[13]=u;t[14]=f;t[15]=e[15];return t};c.abs=function(e,t){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("result is required")}t[0]=Math.abs(e[0]);t[1]=Math.abs(e[1]);t[2]=Math.abs(e[2]);t[3]=Math.abs(e[3]);t[4]=Math.abs(e[4]);t[5]=Math.abs(e[5]);t[6]=Math.abs(e[6]);t[7]=Math.abs(e[7]);t[8]=Math.abs(e[8]);t[9]=Math.abs(e[9]);t[10]=Math.abs(e[10]);t[11]=Math.abs(e[11]);t[12]=Math.abs(e[12]);t[13]=Math.abs(e[13]);t[14]=Math.abs(e[14]);t[15]=Math.abs(e[15]);return t};c.equals=function(e,t){return e===t||n(e)&&n(t)&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[3]===t[3]&&e[7]===t[7]&&e[11]===t[11]&&e[15]===t[15]};c.equalsEpsilon=function(e,t,r){if(typeof r!=="number"){throw new a("epsilon must be a number")}return e===t||n(e)&&n(t)&&Math.abs(e[0]-t[0])<=r&&Math.abs(e[1]-t[1])<=r&&Math.abs(e[2]-t[2])<=r&&Math.abs(e[3]-t[3])<=r&&Math.abs(e[4]-t[4])<=r&&Math.abs(e[5]-t[5])<=r&&Math.abs(e[6]-t[6])<=r&&Math.abs(e[7]-t[7])<=r&&Math.abs(e[8]-t[8])<=r&&Math.abs(e[9]-t[9])<=r&&Math.abs(e[10]-t[10])<=r&&Math.abs(e[11]-t[11])<=r&&Math.abs(e[12]-t[12])<=r&&Math.abs(e[13]-t[13])<=r&&Math.abs(e[14]-t[14])<=r&&Math.abs(e[15]-t[15])<=r};c.getTranslation=function(e,t){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("result is required")}t.x=e[12];t.y=e[13];t.z=e[14];return t};c.getRotation=function(e,t){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("result is required")}t[0]=e[0];t[1]=e[1];t[2]=e[2];t[3]=e[4];t[4]=e[5];t[5]=e[6];t[6]=e[8];t[7]=e[9];t[8]=e[10];return t};var w=new u;var y=new u;var g=new t;var S=new t(0,0,0,1);c.inverse=function(e,r){if(!n(e)){throw new a("matrix is required")}if(!n(r)){throw new a("result is required")}if(u.equalsEpsilon(c.getRotation(e,w),y,s.EPSILON7)&&t.equals(c.getRow(e,3,g),S)){
	r[0]=0;r[1]=0;r[2]=0;r[3]=0;r[4]=0;r[5]=0;r[6]=0;r[7]=0;r[8]=0;r[9]=0;r[10]=0;r[11]=0;r[12]=-e[12];r[13]=-e[13];r[14]=-e[14];r[15]=1;return r}var i=e[0];var o=e[4];var l=e[8];var d=e[12];var h=e[1];var v=e[5];var p=e[9];var m=e[13];var b=e[2];var T=e[6];var _=e[10];var E=e[14];var M=e[3];var P=e[7];var A=e[11];var C=e[15];var I=_*C;var x=E*A;var R=T*C;var O=E*P;var D=T*A;var q=_*P;var N=b*C;var G=E*M;var L=b*A;var B=_*M;var H=b*P;var k=T*M;var z=I*v+O*p+D*m-(x*v+R*p+q*m);var F=x*h+N*p+B*m-(I*h+G*p+L*m);var U=R*h+G*v+H*m-(O*h+N*v+k*m);var V=q*h+L*v+k*p-(D*h+B*v+H*p);var j=x*o+R*l+q*d-(I*o+O*l+D*d);var W=I*i+G*l+L*d-(x*i+N*l+B*d);var X=O*i+N*o+k*d-(R*i+G*o+H*d);var Q=D*i+B*o+H*l-(q*i+L*o+k*l);I=l*m;x=d*p;R=o*m;O=d*v;D=o*p;q=l*v;N=i*m;G=d*h;L=i*p;B=l*h;H=i*v;k=o*h;var K=I*P+O*A+D*C-(x*P+R*A+q*C);var Y=x*M+N*A+B*C-(I*M+G*A+L*C);var Z=R*M+G*P+H*C-(O*M+N*P+k*C);var J=q*M+L*P+k*A-(D*M+B*P+H*A);var $=R*_+q*E+x*T-(D*E+I*T+O*_);var ee=L*E+I*b+G*_-(N*_+B*E+x*b);var te=N*T+k*E+O*b-(H*E+R*b+G*T);var re=H*_+D*b+B*T-(L*T+k*_+q*b);var ne=i*z+o*F+l*U+d*V;if(Math.abs(ne)<s.EPSILON20){throw new f("matrix is not invertible because its determinate is zero.")}ne=1/ne;r[0]=z*ne;r[1]=F*ne;r[2]=U*ne;r[3]=V*ne;r[4]=j*ne;r[5]=W*ne;r[6]=X*ne;r[7]=Q*ne;r[8]=K*ne;r[9]=Y*ne;r[10]=Z*ne;r[11]=J*ne;r[12]=$*ne;r[13]=ee*ne;r[14]=te*ne;r[15]=re*ne;return r};c.inverseTransformation=function(e,t){if(!n(e)){throw new a("matrix is required")}if(!n(t)){throw new a("result is required")}var r=e[0];var i=e[1];var o=e[2];var s=e[4];var u=e[5];var f=e[6];var c=e[8];var l=e[9];var d=e[10];var h=e[12];var v=e[13];var p=e[14];var m=-r*h-i*v-o*p;var w=-s*h-u*v-f*p;var y=-c*h-l*v-d*p;t[0]=r;t[1]=s;t[2]=c;t[3]=0;t[4]=i;t[5]=u;t[6]=l;t[7]=0;t[8]=o;t[9]=f;t[10]=d;t[11]=0;t[12]=m;t[13]=w;t[14]=y;t[15]=1;return t};c.IDENTITY=o(new c(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1));c.ZERO=o(new c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0));c.COLUMN0ROW0=0;c.COLUMN0ROW1=1;c.COLUMN0ROW2=2;c.COLUMN0ROW3=3;c.COLUMN1ROW0=4;c.COLUMN1ROW1=5;c.COLUMN1ROW2=6;c.COLUMN1ROW3=7;c.COLUMN2ROW0=8;c.COLUMN2ROW1=9;c.COLUMN2ROW2=10;c.COLUMN2ROW3=11;c.COLUMN3ROW0=12;c.COLUMN3ROW1=13;c.COLUMN3ROW2=14;c.COLUMN3ROW3=15;i(c.prototype,{length:{get:function(){return c.packedLength}}});c.prototype.clone=function(e){return c.clone(this,e)};c.prototype.equals=function(e){return c.equals(this,e)};c.equalsArray=function(e,t,r){return e[0]===t[r]&&e[1]===t[r+1]&&e[2]===t[r+2]&&e[3]===t[r+3]&&e[4]===t[r+4]&&e[5]===t[r+5]&&e[6]===t[r+6]&&e[7]===t[r+7]&&e[8]===t[r+8]&&e[9]===t[r+9]&&e[10]===t[r+10]&&e[11]===t[r+11]&&e[12]===t[r+12]&&e[13]===t[r+13]&&e[14]===t[r+14]&&e[15]===t[r+15]};c.prototype.equalsEpsilon=function(e,t){return c.equalsEpsilon(this,e,t)};c.prototype.toString=function(){return"("+this[0]+", "+this[4]+", "+this[8]+", "+this[12]+")\n"+"("+this[1]+", "+this[5]+", "+this[9]+", "+this[13]+")\n"+"("+this[2]+", "+this[6]+", "+this[10]+", "+this[14]+")\n"+"("+this[3]+", "+this[7]+", "+this[11]+", "+this[15]+")"};return c})})();(function(){var t=e.amdDefine;t("6d",[],function(){var e=function(e){if(e==undefined){e=(new Date).getTime()}this.N=624;this.M=397;this.MATRIX_A=2567483615;this.UPPER_MASK=2147483648;this.LOWER_MASK=2147483647;this.mt=new Array(this.N);this.mti=this.N+1;this.init_genrand(e)};e.prototype.init_genrand=function(e){this.mt[0]=e>>>0;for(this.mti=1;this.mti<this.N;this.mti++){var e=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30;this.mt[this.mti]=(((e&4294901760)>>>16)*1812433253<<16)+(e&65535)*1812433253+this.mti;this.mt[this.mti]>>>=0}};e.prototype.genrand_int32=function(){var e;var t=new Array(0,this.MATRIX_A);if(this.mti>=this.N){var r;if(this.mti==this.N+1)this.init_genrand(5489);for(r=0;r<this.N-this.M;r++){e=this.mt[r]&this.UPPER_MASK|this.mt[r+1]&this.LOWER_MASK;this.mt[r]=this.mt[r+this.M]^e>>>1^t[e&1]}for(;r<this.N-1;r++){e=this.mt[r]&this.UPPER_MASK|this.mt[r+1]&this.LOWER_MASK;this.mt[r]=this.mt[r+(this.M-this.N)]^e>>>1^t[e&1]}e=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK;this.mt[this.N-1]=this.mt[this.M-1]^e>>>1^t[e&1];this.mti=0}e=this.mt[this.mti++];e^=e>>>11;e^=e<<7&2636928640;e^=e<<15&4022730752;e^=e>>>18;return e>>>0};e.prototype.random=function(){return this.genrand_int32()*(1/4294967296)};return e})})();(function(){var t=e.amdDefine;t("23",["1f"],function(e){"use strict";function t(e,t){if(e!==undefined){return e}return t}t.EMPTY_OBJECT=e({});return t})})();(function(){var t=e.amdDefine;t("27",["6d","23","1a","1c"],function(e,t,r,n){"use strict";var i={};i.EPSILON1=.1;i.EPSILON2=.01;i.EPSILON3=.001;i.EPSILON4=1e-4;i.EPSILON5=1e-5;i.EPSILON6=1e-6;i.EPSILON7=1e-7;i.EPSILON8=1e-8;i.EPSILON9=1e-9;i.EPSILON10=1e-10;i.EPSILON11=1e-11;i.EPSILON12=1e-12;i.EPSILON13=1e-13;i.EPSILON14=1e-14;i.EPSILON15=1e-15;i.EPSILON16=1e-16;i.EPSILON17=1e-17;i.EPSILON18=1e-18;i.EPSILON19=1e-19;i.EPSILON20=1e-20;i.GRAVITATIONALPARAMETER=3986004418e5;i.SOLAR_RADIUS=6955e5;i.LUNAR_RADIUS=1737400;i.SIXTY_FOUR_KILOBYTES=64*1024;i.sign=function(e){if(e>0){return 1}if(e<0){return-1}return 0};i.signNotZero=function(e){return e<0?-1:1};i.toSNorm=function(e){return Math.round((i.clamp(e,-1,1)*.5+.5)*255)};i.fromSNorm=function(e){return i.clamp(e,0,255)/255*2-1};i.sinh=function(e){var t=Math.pow(Math.E,e);var r=Math.pow(Math.E,-1*e);return(t-r)*.5};i.cosh=function(e){var t=Math.pow(Math.E,e);var r=Math.pow(Math.E,-1*e);return(t+r)*.5};i.lerp=function(e,t,r){return(1-r)*e+r*t};i.PI=Math.PI;i.ONE_OVER_PI=1/Math.PI;i.PI_OVER_TWO=Math.PI*.5;i.PI_OVER_THREE=Math.PI/3;i.PI_OVER_FOUR=Math.PI/4;i.PI_OVER_SIX=Math.PI/6;i.THREE_PI_OVER_TWO=3*Math.PI*.5;i.TWO_PI=2*Math.PI;i.ONE_OVER_TWO_PI=1/(2*Math.PI);i.RADIANS_PER_DEGREE=Math.PI/180;i.DEGREES_PER_RADIAN=180/Math.PI;i.RADIANS_PER_ARCSECOND=i.RADIANS_PER_DEGREE/3600;i.toRadians=function(e){if(!r(e)){throw new n("degrees is required.")}return e*i.RADIANS_PER_DEGREE};i.toDegrees=function(e){if(!r(e)){throw new n("radians is required.")}return e*i.DEGREES_PER_RADIAN};i.convertLongitudeRange=function(e){if(!r(e)){throw new n("angle is required.")}var t=i.TWO_PI;var a=e-Math.floor(e/t)*t;if(a<-Math.PI){return a+t}if(a>=Math.PI){return a-t}return a};i.negativePiToPi=function(e){if(!r(e)){throw new n("x is required.")}return i.zeroToTwoPi(e+i.PI)-i.PI};i.zeroToTwoPi=function(e){if(!r(e)){throw new n("x is required.")}var t=i.mod(e,i.TWO_PI);if(Math.abs(t)<i.EPSILON14&&Math.abs(e)>i.EPSILON14){return i.TWO_PI}return t};i.mod=function(e,t){if(!r(e)){throw new n("m is required.")}if(!r(t)){throw new n("n is required.")}return(e%t+t)%t};i.equalsEpsilon=function(e,i,a,o){if(!r(e)){throw new n("left is required.")}if(!r(i)){throw new n("right is required.")}if(!r(a)){throw new n("relativeEpsilon is required.")}o=t(o,a);var s=Math.abs(e-i);return s<=o||s<=a*Math.max(Math.abs(e),Math.abs(i))};var a=[1];i.factorial=function(e){if(typeof e!=="number"||e<0){throw new n("A number greater than or equal to 0 is required.")}var t=a.length;if(e>=t){var r=a[t-1];for(var i=t;i<=e;i++){a.push(r*i)}}return a[e]};i.incrementWrap=function(e,i,a){a=t(a,0);if(!r(e)){throw new n("n is required.")}if(i<=a){throw new n("maximumValue must be greater than minimumValue.")}++e;if(e>i){e=a}return e};i.isPowerOfTwo=function(e){if(typeof e!=="number"||e<0){throw new n("A number greater than or equal to 0 is required.")}return e!==0&&(e&e-1)===0};i.nextPowerOfTwo=function(e){if(typeof e!=="number"||e<0){throw new n("A number greater than or equal to 0 is required.")}--e;e|=e>>1;e|=e>>2;e|=e>>4;e|=e>>8;e|=e>>16;++e;return e};i.clamp=function(e,t,i){if(!r(e)){throw new n("value is required")}if(!r(t)){throw new n("min is required.")}if(!r(i)){throw new n("max is required.")}return e<t?t:e>i?i:e};var o=new e;i.setRandomNumberSeed=function(t){if(!r(t)){throw new n("seed is required.")}o=new e(t)};i.nextRandomNumber=function(){return o.random()};i.acosClamped=function(e){if(!r(e)){throw new n("value is required.")}return Math.acos(i.clamp(e,-1,1))};i.asinClamped=function(e){if(!r(e)){throw new n("value is required.")}return Math.asin(i.clamp(e,-1,1))};i.chordLength=function(e,t){if(!r(e)){throw new n("angle is required.")}if(!r(t)){throw new n("radius is required.")}return 2*t*Math.sin(e*.5)};i.logBase=function(e,t){if(!r(e)){throw new n("number is required.")}if(!r(t)){throw new n("base is required.")}return Math.log(e)/Math.log(t)};i.fog=function(e,t){var r=e*t;return 1-Math.exp(-(r*r))};return i})})();(function(){var t=e.amdDefine;t("2c",["23","1a","1c","1f","27"],function(e,t,r,n,i){"use strict";function a(t,r,n){this.x=e(t,0);this.y=e(r,0);this.z=e(n,0)}a.fromSpherical=function(n,i){if(!t(n)){throw new r("spherical is required")}if(!t(i)){i=new a}var o=n.clock;var s=n.cone;var u=e(n.magnitude,1);var f=u*Math.sin(s);i.x=f*Math.cos(o);i.y=f*Math.sin(o);i.z=u*Math.cos(s);return i};a.fromElements=function(e,r,n,i){if(!t(i)){return new a(e,r,n)}i.x=e;i.y=r;i.z=n;return i};a.clone=function(e,r){if(!t(e)){return undefined}if(!t(r)){return new a(e.x,e.y,e.z)}r.x=e.x;r.y=e.y;r.z=e.z;return r};a.fromCartesian4=a.clone;a.packedLength=3;a.pack=function(n,i,a){if(!t(n)){throw new r("value is required")}if(!t(i)){throw new r("array is required")}a=e(a,0);i[a++]=n.x;i[a++]=n.y;i[a]=n.z};a.unpack=function(n,i,o){if(!t(n)){throw new r("array is required")}i=e(i,0);if(!t(o)){o=new a}o.x=n[i++];o.y=n[i++];o.z=n[i];return o};a.packArray=function(e,n){if(!t(e)){throw new r("array is required")}var i=e.length;if(!t(n)){n=new Array(i*3)}else{n.length=i*3}for(var o=0;o<i;++o){a.pack(e[o],n,o*3)}return n};a.unpackArray=function(e,n){if(!t(e)){throw new r("array is required")}var i=e.length;if(!t(n)){n=new Array(i/3)}else{n.length=i/3}for(var o=0;o<i;o+=3){var s=o/3;n[s]=a.unpack(e,o,n[s])}return n};a.fromArray=a.unpack;a.maximumComponent=function(e){if(!t(e)){throw new r("cartesian is required")}return Math.max(e.x,e.y,e.z)};a.minimumComponent=function(e){if(!t(e)){throw new r("cartesian is required")}return Math.min(e.x,e.y,e.z)};a.minimumByComponent=function(e,n,i){if(!t(e)){throw new r("first is required.")}if(!t(n)){throw new r("second is required.")}if(!t(i)){throw new r("result is required.")}i.x=Math.min(e.x,n.x);i.y=Math.min(e.y,n.y);i.z=Math.min(e.z,n.z);return i};a.maximumByComponent=function(e,n,i){if(!t(e)){throw new r("first is required.")}if(!t(n)){throw new r("second is required.")}if(!t(i)){throw new r("result is required.")}i.x=Math.max(e.x,n.x);i.y=Math.max(e.y,n.y);i.z=Math.max(e.z,n.z);return i};a.magnitudeSquared=function(e){if(!t(e)){throw new r("cartesian is required")}return e.x*e.x+e.y*e.y+e.z*e.z};a.magnitude=function(e){return Math.sqrt(a.magnitudeSquared(e))};var o=new a;a.distance=function(e,n){if(!t(e)||!t(n)){throw new r("left and right are required.")}a.subtract(e,n,o);return a.magnitude(o)};a.distanceSquared=function(e,n){if(!t(e)||!t(n)){throw new r("left and right are required.")}a.subtract(e,n,o);return a.magnitudeSquared(o)};a.normalize=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}var i=a.magnitude(e);n.x=e.x/i;n.y=e.y/i;n.z=e.z/i;return n};a.dot=function(e,n){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}return e.x*n.x+e.y*n.y+e.z*n.z};a.multiplyComponents=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}i.x=e.x*n.x;i.y=e.y*n.y;i.z=e.z*n.z;return i};a.add=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}i.x=e.x+n.x;i.y=e.y+n.y;i.z=e.z+n.z;return i};a.subtract=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}i.x=e.x-n.x;i.y=e.y-n.y;i.z=e.z-n.z;return i};a.multiplyByScalar=function(e,n,i){if(!t(e)){throw new r("cartesian is required")}if(typeof n!=="number"){throw new r("scalar is required and must be a number.")}if(!t(i)){throw new r("result is required")}i.x=e.x*n;i.y=e.y*n;i.z=e.z*n;return i};a.divideByScalar=function(e,n,i){if(!t(e)){throw new r("cartesian is required")}if(typeof n!=="number"){throw new r("scalar is required and must be a number.")}if(!t(i)){throw new r("result is required")}i.x=e.x/n;i.y=e.y/n;i.z=e.z/n;return i};a.negate=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}n.x=-e.x;n.y=-e.y;n.z=-e.z;return n};a.abs=function(e,n){if(!t(e)){throw new r("cartesian is required")}if(!t(n)){throw new r("result is required")}n.x=Math.abs(e.x);n.y=Math.abs(e.y);n.z=Math.abs(e.z);return n};var s=new a;a.lerp=function(e,n,i,o){if(!t(e)){throw new r("start is required.")}if(!t(n)){throw new r("end is required.")}if(typeof i!=="number"){throw new r("t is required and must be a number.")}if(!t(o)){throw new r("result is required.")}a.multiplyByScalar(n,i,s);o=a.multiplyByScalar(e,1-i,o);return a.add(s,o,o)};var u=new a;var f=new a;a.angleBetween=function(e,n){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}a.normalize(e,u);a.normalize(n,f);var i=a.dot(u,f);var o=a.magnitude(a.cross(u,f,u));return Math.atan2(o,i)};var c=new a;a.mostOrthogonalAxis=function(e,n){if(!t(e)){throw new r("cartesian is required.")}if(!t(n)){throw new r("result is required.")}var i=a.normalize(e,c);a.abs(i,i);if(i.x<=i.y){if(i.x<=i.z){n=a.clone(a.UNIT_X,n)}else{n=a.clone(a.UNIT_Z,n)}}else{if(i.y<=i.z){n=a.clone(a.UNIT_Y,n)}else{n=a.clone(a.UNIT_Z,n)}}return n};a.equals=function(e,r){return e===r||t(e)&&t(r)&&e.x===r.x&&e.y===r.y&&e.z===r.z};a.equalsArray=function(e,t,r){return e.x===t[r]&&e.y===t[r+1]&&e.z===t[r+2]};a.equalsEpsilon=function(e,r,n,a){return e===r||t(e)&&t(r)&&i.equalsEpsilon(e.x,r.x,n,a)&&i.equalsEpsilon(e.y,r.y,n,a)&&i.equalsEpsilon(e.z,r.z,n,a)};a.cross=function(e,n,i){if(!t(e)){throw new r("left is required")}if(!t(n)){throw new r("right is required")}if(!t(i)){throw new r("result is required")}var a=e.x;var o=e.y;var s=e.z;var u=n.x;var f=n.y;var c=n.z;var l=o*c-s*f;var d=s*u-a*c;var h=a*f-o*u;i.x=l;i.y=d;i.z=h;return i};a.fromDegrees=function(e,n,o,s,u){if(!t(e)){throw new r("longitude is required")}if(!t(n)){throw new r("latitude is required")}var f=i.toRadians(e);var c=i.toRadians(n);return a.fromRadians(f,c,o,s,u)};var l=new a;var d=new a;var h=new a(6378137*6378137,6378137*6378137,6356752.314245179*6356752.314245179);a.fromRadians=function(n,i,o,s,u){if(!t(n)){throw new r("longitude is required")}if(!t(i)){throw new r("latitude is required")}o=e(o,0);var f=t(s)?s.radiiSquared:h;var c=Math.cos(i);l.x=c*Math.cos(n);l.y=c*Math.sin(n);l.z=Math.sin(i);l=a.normalize(l,l);a.multiplyComponents(f,l,d);var v=Math.sqrt(a.dot(l,d));d=a.divideByScalar(d,v,d);l=a.multiplyByScalar(l,o,l);if(!t(u)){u=new a}return a.add(d,l,u)};a.fromDegreesArray=function(e,n,o){if(!t(e)){throw new r("positions is required.")}var s=new Array(e.length);for(var u=0;u<e.length;u++){s[u]=i.toRadians(e[u])}return a.fromRadiansArray(s,n,o)};a.fromRadiansArray=function(e,n,i){if(!t(e)){throw new r("positions is required.")}if(e.length<2){throw new r("positions length cannot be less than 2.")}if(e.length%2!==0){throw new r("positions length must be a multiple of 2.")}var o=e.length;if(!t(i)){i=new Array(o/2)}else{i.length=o/2}for(var s=0;s<o;s+=2){var u=e[s];var f=e[s+1];i[s/2]=a.fromRadians(u,f,0,n,i[s/2])}return i};a.fromDegreesArrayHeights=function(e,n,o){if(!t(e)){throw new r("positions is required.")}if(e.length<3){throw new r("positions length cannot be less than 3.")}if(e.length%3!==0){throw new r("positions length must be a multiple of 3.")}var s=new Array(e.length);for(var u=0;u<e.length;u+=3){s[u]=i.toRadians(e[u]);s[u+1]=i.toRadians(e[u+1]);s[u+2]=e[u+2]}return a.fromRadiansArrayHeights(s,n,o)};a.fromRadiansArrayHeights=function(e,n,i){if(!t(e)){throw new r("positions is required.")}if(e.length<3){throw new r("positions length cannot be less than 3.")}if(e.length%3!==0){throw new r("positions length must be a multiple of 3.")}var o=e.length;if(!t(i)){i=new Array(o/3)}else{i.length=o/3}for(var s=0;s<o;s+=3){var u=e[s];var f=e[s+1];var c=e[s+2];i[s/3]=a.fromRadians(u,f,c,n,i[s/3])}return i};a.ZERO=n(new a(0,0,0));a.UNIT_X=n(new a(1,0,0));a.UNIT_Y=n(new a(0,1,0));a.UNIT_Z=n(new a(0,0,1));a.prototype.clone=function(e){return a.clone(this,e)};a.prototype.equals=function(e){return a.equals(this,e)};a.prototype.equalsEpsilon=function(e,t,r){return a.equalsEpsilon(this,e,t,r)};a.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+")"};return a})})();(function(){var t=e.amdDefine;t("1c",["1a"],function(e){"use strict";function t(e){this.name="DeveloperError";this.message=e;var t;try{throw new Error}catch(e){t=e.stack}this.stack=t}if(e(Object.create)){t.prototype=Object.create(Error.prototype);t.prototype.constructor=t}t.prototype.toString=function(){var t=this.name+": "+this.message;if(e(this.stack)){t+="\n"+this.stack.toString()}return t};t.throwInstantiationError=function(){throw new t("This function defines an interface and should not be called directly.")};return t})})();(function(){var t=e.amdDefine;t("1a",[],function(){"use strict";function e(e){return e!==undefined&&e!==null}return e})})();(function(){var t=e.amdDefine;t("1f",["1a"],function(e){"use strict";var t=Object.freeze;if(!e(t)){t=function(e){return e}}return t})})();(function(){var t=e.amdDefine;t("44",["2c","1a","1c","1f"],function(e,t,r,n){"use strict";function i(n,i){if(!t(n)){throw new r("normal is required.")}if(!t(i)){throw new r("distance is required.")}this.normal=e.clone(n);this.distance=i}i.fromPointNormal=function(n,a,o){if(!t(n)){throw new r("point is required.")}if(!t(a)){throw new r("normal is required.")}var s=-e.dot(a,n);if(!t(o)){return new i(a,s)}e.clone(a,o.normal);o.distance=s;return o};var a=new e;i.fromCartesian4=function(n,o){if(!t(n)){throw new r("coefficients is required.")}var s=e.fromCartesian4(n,a);var u=n.w;if(!t(o)){return new i(s,u)}else{e.clone(s,o.normal);o.distance=u;return o}};i.getPointDistance=function(n,i){if(!t(n)){throw new r("plane is required.")}if(!t(i)){throw new r("point is required.")}return e.dot(n.normal,i)+n.distance};i.ORIGIN_XY_PLANE=n(new i(e.UNIT_Z,0));i.ORIGIN_YZ_PLANE=n(new i(e.UNIT_X,0));i.ORIGIN_ZX_PLANE=n(new i(e.UNIT_Y,0));return i})})();(function(){var t=e.amdDefine;t("6e",["2c","3b","23","1a","1c","3c","66","6b","6c","27","33","44"],function(e,t,r,n,i,a,o,s,u,f,c,l){"use strict";var d={};d.numberOfPoints=function(t,r,n){var i=e.distance(t,r);return Math.ceil(i/n)};var h=new t;d.extractHeights=function(e,t){var r=e.length;var n=new Array(r);for(var i=0;i<r;i++){var a=e[i];n[i]=t.cartesianToCartographic(a,h).height}return n};var v=new c;var p=new e;var m=new e;var w=new l(e.ZERO,0);var y=new e;var g=new l(e.ZERO,0);var S=new e;var b=new e;var T=[];function _(e,t,r){var n=T;n.length=e;var i;if(t===r){for(i=0;i<e;i++){n[i]=t}return n}var a=r-t;var o=a/e;for(i=0;i<e;i++){var s=t+i*o;n[i]=s}return n}var E=new t;var M=new t;var P=new e;var A=new e;var C=new e;var I=new o;function x(t,r,n,i,a,o,s,u){var f=i.scaleToGeodeticSurface(t,A);var c=i.scaleToGeodeticSurface(r,C);var l=d.numberOfPoints(t,r,n);var h=i.cartesianToCartographic(f,E);var v=i.cartesianToCartographic(c,M);var p=_(l,a,o);I.setEndPoints(h,v);var m=I.surfaceDistance/l;var w=u;h.height=a;var y=i.cartographicToCartesian(h,P);e.pack(y,s,w);w+=3;for(var g=1;g<l;g++){var S=I.interpolateUsingSurfaceDistance(g*m,M);S.height=p[g];y=i.cartographicToCartesian(S,P);e.pack(y,s,w);w+=3}return w}d.wrapLongitude=function(t,i){var a=[];var o=[];if(n(t)&&t.length>0){i=r(i,c.IDENTITY);var u=c.inverseTransformation(i,v);var f=c.multiplyByPoint(u,e.ZERO,p);var d=c.multiplyByPointAsVector(u,e.UNIT_Y,m);var h=l.fromPointNormal(f,d,w);var T=c.multiplyByPointAsVector(u,e.UNIT_X,y);var _=l.fromPointNormal(f,T,g);var E=1;a.push(e.clone(t[0]));var M=a[0];var P=t.length;for(var A=1;A<P;++A){var C=t[A];if(l.getPointDistance(_,M)<0||l.getPointDistance(_,C)<0){var I=s.lineSegmentPlane(M,C,h,S);if(n(I)){var x=e.multiplyByScalar(d,5e-9,b);if(l.getPointDistance(h,M)<0){e.negate(x,x)}a.push(e.add(I,x,new e));o.push(E+1);e.negate(x,x);a.push(e.add(I,x,new e));E=1}}a.push(e.clone(t[A]));E++;M=C}o.push(E)}return{positions:a,lengths:o}};d.generateArc=function(t){if(!n(t)){t={}}var o=t.positions;if(!n(o)){throw new i("options.positions is required.")}var s=o.length;var c=r(t.ellipsoid,a.WGS84);var l=r(t.height,0);if(s<1){return[]}else if(s===1){var h=c.scaleToGeodeticSurface(o[0],A);if(l!==0){var v=c.geodeticSurfaceNormal(h,P);e.multiplyByScalar(v,l,v);e.add(h,v,h)}return[h.x,h.y,h.z]}var p=t.minDistance;if(!n(p)){var m=r(t.granularity,f.RADIANS_PER_DEGREE);p=f.chordLength(m,c.maximumRadius)}var w=0;var y;for(y=0;y<s-1;y++){w+=d.numberOfPoints(o[y],o[y+1],p)}var g=(w+1)*3;var S=new Array(g);var b=0;var _=u(l);for(y=0;y<s-1;y++){var M=o[y];var C=o[y+1];var I=_?l[y]:l;var R=_?l[y+1]:l;b=x(M,C,p,c,I,R,S,b)}T.length=0;var O=o[s-1];var D=c.cartesianToCartographic(O,E);D.height=_?l[s-1]:l;var q=c.cartographicToCartesian(D,P);e.pack(q,S,g-3);return S};d.generateCartesianArc=function(t){var r=d.generateArc(t);var n=r.length/3;var i=new Array(n);for(var a=0;a<n;a++){i[a]=e.unpack(r,a*3)}return i};return d})})();e.register("6f",["a"],function(e,t){"use strict";var r=t&&t.id;var n;var i;function a(e,t){var r=e._times;var i=~n.binarySearch(r,t,n.JulianDate.compare);if(i>0){r.splice(0,i);e._values.splice(0,i*e._innerType.packedLength);e._updateTableLength=true;e._definitionChanged.raiseEvent(e)}}function o(e,t){if(t===undefined)return;var r=e._times.length-t;if(r>0){e._times.splice(0,r);e._values.splice(0,r*e._innerType.packedLength);e._updateTableLength=true}}return{setters:[function(e){n=e}],execute:function(){i=function(e,t){return function(){var r=e.apply(this,arguments);t.call(this,r);return r}};n.SampledProperty.prototype.removeSamplesBeforeDate=function(e){a(this,e)};n.SampledPositionProperty.prototype.removeSamplesBeforeDate=function(e){a(this._property,e)};n.SampledProperty.prototype.addSample=i(n.SampledProperty.prototype.addSample,function(){o(this,this.maxNumSamples)});n.SampledProperty.prototype.addSamples=i(n.SampledProperty.prototype.addSamples,function(){o(this,this.maxNumSamples)});n.SampledProperty.prototype.addSamplesPackedArray=i(n.SampledProperty.prototype.addSamplesPackedArray,function(){o(this,this.maxNumSamples)});n.SampledPositionProperty.prototype.addSample=i(n.SampledPositionProperty.prototype.addSample,function(){o(this._property,this.maxNumSamples)});n.SampledPositionProperty.prototype.addSamples=i(n.SampledPositionProperty.prototype.addSamples,function(){o(this._property,this.maxNumSamples)});n.SampledPositionProperty.prototype.addSamplesPackedArray=i(n.SampledPositionProperty.prototype.addSamplesPackedArray,function(){o(this._property,this.maxNumSamples)})}}});e.register("a",["4c","19","45","2c","43","21","22","25","2b","2f","26","23","1a","1c","3c","28","29","1d","4a","3a","3d","24","27","32","33","3e","3f","40","2e","36","34","46","2d","47","48","49","35","64","6e","6f"],function(e,t){"use strict";var r=t&&t.id;return{setters:[function(t){e({binarySearch:t["default"]})},function(t){e({CallbackProperty:t["default"]})},function(t){e({Cartesian2:t["default"]})},function(t){e({Cartesian3:t["default"]})},function(t){e({Cartesian4:t["default"]})},function(t){e({Clock:t["default"]})},function(t){e({ClockStep:t["default"]})},function(t){e({CompositeEntityCollection:t["default"]})},function(t){e({ConstantPositionProperty:t["default"]})},function(t){e({ConstantProperty:t["default"]})},function(t){e({createGuid:t["default"]})},function(t){e({defaultValue:t["default"]})},function(t){e({defined:t["default"]})},function(t){e({DeveloperError:t["default"]})},function(t){e({Ellipsoid:t["default"]})},function(t){e({Entity:t["default"]})},function(t){e({EntityCollection:t["default"]})},function(t){e({Event:t["default"]})},function(t){e({ExtrapolationType:t["default"]})},function(t){e({GeographicProjection:t["default"]})},function(t){e({HermitePolynomialApproximation:t["default"]})},function(t){e({JulianDate:t["default"]})},function(t){e({CesiumMath:t["default"]})},function(t){e({Matrix3:t["default"]})},function(t){e({Matrix4:t["default"]})},function(t){e({OrientationProperty:t["default"]})},function(t){e({PerspectiveFrustum:t["default"]})},function(t){e({PerspectiveOffCenterFrustum:t["default"]})},function(t){e({PositionProperty:t["default"]})},function(t){e({Property:t["default"]})},function(t){e({Quaternion:t["default"]})},function(t){e({ReferenceEntity:t["default"]})},function(t){e({ReferenceFrame:t["default"]})},function(t){e({ReferenceProperty:t["default"]})},function(t){e({SampledPositionProperty:t["default"]})},function(t){e({SampledProperty:t["default"]})},function(t){e({Transforms:t["default"]})},function(t){e({Simon1994PlanetaryPositions:t["default"]})},function(t){e({PolylinePipeline:t["default"]})},function(e){}],execute:function(){}}});e.register("12",["1d","a"],function(e,t){"use strict";var r=t&&t.id;var n,i;var a,o,s,u,f,c,l,d,h,v,p;function m(e){var t=[];var r=e;while(i.defined(r)){t.unshift(r);var n=r.position;r=n&&n.referenceFrame}return t}e("getAncestorReferenceFrames",m);function w(e){return m(e)[0]}e("getRootReferenceFrame",w);function y(e,t,r,n){return e.position&&e.position.getValueInReferenceFrame(t,r,n)}e("getEntityPositionInReferenceFrame",y);function g(e,t,r,n){var a=e.position&&e.position.referenceFrame;if(!i.defined(a))return undefined;var o=e.orientation&&e.orientation.getValue(t,n);if(!i.defined(o))return undefined;return i.OrientationProperty.convertToReferenceFrame(t,o,a,r,n)}e("getEntityOrientationInReferenceFrame",g);function S(e,t,r){var n=r?r:w(e);var a=y(e,t,n,{});if(!a)return undefined;var o=g(e,t,n,{});if(!o)return undefined;return{p:i.Cartesian3.ZERO.equalsEpsilon(a,i.CesiumMath.EPSILON16)?0:a,o:i.Quaternion.IDENTITY.equalsEpsilon(o,i.CesiumMath.EPSILON16)?0:o,r:typeof n==="number"?n:n.id}}e("getSerializedEntityPose",S);function b(e){if(!f)throw new Error("resolveURL requires DOM api");if(e===undefined)throw new Error("Expected inURL");f.href="";f.href=e;return f.href}e("resolveURL",b);function T(e){if(!f)throw new Error("parseURL requires DOM api");if(e===undefined)throw new Error("Expected inURL");f.href="";f.href=e;return{href:f.href,protocol:f.protocol,hostname:f.hostname,port:f.port,pathname:f.pathname,search:f.search,hash:f.hash,host:f.host}}e("parseURL",T);function _(e,t){var r=e[i.Matrix4.COLUMN0ROW0];var n=e[i.Matrix4.COLUMN1ROW1];var a=e[i.Matrix4.COLUMN2ROW0];var o=e[i.Matrix4.COLUMN2ROW1];var s=e[i.Matrix4.COLUMN2ROW2];var u=e[i.Matrix4.COLUMN3ROW2];var f=t.near=u/(s-1);t.far=u/(s+1);t.bottom=f*(o-1)/n;t.top=f*(o+1)/n;t.left=f*(a-1)/r;t.right=f*(a+1)/r;return t}e("decomposePerspectiveOffCenterProjectionMatrix",_);function E(e,t){var r=_(e,h);var n=(r.left+r.right)/2;var i=(r.top+r.bottom)/2;var a=r.near;var o=r.far;var s=r.right-n;var u=r.top-i;var f=s/u;var c=2*Math.atan(u/a);var l;if(f<1){l=c}else{l=Math.atan(Math.tan(c*.5)*f)*2}t.near=a;t.far=o;t.fov=l;t.aspectRatio=f;t.xOffset=n;t.yOffset=i;return t}e("decomposePerspectiveProjectionMatrix",E);function M(e,t,r){if(!e.position||!(e.position instanceof i.ConstantPositionProperty)||!e.orientation||!(e.orientation instanceof i.ConstantProperty)){return false}if(!y(e,t,r,v)){return false}if(!g(e,t,r,p)){return false}e.position.setValue(v,r);e.orientation.setValue(p);return true}e("convertEntityReferenceFrame",M);return{setters:[function(e){n=e},function(e){i=e}],execute:function(){a=function(){function e(){this._event=new n.default}Object.defineProperty(e.prototype,"numberOfListeners",{get:function(){return this._event.numberOfListeners},enumerable:true,configurable:true});e.prototype.addEventListener=function(e){return this._event.addEventListener(e)};e.prototype.removeEventListener=function(e){return this._event.removeEventListener(e)};e.prototype.raiseEvent=function(e){this._event.raiseEvent(e)};return e}();e("Event",a);o=function(){function e(){var e=this;this._queue=[];this._paused=true;this.errorEvent=new a;this.errorEvent.addEventListener(function(t){if(e.errorEvent.numberOfListeners===1)console.error(t)})}e.prototype.push=function(e,t){var r=this;var n=new Promise(function(t,n){r._queue.push({command:e,reject:n,execute:function(){var r=Promise.resolve().then(e);t(r);return r}})});if(t)this.execute();return n};e.prototype.execute=function(){var e=this;this._paused=false;Promise.resolve().then(function(){if(e._queue.length>0&&!e._currentCommandPending){e._executeNextCommand()}})};e.prototype.pause=function(){this._paused=true};e.prototype.clear=function(){this._queue.forEach(function(e){e.reject("Unable to execute.")});this._queue=[]};e.prototype._executeNextCommand=function(){var e=this;this._currentCommand=undefined;this._currentCommandPending=undefined;if(this._paused)return;var t=this._queue.shift();if(!t)return;this._currentCommand=t.command;this._currentCommandPending=t.execute().then(this._executeNextCommand.bind(this)).catch(function(t){e.errorEvent.raiseEvent(t);e._executeNextCommand()})};return e}();e("CommandQueue",o);e("getEntityPosition",s=y);e("getEntityOrientation",u=g);f=typeof document!=="undefined"?document.createElement("a"):undefined;c=function(){function e(){var e=this;var t=true;var r;var n;var i;r=new Promise(function(r){e.port1={set onmessage(e){i=e;r()},get onmessage(){return i},postMessage:function(r){if(t){n.then(function(){if(e.port2.onmessage)e.port2.onmessage({data:r})})}},close:function(){t=false}}});var a;n=new Promise(function(n){e.port2={set onmessage(e){a=e;n()},get onmessage(){return a},postMessage:function(n){if(t){r.then(function(){if(e.port1.onmessage)e.port1.onmessage({data:n})})}},close:function(){t=false}}})}return e}();e("MessageChannelLike",c);l=function(){function e(){var e=this;var t=[];var r=function(e){t.push(e)};e.port1={get onmessage(){return r},set onmessage(e){r=e;t.forEach(function(t){return e(t)});t=[]},postMessage:function(t){if(e.port2.onmessage)e.port2.onmessage({data:t})},close:function(){e.port1.onmessage=undefined;e.port2.onmessage=undefined}};var n=[];var i=function(e){n.push(e)};e.port2={get onmessage(){return i},set onmessage(e){i=e;n.forEach(function(t){return e(t)});n=[]},postMessage:function(t){if(e.port1.onmessage)e.port1.onmessage({data:t})},close:function(){e.port1.onmessage=undefined;e.port2.onmessage=undefined}}}return e}();e("SynchronousMessageChannel",l);d=function(){function e(){}e.prototype.create=function(){if(typeof MessageChannel!=="undefined")return new MessageChannel;else return new c};e.prototype.createSynchronous=function(){return new l};return e}();e("MessageChannelFactory",d);h=new i.PerspectiveOffCenterFrustum;v=new i.Cartesian3;p=new i.Quaternion}}});e.register("1",["2","c","a","7","10","f","b","9","14","11","d","17","13","e","15","18","12"],function(e,t){"use strict";var r=t&&t.id;var n,i,a,o,s,u,f,c,l,d,h,v,p,m,w;var y;function g(e){var t=e===void 0?{}:e,r=t.configuration,i=t.container,a=i===void 0?new n.Container:i;var o;if(typeof HTMLElement==="undefined"){o=s.Role.REALITY_MANAGER}else if(navigator.userAgent.indexOf("Argon")>0||window.top!==window){o=s.Role.APPLICATION}else{o=s.Role.REALITY_MANAGER}var u=Object.assign(r||{},{role:o});a.registerInstance("containerElement",null);return new y(u,a)}e("init",g);function S(e){var t=e===void 0?{}:e,r=t.configuration,i=t.container,a=i===void 0?new n.Container:i;var o=Object.assign(r||{},{role:s.Role.REALITY_VIEW,"reality.supportsControlPort":true});a.registerInstance("containerElement",null);return new y(o,a)}e("initReality",S);function b(e){var t=e.containerElement,r=e.configuration,i=e.container,a=i===void 0?new n.Container:i;var o=Object.assign(r||{},{role:s.Role.REALITY_MANAGER});a.registerInstance("containerElement",t);return new y(o,a)}e("initLocal",b);var T={ArgonSystem:true,init:true,initReality:true,initLocal:true,DI:true,Cesium:true,URI:true,EmptyRealityLoader:true,LiveVideoRealityLoader:true,HostedRealityLoader:true
	};function _(t){var r={};for(var n in t){if(n!=="default"&&!T.hasOwnProperty(n))r[n]=t[n]}e(r)}return{setters:[function(e){},function(e){n=e},function(e){i=e},function(e){a=e},function(e){o=e;_(e)},function(e){s=e;_(e)},function(e){u=e;_(e)},function(e){f=e;_(e)},function(e){c=e;_(e)},function(e){l=e;_(e)},function(e){d=e;_(e)},function(e){h=e;_(e)},function(e){v=e;_(e)},function(e){p=e},function(e){m=e},function(e){w=e},function(e){_(e)}],execute:function(){e("DI",n);e("Cesium",i);e("URI",a);e("EmptyRealityLoader",p.EmptyRealityLoader);e("LiveVideoRealityLoader",m.LiveVideoRealityLoader);e("HostedRealityLoader",w.HostedRealityLoader);y=function(){function e(t,r){if(r===void 0){r=new n.Container}this.container=r;if(!e.instance)e.instance=this;r.registerInstance("config",t);r.registerInstance(e,this);if(!r.hasResolver("containerElement"))r.registerInstance("containerElement",null);if(t.role===s.Role.REALITY_MANAGER){r.registerSingleton(o.ConnectService,o.LoopbackConnectService)}else if(o.WKWebViewConnectService.isAvailable()){r.registerSingleton(o.ConnectService,o.WKWebViewConnectService)}else if(o.DOMConnectService.isAvailable()){r.registerSingleton(o.ConnectService,o.DOMConnectService)}else if(o.DebugConnectService.isAvailable()){r.registerSingleton(o.ConnectService,o.DebugConnectService)}if(t.role===s.Role.REALITY_MANAGER){this.reality.registerLoader(r.get(p.EmptyRealityLoader));this.reality.registerLoader(r.get(m.LiveVideoRealityLoader));if(typeof document!=="undefined"){this.reality.registerLoader(r.get(w.HostedRealityLoader));r.get(h.PinchZoomService)}this.reality.setDefault(s.RealityView.EMPTY)}for(var i=0,a=Object.keys(e.prototype);i<a.length;i++){var u=a[i];this[u]}this.session.connect()}Object.defineProperty(e.prototype,"context",{get:function(){return this.container.get(u.ContextService)},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"device",{get:function(){return this.container.get(f.DeviceService)},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"focus",{get:function(){return this.container.get(c.FocusService)},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"reality",{get:function(){return this.container.get(l.RealityService)},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"session",{get:function(){return this.container.get(o.SessionService)},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"timer",{get:function(){return this.container.get(d.TimerService)},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"view",{get:function(){return this.container.get(h.ViewService)},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"vuforia",{get:function(){return this.container.get(v.VuforiaService)},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"updateEvent",{get:function(){return this.context.updateEvent},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"renderEvent",{get:function(){return this.context.renderEvent},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"focusEvent",{get:function(){return this.focus.focusEvent},enumerable:true,configurable:true});Object.defineProperty(e.prototype,"blurEvent",{get:function(){return this.focus.blurEvent},enumerable:true,configurable:true});return e}();e("ArgonSystem",y)}}})})(function(e){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if(typeof module=="object"&&module.exports&&typeof require=="function")module.exports=e();else Argon=e()});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.THREE = global.THREE || {})));
	}(this, (function (exports) { 'use strict';

		// Polyfills

		if ( Number.EPSILON === undefined ) {

			Number.EPSILON = Math.pow( 2, - 52 );

		}

		//

		if ( Math.sign === undefined ) {

			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

			Math.sign = function ( x ) {

				return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

			};

		}

		if ( Function.prototype.name === undefined ) {

			// Missing in IE9-11.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

			Object.defineProperty( Function.prototype, 'name', {

				get: function () {

					return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

				}

			} );

		}

		if ( Object.assign === undefined ) {

			// Missing in IE.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

			( function () {

				Object.assign = function ( target ) {

					'use strict';

					if ( target === undefined || target === null ) {

						throw new TypeError( 'Cannot convert undefined or null to object' );

					}

					var output = Object( target );

					for ( var index = 1; index < arguments.length; index ++ ) {

						var source = arguments[ index ];

						if ( source !== undefined && source !== null ) {

							for ( var nextKey in source ) {

								if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

									output[ nextKey ] = source[ nextKey ];

								}

							}

						}

					}

					return output;

				};

			} )();

		}

		/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */

		function EventDispatcher() {}

		Object.assign( EventDispatcher.prototype, {

			addEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) this._listeners = {};

				var listeners = this._listeners;

				if ( listeners[ type ] === undefined ) {

					listeners[ type ] = [];

				}

				if ( listeners[ type ].indexOf( listener ) === - 1 ) {

					listeners[ type ].push( listener );

				}

			},

			hasEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) return false;

				var listeners = this._listeners;

				if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

					return true;

				}

				return false;

			},

			removeEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) return;

				var listeners = this._listeners;
				var listenerArray = listeners[ type ];

				if ( listenerArray !== undefined ) {

					var index = listenerArray.indexOf( listener );

					if ( index !== - 1 ) {

						listenerArray.splice( index, 1 );

					}

				}

			},

			dispatchEvent: function ( event ) {

				if ( this._listeners === undefined ) return;

				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];

				if ( listenerArray !== undefined ) {

					event.target = this;

					var array = [], i = 0;
					var length = listenerArray.length;

					for ( i = 0; i < length; i ++ ) {

						array[ i ] = listenerArray[ i ];

					}

					for ( i = 0; i < length; i ++ ) {

						array[ i ].call( this, event );

					}

				}

			}

		} );

		var REVISION = '82';
		var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
		var CullFaceNone = 0;
		var CullFaceBack = 1;
		var CullFaceFront = 2;
		var CullFaceFrontBack = 3;
		var FrontFaceDirectionCW = 0;
		var FrontFaceDirectionCCW = 1;
		var BasicShadowMap = 0;
		var PCFShadowMap = 1;
		var PCFSoftShadowMap = 2;
		var FrontSide = 0;
		var BackSide = 1;
		var DoubleSide = 2;
		var FlatShading = 1;
		var SmoothShading = 2;
		var NoColors = 0;
		var FaceColors = 1;
		var VertexColors = 2;
		var NoBlending = 0;
		var NormalBlending = 1;
		var AdditiveBlending = 2;
		var SubtractiveBlending = 3;
		var MultiplyBlending = 4;
		var CustomBlending = 5;
		var BlendingMode = {
			NoBlending: NoBlending,
			NormalBlending: NormalBlending,
			AdditiveBlending: AdditiveBlending,
			SubtractiveBlending: SubtractiveBlending,
			MultiplyBlending: MultiplyBlending,
			CustomBlending: CustomBlending
		};
		var AddEquation = 100;
		var SubtractEquation = 101;
		var ReverseSubtractEquation = 102;
		var MinEquation = 103;
		var MaxEquation = 104;
		var ZeroFactor = 200;
		var OneFactor = 201;
		var SrcColorFactor = 202;
		var OneMinusSrcColorFactor = 203;
		var SrcAlphaFactor = 204;
		var OneMinusSrcAlphaFactor = 205;
		var DstAlphaFactor = 206;
		var OneMinusDstAlphaFactor = 207;
		var DstColorFactor = 208;
		var OneMinusDstColorFactor = 209;
		var SrcAlphaSaturateFactor = 210;
		var NeverDepth = 0;
		var AlwaysDepth = 1;
		var LessDepth = 2;
		var LessEqualDepth = 3;
		var EqualDepth = 4;
		var GreaterEqualDepth = 5;
		var GreaterDepth = 6;
		var NotEqualDepth = 7;
		var MultiplyOperation = 0;
		var MixOperation = 1;
		var AddOperation = 2;
		var NoToneMapping = 0;
		var LinearToneMapping = 1;
		var ReinhardToneMapping = 2;
		var Uncharted2ToneMapping = 3;
		var CineonToneMapping = 4;
		var UVMapping = 300;
		var CubeReflectionMapping = 301;
		var CubeRefractionMapping = 302;
		var EquirectangularReflectionMapping = 303;
		var EquirectangularRefractionMapping = 304;
		var SphericalReflectionMapping = 305;
		var CubeUVReflectionMapping = 306;
		var CubeUVRefractionMapping = 307;
		var TextureMapping = {
			UVMapping: UVMapping,
			CubeReflectionMapping: CubeReflectionMapping,
			CubeRefractionMapping: CubeRefractionMapping,
			EquirectangularReflectionMapping: EquirectangularReflectionMapping,
			EquirectangularRefractionMapping: EquirectangularRefractionMapping,
			SphericalReflectionMapping: SphericalReflectionMapping,
			CubeUVReflectionMapping: CubeUVReflectionMapping,
			CubeUVRefractionMapping: CubeUVRefractionMapping
		};
		var RepeatWrapping = 1000;
		var ClampToEdgeWrapping = 1001;
		var MirroredRepeatWrapping = 1002;
		var TextureWrapping = {
			RepeatWrapping: RepeatWrapping,
			ClampToEdgeWrapping: ClampToEdgeWrapping,
			MirroredRepeatWrapping: MirroredRepeatWrapping
		};
		var NearestFilter = 1003;
		var NearestMipMapNearestFilter = 1004;
		var NearestMipMapLinearFilter = 1005;
		var LinearFilter = 1006;
		var LinearMipMapNearestFilter = 1007;
		var LinearMipMapLinearFilter = 1008;
		var TextureFilter = {
			NearestFilter: NearestFilter,
			NearestMipMapNearestFilter: NearestMipMapNearestFilter,
			NearestMipMapLinearFilter: NearestMipMapLinearFilter,
			LinearFilter: LinearFilter,
			LinearMipMapNearestFilter: LinearMipMapNearestFilter,
			LinearMipMapLinearFilter: LinearMipMapLinearFilter
		};
		var UnsignedByteType = 1009;
		var ByteType = 1010;
		var ShortType = 1011;
		var UnsignedShortType = 1012;
		var IntType = 1013;
		var UnsignedIntType = 1014;
		var FloatType = 1015;
		var HalfFloatType = 1016;
		var UnsignedShort4444Type = 1017;
		var UnsignedShort5551Type = 1018;
		var UnsignedShort565Type = 1019;
		var UnsignedInt248Type = 1020;
		var AlphaFormat = 1021;
		var RGBFormat = 1022;
		var RGBAFormat = 1023;
		var LuminanceFormat = 1024;
		var LuminanceAlphaFormat = 1025;
		var RGBEFormat = RGBAFormat;
		var DepthFormat = 1026;
		var DepthStencilFormat = 1027;
		var RGB_S3TC_DXT1_Format = 2001;
		var RGBA_S3TC_DXT1_Format = 2002;
		var RGBA_S3TC_DXT3_Format = 2003;
		var RGBA_S3TC_DXT5_Format = 2004;
		var RGB_PVRTC_4BPPV1_Format = 2100;
		var RGB_PVRTC_2BPPV1_Format = 2101;
		var RGBA_PVRTC_4BPPV1_Format = 2102;
		var RGBA_PVRTC_2BPPV1_Format = 2103;
		var RGB_ETC1_Format = 2151;
		var LoopOnce = 2200;
		var LoopRepeat = 2201;
		var LoopPingPong = 2202;
		var InterpolateDiscrete = 2300;
		var InterpolateLinear = 2301;
		var InterpolateSmooth = 2302;
		var ZeroCurvatureEnding = 2400;
		var ZeroSlopeEnding = 2401;
		var WrapAroundEnding = 2402;
		var TrianglesDrawMode = 0;
		var TriangleStripDrawMode = 1;
		var TriangleFanDrawMode = 2;
		var LinearEncoding = 3000;
		var sRGBEncoding = 3001;
		var GammaEncoding = 3007;
		var RGBEEncoding = 3002;
		var LogLuvEncoding = 3003;
		var RGBM7Encoding = 3004;
		var RGBM16Encoding = 3005;
		var RGBDEncoding = 3006;
		var BasicDepthPacking = 3200;
		var RGBADepthPacking = 3201;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _Math = {

			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,

			generateUUID: function () {

				// http://www.broofa.com/Tools/Math.uuid.htm

				var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
				var uuid = new Array( 36 );
				var rnd = 0, r;

				return function generateUUID() {

					for ( var i = 0; i < 36; i ++ ) {

						if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

							uuid[ i ] = '-';

						} else if ( i === 14 ) {

							uuid[ i ] = '4';

						} else {

							if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
							r = rnd & 0xf;
							rnd = rnd >> 4;
							uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

						}

					}

					return uuid.join( '' );

				};

			}(),

			clamp: function ( value, min, max ) {

				return Math.max( min, Math.min( max, value ) );

			},

			// compute euclidian modulo of m % n
			// https://en.wikipedia.org/wiki/Modulo_operation

			euclideanModulo: function ( n, m ) {

				return ( ( n % m ) + m ) % m;

			},

			// Linear mapping from range <a1, a2> to range <b1, b2>

			mapLinear: function ( x, a1, a2, b1, b2 ) {

				return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

			},

			// https://en.wikipedia.org/wiki/Linear_interpolation

			lerp: function ( x, y, t ) {

				return ( 1 - t ) * x + t * y;

			},

			// http://en.wikipedia.org/wiki/Smoothstep

			smoothstep: function ( x, min, max ) {

				if ( x <= min ) return 0;
				if ( x >= max ) return 1;

				x = ( x - min ) / ( max - min );

				return x * x * ( 3 - 2 * x );

			},

			smootherstep: function ( x, min, max ) {

				if ( x <= min ) return 0;
				if ( x >= max ) return 1;

				x = ( x - min ) / ( max - min );

				return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

			},

			random16: function () {

				console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
				return Math.random();

			},

			// Random integer from <low, high> interval

			randInt: function ( low, high ) {

				return low + Math.floor( Math.random() * ( high - low + 1 ) );

			},

			// Random float from <low, high> interval

			randFloat: function ( low, high ) {

				return low + Math.random() * ( high - low );

			},

			// Random float from <-range/2, range/2> interval

			randFloatSpread: function ( range ) {

				return range * ( 0.5 - Math.random() );

			},

			degToRad: function ( degrees ) {

				return degrees * _Math.DEG2RAD;

			},

			radToDeg: function ( radians ) {

				return radians * _Math.RAD2DEG;

			},

			isPowerOfTwo: function ( value ) {

				return ( value & ( value - 1 ) ) === 0 && value !== 0;

			},

			nearestPowerOfTwo: function ( value ) {

				return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

			},

			nextPowerOfTwo: function ( value ) {

				value --;
				value |= value >> 1;
				value |= value >> 2;
				value |= value >> 4;
				value |= value >> 8;
				value |= value >> 16;
				value ++;

				return value;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		function Vector2( x, y ) {

			this.x = x || 0;
			this.y = y || 0;

		}

		Vector2.prototype = {

			constructor: Vector2,

			isVector2: true,

			get width() {

				return this.x;

			},

			set width( value ) {

				this.x = value;

			},

			get height() {

				return this.y;

			},

			set height( value ) {

				this.y = value;

			},

			//

			set: function ( x, y ) {

				this.x = x;
				this.y = y;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}
				
				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;

				return this;

			},

			multiply: function ( v ) {

				this.x *= v.x;
				this.y *= v.y;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;

				} else {

					this.x = 0;
					this.y = 0;

				}

				return this;

			},

			divide: function ( v ) {

				this.x /= v.x;
				this.y /= v.y;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector2();
						max = new Vector2();

					}

					min.set( minVal, minVal );
					max.set( maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y );

			},

			lengthManhattan: function() {

				return Math.abs( this.x ) + Math.abs( this.y );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			angle: function () {

				// computes the angle in radians with respect to the positive x-axis

				var angle = Math.atan2( this.y, this.x );

				if ( angle < 0 ) angle += 2 * Math.PI;

				return angle;

			},

			distanceTo: function ( v ) {

				return Math.sqrt( this.distanceToSquared( v ) );

			},

			distanceToSquared: function ( v ) {

				var dx = this.x - v.x, dy = this.y - v.y;
				return dx * dx + dy * dy;

			},

			distanceToManhattan: function ( v ) {

				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;

				return array;

			},

			fromAttribute: function ( attribute, index, offset ) {

				if ( offset === undefined ) offset = 0;

				index = index * attribute.itemSize + offset;

				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];

				return this;

			},

			rotateAround: function ( center, angle ) {

				var c = Math.cos( angle ), s = Math.sin( angle );

				var x = this.x - center.x;
				var y = this.y - center.y;

				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */

		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			Object.defineProperty( this, 'id', { value: TextureIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.sourceFile = '';

			this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
			this.mipmaps = [];

			this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

			this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
			this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

			this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

			this.format = format !== undefined ? format : RGBAFormat;
			this.type = type !== undefined ? type : UnsignedByteType;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding !== undefined ? encoding :  LinearEncoding;

			this.version = 0;
			this.onUpdate = null;

		}

		Texture.DEFAULT_IMAGE = undefined;
		Texture.DEFAULT_MAPPING = UVMapping;

		Texture.prototype = {

			constructor: Texture,

			isTexture: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.image = source.image;
				this.mipmaps = source.mipmaps.slice( 0 );

				this.mapping = source.mapping;

				this.wrapS = source.wrapS;
				this.wrapT = source.wrapT;

				this.magFilter = source.magFilter;
				this.minFilter = source.minFilter;

				this.anisotropy = source.anisotropy;

				this.format = source.format;
				this.type = source.type;

				this.offset.copy( source.offset );
				this.repeat.copy( source.repeat );

				this.generateMipmaps = source.generateMipmaps;
				this.premultiplyAlpha = source.premultiplyAlpha;
				this.flipY = source.flipY;
				this.unpackAlignment = source.unpackAlignment;
				this.encoding = source.encoding;

				return this;

			},

			toJSON: function ( meta ) {

				if ( meta.textures[ this.uuid ] !== undefined ) {

					return meta.textures[ this.uuid ];

				}

				function getDataURL( image ) {

					var canvas;

					if ( image.toDataURL !== undefined ) {

						canvas = image;

					} else {

						canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
						canvas.width = image.width;
						canvas.height = image.height;

						canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

					}

					if ( canvas.width > 2048 || canvas.height > 2048 ) {

						return canvas.toDataURL( 'image/jpeg', 0.6 );

					} else {

						return canvas.toDataURL( 'image/png' );

					}

				}

				var output = {
					metadata: {
						version: 4.4,
						type: 'Texture',
						generator: 'Texture.toJSON'
					},

					uuid: this.uuid,
					name: this.name,

					mapping: this.mapping,

					repeat: [ this.repeat.x, this.repeat.y ],
					offset: [ this.offset.x, this.offset.y ],
					wrap: [ this.wrapS, this.wrapT ],

					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,

					flipY: this.flipY
				};

				if ( this.image !== undefined ) {

					// TODO: Move to THREE.Image

					var image = this.image;

					if ( image.uuid === undefined ) {

						image.uuid = _Math.generateUUID(); // UGH

					}

					if ( meta.images[ image.uuid ] === undefined ) {

						meta.images[ image.uuid ] = {
							uuid: image.uuid,
							url: getDataURL( image )
						};

					}

					output.image = image.uuid;

				}

				meta.textures[ this.uuid ] = output;

				return output;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			},

			transformUv: function ( uv ) {

				if ( this.mapping !== UVMapping )  return;

				uv.multiply( this.repeat );
				uv.add( this.offset );

				if ( uv.x < 0 || uv.x > 1 ) {

					switch ( this.wrapS ) {

						case RepeatWrapping:

							uv.x = uv.x - Math.floor( uv.x );
							break;

						case ClampToEdgeWrapping:

							uv.x = uv.x < 0 ? 0 : 1;
							break;

						case MirroredRepeatWrapping:

							if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

								uv.x = Math.ceil( uv.x ) - uv.x;

							} else {

								uv.x = uv.x - Math.floor( uv.x );

							}
							break;

					}

				}

				if ( uv.y < 0 || uv.y > 1 ) {

					switch ( this.wrapT ) {

						case RepeatWrapping:

							uv.y = uv.y - Math.floor( uv.y );
							break;

						case ClampToEdgeWrapping:

							uv.y = uv.y < 0 ? 0 : 1;
							break;

						case MirroredRepeatWrapping:

							if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

								uv.y = Math.ceil( uv.y ) - uv.y;

							} else {

								uv.y = uv.y - Math.floor( uv.y );

							}
							break;

					}

				}

				if ( this.flipY ) {

					uv.y = 1 - uv.y;

				}

			}

		};

		Object.assign( Texture.prototype, EventDispatcher.prototype );

		var count = 0;
		function TextureIdCount() { return count++; }

		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Vector4( x, y, z, w ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;

		}

		Vector4.prototype = {

			constructor: Vector4,

			isVector4: true,

			set: function ( x, y, z, w ) {

				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setZ: function ( z ) {

				this.z = z;

				return this;

			},

			setW: function ( w ) {

				this.w = w;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					case 3: this.w = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}
				
				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					case 3: return this.w;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y, this.z, this.w );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = ( v.w !== undefined ) ? v.w : 1;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
					this.w *= scalar;

				} else {

					this.x = 0;
					this.y = 0;
					this.z = 0;
					this.w = 0;

				}

				return this;

			},

			applyMatrix4: function ( m ) {

				var x = this.x, y = this.y, z = this.z, w = this.w;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
				this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			setAxisAngleFromQuaternion: function ( q ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

				// q is assumed to be normalized

				this.w = 2 * Math.acos( q.w );

				var s = Math.sqrt( 1 - q.w * q.w );

				if ( s < 0.0001 ) {

					 this.x = 1;
					 this.y = 0;
					 this.z = 0;

				} else {

					 this.x = q.x / s;
					 this.y = q.y / s;
					 this.z = q.z / s;

				}

				return this;

			},

			setAxisAngleFromRotationMatrix: function ( m ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var angle, x, y, z,		// variables for result
					epsilon = 0.01,		// margin to allow for rounding errors
					epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

					te = m.elements,

					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

				if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
				     ( Math.abs( m13 - m31 ) < epsilon ) &&
				     ( Math.abs( m23 - m32 ) < epsilon ) ) {

					// singularity found
					// first check for identity matrix which must have +1 for all terms
					// in leading diagonal and zero in other terms

					if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
					     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
					     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
					     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

						// this singularity is identity matrix so angle = 0

						this.set( 1, 0, 0, 0 );

						return this; // zero angle, arbitrary axis

					}

					// otherwise this singularity is angle = 180

					angle = Math.PI;

					var xx = ( m11 + 1 ) / 2;
					var yy = ( m22 + 1 ) / 2;
					var zz = ( m33 + 1 ) / 2;
					var xy = ( m12 + m21 ) / 4;
					var xz = ( m13 + m31 ) / 4;
					var yz = ( m23 + m32 ) / 4;

					if ( ( xx > yy ) && ( xx > zz ) ) {

						// m11 is the largest diagonal term

						if ( xx < epsilon ) {

							x = 0;
							y = 0.707106781;
							z = 0.707106781;

						} else {

							x = Math.sqrt( xx );
							y = xy / x;
							z = xz / x;

						}

					} else if ( yy > zz ) {

						// m22 is the largest diagonal term

						if ( yy < epsilon ) {

							x = 0.707106781;
							y = 0;
							z = 0.707106781;

						} else {

							y = Math.sqrt( yy );
							x = xy / y;
							z = yz / y;

						}

					} else {

						// m33 is the largest diagonal term so base result on this

						if ( zz < epsilon ) {

							x = 0.707106781;
							y = 0.707106781;
							z = 0;

						} else {

							z = Math.sqrt( zz );
							x = xz / z;
							y = yz / z;

						}

					}

					this.set( x, y, z, angle );

					return this; // return 180 deg rotation

				}

				// as we have reached here there are no singularities so we can handle normally

				var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				                   ( m13 - m31 ) * ( m13 - m31 ) +
				                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

				if ( Math.abs( s ) < 0.001 ) s = 1;

				// prevent divide by zero, should not happen if matrix is orthogonal and should be
				// caught by singularity test above, but I've left it in just in case

				this.x = ( m32 - m23 ) / s;
				this.y = ( m13 - m31 ) / s;
				this.z = ( m21 - m12 ) / s;
				this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

				return this;

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
				this.w = Math.min( this.w, v.w );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
				this.w = Math.max( this.w, v.w );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
				this.w = Math.max( min.w, Math.min( max.w, this.w ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector4();
						max = new Vector4();

					}

					min.set( minVal, minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
				this.w = Math.floor( this.w );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
				this.w = Math.ceil( this.w );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
				this.w = Math.round( this.w );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
				this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
				this.w = - this.w;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

			},

			lengthManhattan: function () {

				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
				this.w += ( v.w - this.w ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
				this.w = array[ offset + 3 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
				array[ offset + 3 ] = this.w;

				return array;

			},

			fromAttribute: function ( attribute, index, offset ) {

				if ( offset === undefined ) offset = 0;

				index = index * attribute.itemSize + offset;

				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];
				this.z = attribute.array[ index + 2 ];
				this.w = attribute.array[ index + 3 ];

				return this;

			}

		};

		/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 */

		/*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/
		function WebGLRenderTarget( width, height, options ) {

			this.uuid = _Math.generateUUID();

			this.width = width;
			this.height = height;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			options = options || {};

			if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

			this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

		}

		Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

			isWebGLRenderTarget: true,

			setSize: function ( width, height ) {

				if ( this.width !== width || this.height !== height ) {

					this.width = width;
					this.height = height;

					this.dispose();

				}

				this.viewport.set( 0, 0, width, height );
				this.scissor.set( 0, 0, width, height );

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.width = source.width;
				this.height = source.height;

				this.viewport.copy( source.viewport );

				this.texture = source.texture.clone();

				this.depthBuffer = source.depthBuffer;
				this.stencilBuffer = source.stencilBuffer;
				this.depthTexture = source.depthTexture;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com
		 */

		function WebGLRenderTargetCube( width, height, options ) {

			WebGLRenderTarget.call( this, width, height, options );

			this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
			this.activeMipMapLevel = 0;

		}

		WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
		WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

		WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */

		function Quaternion( x, y, z, w ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;

		}

		Quaternion.prototype = {

			constructor: Quaternion,

			get x () {

				return this._x;

			},

			set x ( value ) {

				this._x = value;
				this.onChangeCallback();

			},

			get y () {

				return this._y;

			},

			set y ( value ) {

				this._y = value;
				this.onChangeCallback();

			},

			get z () {

				return this._z;

			},

			set z ( value ) {

				this._z = value;
				this.onChangeCallback();

			},

			get w () {

				return this._w;

			},

			set w ( value ) {

				this._w = value;
				this.onChangeCallback();

			},

			set: function ( x, y, z, w ) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;

				this.onChangeCallback();

				return this;

			},

			clone: function () {

				return new this.constructor( this._x, this._y, this._z, this._w );

			},

			copy: function ( quaternion ) {

				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;

				this.onChangeCallback();

				return this;

			},

			setFromEuler: function ( euler, update ) {

				if ( (euler && euler.isEuler) === false ) {

					throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				// http://www.mathworks.com/matlabcentral/fileexchange/
				// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
				//	content/SpinCalc.m

				var c1 = Math.cos( euler._x / 2 );
				var c2 = Math.cos( euler._y / 2 );
				var c3 = Math.cos( euler._z / 2 );
				var s1 = Math.sin( euler._x / 2 );
				var s2 = Math.sin( euler._y / 2 );
				var s3 = Math.sin( euler._z / 2 );

				var order = euler.order;

				if ( order === 'XYZ' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'YXZ' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				} else if ( order === 'ZXY' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'ZYX' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				} else if ( order === 'YZX' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'XZY' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				}

				if ( update !== false ) this.onChangeCallback();

				return this;

			},

			setFromAxisAngle: function ( axis, angle ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

				// assumes axis is normalized

				var halfAngle = angle / 2, s = Math.sin( halfAngle );

				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos( halfAngle );

				this.onChangeCallback();

				return this;

			},

			setFromRotationMatrix: function ( m ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var te = m.elements,

					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

					trace = m11 + m22 + m33,
					s;

				if ( trace > 0 ) {

					s = 0.5 / Math.sqrt( trace + 1.0 );

					this._w = 0.25 / s;
					this._x = ( m32 - m23 ) * s;
					this._y = ( m13 - m31 ) * s;
					this._z = ( m21 - m12 ) * s;

				} else if ( m11 > m22 && m11 > m33 ) {

					s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

					this._w = ( m32 - m23 ) / s;
					this._x = 0.25 * s;
					this._y = ( m12 + m21 ) / s;
					this._z = ( m13 + m31 ) / s;

				} else if ( m22 > m33 ) {

					s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

					this._w = ( m13 - m31 ) / s;
					this._x = ( m12 + m21 ) / s;
					this._y = 0.25 * s;
					this._z = ( m23 + m32 ) / s;

				} else {

					s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

					this._w = ( m21 - m12 ) / s;
					this._x = ( m13 + m31 ) / s;
					this._y = ( m23 + m32 ) / s;
					this._z = 0.25 * s;

				}

				this.onChangeCallback();

				return this;

			},

			setFromUnitVectors: function () {

				// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

				// assumes direction vectors vFrom and vTo are normalized

				var v1, r;

				var EPS = 0.000001;

				return function setFromUnitVectors( vFrom, vTo ) {

					if ( v1 === undefined ) v1 = new Vector3();

					r = vFrom.dot( vTo ) + 1;

					if ( r < EPS ) {

						r = 0;

						if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

							v1.set( - vFrom.y, vFrom.x, 0 );

						} else {

							v1.set( 0, - vFrom.z, vFrom.y );

						}

					} else {

						v1.crossVectors( vFrom, vTo );

					}

					this._x = v1.x;
					this._y = v1.y;
					this._z = v1.z;
					this._w = r;

					return this.normalize();

				};

			}(),

			inverse: function () {

				return this.conjugate().normalize();

			},

			conjugate: function () {

				this._x *= - 1;
				this._y *= - 1;
				this._z *= - 1;

				this.onChangeCallback();

				return this;

			},

			dot: function ( v ) {

				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

			},

			lengthSq: function () {

				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

			},

			length: function () {

				return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

			},

			normalize: function () {

				var l = this.length();

				if ( l === 0 ) {

					this._x = 0;
					this._y = 0;
					this._z = 0;
					this._w = 1;

				} else {

					l = 1 / l;

					this._x = this._x * l;
					this._y = this._y * l;
					this._z = this._z * l;
					this._w = this._w * l;

				}

				this.onChangeCallback();

				return this;

			},

			multiply: function ( q, p ) {

				if ( p !== undefined ) {

					console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
					return this.multiplyQuaternions( q, p );

				}

				return this.multiplyQuaternions( this, q );

			},

			premultiply: function ( q ) {

				return this.multiplyQuaternions( q, this );

			},

			multiplyQuaternions: function ( a, b ) {

				// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

				var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
				var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

				this.onChangeCallback();

				return this;

			},

			slerp: function ( qb, t ) {

				if ( t === 0 ) return this;
				if ( t === 1 ) return this.copy( qb );

				var x = this._x, y = this._y, z = this._z, w = this._w;

				// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

				if ( cosHalfTheta < 0 ) {

					this._w = - qb._w;
					this._x = - qb._x;
					this._y = - qb._y;
					this._z = - qb._z;

					cosHalfTheta = - cosHalfTheta;

				} else {

					this.copy( qb );

				}

				if ( cosHalfTheta >= 1.0 ) {

					this._w = w;
					this._x = x;
					this._y = y;
					this._z = z;

					return this;

				}

				var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

				if ( Math.abs( sinHalfTheta ) < 0.001 ) {

					this._w = 0.5 * ( w + this._w );
					this._x = 0.5 * ( x + this._x );
					this._y = 0.5 * ( y + this._y );
					this._z = 0.5 * ( z + this._z );

					return this;

				}

				var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
				var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

				this._w = ( w * ratioA + this._w * ratioB );
				this._x = ( x * ratioA + this._x * ratioB );
				this._y = ( y * ratioA + this._y * ratioB );
				this._z = ( z * ratioA + this._z * ratioB );

				this.onChangeCallback();

				return this;

			},

			equals: function ( quaternion ) {

				return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this._x = array[ offset ];
				this._y = array[ offset + 1 ];
				this._z = array[ offset + 2 ];
				this._w = array[ offset + 3 ];

				this.onChangeCallback();

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._w;

				return array;

			},

			onChange: function ( callback ) {

				this.onChangeCallback = callback;

				return this;

			},

			onChangeCallback: function () {}

		};

		Object.assign( Quaternion, {

			slerp: function( qa, qb, qm, t ) {

				return qm.copy( qa ).slerp( qb, t );

			},

			slerpFlat: function(
					dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

				// fuzz-free, array-based Quaternion SLERP operation

				var x0 = src0[ srcOffset0 + 0 ],
					y0 = src0[ srcOffset0 + 1 ],
					z0 = src0[ srcOffset0 + 2 ],
					w0 = src0[ srcOffset0 + 3 ],

					x1 = src1[ srcOffset1 + 0 ],
					y1 = src1[ srcOffset1 + 1 ],
					z1 = src1[ srcOffset1 + 2 ],
					w1 = src1[ srcOffset1 + 3 ];

				if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

					var s = 1 - t,

						cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

						dir = ( cos >= 0 ? 1 : - 1 ),
						sqrSin = 1 - cos * cos;

					// Skip the Slerp for tiny steps to avoid numeric problems:
					if ( sqrSin > Number.EPSILON ) {

						var sin = Math.sqrt( sqrSin ),
							len = Math.atan2( sin, cos * dir );

						s = Math.sin( s * len ) / sin;
						t = Math.sin( t * len ) / sin;

					}

					var tDir = t * dir;

					x0 = x0 * s + x1 * tDir;
					y0 = y0 * s + y1 * tDir;
					z0 = z0 * s + z1 * tDir;
					w0 = w0 * s + w1 * tDir;

					// Normalize in case we just did a lerp:
					if ( s === 1 - t ) {

						var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

						x0 *= f;
						y0 *= f;
						z0 *= f;
						w0 *= f;

					}

				}

				dst[ dstOffset ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author *kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Vector3( x, y, z ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;

		}

		Vector3.prototype = {

			constructor: Vector3,

			isVector3: true,

			set: function ( x, y, z ) {

				this.x = x;
				this.y = y;
				this.z = z;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setZ: function ( z ) {

				this.z = z;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}
				
				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y, this.z );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;
				this.z += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;
				this.z -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;

				return this;

			},

			multiply: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
					return this.multiplyVectors( v, w );

				}

				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;

				} else {

					this.x = 0;
					this.y = 0;
					this.z = 0;

				}

				return this;

			},

			multiplyVectors: function ( a, b ) {

				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;

				return this;

			},

			applyEuler: function () {

				var quaternion;

				return function applyEuler( euler ) {

					if ( (euler && euler.isEuler) === false ) {

						console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

					}

					if ( quaternion === undefined ) quaternion = new Quaternion();

					return this.applyQuaternion( quaternion.setFromEuler( euler ) );

				};

			}(),

			applyAxisAngle: function () {

				var quaternion;

				return function applyAxisAngle( axis, angle ) {

					if ( quaternion === undefined ) quaternion = new Quaternion();

					return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				};

			}(),

			applyMatrix3: function ( m ) {

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
				this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

				return this;

			},

			applyMatrix4: function ( m ) {

				// input: THREE.Matrix4 affine matrix

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

				return this;

			},

			applyProjection: function ( m ) {

				// input: THREE.Matrix4 projection matrix

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
				var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

				this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
				this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
				this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

				return this;

			},

			applyQuaternion: function ( q ) {

				var x = this.x, y = this.y, z = this.z;
				var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

				// calculate quat * vector

				var ix =  qw * x + qy * z - qz * y;
				var iy =  qw * y + qz * x - qx * z;
				var iz =  qw * z + qx * y - qy * x;
				var iw = - qx * x - qy * y - qz * z;

				// calculate result * inverse quat

				this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
				this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
				this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

				return this;

			},

			project: function () {

				var matrix;

				return function project( camera ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
					return this.applyProjection( matrix );

				};

			}(),

			unproject: function () {

				var matrix;

				return function unproject( camera ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
					return this.applyProjection( matrix );

				};

			}(),

			transformDirection: function ( m ) {

				// input: THREE.Matrix4 affine matrix
				// vector interpreted as a direction

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

				return this.normalize();

			},

			divide: function ( v ) {

				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector3();
						max = new Vector3();

					}

					min.set( minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y + this.z * v.z;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y + this.z * this.z;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

			},

			lengthManhattan: function () {

				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			cross: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
					return this.crossVectors( v, w );

				}

				var x = this.x, y = this.y, z = this.z;

				this.x = y * v.z - z * v.y;
				this.y = z * v.x - x * v.z;
				this.z = x * v.y - y * v.x;

				return this;

			},

			crossVectors: function ( a, b ) {

				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;

				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;

				return this;

			},

			projectOnVector: function ( vector ) {

				var scalar = vector.dot( this ) / vector.lengthSq();

				return this.copy( vector ).multiplyScalar( scalar );

			},

			projectOnPlane: function () {

				var v1;

				return function projectOnPlane( planeNormal ) {

					if ( v1 === undefined ) v1 = new Vector3();

					v1.copy( this ).projectOnVector( planeNormal );

					return this.sub( v1 );

				};

			}(),

			reflect: function () {

				// reflect incident vector off plane orthogonal to normal
				// normal is assumed to have unit length

				var v1;

				return function reflect( normal ) {

					if ( v1 === undefined ) v1 = new Vector3();

					return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

				};

			}(),

			angleTo: function ( v ) {

				var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

				// clamp, to handle numerical problems

				return Math.acos( _Math.clamp( theta, - 1, 1 ) );

			},

			distanceTo: function ( v ) {

				return Math.sqrt( this.distanceToSquared( v ) );

			},

			distanceToSquared: function ( v ) {

				var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

				return dx * dx + dy * dy + dz * dz;

			},

			distanceToManhattan: function ( v ) {

				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

			},

			setFromSpherical: function( s ) {

				var sinPhiRadius = Math.sin( s.phi ) * s.radius;

				this.x = sinPhiRadius * Math.sin( s.theta );
				this.y = Math.cos( s.phi ) * s.radius;
				this.z = sinPhiRadius * Math.cos( s.theta );

				return this;

			},

			setFromMatrixPosition: function ( m ) {

				return this.setFromMatrixColumn( m, 3 );

			},

			setFromMatrixScale: function ( m ) {

				var sx = this.setFromMatrixColumn( m, 0 ).length();
				var sy = this.setFromMatrixColumn( m, 1 ).length();
				var sz = this.setFromMatrixColumn( m, 2 ).length();

				this.x = sx;
				this.y = sy;
				this.z = sz;

				return this;

			},

			setFromMatrixColumn: function ( m, index ) {

				if ( typeof m === 'number' ) {

					console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
					var temp = m;
					m = index;
					index = temp;

				}

				return this.fromArray( m.elements, index * 4 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;

				return array;

			},

			fromAttribute: function ( attribute, index, offset ) {

				if ( offset === undefined ) offset = 0;

				index = index * attribute.itemSize + offset;

				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];
				this.z = attribute.array[ index + 2 ];

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Matrix4() {

			this.elements = new Float32Array( [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			] );

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		Matrix4.prototype = {

			constructor: Matrix4,

			isMatrix4: true,

			set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

				var te = this.elements;

				te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
				te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
				te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
				te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

				return this;

			},

			identity: function () {

				this.set(

					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1

				);

				return this;

			},

			clone: function () {

				return new Matrix4().fromArray( this.elements );

			},

			copy: function ( m ) {

				this.elements.set( m.elements );

				return this;

			},

			copyPosition: function ( m ) {

				var te = this.elements;
				var me = m.elements;

				te[ 12 ] = me[ 12 ];
				te[ 13 ] = me[ 13 ];
				te[ 14 ] = me[ 14 ];

				return this;

			},

			extractBasis: function ( xAxis, yAxis, zAxis ) {

				xAxis.setFromMatrixColumn( this, 0 );
				yAxis.setFromMatrixColumn( this, 1 );
				zAxis.setFromMatrixColumn( this, 2 );

				return this;

			},

			makeBasis: function ( xAxis, yAxis, zAxis ) {

				this.set(
					xAxis.x, yAxis.x, zAxis.x, 0,
					xAxis.y, yAxis.y, zAxis.y, 0,
					xAxis.z, yAxis.z, zAxis.z, 0,
					0,       0,       0,       1
				);

				return this;

			},

			extractRotation: function () {

				var v1;

				return function extractRotation( m ) {

					if ( v1 === undefined ) v1 = new Vector3();

					var te = this.elements;
					var me = m.elements;

					var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
					var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
					var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

					te[ 0 ] = me[ 0 ] * scaleX;
					te[ 1 ] = me[ 1 ] * scaleX;
					te[ 2 ] = me[ 2 ] * scaleX;

					te[ 4 ] = me[ 4 ] * scaleY;
					te[ 5 ] = me[ 5 ] * scaleY;
					te[ 6 ] = me[ 6 ] * scaleY;

					te[ 8 ] = me[ 8 ] * scaleZ;
					te[ 9 ] = me[ 9 ] * scaleZ;
					te[ 10 ] = me[ 10 ] * scaleZ;

					return this;

				};

			}(),

			makeRotationFromEuler: function ( euler ) {

				if ( (euler && euler.isEuler) === false ) {

					console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				var te = this.elements;

				var x = euler.x, y = euler.y, z = euler.z;
				var a = Math.cos( x ), b = Math.sin( x );
				var c = Math.cos( y ), d = Math.sin( y );
				var e = Math.cos( z ), f = Math.sin( z );

				if ( euler.order === 'XYZ' ) {

					var ae = a * e, af = a * f, be = b * e, bf = b * f;

					te[ 0 ] = c * e;
					te[ 4 ] = - c * f;
					te[ 8 ] = d;

					te[ 1 ] = af + be * d;
					te[ 5 ] = ae - bf * d;
					te[ 9 ] = - b * c;

					te[ 2 ] = bf - ae * d;
					te[ 6 ] = be + af * d;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'YXZ' ) {

					var ce = c * e, cf = c * f, de = d * e, df = d * f;

					te[ 0 ] = ce + df * b;
					te[ 4 ] = de * b - cf;
					te[ 8 ] = a * d;

					te[ 1 ] = a * f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b;

					te[ 2 ] = cf * b - de;
					te[ 6 ] = df + ce * b;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'ZXY' ) {

					var ce = c * e, cf = c * f, de = d * e, df = d * f;

					te[ 0 ] = ce - df * b;
					te[ 4 ] = - a * f;
					te[ 8 ] = de + cf * b;

					te[ 1 ] = cf + de * b;
					te[ 5 ] = a * e;
					te[ 9 ] = df - ce * b;

					te[ 2 ] = - a * d;
					te[ 6 ] = b;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'ZYX' ) {

					var ae = a * e, af = a * f, be = b * e, bf = b * f;

					te[ 0 ] = c * e;
					te[ 4 ] = be * d - af;
					te[ 8 ] = ae * d + bf;

					te[ 1 ] = c * f;
					te[ 5 ] = bf * d + ae;
					te[ 9 ] = af * d - be;

					te[ 2 ] = - d;
					te[ 6 ] = b * c;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'YZX' ) {

					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

					te[ 0 ] = c * e;
					te[ 4 ] = bd - ac * f;
					te[ 8 ] = bc * f + ad;

					te[ 1 ] = f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b * e;

					te[ 2 ] = - d * e;
					te[ 6 ] = ad * f + bc;
					te[ 10 ] = ac - bd * f;

				} else if ( euler.order === 'XZY' ) {

					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

					te[ 0 ] = c * e;
					te[ 4 ] = - f;
					te[ 8 ] = d * e;

					te[ 1 ] = ac * f + bd;
					te[ 5 ] = a * e;
					te[ 9 ] = ad * f - bc;

					te[ 2 ] = bc * f - ad;
					te[ 6 ] = b * e;
					te[ 10 ] = bd * f + ac;

				}

				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;

				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			},

			makeRotationFromQuaternion: function ( q ) {

				var te = this.elements;

				var x = q.x, y = q.y, z = q.z, w = q.w;
				var x2 = x + x, y2 = y + y, z2 = z + z;
				var xx = x * x2, xy = x * y2, xz = x * z2;
				var yy = y * y2, yz = y * z2, zz = z * z2;
				var wx = w * x2, wy = w * y2, wz = w * z2;

				te[ 0 ] = 1 - ( yy + zz );
				te[ 4 ] = xy - wz;
				te[ 8 ] = xz + wy;

				te[ 1 ] = xy + wz;
				te[ 5 ] = 1 - ( xx + zz );
				te[ 9 ] = yz - wx;

				te[ 2 ] = xz - wy;
				te[ 6 ] = yz + wx;
				te[ 10 ] = 1 - ( xx + yy );

				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;

				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			},

			lookAt: function () {

				var x, y, z;

				return function lookAt( eye, target, up ) {

					if ( x === undefined ) {

						x = new Vector3();
						y = new Vector3();
						z = new Vector3();

					}

					var te = this.elements;

					z.subVectors( eye, target ).normalize();

					if ( z.lengthSq() === 0 ) {

						z.z = 1;

					}

					x.crossVectors( up, z ).normalize();

					if ( x.lengthSq() === 0 ) {

						z.z += 0.0001;
						x.crossVectors( up, z ).normalize();

					}

					y.crossVectors( z, x );


					te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
					te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
					te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

					return this;

				};

			}(),

			multiply: function ( m, n ) {

				if ( n !== undefined ) {

					console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
					return this.multiplyMatrices( m, n );

				}

				return this.multiplyMatrices( this, m );

			},

			premultiply: function ( m ) {

				return this.multiplyMatrices( m, this );

			},

			multiplyMatrices: function ( a, b ) {

				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;

				var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
				var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
				var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
				var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

				var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
				var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
				var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
				var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

				te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

				return this;

			},

			multiplyToArray: function ( a, b, r ) {

				var te = this.elements;

				this.multiplyMatrices( a, b );

				r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
				r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
				r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
				r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

				return this;

			},

			multiplyScalar: function ( s ) {

				var te = this.elements;

				te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
				te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
				te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
				te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

				return this;

			},

			applyToVector3Array: function () {

				var v1;

				return function applyToVector3Array( array, offset, length ) {

					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = array.length;

					for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

						v1.fromArray( array, j );
						v1.applyMatrix4( this );
						v1.toArray( array, j );

					}

					return array;

				};

			}(),

			applyToBuffer: function () {

				var v1;

				return function applyToBuffer( buffer, offset, length ) {

					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = buffer.length / buffer.itemSize;

					for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

						v1.x = buffer.getX( j );
						v1.y = buffer.getY( j );
						v1.z = buffer.getZ( j );

						v1.applyMatrix4( this );

						buffer.setXYZ( j, v1.x, v1.y, v1.z );

					}

					return buffer;

				};

			}(),

			determinant: function () {

				var te = this.elements;

				var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
				var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
				var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
				var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

				//TODO: make this more efficient
				//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

				return (
					n41 * (
						+ n14 * n23 * n32
						 - n13 * n24 * n32
						 - n14 * n22 * n33
						 + n12 * n24 * n33
						 + n13 * n22 * n34
						 - n12 * n23 * n34
					) +
					n42 * (
						+ n11 * n23 * n34
						 - n11 * n24 * n33
						 + n14 * n21 * n33
						 - n13 * n21 * n34
						 + n13 * n24 * n31
						 - n14 * n23 * n31
					) +
					n43 * (
						+ n11 * n24 * n32
						 - n11 * n22 * n34
						 - n14 * n21 * n32
						 + n12 * n21 * n34
						 + n14 * n22 * n31
						 - n12 * n24 * n31
					) +
					n44 * (
						- n13 * n22 * n31
						 - n11 * n23 * n32
						 + n11 * n22 * n33
						 + n13 * n21 * n32
						 - n12 * n21 * n33
						 + n12 * n23 * n31
					)

				);

			},

			transpose: function () {

				var te = this.elements;
				var tmp;

				tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
				tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
				tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

				tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
				tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
				tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

				return this;

			},

			flattenToArrayOffset: function ( array, offset ) {

				console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
						"- just use .toArray instead." );

				return this.toArray( array, offset );

			},

			getPosition: function () {

				var v1;

				return function getPosition() {

					if ( v1 === undefined ) v1 = new Vector3();
					console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

					return v1.setFromMatrixColumn( this, 3 );

				};

			}(),

			setPosition: function ( v ) {

				var te = this.elements;

				te[ 12 ] = v.x;
				te[ 13 ] = v.y;
				te[ 14 ] = v.z;

				return this;

			},

			getInverse: function ( m, throwOnDegenerate ) {

				// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
				var te = this.elements,
					me = m.elements,

					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
					n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
					n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
					n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

				if ( det === 0 ) {

					var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

					if ( throwOnDegenerate === true ) {

						throw new Error( msg );

					} else {

						console.warn( msg );

					}

					return this.identity();

				}

				var detInv = 1 / det;

				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
				te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
				te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

				te[ 4 ] = t12 * detInv;
				te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
				te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
				te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

				te[ 8 ] = t13 * detInv;
				te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
				te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
				te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

				te[ 12 ] = t14 * detInv;
				te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
				te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
				te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

				return this;

			},

			scale: function ( v ) {

				var te = this.elements;
				var x = v.x, y = v.y, z = v.z;

				te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
				te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
				te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
				te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

				return this;

			},

			getMaxScaleOnAxis: function () {

				var te = this.elements;

				var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
				var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
				var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

				return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

			},

			makeTranslation: function ( x, y, z ) {

				this.set(

					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1

				);

				return this;

			},

			makeRotationX: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					1, 0,  0, 0,
					0, c, - s, 0,
					0, s,  c, 0,
					0, 0,  0, 1

				);

				return this;

			},

			makeRotationY: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					 c, 0, s, 0,
					 0, 1, 0, 0,
					- s, 0, c, 0,
					 0, 0, 0, 1

				);

				return this;

			},

			makeRotationZ: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					c, - s, 0, 0,
					s,  c, 0, 0,
					0,  0, 1, 0,
					0,  0, 0, 1

				);

				return this;

			},

			makeRotationAxis: function ( axis, angle ) {

				// Based on http://www.gamedev.net/reference/articles/article1199.asp

				var c = Math.cos( angle );
				var s = Math.sin( angle );
				var t = 1 - c;
				var x = axis.x, y = axis.y, z = axis.z;
				var tx = t * x, ty = t * y;

				this.set(

					tx * x + c, tx * y - s * z, tx * z + s * y, 0,
					tx * y + s * z, ty * y + c, ty * z - s * x, 0,
					tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
					0, 0, 0, 1

				);

				 return this;

			},

			makeScale: function ( x, y, z ) {

				this.set(

					x, 0, 0, 0,
					0, y, 0, 0,
					0, 0, z, 0,
					0, 0, 0, 1

				);

				return this;

			},

			compose: function ( position, quaternion, scale ) {

				this.makeRotationFromQuaternion( quaternion );
				this.scale( scale );
				this.setPosition( position );

				return this;

			},

			decompose: function () {

				var vector, matrix;

				return function decompose( position, quaternion, scale ) {

					if ( vector === undefined ) {

						vector = new Vector3();
						matrix = new Matrix4();

					}

					var te = this.elements;

					var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
					var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
					var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

					// if determine is negative, we need to invert one scale
					var det = this.determinant();
					if ( det < 0 ) {

						sx = - sx;

					}

					position.x = te[ 12 ];
					position.y = te[ 13 ];
					position.z = te[ 14 ];

					// scale the rotation part

					matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

					var invSX = 1 / sx;
					var invSY = 1 / sy;
					var invSZ = 1 / sz;

					matrix.elements[ 0 ] *= invSX;
					matrix.elements[ 1 ] *= invSX;
					matrix.elements[ 2 ] *= invSX;

					matrix.elements[ 4 ] *= invSY;
					matrix.elements[ 5 ] *= invSY;
					matrix.elements[ 6 ] *= invSY;

					matrix.elements[ 8 ] *= invSZ;
					matrix.elements[ 9 ] *= invSZ;
					matrix.elements[ 10 ] *= invSZ;

					quaternion.setFromRotationMatrix( matrix );

					scale.x = sx;
					scale.y = sy;
					scale.z = sz;

					return this;

				};

			}(),

			makeFrustum: function ( left, right, bottom, top, near, far ) {

				var te = this.elements;
				var x = 2 * near / ( right - left );
				var y = 2 * near / ( top - bottom );

				var a = ( right + left ) / ( right - left );
				var b = ( top + bottom ) / ( top - bottom );
				var c = - ( far + near ) / ( far - near );
				var d = - 2 * far * near / ( far - near );

				te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
				te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

				return this;

			},

			makePerspective: function ( fov, aspect, near, far ) {

				var ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );
				var ymin = - ymax;
				var xmin = ymin * aspect;
				var xmax = ymax * aspect;

				return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

			},

			makeOrthographic: function ( left, right, top, bottom, near, far ) {

				var te = this.elements;
				var w = 1.0 / ( right - left );
				var h = 1.0 / ( top - bottom );
				var p = 1.0 / ( far - near );

				var x = ( right + left ) * w;
				var y = ( top + bottom ) * h;
				var z = ( far + near ) * p;

				te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
				te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

				return this;

			},

			equals: function ( matrix ) {

				var te = this.elements;
				var me = matrix.elements;

				for ( var i = 0; i < 16; i ++ ) {

					if ( te[ i ] !== me[ i ] ) return false;

				}

				return true;

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				for( var i = 0; i < 16; i ++ ) {

					this.elements[ i ] = array[ i + offset ];

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				var te = this.elements;

				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
				array[ offset + 3 ] = te[ 3 ];

				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];

				array[ offset + 8 ]  = te[ 8 ];
				array[ offset + 9 ]  = te[ 9 ];
				array[ offset + 10 ] = te[ 10 ];
				array[ offset + 11 ] = te[ 11 ];

				array[ offset + 12 ] = te[ 12 ];
				array[ offset + 13 ] = te[ 13 ];
				array[ offset + 14 ] = te[ 14 ];
				array[ offset + 15 ] = te[ 15 ];

				return array;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.flipY = false;

		}

		CubeTexture.prototype = Object.create( Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;

		CubeTexture.prototype.isCubeTexture = true;

		Object.defineProperty( CubeTexture.prototype, 'images', {

			get: function () {

				return this.image;

			},

			set: function ( value ) {

				this.image = value;

			}

		} );

		/**
		 * @author tschw
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [renderer] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'renderer' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (renderer factorizations):
		 *
		 * .upload( gl, seq, values, renderer )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (renderer factorizations):
		 *
		 * .setValue( gl, name, value )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .set( gl, obj, prop )
		 *
		 * 		sets uniform from object and property with same name than uniform
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */

		var emptyTexture = new Texture();
		var emptyCubeTexture = new CubeTexture();

		// --- Base for inner nodes (including the root) ---

		function UniformContainer() {

			this.seq = [];
			this.map = {};

		}

		// --- Utilities ---

		// Array Caches (provide typed arrays for temporary by size)

		var arrayCacheF32 = [];
		var arrayCacheI32 = [];

		// Flattening for arrays of vectors and matrices

		function flatten( array, nBlocks, blockSize ) {

			var firstElem = array[ 0 ];

			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983

			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];

			if ( r === undefined ) {

				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;

			}

			if ( nBlocks !== 0 ) {

				firstElem.toArray( r, 0 );

				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

					offset += blockSize;
					array[ i ].toArray( r, offset );

				}

			}

			return r;

		}

		// Texture unit allocation

		function allocTexUnits( renderer, n ) {

			var r = arrayCacheI32[ n ];

			if ( r === undefined ) {

				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;

			}

			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();

			return r;

		}

		// --- Setters ---

		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.

		// Single scalar

		function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
		function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

		// Single float vector (from flat array or THREE.VectorN)

		function setValue2fv( gl, v ) {

			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );

		}

		function setValue3fv( gl, v ) {

			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );

		}

		function setValue4fv( gl, v ) {

			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

		}

		// Single matrix (from flat array or MatrixN)

		function setValue2fm( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, v.elements || v );

		}

		function setValue3fm( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, v.elements || v );

		}

		function setValue4fm( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, v.elements || v );

		}

		// Single texture (2D / Cube)

		function setValueT1( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTexture2D( v || emptyTexture, unit );

		}

		function setValueT6( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTextureCube( v || emptyCubeTexture, unit );

		}

		// Integer / Boolean vectors or arrays thereof (always flat arrays)

		function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
		function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
		function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

		// Helper to pick the right setter for the singular case

		function getSingularSetter( type ) {

			switch ( type ) {

				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4

				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4

				case 0x8b5e: return setValueT1; // SAMPLER_2D
				case 0x8b60: return setValueT6; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		}

		// Array of scalars

		function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
		function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

		// Array of vectors (flat or from THREE classes)

		function setValueV2a( gl, v ) {

			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

		}

		function setValueV3a( gl, v ) {

			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

		}

		function setValueV4a( gl, v ) {

			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

		}

		// Array of matrices (flat or from THREE clases)

		function setValueM2a( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

		}

		function setValueM3a( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

		}

		function setValueM4a( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

		}

		// Array of textures (2D / Cube)

		function setValueT1a( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

			}

		}

		function setValueT6a( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

			}

		}

		// Helper to pick the right setter for a pure (bottom-level) array

		function getPureArraySetter( type ) {

			switch ( type ) {

				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4

				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4

				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		}

		// --- Uniform Classes ---

		function SingleUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

		function PureArrayUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

		function StructuredUniform( id ) {

			this.id = id;

			UniformContainer.call( this ); // mix-in

		}

		StructuredUniform.prototype.setValue = function( gl, value ) {

			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.

			var seq = this.seq;

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ];
				u.setValue( gl, value[ u.id ] );

			}

		};

		// --- Top-level ---

		// Parser - builds up the property tree from the path strings

		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.

		function addUniform( container, uniformObject ) {

			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;

		}

		function parseUniform( activeInfo, addr, container ) {

			var path = activeInfo.name,
				pathLength = path.length;

			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;

			for (; ;) {

				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,

					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];

				if ( idIsIndex ) id = id | 0; // convert to integer

				if ( subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength ) {
					// bare name or "pure" bottom-level array "[0]" suffix

					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );

					break;

				} else {
					// step into inner node / create it in case it doesn't exist

					var map = container.map,
						next = map[ id ];

					if ( next === undefined ) {

						next = new StructuredUniform( id );
						addUniform( container, next );

					}

					container = next;

				}

			}

		}

		// Root Container

		function WebGLUniforms( gl, program, renderer ) {

			UniformContainer.call( this );

			this.renderer = renderer;

			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( var i = 0; i !== n; ++ i ) {

				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );

				parseUniform( info, addr, this );

			}

		}

		WebGLUniforms.prototype.setValue = function( gl, name, value ) {

			var u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, value, this.renderer );

		};

		WebGLUniforms.prototype.set = function( gl, object, name ) {

			var u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

		};

		WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

			var v = object[ name ];

			if ( v !== undefined ) this.setValue( gl, name, v );

		};


		// Static interface

		WebGLUniforms.upload = function( gl, seq, values, renderer ) {

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ],
					v = values[ u.id ];

				if ( v.needsUpdate !== false ) {
					// note: always updating when .needsUpdate is undefined

					u.setValue( gl, v.value, renderer );

				}

			}

		};

		WebGLUniforms.seqWithValue = function( seq, values ) {

			var r = [];

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ];
				if ( u.id in values ) r.push( u );

			}

			return r;

		};

		/**
		 * Uniform Utilities
		 */

		var UniformsUtils = {

			merge: function ( uniforms ) {

				var merged = {};

				for ( var u = 0; u < uniforms.length; u ++ ) {

					var tmp = this.clone( uniforms[ u ] );

					for ( var p in tmp ) {

						merged[ p ] = tmp[ p ];

					}

				}

				return merged;

			},

			clone: function ( uniforms_src ) {

				var uniforms_dst = {};

				for ( var u in uniforms_src ) {

					uniforms_dst[ u ] = {};

					for ( var p in uniforms_src[ u ] ) {

						var parameter_src = uniforms_src[ u ][ p ];

						if ( parameter_src && ( parameter_src.isColor ||
							parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
							parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
							parameter_src.isTexture ) ) {

							uniforms_dst[ u ][ p ] = parameter_src.clone();

						} else if ( Array.isArray( parameter_src ) ) {

							uniforms_dst[ u ][ p ] = parameter_src.slice();

						} else {

							uniforms_dst[ u ][ p ] = parameter_src;

						}

					}

				}

				return uniforms_dst;

			}

		};

		var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

		var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

		var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

		var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

		var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

		var begin_vertex = "\nvec3 transformed = vec3( position );\n";

		var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

		var bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

		var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

		var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

		var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

		var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

		var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

		var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

		var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

		var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

		var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

		var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

		var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

		var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

		var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

		var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

		var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

		var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

		var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

		var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

		var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

		var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

		var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

		var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

		var fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

		var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

		var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

		var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

		var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

		var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

		var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

		var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

		var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

		var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

		var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

		var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

		var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

		var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

		var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

		var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

		var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

		var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

		var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

		var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";

		var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

		var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

		var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

		var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

		var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

		var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

		var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

		var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

		var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

		var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

		var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

		var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

		var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

		var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

		var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

		var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

		var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

		var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

		var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

		var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

		var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

		var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

		var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

		var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

		var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

		var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

		var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

		var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

		var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

		var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

		var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

		var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

		var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

		var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

		var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

		var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

		var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

		var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

		var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

		var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

		var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";

		var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";

		var normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

		var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

		var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var ShaderChunk = {
			alphamap_fragment: alphamap_fragment,
			alphamap_pars_fragment: alphamap_pars_fragment,
			alphatest_fragment: alphatest_fragment,
			aomap_fragment: aomap_fragment,
			aomap_pars_fragment: aomap_pars_fragment,
			begin_vertex: begin_vertex,
			beginnormal_vertex: beginnormal_vertex,
			bsdfs: bsdfs,
			bumpmap_pars_fragment: bumpmap_pars_fragment,
			clipping_planes_fragment: clipping_planes_fragment,
			clipping_planes_pars_fragment: clipping_planes_pars_fragment,
			clipping_planes_pars_vertex: clipping_planes_pars_vertex,
			clipping_planes_vertex: clipping_planes_vertex,
			color_fragment: color_fragment,
			color_pars_fragment: color_pars_fragment,
			color_pars_vertex: color_pars_vertex,
			color_vertex: color_vertex,
			common: common,
			cube_uv_reflection_fragment: cube_uv_reflection_fragment,
			defaultnormal_vertex: defaultnormal_vertex,
			displacementmap_pars_vertex: displacementmap_pars_vertex,
			displacementmap_vertex: displacementmap_vertex,
			emissivemap_fragment: emissivemap_fragment,
			emissivemap_pars_fragment: emissivemap_pars_fragment,
			encodings_fragment: encodings_fragment,
			encodings_pars_fragment: encodings_pars_fragment,
			envmap_fragment: envmap_fragment,
			envmap_pars_fragment: envmap_pars_fragment,
			envmap_pars_vertex: envmap_pars_vertex,
			envmap_vertex: envmap_vertex,
			fog_fragment: fog_fragment,
			fog_pars_fragment: fog_pars_fragment,
			lightmap_fragment: lightmap_fragment,
			lightmap_pars_fragment: lightmap_pars_fragment,
			lights_lambert_vertex: lights_lambert_vertex,
			lights_pars: lights_pars,
			lights_phong_fragment: lights_phong_fragment,
			lights_phong_pars_fragment: lights_phong_pars_fragment,
			lights_physical_fragment: lights_physical_fragment,
			lights_physical_pars_fragment: lights_physical_pars_fragment,
			lights_template: lights_template,
			logdepthbuf_fragment: logdepthbuf_fragment,
			logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
			logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
			logdepthbuf_vertex: logdepthbuf_vertex,
			map_fragment: map_fragment,
			map_pars_fragment: map_pars_fragment,
			map_particle_fragment: map_particle_fragment,
			map_particle_pars_fragment: map_particle_pars_fragment,
			metalnessmap_fragment: metalnessmap_fragment,
			metalnessmap_pars_fragment: metalnessmap_pars_fragment,
			morphnormal_vertex: morphnormal_vertex,
			morphtarget_pars_vertex: morphtarget_pars_vertex,
			morphtarget_vertex: morphtarget_vertex,
			normal_flip: normal_flip,
			normal_fragment: normal_fragment,
			normalmap_pars_fragment: normalmap_pars_fragment,
			packing: packing,
			premultiplied_alpha_fragment: premultiplied_alpha_fragment,
			project_vertex: project_vertex,
			roughnessmap_fragment: roughnessmap_fragment,
			roughnessmap_pars_fragment: roughnessmap_pars_fragment,
			shadowmap_pars_fragment: shadowmap_pars_fragment,
			shadowmap_pars_vertex: shadowmap_pars_vertex,
			shadowmap_vertex: shadowmap_vertex,
			shadowmask_pars_fragment: shadowmask_pars_fragment,
			skinbase_vertex: skinbase_vertex,
			skinning_pars_vertex: skinning_pars_vertex,
			skinning_vertex: skinning_vertex,
			skinnormal_vertex: skinnormal_vertex,
			specularmap_fragment: specularmap_fragment,
			specularmap_pars_fragment: specularmap_pars_fragment,
			tonemapping_fragment: tonemapping_fragment,
			tonemapping_pars_fragment: tonemapping_pars_fragment,
			uv_pars_fragment: uv_pars_fragment,
			uv_pars_vertex: uv_pars_vertex,
			uv_vertex: uv_vertex,
			uv2_pars_fragment: uv2_pars_fragment,
			uv2_pars_vertex: uv2_pars_vertex,
			uv2_vertex: uv2_vertex,
			worldpos_vertex: worldpos_vertex,

			cube_frag: cube_frag,
			cube_vert: cube_vert,
			depth_frag: depth_frag,
			depth_vert: depth_vert,
			distanceRGBA_frag: distanceRGBA_frag,
			distanceRGBA_vert: distanceRGBA_vert,
			equirect_frag: equirect_frag,
			equirect_vert: equirect_vert,
			linedashed_frag: linedashed_frag,
			linedashed_vert: linedashed_vert,
			meshbasic_frag: meshbasic_frag,
			meshbasic_vert: meshbasic_vert,
			meshlambert_frag: meshlambert_frag,
			meshlambert_vert: meshlambert_vert,
			meshphong_frag: meshphong_frag,
			meshphong_vert: meshphong_vert,
			meshphysical_frag: meshphysical_frag,
			meshphysical_vert: meshphysical_vert,
			normal_frag: normal_frag,
			normal_vert: normal_vert,
			points_frag: points_frag,
			points_vert: points_vert,
			shadow_frag: shadow_frag,
			shadow_vert: shadow_vert
		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Color( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string
				return this.set( r );

			}

			return this.setRGB( r, g, b );

		}

		Color.prototype = {

			constructor: Color,

			isColor: true,

			r: 1, g: 1, b: 1,

			set: function ( value ) {

				if ( (value && value.isColor) ) {

					this.copy( value );

				} else if ( typeof value === 'number' ) {

					this.setHex( value );

				} else if ( typeof value === 'string' ) {

					this.setStyle( value );

				}

				return this;

			},

			setScalar: function ( scalar ) {

				this.r = scalar;
				this.g = scalar;
				this.b = scalar;

				return this;

			},

			setHex: function ( hex ) {

				hex = Math.floor( hex );

				this.r = ( hex >> 16 & 255 ) / 255;
				this.g = ( hex >> 8 & 255 ) / 255;
				this.b = ( hex & 255 ) / 255;

				return this;

			},

			setRGB: function ( r, g, b ) {

				this.r = r;
				this.g = g;
				this.b = b;

				return this;

			},

			setHSL: function () {

				function hue2rgb( p, q, t ) {

					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;

				}

				return function setHSL( h, s, l ) {

					// h,s,l ranges are in 0.0 - 1.0
					h = _Math.euclideanModulo( h, 1 );
					s = _Math.clamp( s, 0, 1 );
					l = _Math.clamp( l, 0, 1 );

					if ( s === 0 ) {

						this.r = this.g = this.b = l;

					} else {

						var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
						var q = ( 2 * l ) - p;

						this.r = hue2rgb( q, p, h + 1 / 3 );
						this.g = hue2rgb( q, p, h );
						this.b = hue2rgb( q, p, h - 1 / 3 );

					}

					return this;

				};

			}(),

			setStyle: function ( style ) {

				function handleAlpha( string ) {

					if ( string === undefined ) return;

					if ( parseFloat( string ) < 1 ) {

						console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

					}

				}


				var m;

				if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

					// rgb / hsl

					var color;
					var name = m[ 1 ];
					var components = m[ 2 ];

					switch ( name ) {

						case 'rgb':
						case 'rgba':

							if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// rgb(255,0,0) rgba(255,0,0,0.5)
								this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
								this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
								this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

								handleAlpha( color[ 5 ] );

								return this;

							}

							if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
								this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
								this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
								this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

								handleAlpha( color[ 5 ] );

								return this;

							}

							break;

						case 'hsl':
						case 'hsla':

							if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
								var h = parseFloat( color[ 1 ] ) / 360;
								var s = parseInt( color[ 2 ], 10 ) / 100;
								var l = parseInt( color[ 3 ], 10 ) / 100;

								handleAlpha( color[ 5 ] );

								return this.setHSL( h, s, l );

							}

							break;

					}

				} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

					// hex color

					var hex = m[ 1 ];
					var size = hex.length;

					if ( size === 3 ) {

						// #ff0
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

						return this;

					} else if ( size === 6 ) {

						// #ff0000
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

						return this;

					}

				}

				if ( style && style.length > 0 ) {

					// color keywords
					var hex = ColorKeywords[ style ];

					if ( hex !== undefined ) {

						// red
						this.setHex( hex );

					} else {

						// unknown color
						console.warn( 'THREE.Color: Unknown color ' + style );

					}

				}

				return this;

			},

			clone: function () {

				return new this.constructor( this.r, this.g, this.b );

			},

			copy: function ( color ) {

				this.r = color.r;
				this.g = color.g;
				this.b = color.b;

				return this;

			},

			copyGammaToLinear: function ( color, gammaFactor ) {

				if ( gammaFactor === undefined ) gammaFactor = 2.0;

				this.r = Math.pow( color.r, gammaFactor );
				this.g = Math.pow( color.g, gammaFactor );
				this.b = Math.pow( color.b, gammaFactor );

				return this;

			},

			copyLinearToGamma: function ( color, gammaFactor ) {

				if ( gammaFactor === undefined ) gammaFactor = 2.0;

				var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

				this.r = Math.pow( color.r, safeInverse );
				this.g = Math.pow( color.g, safeInverse );
				this.b = Math.pow( color.b, safeInverse );

				return this;

			},

			convertGammaToLinear: function () {

				var r = this.r, g = this.g, b = this.b;

				this.r = r * r;
				this.g = g * g;
				this.b = b * b;

				return this;

			},

			convertLinearToGamma: function () {

				this.r = Math.sqrt( this.r );
				this.g = Math.sqrt( this.g );
				this.b = Math.sqrt( this.b );

				return this;

			},

			getHex: function () {

				return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

			},

			getHexString: function () {

				return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

			},

			getHSL: function ( optionalTarget ) {

				// h,s,l ranges are in 0.0 - 1.0

				var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

				var r = this.r, g = this.g, b = this.b;

				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );

				var hue, saturation;
				var lightness = ( min + max ) / 2.0;

				if ( min === max ) {

					hue = 0;
					saturation = 0;

				} else {

					var delta = max - min;

					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

					switch ( max ) {

						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;

					}

					hue /= 6;

				}

				hsl.h = hue;
				hsl.s = saturation;
				hsl.l = lightness;

				return hsl;

			},

			getStyle: function () {

				return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

			},

			offsetHSL: function ( h, s, l ) {

				var hsl = this.getHSL();

				hsl.h += h; hsl.s += s; hsl.l += l;

				this.setHSL( hsl.h, hsl.s, hsl.l );

				return this;

			},

			add: function ( color ) {

				this.r += color.r;
				this.g += color.g;
				this.b += color.b;

				return this;

			},

			addColors: function ( color1, color2 ) {

				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;

				return this;

			},

			addScalar: function ( s ) {

				this.r += s;
				this.g += s;
				this.b += s;

				return this;

			},

			sub: function( color ) {

				this.r = Math.max( 0, this.r - color.r );
				this.g = Math.max( 0, this.g - color.g );
				this.b = Math.max( 0, this.b - color.b );

				return this;

			},

			multiply: function ( color ) {

				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;

				return this;

			},

			multiplyScalar: function ( s ) {

				this.r *= s;
				this.g *= s;
				this.b *= s;

				return this;

			},

			lerp: function ( color, alpha ) {

				this.r += ( color.r - this.r ) * alpha;
				this.g += ( color.g - this.g ) * alpha;
				this.b += ( color.b - this.b ) * alpha;

				return this;

			},

			equals: function ( c ) {

				return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.r = array[ offset ];
				this.g = array[ offset + 1 ];
				this.b = array[ offset + 2 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.r;
				array[ offset + 1 ] = this.g;
				array[ offset + 2 ] = this.b;

				return array;

			},

			toJSON: function () {

				return this.getHex();

			}

		};

		var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

		/**
		 * Uniforms library for shared webgl shaders
		 */

		var UniformsLib = {

			common: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },

				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

				specularMap: { value: null },
				alphaMap: { value: null },

				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				reflectivity: { value: 1.0 },
				refractionRatio: { value: 0.98 }

			},

			aomap: {

				aoMap: { value: null },
				aoMapIntensity: { value: 1 }

			},

			lightmap: {

				lightMap: { value: null },
				lightMapIntensity: { value: 1 }

			},

			emissivemap: {

				emissiveMap: { value: null }

			},

			bumpmap: {

				bumpMap: { value: null },
				bumpScale: { value: 1 }

			},

			normalmap: {

				normalMap: { value: null },
				normalScale: { value: new Vector2( 1, 1 ) }

			},

			displacementmap: {

				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 }

			},

			roughnessmap: {

				roughnessMap: { value: null }

			},

			metalnessmap: {

				metalnessMap: { value: null }

			},

			fog: {

				fogDensity: { value: 0.00025 },
				fogNear: { value: 1 },
				fogFar: { value: 2000 },
				fogColor: { value: new Color( 0xffffff ) }

			},

			lights: {

				ambientLightColor: { value: [] },

				directionalLights: { value: [], properties: {
					direction: {},
					color: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },

				spotLights: { value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },

				pointLights: { value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },

				hemisphereLights: { value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				} }

			},

			points: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				size: { value: 1.0 },
				scale: { value: 1.0 },
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */

		var ShaderLib = {

			basic: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.fog

				] ),

				vertexShader: ShaderChunk.meshbasic_vert,
				fragmentShader: ShaderChunk.meshbasic_frag

			},

			lambert: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.fog,
					UniformsLib.lights,

					{
						emissive : { value: new Color( 0x000000 ) }
					}

				] ),

				vertexShader: ShaderChunk.meshlambert_vert,
				fragmentShader: ShaderChunk.meshlambert_frag

			},

			phong: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.fog,
					UniformsLib.lights,

					{
						emissive : { value: new Color( 0x000000 ) },
						specular : { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}

				] ),

				vertexShader: ShaderChunk.meshphong_vert,
				fragmentShader: ShaderChunk.meshphong_frag

			},

			standard: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.roughnessmap,
					UniformsLib.metalnessmap,
					UniformsLib.fog,
					UniformsLib.lights,

					{
						emissive : { value: new Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0 },
						envMapIntensity : { value: 1 }, // temporary
					}

				] ),

				vertexShader: ShaderChunk.meshphysical_vert,
				fragmentShader: ShaderChunk.meshphysical_frag

			},

			points: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.points,
					UniformsLib.fog

				] ),

				vertexShader: ShaderChunk.points_vert,
				fragmentShader: ShaderChunk.points_frag

			},

			dashed: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.fog,

					{
						scale    : { value: 1 },
						dashSize : { value: 1 },
						totalSize: { value: 2 }
					}

				] ),

				vertexShader: ShaderChunk.linedashed_vert,
				fragmentShader: ShaderChunk.linedashed_frag

			},

			depth: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.displacementmap

				] ),

				vertexShader: ShaderChunk.depth_vert,
				fragmentShader: ShaderChunk.depth_frag

			},

			normal: {

				uniforms: {

					opacity : { value: 1.0 }

				},

				vertexShader: ShaderChunk.normal_vert,
				fragmentShader: ShaderChunk.normal_frag

			},

			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */

			cube: {

				uniforms: {
					tCube: { value: null },
					tFlip: { value: - 1 },
					opacity: { value: 1.0 }
				},

				vertexShader: ShaderChunk.cube_vert,
				fragmentShader: ShaderChunk.cube_frag

			},

			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */

			equirect: {

				uniforms: {
					tEquirect: { value: null },
					tFlip: { value: - 1 }
				},

				vertexShader: ShaderChunk.equirect_vert,
				fragmentShader: ShaderChunk.equirect_frag

			},

			distanceRGBA: {

				uniforms: {

					lightPos: { value: new Vector3() }

				},

				vertexShader: ShaderChunk.distanceRGBA_vert,
				fragmentShader: ShaderChunk.distanceRGBA_frag

			}

		};

		ShaderLib.physical = {

			uniforms: UniformsUtils.merge( [

				ShaderLib.standard.uniforms,

				{
					clearCoat: { value: 0 },
					clearCoatRoughness: { value: 0 }
				}

			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		};

		/**
		 * @author bhouston / http://clara.io
		 */

		function Box2( min, max ) {

			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

		}

		Box2.prototype = {

			constructor: Box2,

			set: function ( min, max ) {

				this.min.copy( min );
				this.max.copy( max );

				return this;

			},

			setFromPoints: function ( points ) {

				this.makeEmpty();

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					this.expandByPoint( points[ i ] );

				}

				return this;

			},

			setFromCenterAndSize: function () {

				var v1 = new Vector2();

				return function setFromCenterAndSize( center, size ) {

					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( box ) {

				this.min.copy( box.min );
				this.max.copy( box.max );

				return this;

			},

			makeEmpty: function () {

				this.min.x = this.min.y = + Infinity;
				this.max.x = this.max.y = - Infinity;

				return this;

			},

			isEmpty: function () {

				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

			},

			getSize: function ( optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

			},

			expandByPoint: function ( point ) {

				this.min.min( point );
				this.max.max( point );

				return this;

			},

			expandByVector: function ( vector ) {

				this.min.sub( vector );
				this.max.add( vector );

				return this;

			},

			expandByScalar: function ( scalar ) {

				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );

				return this;

			},

			containsPoint: function ( point ) {

				if ( point.x < this.min.x || point.x > this.max.x ||
				     point.y < this.min.y || point.y > this.max.y ) {

					return false;

				}

				return true;

			},

			containsBox: function ( box ) {

				if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

					return true;

				}

				return false;

			},

			getParameter: function ( point, optionalTarget ) {

				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.

				var result = optionalTarget || new Vector2();

				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y )
				);

			},

			intersectsBox: function ( box ) {

				// using 6 splitting planes to rule out intersections.

				if ( box.max.x < this.min.x || box.min.x > this.max.x ||
				     box.max.y < this.min.y || box.min.y > this.max.y ) {

					return false;

				}

				return true;

			},

			clampPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return result.copy( point ).clamp( this.min, this.max );

			},

			distanceToPoint: function () {

				var v1 = new Vector2();

				return function distanceToPoint( point ) {

					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();

				};

			}(),

			intersect: function ( box ) {

				this.min.max( box.min );
				this.max.min( box.max );

				return this;

			},

			union: function ( box ) {

				this.min.min( box.min );
				this.max.max( box.max );

				return this;

			},

			translate: function ( offset ) {

				this.min.add( offset );
				this.max.add( offset );

				return this;

			},

			equals: function ( box ) {

				return box.min.equals( this.min ) && box.max.equals( this.max );

			}

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function LensFlarePlugin( renderer, flares ) {

			var gl = renderer.context;
			var state = renderer.state;

			var vertexBuffer, elementBuffer;
			var shader, program, attributes, uniforms;

			var tempTexture, occlusionTexture;

			function init() {

				var vertices = new Float32Array( [
					- 1, - 1,  0, 0,
					 1, - 1,  1, 0,
					 1,  1,  1, 1,
					- 1,  1,  0, 1
				] );

				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );

				// buffers

				vertexBuffer     = gl.createBuffer();
				elementBuffer    = gl.createBuffer();

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

				// textures

				tempTexture      = gl.createTexture();
				occlusionTexture = gl.createTexture();

				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if ( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if ( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if ( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

				program = createProgram( shader );

				attributes = {
					vertex: gl.getAttribLocation ( program, "position" ),
					uv:     gl.getAttribLocation ( program, "uv" )
				};

				uniforms = {
					renderType:     gl.getUniformLocation( program, "renderType" ),
					map:            gl.getUniformLocation( program, "map" ),
					occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
					opacity:        gl.getUniformLocation( program, "opacity" ),
					color:          gl.getUniformLocation( program, "color" ),
					scale:          gl.getUniformLocation( program, "scale" ),
					rotation:       gl.getUniformLocation( program, "rotation" ),
					screenPosition: gl.getUniformLocation( program, "screenPosition" )
				};

			}

			/*
			 * Render lens flares
			 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
			 *         reads these back and calculates occlusion.
			 */

			this.render = function ( scene, camera, viewport ) {

				if ( flares.length === 0 ) return;

				var tempPosition = new Vector3();

				var invAspect = viewport.w / viewport.z,
					halfViewportWidth = viewport.z * 0.5,
					halfViewportHeight = viewport.w * 0.5;

				var size = 16 / viewport.w,
					scale = new Vector2( size * invAspect, size );

				var screenPosition = new Vector3( 1, 1, 0 ),
					screenPositionPixels = new Vector2( 1, 1 );

				var validArea = new Box2();

				validArea.min.set( viewport.x, viewport.y );
				validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

				if ( program === undefined ) {

					init();

				}

				gl.useProgram( program );

				state.initAttributes();
				state.enableAttribute( attributes.vertex );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();

				// loop through all lens flares to update their occlusion and positions
				// setup gl and common used attribs/uniforms

				gl.uniform1i( uniforms.occlusionMap, 0 );
				gl.uniform1i( uniforms.map, 1 );

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

				state.disable( gl.CULL_FACE );
				state.setDepthWrite( false );

				for ( var i = 0, l = flares.length; i < l; i ++ ) {

					size = 16 / viewport.w;
					scale.set( size * invAspect, size );

					// calc object screen position

					var flare = flares[ i ];

					tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

					tempPosition.applyMatrix4( camera.matrixWorldInverse );
					tempPosition.applyProjection( camera.projectionMatrix );

					// setup arrays for gl programs

					screenPosition.copy( tempPosition );

					// horizontal and vertical coordinate of the lower left corner of the pixels to copy

					screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
					screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

					// screen cull

					if ( validArea.containsPoint( screenPositionPixels ) === true ) {

						// save current RGB to temp texture

						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, null );
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


						// render pink quad

						gl.uniform1i( uniforms.renderType, 0 );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

						state.disable( gl.BLEND );
						state.enable( gl.DEPTH_TEST );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


						// copy result to occlusionMap

						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


						// restore graphics

						gl.uniform1i( uniforms.renderType, 1 );
						state.disable( gl.DEPTH_TEST );

						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


						// update object positions

						flare.positionScreen.copy( screenPosition );

						if ( flare.customUpdateCallback ) {

							flare.customUpdateCallback( flare );

						} else {

							flare.updateLensFlares();

						}

						// render flares

						gl.uniform1i( uniforms.renderType, 2 );
						state.enable( gl.BLEND );

						for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

							var sprite = flare.lensFlares[ j ];

							if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

								screenPosition.x = sprite.x;
								screenPosition.y = sprite.y;
								screenPosition.z = sprite.z;

								size = sprite.size * sprite.scale / viewport.w;

								scale.x = size * invAspect;
								scale.y = size;

								gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
								gl.uniform2f( uniforms.scale, scale.x, scale.y );
								gl.uniform1f( uniforms.rotation, sprite.rotation );

								gl.uniform1f( uniforms.opacity, sprite.opacity );
								gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

								state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
								renderer.setTexture2D( sprite.texture, 1 );

								gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

							}

						}

					}

				}

				// restore gl

				state.enable( gl.CULL_FACE );
				state.enable( gl.DEPTH_TEST );
				state.setDepthWrite( true );

				renderer.resetGLState();

			};

			function createProgram( shader ) {

				var program = gl.createProgram();

				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );

				var prefix = "precision " + renderer.getPrecision() + " float;\n";

				gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
				gl.shaderSource( vertexShader, prefix + shader.vertexShader );

				gl.compileShader( fragmentShader );
				gl.compileShader( vertexShader );

				gl.attachShader( program, fragmentShader );
				gl.attachShader( program, vertexShader );

				gl.linkProgram( program );

				return program;

			}

		}

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function SpritePlugin( renderer, sprites ) {

			var gl = renderer.context;
			var state = renderer.state;

			var vertexBuffer, elementBuffer;
			var program, attributes, uniforms;

			var texture;

			// decompose matrixWorld

			var spritePosition = new Vector3();
			var spriteRotation = new Quaternion();
			var spriteScale = new Vector3();

			function init() {

				var vertices = new Float32Array( [
					- 0.5, - 0.5,  0, 0,
					  0.5, - 0.5,  1, 0,
					  0.5,   0.5,  1, 1,
					- 0.5,   0.5,  0, 1
				] );

				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );

				vertexBuffer  = gl.createBuffer();
				elementBuffer = gl.createBuffer();

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

				program = createProgram();

				attributes = {
					position:			gl.getAttribLocation ( program, 'position' ),
					uv:					gl.getAttribLocation ( program, 'uv' )
				};

				uniforms = {
					uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
					uvScale:			gl.getUniformLocation( program, 'uvScale' ),

					rotation:			gl.getUniformLocation( program, 'rotation' ),
					scale:				gl.getUniformLocation( program, 'scale' ),

					color:				gl.getUniformLocation( program, 'color' ),
					map:				gl.getUniformLocation( program, 'map' ),
					opacity:			gl.getUniformLocation( program, 'opacity' ),

					modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
					projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

					fogType:			gl.getUniformLocation( program, 'fogType' ),
					fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
					fogNear:			gl.getUniformLocation( program, 'fogNear' ),
					fogFar:				gl.getUniformLocation( program, 'fogFar' ),
					fogColor:			gl.getUniformLocation( program, 'fogColor' ),

					alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
				};

				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = 8;
				canvas.height = 8;

				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 0, 8, 8 );

				texture = new Texture( canvas );
				texture.needsUpdate = true;

			}

			this.render = function ( scene, camera ) {

				if ( sprites.length === 0 ) return;

				// setup gl

				if ( program === undefined ) {

					init();

				}

				gl.useProgram( program );

				state.initAttributes();
				state.enableAttribute( attributes.position );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();

				state.disable( gl.CULL_FACE );
				state.enable( gl.BLEND );

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

				gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				state.activeTexture( gl.TEXTURE0 );
				gl.uniform1i( uniforms.map, 0 );

				var oldFogType = 0;
				var sceneFogType = 0;
				var fog = scene.fog;

				if ( fog ) {

					gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

					if ( (fog && fog.isFog) ) {

						gl.uniform1f( uniforms.fogNear, fog.near );
						gl.uniform1f( uniforms.fogFar, fog.far );

						gl.uniform1i( uniforms.fogType, 1 );
						oldFogType = 1;
						sceneFogType = 1;

					} else if ( (fog && fog.isFogExp2) ) {

						gl.uniform1f( uniforms.fogDensity, fog.density );

						gl.uniform1i( uniforms.fogType, 2 );
						oldFogType = 2;
						sceneFogType = 2;

					}

				} else {

					gl.uniform1i( uniforms.fogType, 0 );
					oldFogType = 0;
					sceneFogType = 0;

				}


				// update positions and sort

				for ( var i = 0, l = sprites.length; i < l; i ++ ) {

					var sprite = sprites[ i ];

					sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
					sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

				}

				sprites.sort( painterSortStable );

				// render all sprites

				var scale = [];

				for ( var i = 0, l = sprites.length; i < l; i ++ ) {

					var sprite = sprites[ i ];
					var material = sprite.material;

					if ( material.visible === false ) continue;

					gl.uniform1f( uniforms.alphaTest, material.alphaTest );
					gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

					sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

					scale[ 0 ] = spriteScale.x;
					scale[ 1 ] = spriteScale.y;

					var fogType = 0;

					if ( scene.fog && material.fog ) {

						fogType = sceneFogType;

					}

					if ( oldFogType !== fogType ) {

						gl.uniform1i( uniforms.fogType, fogType );
						oldFogType = fogType;

					}

					if ( material.map !== null ) {

						gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
						gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

					} else {

						gl.uniform2f( uniforms.uvOffset, 0, 0 );
						gl.uniform2f( uniforms.uvScale, 1, 1 );

					}

					gl.uniform1f( uniforms.opacity, material.opacity );
					gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

					gl.uniform1f( uniforms.rotation, material.rotation );
					gl.uniform2fv( uniforms.scale, scale );

					state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
					state.setDepthTest( material.depthTest );
					state.setDepthWrite( material.depthWrite );

					if ( material.map ) {

						renderer.setTexture2D( material.map, 0 );

					} else {

						renderer.setTexture2D( texture, 0 );

					}

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

				}

				// restore gl

				state.enable( gl.CULL_FACE );

				renderer.resetGLState();

			};

			function createProgram() {

				var program = gl.createProgram();

				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

				gl.shaderSource( vertexShader, [

					'precision ' + renderer.getPrecision() + ' float;',

					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform float rotation;',
					'uniform vec2 scale;',
					'uniform vec2 uvOffset;',
					'uniform vec2 uvScale;',

					'attribute vec2 position;',
					'attribute vec2 uv;',

					'varying vec2 vUV;',

					'void main() {',

						'vUV = uvOffset + uv * uvScale;',

						'vec2 alignedPosition = position * scale;',

						'vec2 rotatedPosition;',
						'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
						'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

						'vec4 finalPosition;',

						'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
						'finalPosition.xy += rotatedPosition;',
						'finalPosition = projectionMatrix * finalPosition;',

						'gl_Position = finalPosition;',

					'}'

				].join( '\n' ) );

				gl.shaderSource( fragmentShader, [

					'precision ' + renderer.getPrecision() + ' float;',

					'uniform vec3 color;',
					'uniform sampler2D map;',
					'uniform float opacity;',

					'uniform int fogType;',
					'uniform vec3 fogColor;',
					'uniform float fogDensity;',
					'uniform float fogNear;',
					'uniform float fogFar;',
					'uniform float alphaTest;',

					'varying vec2 vUV;',

					'void main() {',

						'vec4 texture = texture2D( map, vUV );',

						'if ( texture.a < alphaTest ) discard;',

						'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

						'if ( fogType > 0 ) {',

							'float depth = gl_FragCoord.z / gl_FragCoord.w;',
							'float fogFactor = 0.0;',

							'if ( fogType == 1 ) {',

								'fogFactor = smoothstep( fogNear, fogFar, depth );',

							'} else {',

								'const float LOG2 = 1.442695;',
								'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
								'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

							'}',

							'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

						'}',

					'}'

				].join( '\n' ) );

				gl.compileShader( vertexShader );
				gl.compileShader( fragmentShader );

				gl.attachShader( program, vertexShader );
				gl.attachShader( program, fragmentShader );

				gl.linkProgram( program );

				return program;

			}

			function painterSortStable( a, b ) {

				if ( a.renderOrder !== b.renderOrder ) {

					return a.renderOrder - b.renderOrder;

				} else if ( a.z !== b.z ) {

					return b.z - a.z;

				} else {

					return b.id - a.id;

				}

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Material() {

			Object.defineProperty( this, 'id', { value: MaterialIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Material';

			this.fog = true;
			this.lights = true;

			this.blending = NormalBlending;
			this.side = FrontSide;
			this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
			this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

			this.opacity = 1;
			this.transparent = false;

			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;

			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;

			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;

			this.colorWrite = true;

			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;

			this.alphaTest = 0;
			this.premultipliedAlpha = false;

			this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

			this.visible = true;

			this._needsUpdate = true;

		}

		Material.prototype = {

			constructor: Material,

			isMaterial: true,

			get needsUpdate() {

				return this._needsUpdate;

			},

			set needsUpdate( value ) {

				if ( value === true ) this.update();
				this._needsUpdate = value;

			},

			setValues: function ( values ) {

				if ( values === undefined ) return;

				for ( var key in values ) {

					var newValue = values[ key ];

					if ( newValue === undefined ) {

						console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
						continue;

					}

					var currentValue = this[ key ];

					if ( currentValue === undefined ) {

						console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
						continue;

					}

					if ( (currentValue && currentValue.isColor) ) {

						currentValue.set( newValue );

					} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {

						currentValue.copy( newValue );

					} else if ( key === 'overdraw' ) {

						// ensure overdraw is backwards-compatible with legacy boolean type
						this[ key ] = Number( newValue );

					} else {

						this[ key ] = newValue;

					}

				}

			},

			toJSON: function ( meta ) {

				var isRoot = meta === undefined;

				if ( isRoot ) {

					meta = {
						textures: {},
						images: {}
					};

				}

				var data = {
					metadata: {
						version: 4.4,
						type: 'Material',
						generator: 'Material.toJSON'
					}
				};

				// standard Material serialization
				data.uuid = this.uuid;
				data.type = this.type;

				if ( this.name !== '' ) data.name = this.name;

				if ( (this.color && this.color.isColor) ) data.color = this.color.getHex();

				if ( this.roughness !== undefined ) data.roughness = this.roughness;
				if ( this.metalness !== undefined ) data.metalness = this.metalness;

				if ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();
				if ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();
				if ( this.shininess !== undefined ) data.shininess = this.shininess;

				if ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;
				if ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
				if ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
				if ( (this.bumpMap && this.bumpMap.isTexture) ) {

					data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
					data.bumpScale = this.bumpScale;

				}
				if ( (this.normalMap && this.normalMap.isTexture) ) {

					data.normalMap = this.normalMap.toJSON( meta ).uuid;
					data.normalScale = this.normalScale.toArray();

				}
				if ( (this.displacementMap && this.displacementMap.isTexture) ) {

					data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
					data.displacementScale = this.displacementScale;
					data.displacementBias = this.displacementBias;

				}
				if ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
				if ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

				if ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
				if ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

				if ( (this.envMap && this.envMap.isTexture) ) {

					data.envMap = this.envMap.toJSON( meta ).uuid;
					data.reflectivity = this.reflectivity; // Scale behind envMap

				}

				if ( this.size !== undefined ) data.size = this.size;
				if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

				if ( this.blending !== NormalBlending ) data.blending = this.blending;
				if ( this.shading !== SmoothShading ) data.shading = this.shading;
				if ( this.side !== FrontSide ) data.side = this.side;
				if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

				if ( this.opacity < 1 ) data.opacity = this.opacity;
				if ( this.transparent === true ) data.transparent = this.transparent;

				data.depthFunc = this.depthFunc;
				data.depthTest = this.depthTest;
				data.depthWrite = this.depthWrite;

				if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
				if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
				if ( this.wireframe === true ) data.wireframe = this.wireframe;
				if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
				if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
				if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

				data.skinning = this.skinning;
				data.morphTargets = this.morphTargets;

				// TODO: Copied from Object3D.toJSON

				function extractFromCache( cache ) {

					var values = [];

					for ( var key in cache ) {

						var data = cache[ key ];
						delete data.metadata;
						values.push( data );

					}

					return values;

				}

				if ( isRoot ) {

					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );

					if ( textures.length > 0 ) data.textures = textures;
					if ( images.length > 0 ) data.images = images;

				}

				return data;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.name = source.name;

				this.fog = source.fog;
				this.lights = source.lights;

				this.blending = source.blending;
				this.side = source.side;
				this.shading = source.shading;
				this.vertexColors = source.vertexColors;

				this.opacity = source.opacity;
				this.transparent = source.transparent;

				this.blendSrc = source.blendSrc;
				this.blendDst = source.blendDst;
				this.blendEquation = source.blendEquation;
				this.blendSrcAlpha = source.blendSrcAlpha;
				this.blendDstAlpha = source.blendDstAlpha;
				this.blendEquationAlpha = source.blendEquationAlpha;

				this.depthFunc = source.depthFunc;
				this.depthTest = source.depthTest;
				this.depthWrite = source.depthWrite;

				this.colorWrite = source.colorWrite;

				this.precision = source.precision;

				this.polygonOffset = source.polygonOffset;
				this.polygonOffsetFactor = source.polygonOffsetFactor;
				this.polygonOffsetUnits = source.polygonOffsetUnits;

				this.alphaTest = source.alphaTest;

				this.premultipliedAlpha = source.premultipliedAlpha;

				this.overdraw = source.overdraw;

				this.visible = source.visible;
				this.clipShadows = source.clipShadows;
				this.clipIntersection = source.clipIntersection;

				var srcPlanes = source.clippingPlanes,
					dstPlanes = null;

				if ( srcPlanes !== null ) {

					var n = srcPlanes.length;
					dstPlanes = new Array( n );

					for ( var i = 0; i !== n; ++ i )
						dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

				this.clippingPlanes = dstPlanes;

				return this;

			},

			update: function () {

				this.dispatchEvent( { type: 'update' } );

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		};

		Object.assign( Material.prototype, EventDispatcher.prototype );

		var count$1 = 0;
		function MaterialIdCount() { return count$1++; }

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function ShaderMaterial( parameters ) {

			Material.call( this );

			this.type = 'ShaderMaterial';

			this.defines = {};
			this.uniforms = {};

			this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
			this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

			this.linewidth = 1;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes

			this.skinning = false; // set to use skinning attribute streams
			this.morphTargets = false; // set to use morph targets
			this.morphNormals = false; // set to use morph normals

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};

			this.index0AttributeName = undefined;

			if ( parameters !== undefined ) {

				if ( parameters.attributes !== undefined ) {

					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

				}

				this.setValues( parameters );

			}

		}

		ShaderMaterial.prototype = Object.create( Material.prototype );
		ShaderMaterial.prototype.constructor = ShaderMaterial;

		ShaderMaterial.prototype.isShaderMaterial = true;

		ShaderMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = UniformsUtils.clone( source.uniforms );

			this.defines = source.defines;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.lights = source.lights;
			this.clipping = source.clipping;

			this.skinning = source.skinning;

			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.extensions = source.extensions;

			return this;

		};

		ShaderMaterial.prototype.toJSON = function ( meta ) {

			var data = Material.prototype.toJSON.call( this, meta );

			data.uniforms = this.uniforms;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			return data;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */

		function MeshDepthMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;
			this.lights = false;

			this.setValues( parameters );

		}

		MeshDepthMaterial.prototype = Object.create( Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

		MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

		MeshDepthMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.depthPacking = source.depthPacking;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Box3( min, max ) {

			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

		}

		Box3.prototype = {

			constructor: Box3,

			isBox3: true,

			set: function ( min, max ) {

				this.min.copy( min );
				this.max.copy( max );

				return this;

			},

			setFromArray: function ( array ) {

				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;

				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var x = array[ i ];
					var y = array[ i + 1 ];
					var z = array[ i + 2 ];

					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;

					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;

				}

				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );

			},

			setFromPoints: function ( points ) {

				this.makeEmpty();

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					this.expandByPoint( points[ i ] );

				}

				return this;

			},

			setFromCenterAndSize: function () {

				var v1 = new Vector3();

				return function setFromCenterAndSize( center, size ) {

					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );

					return this;

				};

			}(),

			setFromObject: function () {

				// Computes the world-axis-aligned bounding box of an object (including its children),
				// accounting for both the object's, and children's, world transforms

				var v1 = new Vector3();

				return function setFromObject( object ) {

					var scope = this;

					object.updateMatrixWorld( true );

					this.makeEmpty();

					object.traverse( function ( node ) {

						var geometry = node.geometry;

						if ( geometry !== undefined ) {

							if ( (geometry && geometry.isGeometry) ) {

								var vertices = geometry.vertices;

								for ( var i = 0, il = vertices.length; i < il; i ++ ) {

									v1.copy( vertices[ i ] );
									v1.applyMatrix4( node.matrixWorld );

									scope.expandByPoint( v1 );

								}

							} else if ( (geometry && geometry.isBufferGeometry) ) {

								var attribute = geometry.attributes.position;

								if ( attribute !== undefined ) {

									var array, offset, stride;

									if ( (attribute && attribute.isInterleavedBufferAttribute) ) {

										array = attribute.data.array;
										offset = attribute.offset;
										stride = attribute.data.stride;

									} else {

										array = attribute.array;
										offset = 0;
										stride = 3;

									}

									for ( var i = offset, il = array.length; i < il; i += stride ) {

										v1.fromArray( array, i );
										v1.applyMatrix4( node.matrixWorld );

										scope.expandByPoint( v1 );

									}

								}

							}

						}

					} );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( box ) {

				this.min.copy( box.min );
				this.max.copy( box.max );

				return this;

			},

			makeEmpty: function () {

				this.min.x = this.min.y = this.min.z = + Infinity;
				this.max.x = this.max.y = this.max.z = - Infinity;

				return this;

			},

			isEmpty: function () {

				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

			},

			getSize: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

			},

			expandByPoint: function ( point ) {

				this.min.min( point );
				this.max.max( point );

				return this;

			},

			expandByVector: function ( vector ) {

				this.min.sub( vector );
				this.max.add( vector );

				return this;

			},

			expandByScalar: function ( scalar ) {

				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );

				return this;

			},

			containsPoint: function ( point ) {

				if ( point.x < this.min.x || point.x > this.max.x ||
						 point.y < this.min.y || point.y > this.max.y ||
						 point.z < this.min.z || point.z > this.max.z ) {

					return false;

				}

				return true;

			},

			containsBox: function ( box ) {

				if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
					 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
					 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

					return true;

				}

				return false;

			},

			getParameter: function ( point, optionalTarget ) {

				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.

				var result = optionalTarget || new Vector3();

				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y ),
					( point.z - this.min.z ) / ( this.max.z - this.min.z )
				);

			},

			intersectsBox: function ( box ) {

				// using 6 splitting planes to rule out intersections.

				if ( box.max.x < this.min.x || box.min.x > this.max.x ||
						 box.max.y < this.min.y || box.min.y > this.max.y ||
						 box.max.z < this.min.z || box.min.z > this.max.z ) {

					return false;

				}

				return true;

			},

			intersectsSphere: ( function () {

				var closestPoint;

				return function intersectsSphere( sphere ) {

					if ( closestPoint === undefined ) closestPoint = new Vector3();

					// Find the point on the AABB closest to the sphere center.
					this.clampPoint( sphere.center, closestPoint );

					// If that point is inside the sphere, the AABB and sphere intersect.
					return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

				};

			} )(),

			intersectsPlane: function ( plane ) {

				// We compute the minimum and maximum dot product values. If those values
				// are on the same side (back or front) of the plane, then there is no intersection.

				var min, max;

				if ( plane.normal.x > 0 ) {

					min = plane.normal.x * this.min.x;
					max = plane.normal.x * this.max.x;

				} else {

					min = plane.normal.x * this.max.x;
					max = plane.normal.x * this.min.x;

				}

				if ( plane.normal.y > 0 ) {

					min += plane.normal.y * this.min.y;
					max += plane.normal.y * this.max.y;

				} else {

					min += plane.normal.y * this.max.y;
					max += plane.normal.y * this.min.y;

				}

				if ( plane.normal.z > 0 ) {

					min += plane.normal.z * this.min.z;
					max += plane.normal.z * this.max.z;

				} else {

					min += plane.normal.z * this.max.z;
					max += plane.normal.z * this.min.z;

				}

				return ( min <= plane.constant && max >= plane.constant );

			},

			clampPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.copy( point ).clamp( this.min, this.max );

			},

			distanceToPoint: function () {

				var v1 = new Vector3();

				return function distanceToPoint( point ) {

					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();

				};

			}(),

			getBoundingSphere: function () {

				var v1 = new Vector3();

				return function getBoundingSphere( optionalTarget ) {

					var result = optionalTarget || new Sphere();

					this.getCenter( result.center );

					result.radius = this.getSize( v1 ).length() * 0.5;

					return result;

				};

			}(),

			intersect: function ( box ) {

				this.min.max( box.min );
				this.max.min( box.max );

				// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
				if( this.isEmpty() ) this.makeEmpty();

				return this;

			},

			union: function ( box ) {

				this.min.min( box.min );
				this.max.max( box.max );

				return this;

			},

			applyMatrix4: function () {

				var points = [
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3()
				];

				return function applyMatrix4( matrix ) {

					// transform of empty box is an empty box.
					if( this.isEmpty() ) return this;

					// NOTE: I am using a binary pattern to specify all 2^3 combinations below
					points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
					points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
					points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
					points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
					points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
					points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
					points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
					points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

					this.setFromPoints( points );

					return this;

				};

			}(),

			translate: function ( offset ) {

				this.min.add( offset );
				this.max.add( offset );

				return this;

			},

			equals: function ( box ) {

				return box.min.equals( this.min ) && box.max.equals( this.max );

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Sphere( center, radius ) {

			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : 0;

		}

		Sphere.prototype = {

			constructor: Sphere,

			set: function ( center, radius ) {

				this.center.copy( center );
				this.radius = radius;

				return this;

			},

			setFromPoints: function () {

				var box = new Box3();

				return function setFromPoints( points, optionalCenter ) {

					var center = this.center;

					if ( optionalCenter !== undefined ) {

						center.copy( optionalCenter );

					} else {

						box.setFromPoints( points ).getCenter( center );

					}

					var maxRadiusSq = 0;

					for ( var i = 0, il = points.length; i < il; i ++ ) {

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

					}

					this.radius = Math.sqrt( maxRadiusSq );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( sphere ) {

				this.center.copy( sphere.center );
				this.radius = sphere.radius;

				return this;

			},

			empty: function () {

				return ( this.radius <= 0 );

			},

			containsPoint: function ( point ) {

				return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

			},

			distanceToPoint: function ( point ) {

				return ( point.distanceTo( this.center ) - this.radius );

			},

			intersectsSphere: function ( sphere ) {

				var radiusSum = this.radius + sphere.radius;

				return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

			},

			intersectsBox: function ( box ) {

				return box.intersectsSphere( this );

			},

			intersectsPlane: function ( plane ) {

				// We use the following equation to compute the signed distance from
				// the center of the sphere to the plane.
				//
				// distance = q * n - d
				//
				// If this distance is greater than the radius of the sphere,
				// then there is no intersection.

				return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

			},

			clampPoint: function ( point, optionalTarget ) {

				var deltaLengthSq = this.center.distanceToSquared( point );

				var result = optionalTarget || new Vector3();

				result.copy( point );

				if ( deltaLengthSq > ( this.radius * this.radius ) ) {

					result.sub( this.center ).normalize();
					result.multiplyScalar( this.radius ).add( this.center );

				}

				return result;

			},

			getBoundingBox: function ( optionalTarget ) {

				var box = optionalTarget || new Box3();

				box.set( this.center, this.center );
				box.expandByScalar( this.radius );

				return box;

			},

			applyMatrix4: function ( matrix ) {

				this.center.applyMatrix4( matrix );
				this.radius = this.radius * matrix.getMaxScaleOnAxis();

				return this;

			},

			translate: function ( offset ) {

				this.center.add( offset );

				return this;

			},

			equals: function ( sphere ) {

				return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */

		function Matrix3() {

			this.elements = new Float32Array( [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			] );

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		Matrix3.prototype = {

			constructor: Matrix3,

			isMatrix3: true,

			set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

				var te = this.elements;

				te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
				te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
				te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

				return this;

			},

			identity: function () {

				this.set(

					1, 0, 0,
					0, 1, 0,
					0, 0, 1

				);

				return this;

			},

			clone: function () {

				return new this.constructor().fromArray( this.elements );

			},

			copy: function ( m ) {

				var me = m.elements;

				this.set(

					me[ 0 ], me[ 3 ], me[ 6 ],
					me[ 1 ], me[ 4 ], me[ 7 ],
					me[ 2 ], me[ 5 ], me[ 8 ]

				);

				return this;

			},

			setFromMatrix4: function( m ) {

				var me = m.elements;

				this.set(

					me[ 0 ], me[ 4 ], me[  8 ],
					me[ 1 ], me[ 5 ], me[  9 ],
					me[ 2 ], me[ 6 ], me[ 10 ]

				);

				return this;

			},

			applyToVector3Array: function () {

				var v1;

				return function applyToVector3Array( array, offset, length ) {

					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = array.length;

					for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

						v1.fromArray( array, j );
						v1.applyMatrix3( this );
						v1.toArray( array, j );

					}

					return array;

				};

			}(),

			applyToBuffer: function () {

				var v1;

				return function applyToBuffer( buffer, offset, length ) {

					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = buffer.length / buffer.itemSize;

					for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

						v1.x = buffer.getX( j );
						v1.y = buffer.getY( j );
						v1.z = buffer.getZ( j );

						v1.applyMatrix3( this );

						buffer.setXYZ( j, v1.x, v1.y, v1.z );

					}

					return buffer;

				};

			}(),

			multiplyScalar: function ( s ) {

				var te = this.elements;

				te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
				te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
				te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

				return this;

			},

			determinant: function () {

				var te = this.elements;

				var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
					d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
					g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

			},

			getInverse: function ( matrix, throwOnDegenerate ) {

				if ( (matrix && matrix.isMatrix4) ) {

					console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

				}

				var me = matrix.elements,
					te = this.elements,

					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
					n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
					n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,

					det = n11 * t11 + n21 * t12 + n31 * t13;

				if ( det === 0 ) {

					var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

					if ( throwOnDegenerate === true ) {

						throw new Error( msg );

					} else {

						console.warn( msg );

					}

					return this.identity();
				}

				var detInv = 1 / det;

				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
				te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

				te[ 3 ] = t12 * detInv;
				te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
				te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

				te[ 6 ] = t13 * detInv;
				te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
				te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

				return this;

			},

			transpose: function () {

				var tmp, m = this.elements;

				tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
				tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
				tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

				return this;

			},

			flattenToArrayOffset: function ( array, offset ) {

				console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
						"- just use .toArray instead." );

				return this.toArray( array, offset );

			},

			getNormalMatrix: function ( matrix4 ) {

				return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

			},

			transposeIntoArray: function ( r ) {

				var m = this.elements;

				r[ 0 ] = m[ 0 ];
				r[ 1 ] = m[ 3 ];
				r[ 2 ] = m[ 6 ];
				r[ 3 ] = m[ 1 ];
				r[ 4 ] = m[ 4 ];
				r[ 5 ] = m[ 7 ];
				r[ 6 ] = m[ 2 ];
				r[ 7 ] = m[ 5 ];
				r[ 8 ] = m[ 8 ];

				return this;

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				for( var i = 0; i < 9; i ++ ) {

					this.elements[ i ] = array[ i + offset ];

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				var te = this.elements;

				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];

				array[ offset + 3 ] = te[ 3 ];
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];

				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
				array[ offset + 8 ]  = te[ 8 ];

				return array;

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 */

		function Plane( normal, constant ) {

			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;

		}

		Plane.prototype = {

			constructor: Plane,

			set: function ( normal, constant ) {

				this.normal.copy( normal );
				this.constant = constant;

				return this;

			},

			setComponents: function ( x, y, z, w ) {

				this.normal.set( x, y, z );
				this.constant = w;

				return this;

			},

			setFromNormalAndCoplanarPoint: function ( normal, point ) {

				this.normal.copy( normal );
				this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

				return this;

			},

			setFromCoplanarPoints: function () {

				var v1 = new Vector3();
				var v2 = new Vector3();

				return function setFromCoplanarPoints( a, b, c ) {

					var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

					// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

					this.setFromNormalAndCoplanarPoint( normal, a );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( plane ) {

				this.normal.copy( plane.normal );
				this.constant = plane.constant;

				return this;

			},

			normalize: function () {

				// Note: will lead to a divide by zero if the plane is invalid.

				var inverseNormalLength = 1.0 / this.normal.length();
				this.normal.multiplyScalar( inverseNormalLength );
				this.constant *= inverseNormalLength;

				return this;

			},

			negate: function () {

				this.constant *= - 1;
				this.normal.negate();

				return this;

			},

			distanceToPoint: function ( point ) {

				return this.normal.dot( point ) + this.constant;

			},

			distanceToSphere: function ( sphere ) {

				return this.distanceToPoint( sphere.center ) - sphere.radius;

			},

			projectPoint: function ( point, optionalTarget ) {

				return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

			},

			orthoPoint: function ( point, optionalTarget ) {

				var perpendicularMagnitude = this.distanceToPoint( point );

				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

			},

			intersectLine: function () {

				var v1 = new Vector3();

				return function intersectLine( line, optionalTarget ) {

					var result = optionalTarget || new Vector3();

					var direction = line.delta( v1 );

					var denominator = this.normal.dot( direction );

					if ( denominator === 0 ) {

						// line is coplanar, return origin
						if ( this.distanceToPoint( line.start ) === 0 ) {

							return result.copy( line.start );

						}

						// Unsure if this is the correct method to handle this case.
						return undefined;

					}

					var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

					if ( t < 0 || t > 1 ) {

						return undefined;

					}

					return result.copy( direction ).multiplyScalar( t ).add( line.start );

				};

			}(),

			intersectsLine: function ( line ) {

				// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

				var startSign = this.distanceToPoint( line.start );
				var endSign = this.distanceToPoint( line.end );

				return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

			},

			intersectsBox: function ( box ) {

				return box.intersectsPlane( this );

			},

			intersectsSphere: function ( sphere ) {

				return sphere.intersectsPlane( this );

			},

			coplanarPoint: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( - this.constant );

			},

			applyMatrix4: function () {

				var v1 = new Vector3();
				var m1 = new Matrix3();

				return function applyMatrix4( matrix, optionalNormalMatrix ) {

					var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

					// transform normal based on theory here:
					// http://www.songho.ca/opengl/gl_normaltransform.html
					var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
					var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

					// recalculate constant (like in setFromNormalAndCoplanarPoint)
					this.constant = - referencePoint.dot( normal );

					return this;

				};

			}(),

			translate: function ( offset ) {

				this.constant = this.constant - offset.dot( this.normal );

				return this;

			},

			equals: function ( plane ) {

				return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */

		function Frustum( p0, p1, p2, p3, p4, p5 ) {

			this.planes = [

				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()

			];

		}

		Frustum.prototype = {

			constructor: Frustum,

			set: function ( p0, p1, p2, p3, p4, p5 ) {

				var planes = this.planes;

				planes[ 0 ].copy( p0 );
				planes[ 1 ].copy( p1 );
				planes[ 2 ].copy( p2 );
				planes[ 3 ].copy( p3 );
				planes[ 4 ].copy( p4 );
				planes[ 5 ].copy( p5 );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( frustum ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					planes[ i ].copy( frustum.planes[ i ] );

				}

				return this;

			},

			setFromMatrix: function ( m ) {

				var planes = this.planes;
				var me = m.elements;
				var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
				var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
				var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
				var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

				planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
				planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
				planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
				planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

				return this;

			},

			intersectsObject: function () {

				var sphere = new Sphere();

				return function intersectsObject( object ) {

					var geometry = object.geometry;

					if ( geometry.boundingSphere === null )
						geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere )
						.applyMatrix4( object.matrixWorld );

					return this.intersectsSphere( sphere );

				};

			}(),

			intersectsSprite: function () {

				var sphere = new Sphere();

				return function intersectsSprite( sprite ) {

					sphere.center.set( 0, 0, 0 );
					sphere.radius = 0.7071067811865476;
					sphere.applyMatrix4( sprite.matrixWorld );

					return this.intersectsSphere( sphere );

				};

			}(),

			intersectsSphere: function ( sphere ) {

				var planes = this.planes;
				var center = sphere.center;
				var negRadius = - sphere.radius;

				for ( var i = 0; i < 6; i ++ ) {

					var distance = planes[ i ].distanceToPoint( center );

					if ( distance < negRadius ) {

						return false;

					}

				}

				return true;

			},

			intersectsBox: function () {

				var p1 = new Vector3(),
					p2 = new Vector3();

				return function intersectsBox( box ) {

					var planes = this.planes;

					for ( var i = 0; i < 6 ; i ++ ) {

						var plane = planes[ i ];

						p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
						p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
						p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
						p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
						p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
						p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

						var d1 = plane.distanceToPoint( p1 );
						var d2 = plane.distanceToPoint( p2 );

						// if both outside plane, no intersection

						if ( d1 < 0 && d2 < 0 ) {

							return false;

						}

					}

					return true;

				};

			}(),


			containsPoint: function ( point ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					if ( planes[ i ].distanceToPoint( point ) < 0 ) {

						return false;

					}

				}

				return true;

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

			var _gl = _renderer.context,
			_state = _renderer.state,
			_frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_lightShadows = _lights.shadows,

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_renderList = [],

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

			var cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			var cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

			var cube2DViewPorts = [
				new Vector4(), new Vector4(), new Vector4(),
				new Vector4(), new Vector4(), new Vector4()
			];

			// init

			var depthMaterialTemplate = new MeshDepthMaterial();
			depthMaterialTemplate.depthPacking = RGBADepthPacking;
			depthMaterialTemplate.clipping = true;

			var distanceShader = ShaderLib[ "distanceRGBA" ];
			var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );

			for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

				var useMorphing = ( i & _MorphingFlag ) !== 0;
				var useSkinning = ( i & _SkinningFlag ) !== 0;

				var depthMaterial = depthMaterialTemplate.clone();
				depthMaterial.morphTargets = useMorphing;
				depthMaterial.skinning = useSkinning;

				_depthMaterials[ i ] = depthMaterial;

				var distanceMaterial = new ShaderMaterial( {
					defines: {
						'USE_SHADOWMAP': ''
					},
					uniforms: distanceUniforms,
					vertexShader: distanceShader.vertexShader,
					fragmentShader: distanceShader.fragmentShader,
					morphTargets: useMorphing,
					skinning: useSkinning,
					clipping: true
				} );

				_distanceMaterials[ i ] = distanceMaterial;

			}

			//

			var scope = this;

			this.enabled = false;

			this.autoUpdate = true;
			this.needsUpdate = false;

			this.type = PCFShadowMap;

			this.renderReverseSided = true;
			this.renderSingleSided = true;

			this.render = function ( scene, camera ) {

				if ( scope.enabled === false ) return;
				if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

				if ( _lightShadows.length === 0 ) return;

				// Set GL state for depth map.
				_state.clearColor( 1, 1, 1, 1 );
				_state.disable( _gl.BLEND );
				_state.setDepthTest( true );
				_state.setScissorTest( false );

				// render depth map

				var faceCount, isPointLight;

				for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

					var light = _lightShadows[ i ];
					var shadow = light.shadow;

					if ( shadow === undefined ) {

						console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
						continue;

					}

					var shadowCamera = shadow.camera;

					_shadowMapSize.copy( shadow.mapSize );
					_shadowMapSize.min( _maxShadowMapSize );

					if ( (light && light.isPointLight) ) {

						faceCount = 6;
						isPointLight = true;

						var vpWidth = _shadowMapSize.x;
						var vpHeight = _shadowMapSize.y;

						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction

						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

						_shadowMapSize.x *= 4.0;
						_shadowMapSize.y *= 2.0;

					} else {

						faceCount = 1;
						isPointLight = false;

					}

					if ( shadow.map === null ) {

						var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

						shadowCamera.updateProjectionMatrix();

					}

					if ( (shadow && shadow.isSpotLightShadow) ) {

						shadow.update( light );

					}

					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;

					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );

					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();

					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not

					for ( var face = 0; face < faceCount; face ++ ) {

						if ( isPointLight ) {

							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );

							var vpDimensions = cube2DViewPorts[ face ];
							_state.viewport( vpDimensions );

						} else {

							_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
							shadowCamera.lookAt( _lookTarget );

						}

						shadowCamera.updateMatrixWorld();
						shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

						// compute shadow matrix

						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);

						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

						// update camera matrices and frustum

						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );

						// set object matrices & frustum culling

						_renderList.length = 0;

						projectObject( scene, camera, shadowCamera );

						// render shadow map
						// render regular objects

						for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

							var object = _renderList[ j ];
							var geometry = _objects.update( object );
							var material = object.material;

							if ( (material && material.isMultiMaterial) ) {

								var groups = geometry.groups;
								var materials = material.materials;

								for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

									var group = groups[ k ];
									var groupMaterial = materials[ group.materialIndex ];

									if ( groupMaterial.visible === true ) {

										var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
										_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

									}

								}

							} else {

								var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

							}

						}

					}

				}

				// Restore GL state.
				var clearColor = _renderer.getClearColor(),
				clearAlpha = _renderer.getClearAlpha();
				_renderer.setClearColor( clearColor, clearAlpha );

				scope.needsUpdate = false;

			};

			function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

				var geometry = object.geometry;

				var result = null;

				var materialVariants = _depthMaterials;
				var customMaterial = object.customDepthMaterial;

				if ( isPointLight ) {

					materialVariants = _distanceMaterials;
					customMaterial = object.customDistanceMaterial;

				}

				if ( ! customMaterial ) {

					var useMorphing = false;

					if ( material.morphTargets ) {

						if ( (geometry && geometry.isBufferGeometry) ) {

							useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

						} else if ( (geometry && geometry.isGeometry) ) {

							useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

						}

					}

					var useSkinning = object.isSkinnedMesh && material.skinning;

					var variantIndex = 0;

					if ( useMorphing ) variantIndex |= _MorphingFlag;
					if ( useSkinning ) variantIndex |= _SkinningFlag;

					result = materialVariants[ variantIndex ];

				} else {

					result = customMaterial;

				}

				if ( _renderer.localClippingEnabled &&
					 material.clipShadows === true &&
						material.clippingPlanes.length !== 0 ) {

					// in this case we need a unique material instance reflecting the
					// appropriate state

					var keyA = result.uuid, keyB = material.uuid;

					var materialsForVariant = _materialCache[ keyA ];

					if ( materialsForVariant === undefined ) {

						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;

					}

					var cachedMaterial = materialsForVariant[ keyB ];

					if ( cachedMaterial === undefined ) {

						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;

					}

					result = cachedMaterial;

				}

				result.visible = material.visible;
				result.wireframe = material.wireframe;

				var side = material.side;

				if ( scope.renderSingleSided && side == DoubleSide ) {

					side = FrontSide;

				}

				if ( scope.renderReverseSided ) {

					if ( side === FrontSide ) side = BackSide;
					else if ( side === BackSide ) side = FrontSide;

				}

				result.side = side;

				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;

				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;

				if ( isPointLight && result.uniforms.lightPos !== undefined ) {

					result.uniforms.lightPos.value.copy( lightPositionWorld );

				}

				return result;

			}

			function projectObject( object, camera, shadowCamera ) {

				if ( object.visible === false ) return;

				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

				if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

					if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

						var material = object.material;

						if ( material.visible === true ) {

							object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
							_renderList.push( object );

						}

					}

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera, shadowCamera );

				}

			}

		}

		/**
		 * @author bhouston / http://clara.io
		 */

		function Ray( origin, direction ) {

			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3();

		}

		Ray.prototype = {

			constructor: Ray,

			set: function ( origin, direction ) {

				this.origin.copy( origin );
				this.direction.copy( direction );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( ray ) {

				this.origin.copy( ray.origin );
				this.direction.copy( ray.direction );

				return this;

			},

			at: function ( t, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

			},

			lookAt: function ( v ) {

				this.direction.copy( v ).sub( this.origin ).normalize();

				return this;

			},

			recast: function () {

				var v1 = new Vector3();

				return function recast( t ) {

					this.origin.copy( this.at( t, v1 ) );

					return this;

				};

			}(),

			closestPointToPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector3();
				result.subVectors( point, this.origin );
				var directionDistance = result.dot( this.direction );

				if ( directionDistance < 0 ) {

					return result.copy( this.origin );

				}

				return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			},

			distanceToPoint: function ( point ) {

				return Math.sqrt( this.distanceSqToPoint( point ) );

			},

			distanceSqToPoint: function () {

				var v1 = new Vector3();

				return function distanceSqToPoint( point ) {

					var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

					// point behind the ray

					if ( directionDistance < 0 ) {

						return this.origin.distanceToSquared( point );

					}

					v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

					return v1.distanceToSquared( point );

				};

			}(),

			distanceSqToSegment: function () {

				var segCenter = new Vector3();
				var segDir = new Vector3();
				var diff = new Vector3();

				return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
					// It returns the min distance between the ray and the segment
					// defined by v0 and v1
					// It can also set two optional targets :
					// - The closest point on the ray
					// - The closest point on the segment

					segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
					segDir.copy( v1 ).sub( v0 ).normalize();
					diff.copy( this.origin ).sub( segCenter );

					var segExtent = v0.distanceTo( v1 ) * 0.5;
					var a01 = - this.direction.dot( segDir );
					var b0 = diff.dot( this.direction );
					var b1 = - diff.dot( segDir );
					var c = diff.lengthSq();
					var det = Math.abs( 1 - a01 * a01 );
					var s0, s1, sqrDist, extDet;

					if ( det > 0 ) {

						// The ray and segment are not parallel.

						s0 = a01 * b1 - b0;
						s1 = a01 * b0 - b1;
						extDet = segExtent * det;

						if ( s0 >= 0 ) {

							if ( s1 >= - extDet ) {

								if ( s1 <= extDet ) {

									// region 0
									// Minimum at interior points of ray and segment.

									var invDet = 1 / det;
									s0 *= invDet;
									s1 *= invDet;
									sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

								} else {

									// region 1

									s1 = segExtent;
									s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
									sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

								}

							} else {

								// region 5

								s1 = - segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							if ( s1 <= - extDet ) {

								// region 4

								s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							} else if ( s1 <= extDet ) {

								// region 3

								s0 = 0;
								s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = s1 * ( s1 + 2 * b1 ) + c;

							} else {

								// region 2

								s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						}

					} else {

						// Ray and segment are parallel.

						s1 = ( a01 > 0 ) ? - segExtent : segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

					if ( optionalPointOnRay ) {

						optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

					}

					if ( optionalPointOnSegment ) {

						optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

					}

					return sqrDist;

				};

			}(),

			intersectSphere: function () {

				var v1 = new Vector3();

				return function intersectSphere( sphere, optionalTarget ) {

					v1.subVectors( sphere.center, this.origin );
					var tca = v1.dot( this.direction );
					var d2 = v1.dot( v1 ) - tca * tca;
					var radius2 = sphere.radius * sphere.radius;

					if ( d2 > radius2 ) return null;

					var thc = Math.sqrt( radius2 - d2 );

					// t0 = first intersect point - entrance on front of sphere
					var t0 = tca - thc;

					// t1 = second intersect point - exit point on back of sphere
					var t1 = tca + thc;

					// test to see if both t0 and t1 are behind the ray - if so, return null
					if ( t0 < 0 && t1 < 0 ) return null;

					// test to see if t0 is behind the ray:
					// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
					// in order to always return an intersect point that is in front of the ray.
					if ( t0 < 0 ) return this.at( t1, optionalTarget );

					// else t0 is in front of the ray, so return the first collision point scaled by t0
					return this.at( t0, optionalTarget );

				};

			}(),

			intersectsSphere: function ( sphere ) {

				return this.distanceToPoint( sphere.center ) <= sphere.radius;

			},

			distanceToPlane: function ( plane ) {

				var denominator = plane.normal.dot( this.direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( plane.distanceToPoint( this.origin ) === 0 ) {

						return 0;

					}

					// Null is preferable to undefined since undefined means.... it is undefined

					return null;

				}

				var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

				// Return if the ray never intersects the plane

				return t >= 0 ? t :  null;

			},

			intersectPlane: function ( plane, optionalTarget ) {

				var t = this.distanceToPlane( plane );

				if ( t === null ) {

					return null;

				}

				return this.at( t, optionalTarget );

			},



			intersectsPlane: function ( plane ) {

				// check if the ray lies on the plane first

				var distToPoint = plane.distanceToPoint( this.origin );

				if ( distToPoint === 0 ) {

					return true;

				}

				var denominator = plane.normal.dot( this.direction );

				if ( denominator * distToPoint < 0 ) {

					return true;

				}

				// ray origin is behind the plane (and is pointing behind it)

				return false;

			},

			intersectBox: function ( box, optionalTarget ) {

				var tmin, tmax, tymin, tymax, tzmin, tzmax;

				var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;

				var origin = this.origin;

				if ( invdirx >= 0 ) {

					tmin = ( box.min.x - origin.x ) * invdirx;
					tmax = ( box.max.x - origin.x ) * invdirx;

				} else {

					tmin = ( box.max.x - origin.x ) * invdirx;
					tmax = ( box.min.x - origin.x ) * invdirx;

				}

				if ( invdiry >= 0 ) {

					tymin = ( box.min.y - origin.y ) * invdiry;
					tymax = ( box.max.y - origin.y ) * invdiry;

				} else {

					tymin = ( box.max.y - origin.y ) * invdiry;
					tymax = ( box.min.y - origin.y ) * invdiry;

				}

				if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

				// These lines also handle the case where tmin or tmax is NaN
				// (result of 0 * Infinity). x !== x returns true if x is NaN

				if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

				if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

				if ( invdirz >= 0 ) {

					tzmin = ( box.min.z - origin.z ) * invdirz;
					tzmax = ( box.max.z - origin.z ) * invdirz;

				} else {

					tzmin = ( box.max.z - origin.z ) * invdirz;
					tzmax = ( box.min.z - origin.z ) * invdirz;

				}

				if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

				if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

				if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

				//return point closest to the ray (positive side)

				if ( tmax < 0 ) return null;

				return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

			},

			intersectsBox: ( function () {

				var v = new Vector3();

				return function intersectsBox( box ) {

					return this.intersectBox( box, v ) !== null;

				};

			} )(),

			intersectTriangle: function () {

				// Compute the offset origin, edges, and normal.
				var diff = new Vector3();
				var edge1 = new Vector3();
				var edge2 = new Vector3();
				var normal = new Vector3();

				return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

					edge1.subVectors( b, a );
					edge2.subVectors( c, a );
					normal.crossVectors( edge1, edge2 );

					// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
					// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
					//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
					//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
					//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
					var DdN = this.direction.dot( normal );
					var sign;

					if ( DdN > 0 ) {

						if ( backfaceCulling ) return null;
						sign = 1;

					} else if ( DdN < 0 ) {

						sign = - 1;
						DdN = - DdN;

					} else {

						return null;

					}

					diff.subVectors( this.origin, a );
					var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

					// b1 < 0, no intersection
					if ( DdQxE2 < 0 ) {

						return null;

					}

					var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

					// b2 < 0, no intersection
					if ( DdE1xQ < 0 ) {

						return null;

					}

					// b1+b2 > 1, no intersection
					if ( DdQxE2 + DdE1xQ > DdN ) {

						return null;

					}

					// Line intersects triangle, check if ray does.
					var QdN = - sign * diff.dot( normal );

					// t < 0, no intersection
					if ( QdN < 0 ) {

						return null;

					}

					// Ray intersects triangle.
					return this.at( QdN / DdN, optionalTarget );

				};

			}(),

			applyMatrix4: function ( matrix4 ) {

				this.direction.add( this.origin ).applyMatrix4( matrix4 );
				this.origin.applyMatrix4( matrix4 );
				this.direction.sub( this.origin );
				this.direction.normalize();

				return this;

			},

			equals: function ( ray ) {

				return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */

		function Euler( x, y, z, order ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;

		}

		Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

		Euler.DefaultOrder = 'XYZ';

		Euler.prototype = {

			constructor: Euler,

			isEuler: true,

			get x () {

				return this._x;

			},

			set x ( value ) {

				this._x = value;
				this.onChangeCallback();

			},

			get y () {

				return this._y;

			},

			set y ( value ) {

				this._y = value;
				this.onChangeCallback();

			},

			get z () {

				return this._z;

			},

			set z ( value ) {

				this._z = value;
				this.onChangeCallback();

			},

			get order () {

				return this._order;

			},

			set order ( value ) {

				this._order = value;
				this.onChangeCallback();

			},

			set: function ( x, y, z, order ) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;

				this.onChangeCallback();

				return this;

			},

			clone: function () {

				return new this.constructor( this._x, this._y, this._z, this._order );

			},

			copy: function ( euler ) {

				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;

				this.onChangeCallback();

				return this;

			},

			setFromRotationMatrix: function ( m, order, update ) {

				var clamp = _Math.clamp;

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var te = m.elements;
				var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
				var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
				var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

				order = order || this._order;

				if ( order === 'XYZ' ) {

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.99999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

				} else if ( order === 'YXZ' ) {

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.99999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

				} else if ( order === 'ZXY' ) {

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.99999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

				} else if ( order === 'ZYX' ) {

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.99999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

				} else if ( order === 'YZX' ) {

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.99999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

				} else if ( order === 'XZY' ) {

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.99999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

				} else {

					console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

				}

				this._order = order;

				if ( update !== false ) this.onChangeCallback();

				return this;

			},

			setFromQuaternion: function () {

				var matrix;

				return function setFromQuaternion( q, order, update ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.makeRotationFromQuaternion( q );

					return this.setFromRotationMatrix( matrix, order, update );

				};

			}(),

			setFromVector3: function ( v, order ) {

				return this.set( v.x, v.y, v.z, order || this._order );

			},

			reorder: function () {

				// WARNING: this discards revolution information -bhouston

				var q = new Quaternion();

				return function reorder( newOrder ) {

					q.setFromEuler( this );

					return this.setFromQuaternion( q, newOrder );

				};

			}(),

			equals: function ( euler ) {

				return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

			},

			fromArray: function ( array ) {

				this._x = array[ 0 ];
				this._y = array[ 1 ];
				this._z = array[ 2 ];
				if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

				this.onChangeCallback();

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._order;

				return array;

			},

			toVector3: function ( optionalResult ) {

				if ( optionalResult ) {

					return optionalResult.set( this._x, this._y, this._z );

				} else {

					return new Vector3( this._x, this._y, this._z );

				}

			},

			onChange: function ( callback ) {

				this.onChangeCallback = callback;

				return this;

			},

			onChangeCallback: function () {}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Layers() {

			this.mask = 1;

		}

		Layers.prototype = {

			constructor: Layers,

			set: function ( channel ) {

				this.mask = 1 << channel;

			},

			enable: function ( channel ) {

				this.mask |= 1 << channel;

			},

			toggle: function ( channel ) {

				this.mask ^= 1 << channel;

			},

			disable: function ( channel ) {

				this.mask &= ~ ( 1 << channel );

			},

			test: function ( layers ) {

				return ( this.mask & layers.mask ) !== 0;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */

		function Object3D() {

			Object.defineProperty( this, 'id', { value: Object3DIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Object3D';

			this.parent = null;
			this.children = [];

			this.up = Object3D.DefaultUp.clone();

			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation.onChange( onRotationChange );
			quaternion.onChange( onQuaternionChange );

			Object.defineProperties( this, {
				position: {
					enumerable: true,
					value: position
				},
				rotation: {
					enumerable: true,
					value: rotation
				},
				quaternion: {
					enumerable: true,
					value: quaternion
				},
				scale: {
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();

			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;

			this.layers = new Layers();
			this.visible = true;

			this.castShadow = false;
			this.receiveShadow = false;

			this.frustumCulled = true;
			this.renderOrder = 0;

			this.userData = {};

			this.onBeforeRender = function(){}; 
			this.onAfterRender = function(){};

		}

		Object3D.DefaultUp = new Vector3( 0, 1, 0 );
		Object3D.DefaultMatrixAutoUpdate = true;

		Object.assign( Object3D.prototype, EventDispatcher.prototype, {

			isObject3D: true,

			applyMatrix: function ( matrix ) {

				this.matrix.multiplyMatrices( matrix, this.matrix );

				this.matrix.decompose( this.position, this.quaternion, this.scale );

			},

			setRotationFromAxisAngle: function ( axis, angle ) {

				// assumes axis is normalized

				this.quaternion.setFromAxisAngle( axis, angle );

			},

			setRotationFromEuler: function ( euler ) {

				this.quaternion.setFromEuler( euler, true );

			},

			setRotationFromMatrix: function ( m ) {

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				this.quaternion.setFromRotationMatrix( m );

			},

			setRotationFromQuaternion: function ( q ) {

				// assumes q is normalized

				this.quaternion.copy( q );

			},

			rotateOnAxis: function () {

				// rotate object on axis in object space
				// axis is assumed to be normalized

				var q1 = new Quaternion();

				return function rotateOnAxis( axis, angle ) {

					q1.setFromAxisAngle( axis, angle );

					this.quaternion.multiply( q1 );

					return this;

				};

			}(),

			rotateX: function () {

				var v1 = new Vector3( 1, 0, 0 );

				return function rotateX( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			rotateY: function () {

				var v1 = new Vector3( 0, 1, 0 );

				return function rotateY( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			rotateZ: function () {

				var v1 = new Vector3( 0, 0, 1 );

				return function rotateZ( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			translateOnAxis: function () {

				// translate object by distance along axis in object space
				// axis is assumed to be normalized

				var v1 = new Vector3();

				return function translateOnAxis( axis, distance ) {

					v1.copy( axis ).applyQuaternion( this.quaternion );

					this.position.add( v1.multiplyScalar( distance ) );

					return this;

				};

			}(),

			translateX: function () {

				var v1 = new Vector3( 1, 0, 0 );

				return function translateX( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			translateY: function () {

				var v1 = new Vector3( 0, 1, 0 );

				return function translateY( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			translateZ: function () {

				var v1 = new Vector3( 0, 0, 1 );

				return function translateZ( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			localToWorld: function ( vector ) {

				return vector.applyMatrix4( this.matrixWorld );

			},

			worldToLocal: function () {

				var m1 = new Matrix4();

				return function worldToLocal( vector ) {

					return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

				};

			}(),

			lookAt: function () {

				// This routine does not support objects with rotated and/or translated parent(s)

				var m1 = new Matrix4();

				return function lookAt( vector ) {

					m1.lookAt( vector, this.position, this.up );

					this.quaternion.setFromRotationMatrix( m1 );

				};

			}(),

			add: function ( object ) {

				if ( arguments.length > 1 ) {

					for ( var i = 0; i < arguments.length; i ++ ) {

						this.add( arguments[ i ] );

					}

					return this;

				}

				if ( object === this ) {

					console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
					return this;

				}

				if ( (object && object.isObject3D) ) {

					if ( object.parent !== null ) {

						object.parent.remove( object );

					}

					object.parent = this;
					object.dispatchEvent( { type: 'added' } );

					this.children.push( object );

				} else {

					console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

				}

				return this;

			},

			remove: function ( object ) {

				if ( arguments.length > 1 ) {

					for ( var i = 0; i < arguments.length; i ++ ) {

						this.remove( arguments[ i ] );

					}

				}

				var index = this.children.indexOf( object );

				if ( index !== - 1 ) {

					object.parent = null;

					object.dispatchEvent( { type: 'removed' } );

					this.children.splice( index, 1 );

				}

			},

			getObjectById: function ( id ) {

				return this.getObjectByProperty( 'id', id );

			},

			getObjectByName: function ( name ) {

				return this.getObjectByProperty( 'name', name );

			},

			getObjectByProperty: function ( name, value ) {

				if ( this[ name ] === value ) return this;

				for ( var i = 0, l = this.children.length; i < l; i ++ ) {

					var child = this.children[ i ];
					var object = child.getObjectByProperty( name, value );

					if ( object !== undefined ) {

						return object;

					}

				}

				return undefined;

			},

			getWorldPosition: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.updateMatrixWorld( true );

				return result.setFromMatrixPosition( this.matrixWorld );

			},

			getWorldQuaternion: function () {

				var position = new Vector3();
				var scale = new Vector3();

				return function getWorldQuaternion( optionalTarget ) {

					var result = optionalTarget || new Quaternion();

					this.updateMatrixWorld( true );

					this.matrixWorld.decompose( position, result, scale );

					return result;

				};

			}(),

			getWorldRotation: function () {

				var quaternion = new Quaternion();

				return function getWorldRotation( optionalTarget ) {

					var result = optionalTarget || new Euler();

					this.getWorldQuaternion( quaternion );

					return result.setFromQuaternion( quaternion, this.rotation.order, false );

				};

			}(),

			getWorldScale: function () {

				var position = new Vector3();
				var quaternion = new Quaternion();

				return function getWorldScale( optionalTarget ) {

					var result = optionalTarget || new Vector3();

					this.updateMatrixWorld( true );

					this.matrixWorld.decompose( position, quaternion, result );

					return result;

				};

			}(),

			getWorldDirection: function () {

				var quaternion = new Quaternion();

				return function getWorldDirection( optionalTarget ) {

					var result = optionalTarget || new Vector3();

					this.getWorldQuaternion( quaternion );

					return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

				};

			}(),

			raycast: function () {},

			traverse: function ( callback ) {

				callback( this );

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].traverse( callback );

				}

			},

			traverseVisible: function ( callback ) {

				if ( this.visible === false ) return;

				callback( this );

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].traverseVisible( callback );

				}

			},

			traverseAncestors: function ( callback ) {

				var parent = this.parent;

				if ( parent !== null ) {

					callback( parent );

					parent.traverseAncestors( callback );

				}

			},

			updateMatrix: function () {

				this.matrix.compose( this.position, this.quaternion, this.scale );

				this.matrixWorldNeedsUpdate = true;

			},

			updateMatrixWorld: function ( force ) {

				if ( this.matrixAutoUpdate === true ) this.updateMatrix();

				if ( this.matrixWorldNeedsUpdate === true || force === true ) {

					if ( this.parent === null ) {

						this.matrixWorld.copy( this.matrix );

					} else {

						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

					}

					this.matrixWorldNeedsUpdate = false;

					force = true;

				}

				// update children

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( force );

				}

			},

			toJSON: function ( meta ) {

				// meta is '' when called from JSON.stringify
				var isRootObject = ( meta === undefined || meta === '' );

				var output = {};

				// meta is a hash used to collect geometries, materials.
				// not providing it implies that this is the root object
				// being serialized.
				if ( isRootObject ) {

					// initialize meta obj
					meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {}
					};

					output.metadata = {
						version: 4.4,
						type: 'Object',
						generator: 'Object3D.toJSON'
					};

				}

				// standard Object3D serialization

				var object = {};

				object.uuid = this.uuid;
				object.type = this.type;

				if ( this.name !== '' ) object.name = this.name;
				if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
				if ( this.castShadow === true ) object.castShadow = true;
				if ( this.receiveShadow === true ) object.receiveShadow = true;
				if ( this.visible === false ) object.visible = false;

				object.matrix = this.matrix.toArray();

				//

				if ( this.geometry !== undefined ) {

					if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

						meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

					}

					object.geometry = this.geometry.uuid;

				}

				if ( this.material !== undefined ) {

					if ( meta.materials[ this.material.uuid ] === undefined ) {

						meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

					}

					object.material = this.material.uuid;

				}

				//

				if ( this.children.length > 0 ) {

					object.children = [];

					for ( var i = 0; i < this.children.length; i ++ ) {

						object.children.push( this.children[ i ].toJSON( meta ).object );

					}

				}

				if ( isRootObject ) {

					var geometries = extractFromCache( meta.geometries );
					var materials = extractFromCache( meta.materials );
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );

					if ( geometries.length > 0 ) output.geometries = geometries;
					if ( materials.length > 0 ) output.materials = materials;
					if ( textures.length > 0 ) output.textures = textures;
					if ( images.length > 0 ) output.images = images;

				}

				output.object = object;

				return output;

				// extract data from the cache hash
				// remove metadata on each item
				// and return as array
				function extractFromCache( cache ) {

					var values = [];
					for ( var key in cache ) {

						var data = cache[ key ];
						delete data.metadata;
						values.push( data );

					}
					return values;

				}

			},

			clone: function ( recursive ) {

				return new this.constructor().copy( this, recursive );

			},

			copy: function ( source, recursive ) {

				if ( recursive === undefined ) recursive = true;

				this.name = source.name;

				this.up.copy( source.up );

				this.position.copy( source.position );
				this.quaternion.copy( source.quaternion );
				this.scale.copy( source.scale );

				this.matrix.copy( source.matrix );
				this.matrixWorld.copy( source.matrixWorld );

				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

				this.visible = source.visible;

				this.castShadow = source.castShadow;
				this.receiveShadow = source.receiveShadow;

				this.frustumCulled = source.frustumCulled;
				this.renderOrder = source.renderOrder;

				this.userData = JSON.parse( JSON.stringify( source.userData ) );

				if ( recursive === true ) {

					for ( var i = 0; i < source.children.length; i ++ ) {

						var child = source.children[ i ];
						this.add( child.clone() );

					}

				}

				return this;

			}

		} );

		var count$2 = 0;
		function Object3DIdCount() { return count$2++; }

		/**
		 * @author bhouston / http://clara.io
		 */

		function Line3( start, end ) {

			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();

		}

		Line3.prototype = {

			constructor: Line3,

			set: function ( start, end ) {

				this.start.copy( start );
				this.end.copy( end );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( line ) {

				this.start.copy( line.start );
				this.end.copy( line.end );

				return this;

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

			},

			delta: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.subVectors( this.end, this.start );

			},

			distanceSq: function () {

				return this.start.distanceToSquared( this.end );

			},

			distance: function () {

				return this.start.distanceTo( this.end );

			},

			at: function ( t, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				return this.delta( result ).multiplyScalar( t ).add( this.start );

			},

			closestPointToPointParameter: function () {

				var startP = new Vector3();
				var startEnd = new Vector3();

				return function closestPointToPointParameter( point, clampToLine ) {

					startP.subVectors( point, this.start );
					startEnd.subVectors( this.end, this.start );

					var startEnd2 = startEnd.dot( startEnd );
					var startEnd_startP = startEnd.dot( startP );

					var t = startEnd_startP / startEnd2;

					if ( clampToLine ) {

						t = _Math.clamp( t, 0, 1 );

					}

					return t;

				};

			}(),

			closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

				var t = this.closestPointToPointParameter( point, clampToLine );

				var result = optionalTarget || new Vector3();

				return this.delta( result ).multiplyScalar( t ).add( this.start );

			},

			applyMatrix4: function ( matrix ) {

				this.start.applyMatrix4( matrix );
				this.end.applyMatrix4( matrix );

				return this;

			},

			equals: function ( line ) {

				return line.start.equals( this.start ) && line.end.equals( this.end );

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Triangle( a, b, c ) {

			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();

		}

		Triangle.normal = function () {

			var v0 = new Vector3();

			return function normal( a, b, c, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				result.subVectors( c, b );
				v0.subVectors( a, b );
				result.cross( v0 );

				var resultLengthSq = result.lengthSq();
				if ( resultLengthSq > 0 ) {

					return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

				}

				return result.set( 0, 0, 0 );

			};

		}();

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		Triangle.barycoordFromPoint = function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				var result = optionalTarget || new Vector3();

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return result.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return result.set( 1 - u - v, v, u );

			};

		}();

		Triangle.containsPoint = function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

				return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

			};

		}();

		Triangle.prototype = {

			constructor: Triangle,

			set: function ( a, b, c ) {

				this.a.copy( a );
				this.b.copy( b );
				this.c.copy( c );

				return this;

			},

			setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

				this.a.copy( points[ i0 ] );
				this.b.copy( points[ i1 ] );
				this.c.copy( points[ i2 ] );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( triangle ) {

				this.a.copy( triangle.a );
				this.b.copy( triangle.b );
				this.c.copy( triangle.c );

				return this;

			},

			area: function () {

				var v0 = new Vector3();
				var v1 = new Vector3();

				return function area() {

					v0.subVectors( this.c, this.b );
					v1.subVectors( this.a, this.b );

					return v0.cross( v1 ).length() * 0.5;

				};

			}(),

			midpoint: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

			},

			normal: function ( optionalTarget ) {

				return Triangle.normal( this.a, this.b, this.c, optionalTarget );

			},

			plane: function ( optionalTarget ) {

				var result = optionalTarget || new Plane();

				return result.setFromCoplanarPoints( this.a, this.b, this.c );

			},

			barycoordFromPoint: function ( point, optionalTarget ) {

				return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

			},

			containsPoint: function ( point ) {

				return Triangle.containsPoint( point, this.a, this.b, this.c );

			},

			closestPointToPoint: function () {

				var plane, edgeList, projectedPoint, closestPoint;

				return function closestPointToPoint( point, optionalTarget ) {

					if ( plane === undefined ) {

						plane = new Plane();
						edgeList = [ new Line3(), new Line3(), new Line3() ];
						projectedPoint = new Vector3();
						closestPoint = new Vector3();

					}

					var result = optionalTarget || new Vector3();
					var minDistance = Infinity;

					// project the point onto the plane of the triangle

					plane.setFromCoplanarPoints( this.a, this.b, this.c );
					plane.projectPoint( point, projectedPoint );

					// check if the projection lies within the triangle

					if( this.containsPoint( projectedPoint ) === true ) {

						// if so, this is the closest point

						result.copy( projectedPoint );

					} else {

						// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

						edgeList[ 0 ].set( this.a, this.b );
						edgeList[ 1 ].set( this.b, this.c );
						edgeList[ 2 ].set( this.c, this.a );

						for( var i = 0; i < edgeList.length; i ++ ) {

							edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

							var distance = projectedPoint.distanceToSquared( closestPoint );

							if( distance < minDistance ) {

								minDistance = distance;

								result.copy( closestPoint );

							}

						}

					}

					return result;

				};

			}(),

			equals: function ( triangle ) {

				return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Face3( a, b, c, normal, color, materialIndex ) {

			this.a = a;
			this.b = b;
			this.c = c;

			this.normal = (normal && normal.isVector3) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];

			this.color = (color && color.isColor) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];

			this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

		}

		Face3.prototype = {

			constructor: Face3,

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.a = source.a;
				this.b = source.b;
				this.c = source.c;

				this.normal.copy( source.normal );
				this.color.copy( source.color );

				this.materialIndex = source.materialIndex;

				for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

					this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

				}

				for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

					this.vertexColors[ i ] = source.vertexColors[ i ].clone();

				}

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  shading: THREE.SmoothShading,
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */

		function MeshBasicMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;

			this.lights = false;

			this.setValues( parameters );

		}

		MeshBasicMaterial.prototype = Object.create( Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

		MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

		MeshBasicMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferAttribute( array, itemSize, normalized ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.uuid = _Math.generateUUID();

			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;

			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

		}

		BufferAttribute.prototype = {

			constructor: BufferAttribute,

			isBufferAttribute: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			setArray: function ( array ) {

				if ( Array.isArray( array ) ) {

					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

				}

				this.count = array !== undefined ? array.length / this.itemSize : 0;
				this.array = array;

			},

			setDynamic: function ( value ) {

				this.dynamic = value;

				return this;

			},

			copy: function ( source ) {

				this.array = new source.array.constructor( source.array );
				this.itemSize = source.itemSize;
				this.count = source.count;
				this.normalized = source.normalized;

				this.dynamic = source.dynamic;

				return this;

			},

			copyAt: function ( index1, attribute, index2 ) {

				index1 *= this.itemSize;
				index2 *= attribute.itemSize;

				for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

					this.array[ index1 + i ] = attribute.array[ index2 + i ];

				}

				return this;

			},

			copyArray: function ( array ) {

				this.array.set( array );

				return this;

			},

			copyColorsArray: function ( colors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = colors.length; i < l; i ++ ) {

					var color = colors[ i ];

					if ( color === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
						color = new Color();

					}

					array[ offset ++ ] = color.r;
					array[ offset ++ ] = color.g;
					array[ offset ++ ] = color.b;

				}

				return this;

			},

			copyIndicesArray: function ( indices ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					var index = indices[ i ];

					array[ offset ++ ] = index.a;
					array[ offset ++ ] = index.b;
					array[ offset ++ ] = index.c;

				}

				return this;

			},

			copyVector2sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
						vector = new Vector2();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;

				}

				return this;

			},

			copyVector3sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
						vector = new Vector3();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;

				}

				return this;

			},

			copyVector4sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
						vector = new Vector4();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
					array[ offset ++ ] = vector.w;

				}

				return this;

			},

			set: function ( value, offset ) {

				if ( offset === undefined ) offset = 0;

				this.array.set( value, offset );

				return this;

			},

			getX: function ( index ) {

				return this.array[ index * this.itemSize ];

			},

			setX: function ( index, x ) {

				this.array[ index * this.itemSize ] = x;

				return this;

			},

			getY: function ( index ) {

				return this.array[ index * this.itemSize + 1 ];

			},

			setY: function ( index, y ) {

				this.array[ index * this.itemSize + 1 ] = y;

				return this;

			},

			getZ: function ( index ) {

				return this.array[ index * this.itemSize + 2 ];

			},

			setZ: function ( index, z ) {

				this.array[ index * this.itemSize + 2 ] = z;

				return this;

			},

			getW: function ( index ) {

				return this.array[ index * this.itemSize + 3 ];

			},

			setW: function ( index, w ) {

				this.array[ index * this.itemSize + 3 ] = w;

				return this;

			},

			setXY: function ( index, x, y ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;

				return this;

			},

			setXYZ: function ( index, x, y, z ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;

				return this;

			},

			setXYZW: function ( index, x, y, z, w ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
				this.array[ index + 3 ] = w;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			}

		};

		//

		function Int8Attribute( array, itemSize ) {

			return new BufferAttribute( new Int8Array( array ), itemSize );

		}

		function Uint8Attribute( array, itemSize ) {

			return new BufferAttribute( new Uint8Array( array ), itemSize );

		}

		function Uint8ClampedAttribute( array, itemSize ) {

			return new BufferAttribute( new Uint8ClampedArray( array ), itemSize );

		}

		function Int16Attribute( array, itemSize ) {

			return new BufferAttribute( new Int16Array( array ), itemSize );

		}

		function Uint16Attribute( array, itemSize ) {

			return new BufferAttribute( new Uint16Array( array ), itemSize );

		}

		function Int32Attribute( array, itemSize ) {

			return new BufferAttribute( new Int32Array( array ), itemSize );

		}

		function Uint32Attribute( array, itemSize ) {

			return new BufferAttribute( new Uint32Array( array ), itemSize );

		}

		function Float32Attribute( array, itemSize ) {

			return new BufferAttribute( new Float32Array( array ), itemSize );

		}

		function Float64Attribute( array, itemSize ) {

			return new BufferAttribute( new Float64Array( array ), itemSize );

		}

		// Deprecated

		function DynamicBufferAttribute( array, itemSize ) {

			console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
			return new BufferAttribute( array, itemSize ).setDynamic( true );

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */

		function Geometry() {

			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Geometry';

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];

			this.morphTargets = [];
			this.morphNormals = [];

			this.skinWeights = [];
			this.skinIndices = [];

			this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.elementsNeedUpdate = false;
			this.verticesNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.lineDistancesNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		Object.assign( Geometry.prototype, EventDispatcher.prototype, {

			isGeometry: true,

			applyMatrix: function ( matrix ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

					var vertex = this.vertices[ i ];
					vertex.applyMatrix4( matrix );

				}

				for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

					var face = this.faces[ i ];
					face.normal.applyMatrix3( normalMatrix ).normalize();

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

					}

				}

				if ( this.boundingBox !== null ) {

					this.computeBoundingBox();

				}

				if ( this.boundingSphere !== null ) {

					this.computeBoundingSphere();

				}

				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;

				return this;

			},

			rotateX: function () {

				// rotate geometry around world x-axis

				var m1;

				return function rotateX( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationX( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateY: function () {

				// rotate geometry around world y-axis

				var m1;

				return function rotateY( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationY( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateZ: function () {

				// rotate geometry around world z-axis

				var m1;

				return function rotateZ( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationZ( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			translate: function () {

				// translate geometry

				var m1;

				return function translate( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeTranslation( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			scale: function () {

				// scale geometry

				var m1;

				return function scale( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeScale( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			lookAt: function () {

				var obj;

				return function lookAt( vector ) {

					if ( obj === undefined ) obj = new Object3D();

					obj.lookAt( vector );

					obj.updateMatrix();

					this.applyMatrix( obj.matrix );

				};

			}(),

			fromBufferGeometry: function ( geometry ) {

				var scope = this;

				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;

				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

				if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

				var tempNormals = [];
				var tempUVs = [];
				var tempUVs2 = [];

				for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

					scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

					if ( normals !== undefined ) {

						tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

					}

					if ( colors !== undefined ) {

						scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

					}

					if ( uvs !== undefined ) {

						tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

					}

					if ( uvs2 !== undefined ) {

						tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

					}

				}

				function addFace( a, b, c, materialIndex ) {

					var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
					var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

					var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

					scope.faces.push( face );

					if ( uvs !== undefined ) {

						scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

					}

					if ( uvs2 !== undefined ) {

						scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

					}

				}

				if ( indices !== undefined ) {

					var groups = geometry.groups;

					if ( groups.length > 0 ) {

						for ( var i = 0; i < groups.length; i ++ ) {

							var group = groups[ i ];

							var start = group.start;
							var count = group.count;

							for ( var j = start, jl = start + count; j < jl; j += 3 ) {

								addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

							}

						}

					} else {

						for ( var i = 0; i < indices.length; i += 3 ) {

							addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

						}

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

				this.computeFaceNormals();

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				return this;

			},

			center: function () {

				this.computeBoundingBox();

				var offset = this.boundingBox.getCenter().negate();

				this.translate( offset.x, offset.y, offset.z );

				return offset;

			},

			normalize: function () {

				this.computeBoundingSphere();

				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;

				var s = radius === 0 ? 1 : 1.0 / radius;

				var matrix = new Matrix4();
				matrix.set(
					s, 0, 0, - s * center.x,
					0, s, 0, - s * center.y,
					0, 0, s, - s * center.z,
					0, 0, 0, 1
				);

				this.applyMatrix( matrix );

				return this;

			},

			computeFaceNormals: function () {

				var cb = new Vector3(), ab = new Vector3();

				for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

					var face = this.faces[ f ];

					var vA = this.vertices[ face.a ];
					var vB = this.vertices[ face.b ];
					var vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					cb.normalize();

					face.normal.copy( cb );

				}

			},

			computeVertexNormals: function ( areaWeighted ) {

				if ( areaWeighted === undefined ) areaWeighted = true;

				var v, vl, f, fl, face, vertices;

				vertices = new Array( this.vertices.length );

				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

					vertices[ v ] = new Vector3();

				}

				if ( areaWeighted ) {

					// vertex normals weighted by triangle areas
					// http://www.iquilezles.org/www/articles/normals/normals.htm

					var vA, vB, vC;
					var cb = new Vector3(), ab = new Vector3();

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];

						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );

						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );

					}

				} else {

					this.computeFaceNormals();

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );

					}

				}

				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

					vertices[ v ].normalize();

				}

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						vertexNormals[ 0 ].copy( vertices[ face.a ] );
						vertexNormals[ 1 ].copy( vertices[ face.b ] );
						vertexNormals[ 2 ].copy( vertices[ face.c ] );

					} else {

						vertexNormals[ 0 ] = vertices[ face.a ].clone();
						vertexNormals[ 1 ] = vertices[ face.b ].clone();
						vertexNormals[ 2 ] = vertices[ face.c ].clone();

					}

				}

				if ( this.faces.length > 0 ) {

					this.normalsNeedUpdate = true;

				}

			},

			computeFlatVertexNormals: function () {

				var f, fl, face;

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						vertexNormals[ 0 ].copy( face.normal );
						vertexNormals[ 1 ].copy( face.normal );
						vertexNormals[ 2 ].copy( face.normal );

					} else {

						vertexNormals[ 0 ] = face.normal.clone();
						vertexNormals[ 1 ] = face.normal.clone();
						vertexNormals[ 2 ] = face.normal.clone();

					}

				}

				if ( this.faces.length > 0 ) {

					this.normalsNeedUpdate = true;

				}

			},

			computeMorphNormals: function () {

				var i, il, f, fl, face;

				// save original normals
				// - create temp variables on first access
				//   otherwise just copy (for faster repeated calls)

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					if ( ! face.__originalFaceNormal ) {

						face.__originalFaceNormal = face.normal.clone();

					} else {

						face.__originalFaceNormal.copy( face.normal );

					}

					if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

					for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

						if ( ! face.__originalVertexNormals[ i ] ) {

							face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

						} else {

							face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

						}

					}

				}

				// use temp geometry to compute face and vertex normals for each morph

				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;

				for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

					// create on first access

					if ( ! this.morphNormals[ i ] ) {

						this.morphNormals[ i ] = {};
						this.morphNormals[ i ].faceNormals = [];
						this.morphNormals[ i ].vertexNormals = [];

						var dstNormalsFace = this.morphNormals[ i ].faceNormals;
						var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

						var faceNormal, vertexNormals;

						for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

							faceNormal = new Vector3();
							vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

							dstNormalsFace.push( faceNormal );
							dstNormalsVertex.push( vertexNormals );

						}

					}

					var morphNormals = this.morphNormals[ i ];

					// set vertices to morph target

					tmpGeo.vertices = this.morphTargets[ i ].vertices;

					// compute morph normals

					tmpGeo.computeFaceNormals();
					tmpGeo.computeVertexNormals();

					// store morph normals

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						faceNormal = morphNormals.faceNormals[ f ];
						vertexNormals = morphNormals.vertexNormals[ f ];

						faceNormal.copy( face.normal );

						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );

					}

				}

				// restore original normals

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					face.normal = face.__originalFaceNormal;
					face.vertexNormals = face.__originalVertexNormals;

				}

			},

			computeTangents: function () {

				console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

			},

			computeLineDistances: function () {

				var d = 0;
				var vertices = this.vertices;

				for ( var i = 0, il = vertices.length; i < il; i ++ ) {

					if ( i > 0 ) {

						d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

					}

					this.lineDistances[ i ] = d;

				}

			},

			computeBoundingBox: function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				this.boundingBox.setFromPoints( this.vertices );

			},

			computeBoundingSphere: function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				this.boundingSphere.setFromPoints( this.vertices );

			},

			merge: function ( geometry, matrix, materialIndexOffset ) {

				if ( (geometry && geometry.isGeometry) === false ) {

					console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
					return;

				}

				var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

				if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

				if ( matrix !== undefined ) {

					normalMatrix = new Matrix3().getNormalMatrix( matrix );

				}

				// vertices

				for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

					var vertex = vertices2[ i ];

					var vertexCopy = vertex.clone();

					if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

					vertices1.push( vertexCopy );

				}

				// colors

				for ( var i = 0, il = colors2.length; i < il; i ++ ) {

					colors1.push( colors2[ i ].clone() );

				}

				// faces

				for ( i = 0, il = faces2.length; i < il; i ++ ) {

					var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

					faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
					faceCopy.normal.copy( face.normal );

					if ( normalMatrix !== undefined ) {

						faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

					}

					for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

						normal = faceVertexNormals[ j ].clone();

						if ( normalMatrix !== undefined ) {

							normal.applyMatrix3( normalMatrix ).normalize();

						}

						faceCopy.vertexNormals.push( normal );

					}

					faceCopy.color.copy( face.color );

					for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

						color = faceVertexColors[ j ];
						faceCopy.vertexColors.push( color.clone() );

					}

					faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

					faces1.push( faceCopy );

				}

				// uvs

				for ( i = 0, il = uvs2.length; i < il; i ++ ) {

					var uv = uvs2[ i ], uvCopy = [];

					if ( uv === undefined ) {

						continue;

					}

					for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

						uvCopy.push( uv[ j ].clone() );

					}

					uvs1.push( uvCopy );

				}

			},

			mergeMesh: function ( mesh ) {

				if ( (mesh && mesh.isMesh) === false ) {

					console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
					return;

				}

				mesh.matrixAutoUpdate && mesh.updateMatrix();

				this.merge( mesh.geometry, mesh.matrix );

			},

			/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */

			mergeVertices: function () {

				var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
				var unique = [], changes = [];

				var v, key;
				var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
				var precision = Math.pow( 10, precisionPoints );
				var i, il, face;
				var indices, j, jl;

				for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

					v = this.vertices[ i ];
					key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

					if ( verticesMap[ key ] === undefined ) {

						verticesMap[ key ] = i;
						unique.push( this.vertices[ i ] );
						changes[ i ] = unique.length - 1;

					} else {

						//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
						changes[ i ] = changes[ verticesMap[ key ] ];

					}

				}


				// if faces are completely degenerate after merging vertices, we
				// have to remove them from the geometry.
				var faceIndicesToRemove = [];

				for ( i = 0, il = this.faces.length; i < il; i ++ ) {

					face = this.faces[ i ];

					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];

					indices = [ face.a, face.b, face.c ];

					var dupIndex = - 1;

					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {

						if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

							dupIndex = n;
							faceIndicesToRemove.push( i );
							break;

						}

					}

				}

				for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

					var idx = faceIndicesToRemove[ i ];

					this.faces.splice( idx, 1 );

					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

						this.faceVertexUvs[ j ].splice( idx, 1 );

					}

				}

				// Use unique set of vertices

				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;

			},

			sortFacesByMaterialIndex: function () {

				var faces = this.faces;
				var length = faces.length;

				// tag faces

				for ( var i = 0; i < length; i ++ ) {

					faces[ i ]._id = i;

				}

				// sort faces

				function materialIndexSort( a, b ) {

					return a.materialIndex - b.materialIndex;

				}

				faces.sort( materialIndexSort );

				// sort uvs

				var uvs1 = this.faceVertexUvs[ 0 ];
				var uvs2 = this.faceVertexUvs[ 1 ];

				var newUvs1, newUvs2;

				if ( uvs1 && uvs1.length === length ) newUvs1 = [];
				if ( uvs2 && uvs2.length === length ) newUvs2 = [];

				for ( var i = 0; i < length; i ++ ) {

					var id = faces[ i ]._id;

					if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
					if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

				}

				if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
				if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.4,
						type: 'Geometry',
						generator: 'Geometry.toJSON'
					}
				};

				// standard Geometry serialization

				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;

				if ( this.parameters !== undefined ) {

					var parameters = this.parameters;

					for ( var key in parameters ) {

						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

					}

					return data;

				}

				var vertices = [];

				for ( var i = 0; i < this.vertices.length; i ++ ) {

					var vertex = this.vertices[ i ];
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};

				for ( var i = 0; i < this.faces.length; i ++ ) {

					var face = this.faces[ i ];

					var hasMaterial = true;
					var hasFaceUv = false; // deprecated
					var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
					var hasFaceNormal = face.normal.length() > 0;
					var hasFaceVertexNormal = face.vertexNormals.length > 0;
					var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
					var hasFaceVertexColor = face.vertexColors.length > 0;

					var faceType = 0;

					faceType = setBit( faceType, 0, 0 ); // isQuad
					faceType = setBit( faceType, 1, hasMaterial );
					faceType = setBit( faceType, 2, hasFaceUv );
					faceType = setBit( faceType, 3, hasFaceVertexUv );
					faceType = setBit( faceType, 4, hasFaceNormal );
					faceType = setBit( faceType, 5, hasFaceVertexNormal );
					faceType = setBit( faceType, 6, hasFaceColor );
					faceType = setBit( faceType, 7, hasFaceVertexColor );

					faces.push( faceType );
					faces.push( face.a, face.b, face.c );
					faces.push( face.materialIndex );

					if ( hasFaceVertexUv ) {

						var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

						faces.push(
							getUvIndex( faceVertexUvs[ 0 ] ),
							getUvIndex( faceVertexUvs[ 1 ] ),
							getUvIndex( faceVertexUvs[ 2 ] )
						);

					}

					if ( hasFaceNormal ) {

						faces.push( getNormalIndex( face.normal ) );

					}

					if ( hasFaceVertexNormal ) {

						var vertexNormals = face.vertexNormals;

						faces.push(
							getNormalIndex( vertexNormals[ 0 ] ),
							getNormalIndex( vertexNormals[ 1 ] ),
							getNormalIndex( vertexNormals[ 2 ] )
						);

					}

					if ( hasFaceColor ) {

						faces.push( getColorIndex( face.color ) );

					}

					if ( hasFaceVertexColor ) {

						var vertexColors = face.vertexColors;

						faces.push(
							getColorIndex( vertexColors[ 0 ] ),
							getColorIndex( vertexColors[ 1 ] ),
							getColorIndex( vertexColors[ 2 ] )
						);

					}

				}

				function setBit( value, position, enabled ) {

					return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

				}

				function getNormalIndex( normal ) {

					var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

					if ( normalsHash[ hash ] !== undefined ) {

						return normalsHash[ hash ];

					}

					normalsHash[ hash ] = normals.length / 3;
					normals.push( normal.x, normal.y, normal.z );

					return normalsHash[ hash ];

				}

				function getColorIndex( color ) {

					var hash = color.r.toString() + color.g.toString() + color.b.toString();

					if ( colorsHash[ hash ] !== undefined ) {

						return colorsHash[ hash ];

					}

					colorsHash[ hash ] = colors.length;
					colors.push( color.getHex() );

					return colorsHash[ hash ];

				}

				function getUvIndex( uv ) {

					var hash = uv.x.toString() + uv.y.toString();

					if ( uvsHash[ hash ] !== undefined ) {

						return uvsHash[ hash ];

					}

					uvsHash[ hash ] = uvs.length / 2;
					uvs.push( uv.x, uv.y );

					return uvsHash[ hash ];

				}

				data.data = {};

				data.data.vertices = vertices;
				data.data.normals = normals;
				if ( colors.length > 0 ) data.data.colors = colors;
				if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
				data.data.faces = faces;

				return data;

			},

			clone: function () {

				/*
				// Handle primitives

				var parameters = this.parameters;

				if ( parameters !== undefined ) {

					var values = [];

					for ( var key in parameters ) {

						values.push( parameters[ key ] );

					}

					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;

				}

				return new this.constructor().copy( this );
				*/

				return new Geometry().copy( this );

			},

			copy: function ( source ) {

				this.vertices = [];
				this.faces = [];
				this.faceVertexUvs = [ [] ];
				this.colors = [];

				var vertices = source.vertices;

				for ( var i = 0, il = vertices.length; i < il; i ++ ) {

					this.vertices.push( vertices[ i ].clone() );

				}

				var colors = source.colors;

				for ( var i = 0, il = colors.length; i < il; i ++ ) {

					this.colors.push( colors[ i ].clone() );

				}

				var faces = source.faces;

				for ( var i = 0, il = faces.length; i < il; i ++ ) {

					this.faces.push( faces[ i ].clone() );

				}

				for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

					var faceVertexUvs = source.faceVertexUvs[ i ];

					if ( this.faceVertexUvs[ i ] === undefined ) {

						this.faceVertexUvs[ i ] = [];

					}

					for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

						var uvs = faceVertexUvs[ j ], uvsCopy = [];

						for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

							var uv = uvs[ k ];

							uvsCopy.push( uv.clone() );

						}

						this.faceVertexUvs[ i ].push( uvsCopy );

					}

				}

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		var count$3 = 0;
		function GeometryIdCount() { return count$3++; }

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function DirectGeometry() {

			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'DirectGeometry';

			this.indices = [];
			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];

			this.groups = [];

			this.morphTargets = {};

			this.skinWeights = [];
			this.skinIndices = [];

			// this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		Object.assign( DirectGeometry.prototype, EventDispatcher.prototype, {

			computeBoundingBox: Geometry.prototype.computeBoundingBox,
			computeBoundingSphere: Geometry.prototype.computeBoundingSphere,

			computeFaceNormals: function () {

				console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

			},

			computeVertexNormals: function () {

				console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

			},

			computeGroups: function ( geometry ) {

				var group;
				var groups = [];
				var materialIndex;

				var faces = geometry.faces;

				for ( var i = 0; i < faces.length; i ++ ) {

					var face = faces[ i ];

					// materials

					if ( face.materialIndex !== materialIndex ) {

						materialIndex = face.materialIndex;

						if ( group !== undefined ) {

							group.count = ( i * 3 ) - group.start;
							groups.push( group );

						}

						group = {
							start: i * 3,
							materialIndex: materialIndex
						};

					}

				}

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				this.groups = groups;

			},

			fromGeometry: function ( geometry ) {

				var faces = geometry.faces;
				var vertices = geometry.vertices;
				var faceVertexUvs = geometry.faceVertexUvs;

				var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
				var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

				// morphs

				var morphTargets = geometry.morphTargets;
				var morphTargetsLength = morphTargets.length;

				var morphTargetsPosition;

				if ( morphTargetsLength > 0 ) {

					morphTargetsPosition = [];

					for ( var i = 0; i < morphTargetsLength; i ++ ) {

						morphTargetsPosition[ i ] = [];

					}

					this.morphTargets.position = morphTargetsPosition;

				}

				var morphNormals = geometry.morphNormals;
				var morphNormalsLength = morphNormals.length;

				var morphTargetsNormal;

				if ( morphNormalsLength > 0 ) {

					morphTargetsNormal = [];

					for ( var i = 0; i < morphNormalsLength; i ++ ) {

						morphTargetsNormal[ i ] = [];

					}

					this.morphTargets.normal = morphTargetsNormal;

				}

				// skins

				var skinIndices = geometry.skinIndices;
				var skinWeights = geometry.skinWeights;

				var hasSkinIndices = skinIndices.length === vertices.length;
				var hasSkinWeights = skinWeights.length === vertices.length;

				//

				for ( var i = 0; i < faces.length; i ++ ) {

					var face = faces[ i ];

					this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

					} else {

						var normal = face.normal;

						this.normals.push( normal, normal, normal );

					}

					var vertexColors = face.vertexColors;

					if ( vertexColors.length === 3 ) {

						this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

					} else {

						var color = face.color;

						this.colors.push( color, color, color );

					}

					if ( hasFaceVertexUv === true ) {

						var vertexUvs = faceVertexUvs[ 0 ][ i ];

						if ( vertexUvs !== undefined ) {

							this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

						} else {

							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

							this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

						}

					}

					if ( hasFaceVertexUv2 === true ) {

						var vertexUvs = faceVertexUvs[ 1 ][ i ];

						if ( vertexUvs !== undefined ) {

							this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

						} else {

							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

							this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

						}

					}

					// morphs

					for ( var j = 0; j < morphTargetsLength; j ++ ) {

						var morphTarget = morphTargets[ j ].vertices;

						morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

					}

					for ( var j = 0; j < morphNormalsLength; j ++ ) {

						var morphNormal = morphNormals[ j ].vertexNormals[ i ];

						morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

					}

					// skins

					if ( hasSkinIndices ) {

						this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

					}

					if ( hasSkinWeights ) {

						this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

					}

				}

				this.computeGroups( geometry );

				this.verticesNeedUpdate = geometry.verticesNeedUpdate;
				this.normalsNeedUpdate = geometry.normalsNeedUpdate;
				this.colorsNeedUpdate = geometry.colorsNeedUpdate;
				this.uvsNeedUpdate = geometry.uvsNeedUpdate;
				this.groupsNeedUpdate = geometry.groupsNeedUpdate;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferGeometry() {

			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'BufferGeometry';

			this.index = null;
			this.attributes = {};

			this.morphAttributes = {};

			this.groups = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.drawRange = { start: 0, count: Infinity };

		}

		Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

			isBufferGeometry: true,

			getIndex: function () {

				return this.index;

			},

			setIndex: function ( index ) {

				this.index = index;

			},

			addAttribute: function ( name, attribute ) {

				if ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {

					console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

					this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

					return;

				}

				if ( name === 'index' ) {

					console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
					this.setIndex( attribute );

					return;

				}

				this.attributes[ name ] = attribute;

				return this;

			},

			getAttribute: function ( name ) {

				return this.attributes[ name ];

			},

			removeAttribute: function ( name ) {

				delete this.attributes[ name ];

				return this;

			},

			addGroup: function ( start, count, materialIndex ) {

				this.groups.push( {

					start: start,
					count: count,
					materialIndex: materialIndex !== undefined ? materialIndex : 0

				} );

			},

			clearGroups: function () {

				this.groups = [];

			},

			setDrawRange: function ( start, count ) {

				this.drawRange.start = start;
				this.drawRange.count = count;

			},

			applyMatrix: function ( matrix ) {

				var position = this.attributes.position;

				if ( position !== undefined ) {

					matrix.applyToVector3Array( position.array );
					position.needsUpdate = true;

				}

				var normal = this.attributes.normal;

				if ( normal !== undefined ) {

					var normalMatrix = new Matrix3().getNormalMatrix( matrix );

					normalMatrix.applyToVector3Array( normal.array );
					normal.needsUpdate = true;

				}

				if ( this.boundingBox !== null ) {

					this.computeBoundingBox();

				}

				if ( this.boundingSphere !== null ) {

					this.computeBoundingSphere();

				}

				return this;

			},

			rotateX: function () {

				// rotate geometry around world x-axis

				var m1;

				return function rotateX( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationX( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateY: function () {

				// rotate geometry around world y-axis

				var m1;

				return function rotateY( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationY( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateZ: function () {

				// rotate geometry around world z-axis

				var m1;

				return function rotateZ( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationZ( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			translate: function () {

				// translate geometry

				var m1;

				return function translate( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeTranslation( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			scale: function () {

				// scale geometry

				var m1;

				return function scale( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeScale( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			lookAt: function () {

				var obj;

				return function lookAt( vector ) {

					if ( obj === undefined ) obj = new Object3D();

					obj.lookAt( vector );

					obj.updateMatrix();

					this.applyMatrix( obj.matrix );

				};

			}(),

			center: function () {

				this.computeBoundingBox();

				var offset = this.boundingBox.getCenter().negate();

				this.translate( offset.x, offset.y, offset.z );

				return offset;

			},

			setFromObject: function ( object ) {

				// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

				var geometry = object.geometry;

				if ( (object && object.isPoints) || (object && object.isLine) ) {

					var positions = new Float32Attribute( geometry.vertices.length * 3, 3 );
					var colors = new Float32Attribute( geometry.colors.length * 3, 3 );

					this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
					this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

					if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

						var lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );

						this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

					}

					if ( geometry.boundingSphere !== null ) {

						this.boundingSphere = geometry.boundingSphere.clone();

					}

					if ( geometry.boundingBox !== null ) {

						this.boundingBox = geometry.boundingBox.clone();

					}

				} else if ( (object && object.isMesh) ) {

					if ( (geometry && geometry.isGeometry) ) {

						this.fromGeometry( geometry );

					}

				}

				return this;

			},

			updateFromObject: function ( object ) {

				var geometry = object.geometry;

				if ( (object && object.isMesh) ) {

					var direct = geometry.__directGeometry;

					if ( geometry.elementsNeedUpdate === true ) {

						direct = undefined;
						geometry.elementsNeedUpdate = false;

					}

					if ( direct === undefined ) {

						return this.fromGeometry( geometry );

					}

					direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
					direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
					direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
					direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
					direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

					geometry.verticesNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.groupsNeedUpdate = false;

					geometry = direct;

				}

				var attribute;

				if ( geometry.verticesNeedUpdate === true ) {

					attribute = this.attributes.position;

					if ( attribute !== undefined ) {

						attribute.copyVector3sArray( geometry.vertices );
						attribute.needsUpdate = true;

					}

					geometry.verticesNeedUpdate = false;

				}

				if ( geometry.normalsNeedUpdate === true ) {

					attribute = this.attributes.normal;

					if ( attribute !== undefined ) {

						attribute.copyVector3sArray( geometry.normals );
						attribute.needsUpdate = true;

					}

					geometry.normalsNeedUpdate = false;

				}

				if ( geometry.colorsNeedUpdate === true ) {

					attribute = this.attributes.color;

					if ( attribute !== undefined ) {

						attribute.copyColorsArray( geometry.colors );
						attribute.needsUpdate = true;

					}

					geometry.colorsNeedUpdate = false;

				}

				if ( geometry.uvsNeedUpdate ) {

					attribute = this.attributes.uv;

					if ( attribute !== undefined ) {

						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;

					}

					geometry.uvsNeedUpdate = false;

				}

				if ( geometry.lineDistancesNeedUpdate ) {

					attribute = this.attributes.lineDistance;

					if ( attribute !== undefined ) {

						attribute.copyArray( geometry.lineDistances );
						attribute.needsUpdate = true;

					}

					geometry.lineDistancesNeedUpdate = false;

				}

				if ( geometry.groupsNeedUpdate ) {

					geometry.computeGroups( object.geometry );
					this.groups = geometry.groups;

					geometry.groupsNeedUpdate = false;

				}

				return this;

			},

			fromGeometry: function ( geometry ) {

				geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

				return this.fromDirectGeometry( geometry.__directGeometry );

			},

			fromDirectGeometry: function ( geometry ) {

				var positions = new Float32Array( geometry.vertices.length * 3 );
				this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

				if ( geometry.normals.length > 0 ) {

					var normals = new Float32Array( geometry.normals.length * 3 );
					this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

				}

				if ( geometry.colors.length > 0 ) {

					var colors = new Float32Array( geometry.colors.length * 3 );
					this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

				}

				if ( geometry.uvs.length > 0 ) {

					var uvs = new Float32Array( geometry.uvs.length * 2 );
					this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

				}

				if ( geometry.uvs2.length > 0 ) {

					var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
					this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

				}

				if ( geometry.indices.length > 0 ) {

					var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
					var indices = new TypeArray( geometry.indices.length * 3 );
					this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

				}

				// groups

				this.groups = geometry.groups;

				// morphs

				for ( var name in geometry.morphTargets ) {

					var array = [];
					var morphTargets = geometry.morphTargets[ name ];

					for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

						var morphTarget = morphTargets[ i ];

						var attribute = new Float32Attribute( morphTarget.length * 3, 3 );

						array.push( attribute.copyVector3sArray( morphTarget ) );

					}

					this.morphAttributes[ name ] = array;

				}

				// skinning

				if ( geometry.skinIndices.length > 0 ) {

					var skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );
					this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

				}

				if ( geometry.skinWeights.length > 0 ) {

					var skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );
					this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

				}

				//

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				return this;

			},

			computeBoundingBox: function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				var positions = this.attributes.position.array;

				if ( positions !== undefined ) {

					this.boundingBox.setFromArray( positions );

				} else {

					this.boundingBox.makeEmpty();

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			},

			computeBoundingSphere: function () {

				var box = new Box3();
				var vector = new Vector3();

				return function computeBoundingSphere() {

					if ( this.boundingSphere === null ) {

						this.boundingSphere = new Sphere();

					}

					var positions = this.attributes.position;

					if ( positions ) {

						var array = positions.array;
						var center = this.boundingSphere.center;

						box.setFromArray( array );
						box.getCenter( center );

						// hoping to find a boundingSphere with a radius smaller than the
						// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

						var maxRadiusSq = 0;

						for ( var i = 0, il = array.length; i < il; i += 3 ) {

							vector.fromArray( array, i );
							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

						}

						this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

						if ( isNaN( this.boundingSphere.radius ) ) {

							console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

						}

					}

				};

			}(),

			computeFaceNormals: function () {

				// backwards compatibility

			},

			computeVertexNormals: function () {

				var index = this.index;
				var attributes = this.attributes;
				var groups = this.groups;

				if ( attributes.position ) {

					var positions = attributes.position.array;

					if ( attributes.normal === undefined ) {

						this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

					} else {

						// reset existing normals to zero

						var array = attributes.normal.array;

						for ( var i = 0, il = array.length; i < il; i ++ ) {

							array[ i ] = 0;

						}

					}

					var normals = attributes.normal.array;

					var vA, vB, vC,

					pA = new Vector3(),
					pB = new Vector3(),
					pC = new Vector3(),

					cb = new Vector3(),
					ab = new Vector3();

					// indexed elements

					if ( index ) {

						var indices = index.array;

						if ( groups.length === 0 ) {

							this.addGroup( 0, indices.length );

						}

						for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

							var group = groups[ j ];

							var start = group.start;
							var count = group.count;

							for ( var i = start, il = start + count; i < il; i += 3 ) {

								vA = indices[ i + 0 ] * 3;
								vB = indices[ i + 1 ] * 3;
								vC = indices[ i + 2 ] * 3;

								pA.fromArray( positions, vA );
								pB.fromArray( positions, vB );
								pC.fromArray( positions, vC );

								cb.subVectors( pC, pB );
								ab.subVectors( pA, pB );
								cb.cross( ab );

								normals[ vA ] += cb.x;
								normals[ vA + 1 ] += cb.y;
								normals[ vA + 2 ] += cb.z;

								normals[ vB ] += cb.x;
								normals[ vB + 1 ] += cb.y;
								normals[ vB + 2 ] += cb.z;

								normals[ vC ] += cb.x;
								normals[ vC + 1 ] += cb.y;
								normals[ vC + 2 ] += cb.z;

							}

						}

					} else {

						// non-indexed elements (unconnected triangle soup)

						for ( var i = 0, il = positions.length; i < il; i += 9 ) {

							pA.fromArray( positions, i );
							pB.fromArray( positions, i + 3 );
							pC.fromArray( positions, i + 6 );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ i ] = cb.x;
							normals[ i + 1 ] = cb.y;
							normals[ i + 2 ] = cb.z;

							normals[ i + 3 ] = cb.x;
							normals[ i + 4 ] = cb.y;
							normals[ i + 5 ] = cb.z;

							normals[ i + 6 ] = cb.x;
							normals[ i + 7 ] = cb.y;
							normals[ i + 8 ] = cb.z;

						}

					}

					this.normalizeNormals();

					attributes.normal.needsUpdate = true;

				}

			},

			merge: function ( geometry, offset ) {

				if ( (geometry && geometry.isBufferGeometry) === false ) {

					console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
					return;

				}

				if ( offset === undefined ) offset = 0;

				var attributes = this.attributes;

				for ( var key in attributes ) {

					if ( geometry.attributes[ key ] === undefined ) continue;

					var attribute1 = attributes[ key ];
					var attributeArray1 = attribute1.array;

					var attribute2 = geometry.attributes[ key ];
					var attributeArray2 = attribute2.array;

					var attributeSize = attribute2.itemSize;

					for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

						attributeArray1[ j ] = attributeArray2[ i ];

					}

				}

				return this;

			},

			normalizeNormals: function () {

				var normals = this.attributes.normal.array;

				var x, y, z, n;

				for ( var i = 0, il = normals.length; i < il; i += 3 ) {

					x = normals[ i ];
					y = normals[ i + 1 ];
					z = normals[ i + 2 ];

					n = 1.0 / Math.sqrt( x * x + y * y + z * z );

					normals[ i ] *= n;
					normals[ i + 1 ] *= n;
					normals[ i + 2 ] *= n;

				}

			},

			toNonIndexed: function () {

				if ( this.index === null ) {

					console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
					return this;

				}

				var geometry2 = new BufferGeometry();

				var indices = this.index.array;
				var attributes = this.attributes;

				for ( var name in attributes ) {

					var attribute = attributes[ name ];

					var array = attribute.array;
					var itemSize = attribute.itemSize;

					var array2 = new array.constructor( indices.length * itemSize );

					var index = 0, index2 = 0;

					for ( var i = 0, l = indices.length; i < l; i ++ ) {

						index = indices[ i ] * itemSize;

						for ( var j = 0; j < itemSize; j ++ ) {

							array2[ index2 ++ ] = array[ index ++ ];

						}

					}

					geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

				}

				return geometry2;

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.4,
						type: 'BufferGeometry',
						generator: 'BufferGeometry.toJSON'
					}
				};

				// standard BufferGeometry serialization

				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;

				if ( this.parameters !== undefined ) {

					var parameters = this.parameters;

					for ( var key in parameters ) {

						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

					}

					return data;

				}

				data.data = { attributes: {} };

				var index = this.index;

				if ( index !== null ) {

					var array = Array.prototype.slice.call( index.array );

					data.data.index = {
						type: index.array.constructor.name,
						array: array
					};

				}

				var attributes = this.attributes;

				for ( var key in attributes ) {

					var attribute = attributes[ key ];

					var array = Array.prototype.slice.call( attribute.array );

					data.data.attributes[ key ] = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: array,
						normalized: attribute.normalized
					};

				}

				var groups = this.groups;

				if ( groups.length > 0 ) {

					data.data.groups = JSON.parse( JSON.stringify( groups ) );

				}

				var boundingSphere = this.boundingSphere;

				if ( boundingSphere !== null ) {

					data.data.boundingSphere = {
						center: boundingSphere.center.toArray(),
						radius: boundingSphere.radius
					};

				}

				return data;

			},

			clone: function () {

				/*
				// Handle primitives

				var parameters = this.parameters;

				if ( parameters !== undefined ) {

					var values = [];

					for ( var key in parameters ) {

						values.push( parameters[ key ] );

					}

					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;

				}

				return new this.constructor().copy( this );
				*/

				return new BufferGeometry().copy( this );

			},

			copy: function ( source ) {

				var index = source.index;

				if ( index !== null ) {

					this.setIndex( index.clone() );

				}

				var attributes = source.attributes;

				for ( var name in attributes ) {

					var attribute = attributes[ name ];
					this.addAttribute( name, attribute.clone() );

				}

				var groups = source.groups;

				for ( var i = 0, l = groups.length; i < l; i ++ ) {

					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );

				}

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		BufferGeometry.MaxIndex = 65535;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */

		function Mesh( geometry, material ) {

			Object3D.call( this );

			this.type = 'Mesh';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

			this.drawMode = TrianglesDrawMode;

			this.updateMorphTargets();

		}

		Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Mesh,

			isMesh: true,

			setDrawMode: function ( value ) {

				this.drawMode = value;

			},

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.drawMode = source.drawMode;

				return this;

			},

			updateMorphTargets: function () {

				var morphTargets = this.geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

					}

				}

			},

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				var vA = new Vector3();
				var vB = new Vector3();
				var vC = new Vector3();

				var tempA = new Vector3();
				var tempB = new Vector3();
				var tempC = new Vector3();

				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				var barycoord = new Vector3();

				var intersectionPoint = new Vector3();
				var intersectionPointWorld = new Vector3();

				function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

					Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

					uv1.multiplyScalar( barycoord.x );
					uv2.multiplyScalar( barycoord.y );
					uv3.multiplyScalar( barycoord.z );

					uv1.add( uv2 ).add( uv3 );

					return uv1.clone();

				}

				function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

					var intersect;
					var material = object.material;

					if ( material.side === BackSide ) {

						intersect = ray.intersectTriangle( pC, pB, pA, true, point );

					} else {

						intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

					}

					if ( intersect === null ) return null;

					intersectionPointWorld.copy( point );
					intersectionPointWorld.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

					if ( distance < raycaster.near || distance > raycaster.far ) return null;

					return {
						distance: distance,
						point: intersectionPointWorld.clone(),
						object: object
					};

				}

				function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

					vA.fromArray( positions, a * 3 );
					vB.fromArray( positions, b * 3 );
					vC.fromArray( positions, c * 3 );

					var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

					if ( intersection ) {

						if ( uvs ) {

							uvA.fromArray( uvs, a * 2 );
							uvB.fromArray( uvs, b * 2 );
							uvC.fromArray( uvs, c * 2 );

							intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

						}

						intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
						intersection.faceIndex = a;

					}

					return intersection;

				}

				return function raycast( raycaster, intersects ) {

					var geometry = this.geometry;
					var material = this.material;
					var matrixWorld = this.matrixWorld;

					if ( material === undefined ) return;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					// Check boundingBox before continuing

					if ( geometry.boundingBox !== null ) {

						if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

					}

					var uvs, intersection;

					if ( (geometry && geometry.isBufferGeometry) ) {

						var a, b, c;
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;

						if ( attributes.uv !== undefined ) {

							uvs = attributes.uv.array;

						}

						if ( index !== null ) {

							var indices = index.array;

							for ( var i = 0, l = indices.length; i < l; i += 3 ) {

								a = indices[ i ];
								b = indices[ i + 1 ];
								c = indices[ i + 2 ];

								intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
									intersects.push( intersection );

								}

							}

						} else {


							for ( var i = 0, l = positions.length; i < l; i += 9 ) {

								a = i / 3;
								b = a + 1;
								c = a + 2;

								intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

								if ( intersection ) {

									intersection.index = a; // triangle number in positions buffer semantics
									intersects.push( intersection );

								}

							}

						}

					} else if ( (geometry && geometry.isGeometry) ) {

						var fvA, fvB, fvC;
						var isFaceMaterial = (material && material.isMultiMaterial);
						var materials = isFaceMaterial === true ? material.materials : null;

						var vertices = geometry.vertices;
						var faces = geometry.faces;
						var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
						if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

						for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

							var face = faces[ f ];
							var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

							if ( faceMaterial === undefined ) continue;

							fvA = vertices[ face.a ];
							fvB = vertices[ face.b ];
							fvC = vertices[ face.c ];

							if ( faceMaterial.morphTargets === true ) {

								var morphTargets = geometry.morphTargets;
								var morphInfluences = this.morphTargetInfluences;

								vA.set( 0, 0, 0 );
								vB.set( 0, 0, 0 );
								vC.set( 0, 0, 0 );

								for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

									var influence = morphInfluences[ t ];

									if ( influence === 0 ) continue;

									var targets = morphTargets[ t ].vertices;

									vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
									vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
									vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

								}

								vA.add( fvA );
								vB.add( fvB );
								vC.add( fvC );

								fvA = vA;
								fvB = vB;
								fvC = vC;

							}

							intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

							if ( intersection ) {

								if ( uvs ) {

									var uvs_f = uvs[ f ];
									uvA.copy( uvs_f[ 0 ] );
									uvB.copy( uvs_f[ 1 ] );
									uvC.copy( uvs_f[ 2 ] );

									intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

								}

								intersection.face = face;
								intersection.faceIndex = f;
								intersects.push( intersection );

							}

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

			BufferGeometry.call( this );

			this.type = 'BoxBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			var scope = this;

			// segments
			widthSegments = Math.floor( widthSegments ) || 1;
			heightSegments = Math.floor( heightSegments ) || 1;
			depthSegments = Math.floor( depthSegments ) || 1;

			// these are used to calculate buffer length
			var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
			var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

			// buffers
			var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
			var vertices = new Float32Array( vertexCount * 3 );
			var normals = new Float32Array( vertexCount * 3 );
			var uvs = new Float32Array( vertexCount * 2 );

			// offset variables
			var vertexBufferOffset = 0;
			var uvBufferOffset = 0;
			var indexBufferOffset = 0;
			var numberOfVertices = 0;

			// group variables
			var groupStart = 0;

			// build each side of the box geometry
			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
			buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
			buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

			// build geometry
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

			// helper functions

			function calculateVertexCount( w, h, d ) {

				var vertices = 0;

				// calculate the amount of vertices for each side (plane)
				vertices += (w + 1) * (h + 1) * 2; // xy
				vertices += (w + 1) * (d + 1) * 2; // xz
				vertices += (d + 1) * (h + 1) * 2; // zy

				return vertices;

			}

			function calculateIndexCount( w, h, d ) {

				var index = 0;

				// calculate the amount of squares for each side
				index += w * h * 2; // xy
				index += w * d * 2; // xz
				index += d * h * 2; // zy

				return index * 6; // two triangles per square => six vertices per square

			}

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				var segmentWidth	= width / gridX;
				var segmentHeight = height / gridY;

				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;

				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;

				var vertexCounter = 0;
				var groupCount = 0;

				var vector = new Vector3();

				// generate vertices, normals and uvs

				for ( var iy = 0; iy < gridY1; iy ++ ) {

					var y = iy * segmentHeight - heightHalf;

					for ( var ix = 0; ix < gridX1; ix ++ ) {

						var x = ix * segmentWidth - widthHalf;

						// set values to correct vector component
						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer
						vertices[ vertexBufferOffset ] = vector.x;
						vertices[ vertexBufferOffset + 1 ] = vector.y;
						vertices[ vertexBufferOffset + 2 ] = vector.z;

						// set values to correct vector component
						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer
						normals[ vertexBufferOffset ] = vector.x;
						normals[ vertexBufferOffset + 1 ] = vector.y;
						normals[ vertexBufferOffset + 2 ] = vector.z;

						// uvs
						uvs[ uvBufferOffset ] = ix / gridX;
						uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

						// update offsets and counters
						vertexBufferOffset += 3;
						uvBufferOffset += 2;
						vertexCounter += 1;

					}

				}

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( iy = 0; iy < gridY; iy ++ ) {

					for ( ix = 0; ix < gridX; ix ++ ) {

						// indices
						var a = numberOfVertices + ix + gridX1 * iy;
						var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// face one
						indices[ indexBufferOffset ] = a;
						indices[ indexBufferOffset + 1 ] = b;
						indices[ indexBufferOffset + 2 ] = d;

						// face two
						indices[ indexBufferOffset + 3 ] = b;
						indices[ indexBufferOffset + 4 ] = c;
						indices[ indexBufferOffset + 5 ] = d;

						// update offsets and counters
						indexBufferOffset += 6;
						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups
				groupStart += groupCount;

				// update total number of vertices
				numberOfVertices += vertexCounter;

			}

		}

		BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */

		function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

			BufferGeometry.call( this );

			this.type = 'PlaneBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			var width_half = width / 2;
			var height_half = height / 2;

			var gridX = Math.floor( widthSegments ) || 1;
			var gridY = Math.floor( heightSegments ) || 1;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var segment_width = width / gridX;
			var segment_height = height / gridY;

			var vertices = new Float32Array( gridX1 * gridY1 * 3 );
			var normals = new Float32Array( gridX1 * gridY1 * 3 );
			var uvs = new Float32Array( gridX1 * gridY1 * 2 );

			var offset = 0;
			var offset2 = 0;

			for ( var iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segment_height - height_half;

				for ( var ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segment_width - width_half;

					vertices[ offset ] = x;
					vertices[ offset + 1 ] = - y;

					normals[ offset + 2 ] = 1;

					uvs[ offset2 ] = ix / gridX;
					uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

					offset += 3;
					offset2 += 2;

				}

			}

			offset = 0;

			var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

			for ( var iy = 0; iy < gridY; iy ++ ) {

				for ( var ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					indices[ offset ] = a;
					indices[ offset + 1 ] = b;
					indices[ offset + 2 ] = d;

					indices[ offset + 3 ] = b;
					indices[ offset + 4 ] = c;
					indices[ offset + 5 ] = d;

					offset += 6;

				}

			}

			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

		}

		PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function Camera() {

			Object3D.call( this );

			this.type = 'Camera';

			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();

		}

		Camera.prototype = Object.create( Object3D.prototype );
		Camera.prototype.constructor = Camera;

		Camera.prototype.isCamera = true;

		Camera.prototype.getWorldDirection = function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			};

		}();

		Camera.prototype.lookAt = function () {

			// This routine does not support cameras with rotated and/or translated parent(s)

			var m1 = new Matrix4();

			return function lookAt( vector ) {

				m1.lookAt( this.position, vector, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}();

		Camera.prototype.clone = function () {

			return new this.constructor().copy( this );

		};

		Camera.prototype.copy = function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */

		function PerspectiveCamera( fov, aspect, near, far ) {

			Camera.call( this );

			this.type = 'PerspectiveCamera';

			this.fov = fov !== undefined ? fov : 50;
			this.zoom = 1;

			this.near = near !== undefined ? near : 0.1;
			this.far = far !== undefined ? far : 2000;
			this.focus = 10;

			this.aspect = aspect !== undefined ? aspect : 1;
			this.view = null;

			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();

		}

		PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

			constructor: PerspectiveCamera,

			isPerspectiveCamera: true,

			copy: function ( source ) {

				Camera.prototype.copy.call( this, source );

				this.fov = source.fov;
				this.zoom = source.zoom;

				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;

				this.aspect = source.aspect;
				this.view = source.view === null ? null : Object.assign( {}, source.view );

				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;

				return this;

			},

			/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */
			setFocalLength: function ( focalLength ) {

				// see http://www.bobatkins.com/photography/technical/field_of_view.html
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

				this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
				this.updateProjectionMatrix();

			},

			/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */
			getFocalLength: function () {

				var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

				return 0.5 * this.getFilmHeight() / vExtentSlope;

			},

			getEffectiveFOV: function () {

				return _Math.RAD2DEG * 2 * Math.atan(
						Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

			},

			getFilmWidth: function () {

				// film not completely covered in portrait format (aspect < 1)
				return this.filmGauge * Math.min( this.aspect, 1 );

			},

			getFilmHeight: function () {

				// film not completely covered in landscape format (aspect > 1)
				return this.filmGauge / Math.max( this.aspect, 1 );

			},

			/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */
			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

				this.aspect = fullWidth / fullHeight;

				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};

				this.updateProjectionMatrix();

			},

			clearViewOffset: function() {

				this.view = null;
				this.updateProjectionMatrix();

			},

			updateProjectionMatrix: function () {

				var near = this.near,
					top = near * Math.tan(
							_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
					height = 2 * top,
					width = this.aspect * height,
					left = - 0.5 * width,
					view = this.view;

				if ( view !== null ) {

					var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;

					left += view.offsetX * width / fullWidth;
					top -= view.offsetY * height / fullHeight;
					width *= view.width / fullWidth;
					height *= view.height / fullHeight;

				}

				var skew = this.filmOffset;
				if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

				this.projectionMatrix.makeFrustum(
						left, left + width, top - height, top, near, this.far );

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.fov = this.fov;
				data.object.zoom = this.zoom;

				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;

				data.object.aspect = this.aspect;

				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */

		function OrthographicCamera( left, right, top, bottom, near, far ) {

			Camera.call( this );

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = ( near !== undefined ) ? near : 0.1;
			this.far = ( far !== undefined ) ? far : 2000;

			this.updateProjectionMatrix();

		}

		OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

			constructor: OrthographicCamera,

			isOrthographicCamera: true,

			copy: function ( source ) {

				Camera.prototype.copy.call( this, source );

				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;

				this.zoom = source.zoom;
				this.view = source.view === null ? null : Object.assign( {}, source.view );

				return this;

			},

			setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};

				this.updateProjectionMatrix();

			},

			clearViewOffset: function() {

				this.view = null;
				this.updateProjectionMatrix();

			},

			updateProjectionMatrix: function () {

				var dx = ( this.right - this.left ) / ( 2 * this.zoom );
				var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
				var cx = ( this.right + this.left ) / 2;
				var cy = ( this.top + this.bottom ) / 2;

				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;

				if ( this.view !== null ) {

					var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
					var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
					var scaleW = ( this.right - this.left ) / this.view.width;
					var scaleH = ( this.top - this.bottom ) / this.view.height;

					left += scaleW * ( this.view.offsetX / zoomW );
					right = left + scaleW * ( this.view.width / zoomW );
					top -= scaleH * ( this.view.offsetY / zoomH );
					bottom = top - scaleH * ( this.view.height / zoomH );

				}

				this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;

				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

				return data;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

			var mode;

			function setMode( value ) {

				mode = value;

			}

			var type, size;

			function setIndex( index ) {

				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

					type = gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = gl.UNSIGNED_SHORT;
					size = 2;

				}

			}

			function render( start, count ) {

				gl.drawElements( mode, count, type, start * size );

				infoRender.calls ++;
				infoRender.vertices += count;

				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

			}

			function renderInstances( geometry, start, count ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

				extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;

				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

			}

			return {

				setMode: setMode,
				setIndex: setIndex,
				render: render,
				renderInstances: renderInstances

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLBufferRenderer( gl, extensions, infoRender ) {

			var mode;

			function setMode( value ) {

				mode = value;

			}

			function render( start, count ) {

				gl.drawArrays( mode, start, count );

				infoRender.calls ++;
				infoRender.vertices += count;

				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

			}

			function renderInstances( geometry ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

				var position = geometry.attributes.position;

				var count = 0;

				if ( (position && position.isInterleavedBufferAttribute) ) {

					count = position.data.count;

					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

				} else {

					count = position.count;

					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

				}

				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;

				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

			}

			return {
				setMode: setMode,
				render: render,
				renderInstances: renderInstances
			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLLights() {

			var lights = {};

			return {

				get: function ( light ) {

					if ( lights[ light.id ] !== undefined ) {

						return lights[ light.id ];

					}

					var uniforms;

					switch ( light.type ) {

						case 'DirectionalLight':
							uniforms = {
								direction: new Vector3(),
								color: new Color(),

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'SpotLight':
							uniforms = {
								position: new Vector3(),
								direction: new Vector3(),
								color: new Color(),
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0,

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'PointLight':
							uniforms = {
								position: new Vector3(),
								color: new Color(),
								distance: 0,
								decay: 0,

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'HemisphereLight':
							uniforms = {
								direction: new Vector3(),
								skyColor: new Color(),
								groundColor: new Color()
							};
							break;

					}

					lights[ light.id ] = uniforms;

					return uniforms;

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function addLineNumbers( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		}

		function WebGLShader( gl, type, string ) {

			var shader = gl.createShader( type );

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var programIdCount = 0;

		function getEncodingComponents( encoding ) {

			switch ( encoding ) {

				case LinearEncoding:
					return [ 'Linear','( value )' ];
				case sRGBEncoding:
					return [ 'sRGB','( value )' ];
				case RGBEEncoding:
					return [ 'RGBE','( value )' ];
				case RGBM7Encoding:
					return [ 'RGBM','( value, 7.0 )' ];
				case RGBM16Encoding:
					return [ 'RGBM','( value, 16.0 )' ];
				case RGBDEncoding:
					return [ 'RGBD','( value, 256.0 )' ];
				case GammaEncoding:
					return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );

			}

		}

		function getTexelDecodingFunction( functionName, encoding ) {

			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

		}

		function getTexelEncodingFunction( functionName, encoding ) {

			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

		}

		function getToneMappingFunction( functionName, toneMapping ) {

			var toneMappingName;

			switch ( toneMapping ) {

				case LinearToneMapping:
					toneMappingName = "Linear";
					break;

				case ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;

				case Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;

				case CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;

				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );

			}

			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

		}

		function generateExtensions( extensions, parameters, rendererExtensions ) {

			extensions = extensions || {};

			var chunks = [
				( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
			];

			return chunks.filter( filterEmptyLine ).join( '\n' );

		}

		function generateDefines( defines ) {

			var chunks = [];

			for ( var name in defines ) {

				var value = defines[ name ];

				if ( value === false ) continue;

				chunks.push( '#define ' + name + ' ' + value );

			}

			return chunks.join( '\n' );

		}

		function fetchAttributeLocations( gl, program, identifiers ) {

			var attributes = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveAttrib( program, i );
				var name = info.name;

				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

				attributes[ name ] = gl.getAttribLocation( program, name );

			}

			return attributes;

		}

		function filterEmptyLine( string ) {

			return string !== '';

		}

		function replaceLightNums( string, parameters ) {

			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

		}

		function parseIncludes( string ) {

			var pattern = /#include +<([\w\d.]+)>/g;

			function replace( match, include ) {

				var replace = ShaderChunk[ include ];

				if ( replace === undefined ) {

					throw new Error( 'Can not resolve #include <' + include + '>' );

				}

				return parseIncludes( replace );

			}

			return string.replace( pattern, replace );

		}

		function unrollLoops( string ) {

			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

			function replace( match, start, end, snippet ) {

				var unroll = '';

				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

				}

				return unroll;

			}

			return string.replace( pattern, replace );

		}

		function WebGLProgram( renderer, code, material, parameters ) {

			var gl = renderer.context;

			var extensions = material.extensions;
			var defines = material.defines;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if ( parameters.envMap ) {

				switch ( material.envMap.mapping ) {

					case CubeReflectionMapping:
					case CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case CubeUVReflectionMapping:
					case CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;

					case EquirectangularReflectionMapping:
					case EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch ( material.envMap.mapping ) {

					case CubeRefractionMapping:
					case EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch ( material.combine ) {

					case MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			// console.log( 'building new program ' );

			//

			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

			var customDefines = generateDefines( defines );

			//

			var program = gl.createProgram();

			var prefixVertex, prefixFragment;

			if ( material.isRawShaderMaterial ) {

				prefixVertex = [

					customDefines,

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					customExtensions,
					customDefines,

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			} else {

				prefixVertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					customExtensions,

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
					'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',

					( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
					( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

					( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			}

			vertexShader = parseIncludes( vertexShader, parameters );
			vertexShader = replaceLightNums( vertexShader, parameters );

			fragmentShader = parseIncludes( fragmentShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );

			if ( ! material.isShaderMaterial ) {

				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );

			}

			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;

			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );

			var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );

			// Force a particular attribute to index 0.

			if ( material.index0AttributeName !== undefined ) {

				gl.bindAttribLocation( program, 0, material.index0AttributeName );

			} else if ( parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );

			}

			gl.linkProgram( program );

			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

			var runnable = true;
			var haveDiagnostics = true;

			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,
					material: material,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

			// clean up

			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );

			// set up caching for uniform locations

			var cachedUniforms;

			this.getUniforms = function() {

				if ( cachedUniforms === undefined ) {

					cachedUniforms =
							new WebGLUniforms( gl, program, renderer );

				}

				return cachedUniforms;

			};

			// set up caching for attribute locations

			var cachedAttributes;

			this.getAttributes = function() {

				if ( cachedAttributes === undefined ) {

					cachedAttributes = fetchAttributeLocations( gl, program );

				}

				return cachedAttributes;

			};

			// free resource

			this.destroy = function() {

				gl.deleteProgram( program );
				this.program = undefined;

			};

			// DEPRECATED

			Object.defineProperties( this, {

				uniforms: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();

					}
				},

				attributes: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();

					}
				}

			} );


			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLPrograms( renderer, capabilities ) {

			var programs = [];

			var shaderIDs = {
				MeshDepthMaterial: 'depth',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points'
			};

			var parameterNames = [
				"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
				"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
				"roughnessMap", "metalnessMap",
				"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
				"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
				"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
				"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
				"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
				"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
				"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
			];


			function allocateBones( object ) {

				if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

					return 1024;

				} else {

					// default for when object is not specified
					// ( for example when prebuilding shader to be used with multiple objects )
					//
					//  - leave some extra space for other uniforms
					//  - limit here is ANGLE's 254 max uniform vectors
					//    (up to 54 should be safe)

					var nVertexUniforms = capabilities.maxVertexUniforms;
					var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

					var maxBones = nVertexMatrices;

					if ( object !== undefined && (object && object.isSkinnedMesh) ) {

						maxBones = Math.min( object.skeleton.bones.length, maxBones );

						if ( maxBones < object.skeleton.bones.length ) {

							console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

						}

					}

					return maxBones;

				}

			}

			function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

				var encoding;

				if ( ! map ) {

					encoding = LinearEncoding;

				} else if ( (map && map.isTexture) ) {

					encoding = map.encoding;

				} else if ( (map && map.isWebGLRenderTarget) ) {

					console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
					encoding = map.texture.encoding;

				}

				// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
				if ( encoding === LinearEncoding && gammaOverrideLinear ) {

					encoding = GammaEncoding;

				}

				return encoding;

			}

			this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {

				var shaderID = shaderIDs[ material.type ];

				// heuristics to create shader parameters according to lights in the scene
				// (not to blow over maxLights budget)

				var maxBones = allocateBones( object );
				var precision = renderer.getPrecision();

				if ( material.precision !== null ) {

					precision = capabilities.getMaxPrecision( material.precision );

					if ( precision !== material.precision ) {

						console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

					}

				}

				var currentRenderTarget = renderer.getCurrentRenderTarget();

				var parameters = {

					shaderID: shaderID,

					precision: precision,
					supportsVertexTextures: capabilities.vertexTextures,
					outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
					map: !! material.map,
					mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
					envMap: !! material.envMap,
					envMapMode: material.envMap && material.envMap.mapping,
					envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
					envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
					lightMap: !! material.lightMap,
					aoMap: !! material.aoMap,
					emissiveMap: !! material.emissiveMap,
					emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
					bumpMap: !! material.bumpMap,
					normalMap: !! material.normalMap,
					displacementMap: !! material.displacementMap,
					roughnessMap: !! material.roughnessMap,
					metalnessMap: !! material.metalnessMap,
					specularMap: !! material.specularMap,
					alphaMap: !! material.alphaMap,

					combine: material.combine,

					vertexColors: material.vertexColors,

					fog: !! fog,
					useFog: material.fog,
					fogExp: (fog && fog.isFogExp2),

					flatShading: material.shading === FlatShading,

					sizeAttenuation: material.sizeAttenuation,
					logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

					skinning: material.skinning,
					maxBones: maxBones,
					useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

					morphTargets: material.morphTargets,
					morphNormals: material.morphNormals,
					maxMorphTargets: renderer.maxMorphTargets,
					maxMorphNormals: renderer.maxMorphNormals,

					numDirLights: lights.directional.length,
					numPointLights: lights.point.length,
					numSpotLights: lights.spot.length,
					numHemiLights: lights.hemi.length,

					numClippingPlanes: nClipPlanes,
					numClipIntersection: nClipIntersection,

					shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
					shadowMapType: renderer.shadowMap.type,

					toneMapping: renderer.toneMapping,
					physicallyCorrectLights: renderer.physicallyCorrectLights,

					premultipliedAlpha: material.premultipliedAlpha,

					alphaTest: material.alphaTest,
					doubleSided: material.side === DoubleSide,
					flipSided: material.side === BackSide,

					depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

				};

				return parameters;

			};

			this.getProgramCode = function ( material, parameters ) {

				var array = [];

				if ( parameters.shaderID ) {

					array.push( parameters.shaderID );

				} else {

					array.push( material.fragmentShader );
					array.push( material.vertexShader );

				}

				if ( material.defines !== undefined ) {

					for ( var name in material.defines ) {

						array.push( name );
						array.push( material.defines[ name ] );

					}

				}

				for ( var i = 0; i < parameterNames.length; i ++ ) {

					array.push( parameters[ parameterNames[ i ] ] );

				}

				return array.join();

			};

			this.acquireProgram = function ( material, parameters, code ) {

				var program;

				// Check if code has been already compiled
				for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

					var programInfo = programs[ p ];

					if ( programInfo.code === code ) {

						program = programInfo;
						++ program.usedTimes;

						break;

					}

				}

				if ( program === undefined ) {

					program = new WebGLProgram( renderer, code, material, parameters );
					programs.push( program );

				}

				return program;

			};

			this.releaseProgram = function( program ) {

				if ( -- program.usedTimes === 0 ) {

					// Remove from unordered set
					var i = programs.indexOf( program );
					programs[ i ] = programs[ programs.length - 1 ];
					programs.pop();

					// Free WebGL resources
					program.destroy();

				}

			};

			// Exposed for resource monitoring & error feedback via renderer.info:
			this.programs = programs;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLGeometries( gl, properties, info ) {

			var geometries = {};

			function onGeometryDispose( event ) {

				var geometry = event.target;
				var buffergeometry = geometries[ geometry.id ];

				if ( buffergeometry.index !== null ) {

					deleteAttribute( buffergeometry.index );

				}

				deleteAttributes( buffergeometry.attributes );

				geometry.removeEventListener( 'dispose', onGeometryDispose );

				delete geometries[ geometry.id ];

				// TODO

				var property = properties.get( geometry );

				if ( property.wireframe ) {

					deleteAttribute( property.wireframe );

				}

				properties.delete( geometry );

				var bufferproperty = properties.get( buffergeometry );

				if ( bufferproperty.wireframe ) {

					deleteAttribute( bufferproperty.wireframe );

				}

				properties.delete( buffergeometry );

				//

				info.memory.geometries --;

			}

			function getAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					return properties.get( attribute.data ).__webglBuffer;

				}

				return properties.get( attribute ).__webglBuffer;

			}

			function deleteAttribute( attribute ) {

				var buffer = getAttributeBuffer( attribute );

				if ( buffer !== undefined ) {

					gl.deleteBuffer( buffer );
					removeAttributeBuffer( attribute );

				}

			}

			function deleteAttributes( attributes ) {

				for ( var name in attributes ) {

					deleteAttribute( attributes[ name ] );

				}

			}

			function removeAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					properties.delete( attribute.data );

				} else {

					properties.delete( attribute );

				}

			}

			return {

				get: function ( object ) {

					var geometry = object.geometry;

					if ( geometries[ geometry.id ] !== undefined ) {

						return geometries[ geometry.id ];

					}

					geometry.addEventListener( 'dispose', onGeometryDispose );

					var buffergeometry;

					if ( geometry.isBufferGeometry ) {

						buffergeometry = geometry;

					} else if ( geometry.isGeometry ) {

						if ( geometry._bufferGeometry === undefined ) {

							geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

						}

						buffergeometry = geometry._bufferGeometry;

					}

					geometries[ geometry.id ] = buffergeometry;

					info.memory.geometries ++;

					return buffergeometry;

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLObjects( gl, properties, info ) {

			var geometries = new WebGLGeometries( gl, properties, info );

			//

			function update( object ) {

				// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

				var geometry = geometries.get( object );

				if ( object.geometry.isGeometry ) {

					geometry.updateFromObject( object );

				}

				var index = geometry.index;
				var attributes = geometry.attributes;

				if ( index !== null ) {

					updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

				}

				for ( var name in attributes ) {

					updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

				}

				// morph targets

				var morphAttributes = geometry.morphAttributes;

				for ( var name in morphAttributes ) {

					var array = morphAttributes[ name ];

					for ( var i = 0, l = array.length; i < l; i ++ ) {

						updateAttribute( array[ i ], gl.ARRAY_BUFFER );

					}

				}

				return geometry;

			}

			function updateAttribute( attribute, bufferType ) {

				var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

				var attributeProperties = properties.get( data );

				if ( attributeProperties.__webglBuffer === undefined ) {

					createBuffer( attributeProperties, data, bufferType );

				} else if ( attributeProperties.version !== data.version ) {

					updateBuffer( attributeProperties, data, bufferType );

				}

			}

			function createBuffer( attributeProperties, data, bufferType ) {

				attributeProperties.__webglBuffer = gl.createBuffer();
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

				var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

				gl.bufferData( bufferType, data.array, usage );

				attributeProperties.version = data.version;

			}

			function updateBuffer( attributeProperties, data, bufferType ) {

				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

				if ( data.dynamic === false ) {

					gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );

				} else if ( data.updateRange.count === - 1 ) {

					// Not using update ranges

					gl.bufferSubData( bufferType, 0, data.array );

				} else if ( data.updateRange.count === 0 ) {

					console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

				} else {

					gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
									  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

					data.updateRange.count = 0; // reset range

				}

				attributeProperties.version = data.version;

			}

			function getAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					return properties.get( attribute.data ).__webglBuffer;

				}

				return properties.get( attribute ).__webglBuffer;

			}

			function getWireframeAttribute( geometry ) {

				var property = properties.get( geometry );

				if ( property.wireframe !== undefined ) {

					return property.wireframe;

				}

				var indices = [];

				var index = geometry.index;
				var attributes = geometry.attributes;
				var position = attributes.position;

				// console.time( 'wireframe' );

				if ( index !== null ) {

					var edges = {};
					var array = index.array;

					for ( var i = 0, l = array.length; i < l; i += 3 ) {

						var a = array[ i + 0 ];
						var b = array[ i + 1 ];
						var c = array[ i + 2 ];

						indices.push( a, b, b, c, c, a );

					}

				} else {

					var array = attributes.position.array;

					for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

						var a = i + 0;
						var b = i + 1;
						var c = i + 2;

						indices.push( a, b, b, c, c, a );

					}

				}

				// console.timeEnd( 'wireframe' );

				var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
				var attribute = new BufferAttribute( new TypeArray( indices ), 1 );

				updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

				property.wireframe = attribute;

				return attribute;

			}

			return {

				getAttributeBuffer: getAttributeBuffer,
				getWireframeAttribute: getWireframeAttribute,

				update: update

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

			var _infoMemory = info.memory;
			var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

			//

			function clampToMaxSize( image, maxSize ) {

				if ( image.width > maxSize || image.height > maxSize ) {

					// Warning: Scaling through the canvas will only work with images that use
					// premultiplied alpha.

					var scale = maxSize / Math.max( image.width, image.height );

					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = Math.floor( image.width * scale );
					canvas.height = Math.floor( image.height * scale );

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

					console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

					return canvas;

				}

				return image;

			}

			function isPowerOfTwo( image ) {

				return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

			}

			function makePowerOfTwo( image ) {

				if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = _Math.nearestPowerOfTwo( image.width );
					canvas.height = _Math.nearestPowerOfTwo( image.height );

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, canvas.width, canvas.height );

					console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

					return canvas;

				}

				return image;

			}

			function textureNeedsPowerOfTwo( texture ) {

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;
				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;

				return false;

			}

			// Fallback filters for non-power-of-2 textures

			function filterFallback( f ) {

				if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

					return _gl.NEAREST;

				}

				return _gl.LINEAR;

			}

			//

			function onTextureDispose( event ) {

				var texture = event.target;

				texture.removeEventListener( 'dispose', onTextureDispose );

				deallocateTexture( texture );

				_infoMemory.textures --;


			}

			function onRenderTargetDispose( event ) {

				var renderTarget = event.target;

				renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

				deallocateRenderTarget( renderTarget );

				_infoMemory.textures --;

			}

			//

			function deallocateTexture( texture ) {

				var textureProperties = properties.get( texture );

				if ( texture.image && textureProperties.__image__webglTextureCube ) {

					// cube texture

					_gl.deleteTexture( textureProperties.__image__webglTextureCube );

				} else {

					// 2D texture

					if ( textureProperties.__webglInit === undefined ) return;

					_gl.deleteTexture( textureProperties.__webglTexture );

				}

				// remove all webgl properties
				properties.delete( texture );

			}

			function deallocateRenderTarget( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				if ( ! renderTarget ) return;

				if ( textureProperties.__webglTexture !== undefined ) {

					_gl.deleteTexture( textureProperties.__webglTexture );

				}

				if ( renderTarget.depthTexture ) {

					renderTarget.depthTexture.dispose();

				}

				if ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {

					for ( var i = 0; i < 6; i ++ ) {

						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
						if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

					}

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

				}

				properties.delete( renderTarget.texture );
				properties.delete( renderTarget );

			}

			//



			function setTexture2D( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					var image = texture.image;

					if ( image === undefined ) {

						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

					} else if ( image.complete === false ) {

						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

					} else {

						uploadTexture( textureProperties, texture, slot );
						return;

					}

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			}

			function setTextureCube( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.image.length === 6 ) {

					if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

						if ( ! textureProperties.__image__webglTextureCube ) {

							texture.addEventListener( 'dispose', onTextureDispose );

							textureProperties.__image__webglTextureCube = _gl.createTexture();

							_infoMemory.textures ++;

						}

						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

						_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

						var isCompressed = (texture && texture.isCompressedTexture);
						var isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);

						var cubeImage = [];

						for ( var i = 0; i < 6; i ++ ) {

							if ( ! isCompressed && ! isDataTexture ) {

								cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

							} else {

								cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

							}

						}

						var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = paramThreeToGL( texture.format ),
						glType = paramThreeToGL( texture.type );

						setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

						for ( var i = 0; i < 6; i ++ ) {

							if ( ! isCompressed ) {

								if ( isDataTexture ) {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

								}

							} else {

								var mipmap, mipmaps = cubeImage[ i ].mipmaps;

								for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

									mipmap = mipmaps[ j ];

									if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

										if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

											state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

										} else {

											console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

										}

									} else {

										state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

									}

								}

							}

						}

						if ( texture.generateMipmaps && isPowerOfTwoImage ) {

							_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

						}

						textureProperties.__version = texture.version;

						if ( texture.onUpdate ) texture.onUpdate( texture );

					} else {

						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					}

				}

			}

			function setTextureCubeDynamic( texture, slot ) {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

			}

			function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

				var extension;

				if ( isPowerOfTwoImage ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

				} else {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

					if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

					}

					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

					if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

					}

				}

				extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension ) {

					if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
					if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

					if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

						_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
						properties.get( texture ).__currentAnisotropy = texture.anisotropy;

					}

				}

			}

			function uploadTexture( textureProperties, texture, slot ) {

				if ( textureProperties.__webglInit === undefined ) {

					textureProperties.__webglInit = true;

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__webglTexture = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

				var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

				if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

					image = makePowerOfTwo( image );

				}

				var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

				var mipmap, mipmaps = texture.mipmaps;

				if ( (texture && texture.isDepthTexture) ) {

					// populate depth texture with dummy data

					var internalFormat = _gl.DEPTH_COMPONENT;

					if ( texture.type === FloatType ) {

						if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
						internalFormat = _gl.DEPTH_COMPONENT32F;

					} else if ( _isWebGL2 ) {

						// WebGL 2.0 requires signed internalformat for glTexImage2D
						internalFormat = _gl.DEPTH_COMPONENT16;

					}

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.format === DepthStencilFormat ) {

						internalFormat = _gl.DEPTH_STENCIL;

					}

					state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

				} else if ( (texture && texture.isDataTexture) ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

						texture.generateMipmaps = false;

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				} else if ( (texture && texture.isCompressedTexture) ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

								state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

						}

						texture.generateMipmaps = false;

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

					}

				}

				if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			// Render targets

			// Setup storage for target texture and bind it to correct framebuffer
			function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

				var glFormat = paramThreeToGL( renderTarget.texture.format );
				var glType = paramThreeToGL( renderTarget.texture.type );
				state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
			function setupRenderBufferStorage( renderbuffer, renderTarget ) {

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

				if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

				} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

				} else {

					// FIXME: We don't support !depth !stencil
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

			}

			// Setup resources for a Depth Texture for a FBO (needs an extension)
			function setupDepthTexture( framebuffer, renderTarget ) {

				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
				if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				if ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {

					throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

				}

				// upload an empty depth texture with framebuffer size
				if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
						renderTarget.depthTexture.image.width !== renderTarget.width ||
						renderTarget.depthTexture.image.height !== renderTarget.height ) {
					renderTarget.depthTexture.image.width = renderTarget.width;
					renderTarget.depthTexture.image.height = renderTarget.height;
					renderTarget.depthTexture.needsUpdate = true;
				}

				setTexture2D( renderTarget.depthTexture, 0 );

				var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

				if ( renderTarget.depthTexture.format === DepthFormat ) {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				} else {

					throw new Error('Unknown depthTexture format')

				}

			}

			// Setup GL resources for a non-texture depth buffer
			function setupDepthRenderbuffer( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );

				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );

				if ( renderTarget.depthTexture ) {

					if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

				} else {

					if ( isCube ) {

						renderTargetProperties.__webglDepthbuffer = [];

						for ( var i = 0; i < 6; i ++ ) {

							_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

						}

					} else {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

					}

				}

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			// Set up GL resources for the render target
			function setupRenderTarget( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

				// Setup framebuffer

				if ( isCube ) {

					renderTargetProperties.__webglFramebuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				}

				// Setup color buffer

				if ( isCube ) {

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

					}

					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
					state.bindTexture( _gl.TEXTURE_2D, null );

				}

				// Setup depth and stencil buffers

				if ( renderTarget.depthBuffer ) {

					setupDepthRenderbuffer( renderTarget );

				}

			}

			function updateRenderTargetMipmap( renderTarget ) {

				var texture = renderTarget.texture;

				if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
						texture.minFilter !== NearestFilter &&
						texture.minFilter !== LinearFilter ) {

					var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					var webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( target, webglTexture );
					_gl.generateMipmap( target );
					state.bindTexture( target, null );

				}

			}

			this.setTexture2D = setTexture2D;
			this.setTextureCube = setTextureCube;
			this.setTextureCubeDynamic = setTextureCubeDynamic;
			this.setupRenderTarget = setupRenderTarget;
			this.updateRenderTargetMipmap = updateRenderTargetMipmap;

		}

		/**
		 * @author fordacious / fordacious.github.io
		 */

		function WebGLProperties() {

			var properties = {};

			return {

				get: function ( object ) {

					var uuid = object.uuid;
					var map = properties[ uuid ];

					if ( map === undefined ) {

						map = {};
						properties[ uuid ] = map;

					}

					return map;

				},

				delete: function ( object ) {

					delete properties[ object.uuid ];

				},

				clear: function () {

					properties = {};

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLState( gl, extensions, paramThreeToGL ) {

			function ColorBuffer() {

				var locked = false;

				var color = new Vector4();
				var currentColorMask = null;
				var currentColorClear = new Vector4();

				return {

					setMask: function ( colorMask ) {

						if ( currentColorMask !== colorMask && ! locked ) {

							gl.colorMask( colorMask, colorMask, colorMask, colorMask );
							currentColorMask = colorMask;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( r, g, b, a ) {

						color.set( r, g, b, a );

						if ( currentColorClear.equals( color ) === false ) {

							gl.clearColor( r, g, b, a );
							currentColorClear.copy( color );

						}

					},

					reset: function () {

						locked = false;

						currentColorMask = null;
						currentColorClear.set( 0, 0, 0, 1 );

					}

				};

			}

			function DepthBuffer() {

				var locked = false;

				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;

				return {

					setTest: function ( depthTest ) {

						if ( depthTest ) {

							enable( gl.DEPTH_TEST );

						} else {

							disable( gl.DEPTH_TEST );

						}

					},

					setMask: function ( depthMask ) {

						if ( currentDepthMask !== depthMask && ! locked ) {

							gl.depthMask( depthMask );
							currentDepthMask = depthMask;

						}

					},

					setFunc: function ( depthFunc ) {

						if ( currentDepthFunc !== depthFunc ) {

							if ( depthFunc ) {

								switch ( depthFunc ) {

									case NeverDepth:

										gl.depthFunc( gl.NEVER );
										break;

									case AlwaysDepth:

										gl.depthFunc( gl.ALWAYS );
										break;

									case LessDepth:

										gl.depthFunc( gl.LESS );
										break;

									case LessEqualDepth:

										gl.depthFunc( gl.LEQUAL );
										break;

									case EqualDepth:

										gl.depthFunc( gl.EQUAL );
										break;

									case GreaterEqualDepth:

										gl.depthFunc( gl.GEQUAL );
										break;

									case GreaterDepth:

										gl.depthFunc( gl.GREATER );
										break;

									case NotEqualDepth:

										gl.depthFunc( gl.NOTEQUAL );
										break;

									default:

										gl.depthFunc( gl.LEQUAL );

								}

							} else {

								gl.depthFunc( gl.LEQUAL );

							}

							currentDepthFunc = depthFunc;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( depth ) {

						if ( currentDepthClear !== depth ) {

							gl.clearDepth( depth );
							currentDepthClear = depth;

						}

					},

					reset: function () {

						locked = false;

						currentDepthMask = null;
						currentDepthFunc = null;
						currentDepthClear = null;

					}

				};

			}

			function StencilBuffer() {

				var locked = false;

				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail  = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;

				return {

					setTest: function ( stencilTest ) {

						if ( stencilTest ) {

							enable( gl.STENCIL_TEST );

						} else {

							disable( gl.STENCIL_TEST );

						}

					},

					setMask: function ( stencilMask ) {

						if ( currentStencilMask !== stencilMask && ! locked ) {

							gl.stencilMask( stencilMask );
							currentStencilMask = stencilMask;

						}

					},

					setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

						if ( currentStencilFunc !== stencilFunc ||
						     currentStencilRef 	!== stencilRef 	||
						     currentStencilFuncMask !== stencilMask ) {

							gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

							currentStencilFunc = stencilFunc;
							currentStencilRef  = stencilRef;
							currentStencilFuncMask = stencilMask;

						}

					},

					setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

						if ( currentStencilFail	 !== stencilFail 	||
						     currentStencilZFail !== stencilZFail ||
						     currentStencilZPass !== stencilZPass ) {

							gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

							currentStencilFail  = stencilFail;
							currentStencilZFail = stencilZFail;
							currentStencilZPass = stencilZPass;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( stencil ) {

						if ( currentStencilClear !== stencil ) {

							gl.clearStencil( stencil );
							currentStencilClear = stencil;

						}

					},

					reset: function () {

						locked = false;

						currentStencilMask = null;
						currentStencilFunc = null;
						currentStencilRef = null;
						currentStencilFuncMask = null;
						currentStencilFail = null;
						currentStencilZFail = null;
						currentStencilZPass = null;
						currentStencilClear = null;

					}

				};

			}

			//

			var colorBuffer = new ColorBuffer();
			var depthBuffer = new DepthBuffer();
			var stencilBuffer = new StencilBuffer();

			var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var newAttributes = new Uint8Array( maxVertexAttributes );
			var enabledAttributes = new Uint8Array( maxVertexAttributes );
			var attributeDivisors = new Uint8Array( maxVertexAttributes );

			var capabilities = {};

			var compressedTextureFormats = null;

			var currentBlending = null;
			var currentBlendEquation = null;
			var currentBlendSrc = null;
			var currentBlendDst = null;
			var currentBlendEquationAlpha = null;
			var currentBlendSrcAlpha = null;
			var currentBlendDstAlpha = null;
			var currentPremultipledAlpha = false;

			var currentFlipSided = null;
			var currentCullFace = null;

			var currentLineWidth = null;

			var currentPolygonOffsetFactor = null;
			var currentPolygonOffsetUnits = null;

			var currentScissorTest = null;

			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

			var currentTextureSlot = null;
			var currentBoundTextures = {};

			var currentScissor = new Vector4();
			var currentViewport = new Vector4();

			function createTexture( type, target, count ) {

				var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
				var texture = gl.createTexture();

				gl.bindTexture( type, texture );
				gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
				gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

				for ( var i = 0; i < count; i ++ ) {

					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				}

				return texture;

			}

			var emptyTextures = {};
			emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
			emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

			//

			function init() {

				clearColor( 0, 0, 0, 1 );
				clearDepth( 1 );
				clearStencil( 0 );

				enable( gl.DEPTH_TEST );
				setDepthFunc( LessEqualDepth );

				setFlipSided( false );
				setCullFace( CullFaceBack );
				enable( gl.CULL_FACE );

				enable( gl.BLEND );
				setBlending( NormalBlending );

			}

			function initAttributes() {

				for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

					newAttributes[ i ] = 0;

				}

			}

			function enableAttribute( attribute ) {

				newAttributes[ attribute ] = 1;

				if ( enabledAttributes[ attribute ] === 0 ) {

					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;

				}

				if ( attributeDivisors[ attribute ] !== 0 ) {

					var extension = extensions.get( 'ANGLE_instanced_arrays' );

					extension.vertexAttribDivisorANGLE( attribute, 0 );
					attributeDivisors[ attribute ] = 0;

				}

			}

			function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

				newAttributes[ attribute ] = 1;

				if ( enabledAttributes[ attribute ] === 0 ) {

					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;

				}

				if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

					extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
					attributeDivisors[ attribute ] = meshPerAttribute;

				}

			}

			function disableUnusedAttributes() {

				for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

					if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;

					}

				}

			}

			function enable( id ) {

				if ( capabilities[ id ] !== true ) {

					gl.enable( id );
					capabilities[ id ] = true;

				}

			}

			function disable( id ) {

				if ( capabilities[ id ] !== false ) {

					gl.disable( id );
					capabilities[ id ] = false;

				}

			}

			function getCompressedTextureFormats() {

				if ( compressedTextureFormats === null ) {

					compressedTextureFormats = [];

					if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

						var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

						for ( var i = 0; i < formats.length; i ++ ) {

							compressedTextureFormats.push( formats[ i ] );

						}

					}

				}

				return compressedTextureFormats;

			}

			function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

				if ( blending !== NoBlending ) {

					enable( gl.BLEND );

				} else {

					disable( gl.BLEND );

				}

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( blending === AdditiveBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

						}

					} else if ( blending === SubtractiveBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

						}

					} else if ( blending === MultiplyBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

						}

					} else {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

						} else {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

						}

					}

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				if ( blending === CustomBlending ) {

					blendEquationAlpha = blendEquationAlpha || blendEquation;
					blendSrcAlpha = blendSrcAlpha || blendSrc;
					blendDstAlpha = blendDstAlpha || blendDst;

					if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

						gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

						currentBlendEquation = blendEquation;
						currentBlendEquationAlpha = blendEquationAlpha;

					}

					if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

						gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

						currentBlendSrc = blendSrc;
						currentBlendDst = blendDst;
						currentBlendSrcAlpha = blendSrcAlpha;
						currentBlendDstAlpha = blendDstAlpha;

					}

				} else {

					currentBlendEquation = null;
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendEquationAlpha = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

				}

			}

			// TODO Deprecate

			function setColorWrite( colorWrite ) {

				colorBuffer.setMask( colorWrite );

			}

			function setDepthTest( depthTest ) {

				depthBuffer.setTest( depthTest );

			}

			function setDepthWrite( depthWrite ) {

				depthBuffer.setMask( depthWrite );

			}

			function setDepthFunc( depthFunc ) {

				depthBuffer.setFunc( depthFunc );

			}

			function setStencilTest( stencilTest ) {

				stencilBuffer.setTest( stencilTest );

			}

			function setStencilWrite( stencilWrite ) {

				stencilBuffer.setMask( stencilWrite );

			}

			function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

				stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

			}

			function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

				stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

			}

			//

			function setFlipSided( flipSided ) {

				if ( currentFlipSided !== flipSided ) {

					if ( flipSided ) {

						gl.frontFace( gl.CW );

					} else {

						gl.frontFace( gl.CCW );

					}

					currentFlipSided = flipSided;

				}

			}

			function setCullFace( cullFace ) {

				if ( cullFace !== CullFaceNone ) {

					enable( gl.CULL_FACE );

					if ( cullFace !== currentCullFace ) {

						if ( cullFace === CullFaceBack ) {

							gl.cullFace( gl.BACK );

						} else if ( cullFace === CullFaceFront ) {

							gl.cullFace( gl.FRONT );

						} else {

							gl.cullFace( gl.FRONT_AND_BACK );

						}

					}

				} else {

					disable( gl.CULL_FACE );

				}

				currentCullFace = cullFace;

			}

			function setLineWidth( width ) {

				if ( width !== currentLineWidth ) {

					gl.lineWidth( width );

					currentLineWidth = width;

				}

			}

			function setPolygonOffset( polygonOffset, factor, units ) {

				if ( polygonOffset ) {

					enable( gl.POLYGON_OFFSET_FILL );

					if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

						gl.polygonOffset( factor, units );

						currentPolygonOffsetFactor = factor;
						currentPolygonOffsetUnits = units;

					}

				} else {

					disable( gl.POLYGON_OFFSET_FILL );

				}

			}

			function getScissorTest() {

				return currentScissorTest;

			}

			function setScissorTest( scissorTest ) {

				currentScissorTest = scissorTest;

				if ( scissorTest ) {

					enable( gl.SCISSOR_TEST );

				} else {

					disable( gl.SCISSOR_TEST );

				}

			}

			// texture

			function activeTexture( webglSlot ) {

				if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

				if ( currentTextureSlot !== webglSlot ) {

					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;

				}

			}

			function bindTexture( webglType, webglTexture ) {

				if ( currentTextureSlot === null ) {

					activeTexture();

				}

				var boundTexture = currentBoundTextures[ currentTextureSlot ];

				if ( boundTexture === undefined ) {

					boundTexture = { type: undefined, texture: undefined };
					currentBoundTextures[ currentTextureSlot ] = boundTexture;

				}

				if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

					gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

					boundTexture.type = webglType;
					boundTexture.texture = webglTexture;

				}

			}

			function compressedTexImage2D() {

				try {

					gl.compressedTexImage2D.apply( gl, arguments );

				} catch ( error ) {

					console.error( error );

				}

			}

			function texImage2D() {

				try {

					gl.texImage2D.apply( gl, arguments );

				} catch ( error ) {

					console.error( error );

				}

			}

			// TODO Deprecate

			function clearColor( r, g, b, a ) {

				colorBuffer.setClear( r, g, b, a );

			}

			function clearDepth( depth ) {

				depthBuffer.setClear( depth );

			}

			function clearStencil( stencil ) {

				stencilBuffer.setClear( stencil );

			}

			//

			function scissor( scissor ) {

				if ( currentScissor.equals( scissor ) === false ) {

					gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
					currentScissor.copy( scissor );

				}

			}

			function viewport( viewport ) {

				if ( currentViewport.equals( viewport ) === false ) {

					gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
					currentViewport.copy( viewport );

				}

			}

			//

			function reset() {

				for ( var i = 0; i < enabledAttributes.length; i ++ ) {

					if ( enabledAttributes[ i ] === 1 ) {

						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;

					}

				}

				capabilities = {};

				compressedTextureFormats = null;

				currentTextureSlot = null;
				currentBoundTextures = {};

				currentBlending = null;

				currentFlipSided = null;
				currentCullFace = null;

				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();

			}

			return {

				buffers: {
					color: colorBuffer,
					depth: depthBuffer,
					stencil: stencilBuffer
				},

				init: init,
				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,
				getCompressedTextureFormats: getCompressedTextureFormats,

				setBlending: setBlending,

				setColorWrite: setColorWrite,
				setDepthTest: setDepthTest,
				setDepthWrite: setDepthWrite,
				setDepthFunc: setDepthFunc,
				setStencilTest: setStencilTest,
				setStencilWrite: setStencilWrite,
				setStencilFunc: setStencilFunc,
				setStencilOp: setStencilOp,

				setFlipSided: setFlipSided,
				setCullFace: setCullFace,

				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,

				getScissorTest: getScissorTest,
				setScissorTest: setScissorTest,

				activeTexture: activeTexture,
				bindTexture: bindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,

				clearColor: clearColor,
				clearDepth: clearDepth,
				clearStencil: clearStencil,

				scissor: scissor,
				viewport: viewport,

				reset: reset

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLCapabilities( gl, extensions, parameters ) {

			var maxAnisotropy;

			function getMaxAnisotropy() {

				if ( maxAnisotropy !== undefined ) return maxAnisotropy;

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension !== null ) {

					maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

				} else {

					maxAnisotropy = 0;

				}

				return maxAnisotropy;

			}

			function getMaxPrecision( precision ) {

				if ( precision === 'highp' ) {

					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

						return 'highp';

					}

					precision = 'mediump';

				}

				if ( precision === 'mediump' ) {

					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

						return 'mediump';

					}

				}

				return 'lowp';

			}

			var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
			var maxPrecision = getMaxPrecision( precision );

			if ( maxPrecision !== precision ) {

				console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
				precision = maxPrecision;

			}

			var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
			var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
			var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
			var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

			var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
			var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

			var vertexTextures = maxVertexTextures > 0;
			var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
			var floatVertexTextures = vertexTextures && floatFragmentTextures;

			return {

				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,

				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,

				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,

				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLExtensions( gl ) {

			var extensions = {};

			return {

				get: function ( name ) {

					if ( extensions[ name ] !== undefined ) {

						return extensions[ name ];

					}

					var extension;

					switch ( name ) {

						case 'WEBGL_depth_texture':
							extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
							break;

						case 'EXT_texture_filter_anisotropic':
							extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
							break;

						case 'WEBGL_compressed_texture_s3tc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
							break;

						case 'WEBGL_compressed_texture_pvrtc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
							break;

						case 'WEBGL_compressed_texture_etc1':
							extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
							break;

						default:
							extension = gl.getExtension( name );

					}

					if ( extension === null ) {

						console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

					}

					extensions[ name ] = extension;

					return extension;

				}

			};

		}

		/**
		 * @author tschw
		 */

		function WebGLClipping() {

			var scope = this,

				globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false,

				plane = new Plane(),
				viewNormalMatrix = new Matrix3(),

				uniform = { value: null, needsUpdate: false };

			this.uniform = uniform;
			this.numPlanes = 0;
			this.numIntersection = 0;

			this.init = function( planes, enableLocalClipping, camera ) {

				var enabled =
					planes.length !== 0 ||
					enableLocalClipping ||
					// enable state of previous frame - the clipping code has to
					// run another frame in order to reset the state:
					numGlobalPlanes !== 0 ||
					localClippingEnabled;

				localClippingEnabled = enableLocalClipping;

				globalState = projectPlanes( planes, camera, 0 );
				numGlobalPlanes = planes.length;

				return enabled;

			};

			this.beginShadows = function() {

				renderingShadows = true;
				projectPlanes( null );

			};

			this.endShadows = function() {

				renderingShadows = false;
				resetGlobalState();

			};

			this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

				if ( ! localClippingEnabled ||
						planes === null || planes.length === 0 ||
						renderingShadows && ! clipShadows ) {
					// there's no local clipping

					if ( renderingShadows ) {
						// there's no global clipping

						projectPlanes( null );

					} else {

						resetGlobalState();
					}

				} else {

					var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4,

						dstArray = cache.clippingState || null;

					uniform.value = dstArray; // ensure unique state

					dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

					for ( var i = 0; i !== lGlobal; ++ i ) {

						dstArray[ i ] = globalState[ i ];

					}

					cache.clippingState = dstArray;
					this.numIntersection = clipIntersection ? this.numPlanes : 0;
					this.numPlanes += nGlobal;

				}


			};

			function resetGlobalState() {

				if ( uniform.value !== globalState ) {

					uniform.value = globalState;
					uniform.needsUpdate = numGlobalPlanes > 0;

				}

				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;

			}

			function projectPlanes( planes, camera, dstOffset, skipTransform ) {

				var nPlanes = planes !== null ? planes.length : 0,
					dstArray = null;

				if ( nPlanes !== 0 ) {

					dstArray = uniform.value;

					if ( skipTransform !== true || dstArray === null ) {

						var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;

						viewNormalMatrix.getNormalMatrix( viewMatrix );

						if ( dstArray === null || dstArray.length < flatSize ) {

							dstArray = new Float32Array( flatSize );

						}

						for ( var i = 0, i4 = dstOffset;
											i !== nPlanes; ++ i, i4 += 4 ) {

							plane.copy( planes[ i ] ).
									applyMatrix4( viewMatrix, viewNormalMatrix );

							plane.normal.toArray( dstArray, i4 );
							dstArray[ i4 + 3 ] = plane.constant;

						}

					}

					uniform.value = dstArray;
					uniform.needsUpdate = true;

				}

				scope.numPlanes = nPlanes;
				
				return dstArray;

			}

		}

		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */

		function WebGLRenderer( parameters ) {

			console.log( 'THREE.WebGLRenderer', REVISION );

			parameters = parameters || {};

			var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

			var lights = [];

			var opaqueObjects = [];
			var opaqueObjectsLastIndex = - 1;
			var transparentObjects = [];
			var transparentObjectsLastIndex = - 1;

			var morphInfluences = new Float32Array( 8 );

			var sprites = [];
			var lensFlares = [];

			// public properties

			this.domElement = _canvas;
			this.context = null;

			// clearing

			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;

			// scene graph

			this.sortObjects = true;

			// user-defined clipping

			this.clippingPlanes = [];
			this.localClippingEnabled = false;

			// physically based shading

			this.gammaFactor = 2.0;	// for backwards compatibility
			this.gammaInput = false;
			this.gammaOutput = false;

			// physical lights

			this.physicallyCorrectLights = false;

			// tone mapping

			this.toneMapping = LinearToneMapping;
			this.toneMappingExposure = 1.0;
			this.toneMappingWhitePoint = 1.0;

			// morphs

			this.maxMorphTargets = 8;
			this.maxMorphNormals = 4;

			// internal properties

			var _this = this,

			// internal state cache

			_currentProgram = null,
			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
			_currentGeometryProgram = '',
			_currentCamera = null,

			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			_currentViewport = new Vector4(),

			//

			_usedTextureUnits = 0,

			//

			_clearColor = new Color( 0x000000 ),
			_clearAlpha = 0,

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			_viewport = new Vector4( 0, 0, _width, _height ),

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			_sphere = new Sphere(),

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3(),

			// light arrays cache

			_lights = {

				hash: '',

				ambient: [ 0, 0, 0 ],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],

				shadows: []

			},

			// info

			_infoRender = {

				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0

			};

			this.info = {

				render: _infoRender,
				memory: {

					geometries: 0,
					textures: 0

				},
				programs: null

			};


			// initialize

			var _gl;

			try {

				var attributes = {
					alpha: _alpha,
					depth: _depth,
					stencil: _stencil,
					antialias: _antialias,
					premultipliedAlpha: _premultipliedAlpha,
					preserveDrawingBuffer: _preserveDrawingBuffer
				};

				_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

				if ( _gl === null ) {

					if ( _canvas.getContext( 'webgl' ) !== null ) {

						throw 'Error creating WebGL context with your selected attributes.';

					} else {

						throw 'Error creating WebGL context.';

					}

				}

				// Some experimental-webgl implementations do not have getShaderPrecisionFormat

				if ( _gl.getShaderPrecisionFormat === undefined ) {

					_gl.getShaderPrecisionFormat = function () {

						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

					};

				}

				_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

			} catch ( error ) {

				console.error( 'THREE.WebGLRenderer: ' + error );

			}

			var extensions = new WebGLExtensions( _gl );

			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'ANGLE_instanced_arrays' );

			if ( extensions.get( 'OES_element_index_uint' ) ) {

				BufferGeometry.MaxIndex = 4294967296;

			}

			var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			var state = new WebGLState( _gl, extensions, paramThreeToGL );
			var properties = new WebGLProperties();
			var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
			var objects = new WebGLObjects( _gl, properties, this.info );
			var programCache = new WebGLPrograms( this, capabilities );
			var lightCache = new WebGLLights();

			this.info.programs = programCache.programs;

			var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

			//

			var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
			var backgroundCamera2 = new PerspectiveCamera();
			var backgroundPlaneMesh = new Mesh(
				new PlaneBufferGeometry( 2, 2 ),
				new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
			);
			var backgroundBoxShader = ShaderLib[ 'cube' ];
			var backgroundBoxMesh = new Mesh(
				new BoxBufferGeometry( 5, 5, 5 ),
				new ShaderMaterial( {
					uniforms: backgroundBoxShader.uniforms,
					vertexShader: backgroundBoxShader.vertexShader,
					fragmentShader: backgroundBoxShader.fragmentShader,
					side: BackSide,
					depthTest: false,
					depthWrite: false,
					fog: false
				} )
			);

			//

			function getTargetPixelRatio() {

				return _currentRenderTarget === null ? _pixelRatio : 1;

			}

			function glClearColor( r, g, b, a ) {

				if ( _premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				state.clearColor( r, g, b, a );

			}

			function setDefaultGLState() {

				state.init();

				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

			}

			function resetGLState() {

				_currentProgram = null;
				_currentCamera = null;

				_currentGeometryProgram = '';
				_currentMaterialId = - 1;

				state.reset();

			}

			setDefaultGLState();

			this.context = _gl;
			this.capabilities = capabilities;
			this.extensions = extensions;
			this.properties = properties;
			this.state = state;

			// shadow map

			var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

			this.shadowMap = shadowMap;


			// Plugins

			var spritePlugin = new SpritePlugin( this, sprites );
			var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

			// API

			this.getContext = function () {

				return _gl;

			};

			this.getContextAttributes = function () {

				return _gl.getContextAttributes();

			};

			this.forceContextLoss = function () {

				extensions.get( 'WEBGL_lose_context' ).loseContext();

			};

			this.getMaxAnisotropy = function () {

				return capabilities.getMaxAnisotropy();

			};

			this.getPrecision = function () {

				return capabilities.precision;

			};

			this.getPixelRatio = function () {

				return _pixelRatio;

			};

			this.setPixelRatio = function ( value ) {

				if ( value === undefined ) return;

				_pixelRatio = value;

				this.setSize( _viewport.z, _viewport.w, false );

			};

			this.getSize = function () {

				return {
					width: _width,
					height: _height
				};

			};

			this.setSize = function ( width, height, updateStyle ) {

				_width = width;
				_height = height;

				_canvas.width = width * _pixelRatio;
				_canvas.height = height * _pixelRatio;

				if ( updateStyle !== false ) {

					_canvas.style.width = width + 'px';
					_canvas.style.height = height + 'px';

				}

				this.setViewport( 0, 0, width, height );

			};

			this.setViewport = function ( x, y, width, height ) {

				state.viewport( _viewport.set( x, y, width, height ) );

			};

			this.setScissor = function ( x, y, width, height ) {

				state.scissor( _scissor.set( x, y, width, height ) );

			};

			this.setScissorTest = function ( boolean ) {

				state.setScissorTest( _scissorTest = boolean );

			};

			// Clearing

			this.getClearColor = function () {

				return _clearColor;

			};

			this.setClearColor = function ( color, alpha ) {

				_clearColor.set( color );

				_clearAlpha = alpha !== undefined ? alpha : 1;

				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

			};

			this.getClearAlpha = function () {

				return _clearAlpha;

			};

			this.setClearAlpha = function ( alpha ) {

				_clearAlpha = alpha;

				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

			};

			this.clear = function ( color, depth, stencil ) {

				var bits = 0;

				if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
				if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

				_gl.clear( bits );

			};

			this.clearColor = function () {

				this.clear( true, false, false );

			};

			this.clearDepth = function () {

				this.clear( false, true, false );

			};

			this.clearStencil = function () {

				this.clear( false, false, true );

			};

			this.clearTarget = function ( renderTarget, color, depth, stencil ) {

				this.setRenderTarget( renderTarget );
				this.clear( color, depth, stencil );

			};

			// Reset

			this.resetGLState = resetGLState;

			this.dispose = function() {

				transparentObjects = [];
				transparentObjectsLastIndex = -1;
				opaqueObjects = [];
				opaqueObjectsLastIndex = -1;

				_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

			};

			// Events

			function onContextLost( event ) {

				event.preventDefault();

				resetGLState();
				setDefaultGLState();

				properties.clear();

			}

			function onMaterialDispose( event ) {

				var material = event.target;

				material.removeEventListener( 'dispose', onMaterialDispose );

				deallocateMaterial( material );

			}

			// Buffer deallocation

			function deallocateMaterial( material ) {

				releaseMaterialProgramReference( material );

				properties.delete( material );

			}


			function releaseMaterialProgramReference( material ) {

				var programInfo = properties.get( material ).program;

				material.program = undefined;

				if ( programInfo !== undefined ) {

					programCache.releaseProgram( programInfo );

				}

			}

			// Buffer rendering

			this.renderBufferImmediate = function ( object, program, material ) {

				state.initAttributes();

				var buffers = properties.get( object );

				if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
				if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
				if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
				if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

				var attributes = program.getAttributes();

				if ( object.hasPositions ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

					if ( ! material.isMeshPhongMaterial &&
					     ! material.isMeshStandardMaterial &&
					       material.shading === FlatShading ) {

						for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

							var array = object.normalArray;

							var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
							var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
							var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

							array[ i + 0 ] = nx;
							array[ i + 1 ] = ny;
							array[ i + 2 ] = nz;

							array[ i + 3 ] = nx;
							array[ i + 4 ] = ny;
							array[ i + 5 ] = nz;

							array[ i + 6 ] = nx;
							array[ i + 7 ] = ny;
							array[ i + 8 ] = nz;

						}

					}

					_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.normal );

					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasUvs && material.map ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.uv );

					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasColors && material.vertexColors !== NoColors ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.color );

					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				}

				state.disableUnusedAttributes();

				_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

				object.count = 0;

			};

			this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

				setMaterial( material );

				var program = setProgram( camera, fog, material, object );

				var updateBuffers = false;
				var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

				if ( geometryProgram !== _currentGeometryProgram ) {

					_currentGeometryProgram = geometryProgram;
					updateBuffers = true;

				}

				// morph targets

				var morphTargetInfluences = object.morphTargetInfluences;

				if ( morphTargetInfluences !== undefined ) {

					var activeInfluences = [];

					for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

						var influence = morphTargetInfluences[ i ];
						activeInfluences.push( [ influence, i ] );

					}

					activeInfluences.sort( absNumericalSort );

					if ( activeInfluences.length > 8 ) {

						activeInfluences.length = 8;

					}

					var morphAttributes = geometry.morphAttributes;

					for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

						var influence = activeInfluences[ i ];
						morphInfluences[ i ] = influence[ 0 ];

						if ( influence[ 0 ] !== 0 ) {

							var index = influence[ 1 ];

							if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
							if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

						} else {

							if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
							if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

						}

					}

					for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

						morphInfluences[ i ] = 0.0;

					}

					program.getUniforms().setValue(
							_gl, 'morphTargetInfluences', morphInfluences );

					updateBuffers = true;

				}

				//

				var index = geometry.index;
				var position = geometry.attributes.position;
				var rangeFactor = 1;

				if ( material.wireframe === true ) {

					index = objects.getWireframeAttribute( geometry );
					rangeFactor = 2;

				}

				var renderer;

				if ( index !== null ) {

					renderer = indexedBufferRenderer;
					renderer.setIndex( index );

				} else {

					renderer = bufferRenderer;

				}

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry );

					if ( index !== null ) {

						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

					}

				}

				//

				var dataCount = 0;

				if ( index !== null ) {

					dataCount = index.count;

				} else if ( position !== undefined ) {

					dataCount = position.count;

				}

				var rangeStart = geometry.drawRange.start * rangeFactor;
				var rangeCount = geometry.drawRange.count * rangeFactor;

				var groupStart = group !== null ? group.start * rangeFactor : 0;
				var groupCount = group !== null ? group.count * rangeFactor : Infinity;

				var drawStart = Math.max( rangeStart, groupStart );
				var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

				var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

				if ( drawCount === 0 ) return;

				//

				if ( object.isMesh ) {

					if ( material.wireframe === true ) {

						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );

					} else {

						switch ( object.drawMode ) {

							case TrianglesDrawMode:
								renderer.setMode( _gl.TRIANGLES );
								break;

							case TriangleStripDrawMode:
								renderer.setMode( _gl.TRIANGLE_STRIP );
								break;

							case TriangleFanDrawMode:
								renderer.setMode( _gl.TRIANGLE_FAN );
								break;

						}

					}


				} else if ( object.isLine ) {

					var lineWidth = material.linewidth;

					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

					state.setLineWidth( lineWidth * getTargetPixelRatio() );

					if ( object.isLineSegments ) {

						renderer.setMode( _gl.LINES );

					} else {

						renderer.setMode( _gl.LINE_STRIP );

					}

				} else if ( object.isPoints ) {

					renderer.setMode( _gl.POINTS );

				}

				if ( geometry && geometry.isInstancedBufferGeometry ) {

					if ( geometry.maxInstancedCount > 0 ) {

						renderer.renderInstances( geometry, drawStart, drawCount );

					}

				} else {

					renderer.render( drawStart, drawCount );

				}

			};

			function setupVertexAttributes( material, program, geometry, startIndex ) {

				var extension;

				if ( geometry && geometry.isInstancedBufferGeometry ) {

					extension = extensions.get( 'ANGLE_instanced_arrays' );

					if ( extension === null ) {

						console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;

					}

				}

				if ( startIndex === undefined ) startIndex = 0;

				state.initAttributes();

				var geometryAttributes = geometry.attributes;

				var programAttributes = program.getAttributes();

				var materialDefaultAttributeValues = material.defaultAttributeValues;

				for ( var name in programAttributes ) {

					var programAttribute = programAttributes[ name ];

					if ( programAttribute >= 0 ) {

						var geometryAttribute = geometryAttributes[ name ];

						if ( geometryAttribute !== undefined ) {

							var type = _gl.FLOAT;
							var array = geometryAttribute.array;
							var normalized = geometryAttribute.normalized;

							if ( array instanceof Float32Array ) {

								type = _gl.FLOAT;

							} else if ( array instanceof Float64Array ) {

								console.warn( "Unsupported data buffer format: Float64Array" );

							} else if ( array instanceof Uint16Array ) {

								type = _gl.UNSIGNED_SHORT;

							} else if ( array instanceof Int16Array ) {

								type = _gl.SHORT;

							} else if ( array instanceof Uint32Array ) {

								type = _gl.UNSIGNED_INT;

							} else if ( array instanceof Int32Array ) {

								type = _gl.INT;

							} else if ( array instanceof Int8Array ) {

								type = _gl.BYTE;

							} else if ( array instanceof Uint8Array ) {

								type = _gl.UNSIGNED_BYTE;

							}

							var size = geometryAttribute.itemSize;
							var buffer = objects.getAttributeBuffer( geometryAttribute );

							if ( geometryAttribute.isInterleavedBufferAttribute ) {

								var data = geometryAttribute.data;
								var stride = data.stride;
								var offset = geometryAttribute.offset;

								if ( data && data.isInstancedInterleavedBuffer ) {

									state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

									if ( geometry.maxInstancedCount === undefined ) {

										geometry.maxInstancedCount = data.meshPerAttribute * data.count;

									}

								} else {

									state.enableAttribute( programAttribute );

								}

								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

							} else {

								if ( geometryAttribute.isInstancedBufferAttribute ) {

									state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

									if ( geometry.maxInstancedCount === undefined ) {

										geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

									}

								} else {

									state.enableAttribute( programAttribute );

								}

								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );

							}

						} else if ( materialDefaultAttributeValues !== undefined ) {

							var value = materialDefaultAttributeValues[ name ];

							if ( value !== undefined ) {

								switch ( value.length ) {

									case 2:
										_gl.vertexAttrib2fv( programAttribute, value );
										break;

									case 3:
										_gl.vertexAttrib3fv( programAttribute, value );
										break;

									case 4:
										_gl.vertexAttrib4fv( programAttribute, value );
										break;

									default:
										_gl.vertexAttrib1fv( programAttribute, value );

								}

							}

						}

					}

				}

				state.disableUnusedAttributes();

			}

			// Sorting

			function absNumericalSort( a, b ) {

				return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

			}

			function painterSortStable( a, b ) {

				if ( a.object.renderOrder !== b.object.renderOrder ) {

					return a.object.renderOrder - b.object.renderOrder;

				} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

					return a.material.program.id - b.material.program.id;

				} else if ( a.material.id !== b.material.id ) {

					return a.material.id - b.material.id;

				} else if ( a.z !== b.z ) {

					return a.z - b.z;

				} else {

					return a.id - b.id;

				}

			}

			function reversePainterSortStable( a, b ) {

				if ( a.object.renderOrder !== b.object.renderOrder ) {

					return a.object.renderOrder - b.object.renderOrder;

				} if ( a.z !== b.z ) {

					return b.z - a.z;

				} else {

					return a.id - b.id;

				}

			}

			// Rendering

			this.render = function ( scene, camera, renderTarget, forceClear ) {

				if ( camera !== undefined && camera.isCamera !== true ) {

					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;

				}

				// reset caching for this frame

				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
				_currentCamera = null;

				// update scene graph

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

				// update camera matrices and frustum

				if ( camera.parent === null ) camera.updateMatrixWorld();

				camera.matrixWorldInverse.getInverse( camera.matrixWorld );

				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				lights.length = 0;

				opaqueObjectsLastIndex = - 1;
				transparentObjectsLastIndex = - 1;

				sprites.length = 0;
				lensFlares.length = 0;

				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

				projectObject( scene, camera );

				opaqueObjects.length = opaqueObjectsLastIndex + 1;
				transparentObjects.length = transparentObjectsLastIndex + 1;

				if ( _this.sortObjects === true ) {

					opaqueObjects.sort( painterSortStable );
					transparentObjects.sort( reversePainterSortStable );

				}

				//

				if ( _clippingEnabled ) _clipping.beginShadows();

				setupShadows( lights );

				shadowMap.render( scene, camera );

				setupLights( lights, camera );

				if ( _clippingEnabled ) _clipping.endShadows();

				//

				_infoRender.calls = 0;
				_infoRender.vertices = 0;
				_infoRender.faces = 0;
				_infoRender.points = 0;

				if ( renderTarget === undefined ) {

					renderTarget = null;

				}

				this.setRenderTarget( renderTarget );

				//

				var background = scene.background;

				if ( background === null ) {

					glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

				} else if ( background && background.isColor ) {

					glClearColor( background.r, background.g, background.b, 1 );
					forceClear = true;

				}

				if ( this.autoClear || forceClear ) {

					this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

				}

				if ( background && background.isCubeTexture ) {

					backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

					backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
					backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

					backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
					backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

					objects.update( backgroundBoxMesh );

					_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

				} else if ( background && background.isTexture ) {

					backgroundPlaneMesh.material.map = background;

					objects.update( backgroundPlaneMesh );

					_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

				}

				//

				if ( scene.overrideMaterial ) {

					var overrideMaterial = scene.overrideMaterial;

					renderObjects( opaqueObjects, scene, camera, overrideMaterial );
					renderObjects( transparentObjects, scene, camera, overrideMaterial );

				} else {

					// opaque pass (front-to-back order)

					state.setBlending( NoBlending );
					renderObjects( opaqueObjects, scene, camera );

					// transparent pass (back-to-front order)

					renderObjects( transparentObjects, scene, camera );

				}

				// custom render plugins (post pass)

				spritePlugin.render( scene, camera );
				lensFlarePlugin.render( scene, camera, _currentViewport );

				// Generate mipmap if we're using any kind of mipmap filtering

				if ( renderTarget ) {

					textures.updateRenderTargetMipmap( renderTarget );

				}

				// Ensure depth buffer writing is enabled so it can be cleared on next render

				state.setDepthTest( true );
				state.setDepthWrite( true );
				state.setColorWrite( true );

				// _gl.finish();

			};

			function pushRenderItem( object, geometry, material, z, group ) {

				var array, index;

				// allocate the next position in the appropriate array

				if ( material.transparent ) {

					array = transparentObjects;
					index = ++ transparentObjectsLastIndex;

				} else {

					array = opaqueObjects;
					index = ++ opaqueObjectsLastIndex;

				}

				// recycle existing render item or grow the array

				var renderItem = array[ index ];

				if ( renderItem !== undefined ) {

					renderItem.id = object.id;
					renderItem.object = object;
					renderItem.geometry = geometry;
					renderItem.material = material;
					renderItem.z = _vector3.z;
					renderItem.group = group;

				} else {

					renderItem = {
						id: object.id,
						object: object,
						geometry: geometry,
						material: material,
						z: _vector3.z,
						group: group
					};

					// assert( index === array.length );
					array.push( renderItem );

				}

			}

			// TODO Duplicated code (Frustum)

			function isObjectViewable( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				_sphere.copy( geometry.boundingSphere ).
					applyMatrix4( object.matrixWorld );

				return isSphereViewable( _sphere );

			}

			function isSpriteViewable( sprite ) {

				_sphere.center.set( 0, 0, 0 );
				_sphere.radius = 0.7071067811865476;
				_sphere.applyMatrix4( sprite.matrixWorld );

				return isSphereViewable( _sphere );

			}

			function isSphereViewable( sphere ) {

				if ( ! _frustum.intersectsSphere( sphere ) ) return false;

				var numPlanes = _clipping.numPlanes;

				if ( numPlanes === 0 ) return true;

				var planes = _this.clippingPlanes,

					center = sphere.center,
					negRad = - sphere.radius,
					i = 0;

				do {

					// out when deeper than radius in the negative halfspace
					if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

				} while ( ++ i !== numPlanes );

				return true;

			}

			function projectObject( object, camera ) {

				if ( object.visible === false ) return;

				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

				if ( visible ) {

					if ( object.isLight ) {

						lights.push( object );

					} else if ( object.isSprite ) {

						if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

							sprites.push( object );

						}

					} else if ( object.isLensFlare ) {

						lensFlares.push( object );

					} else if ( object.isImmediateRenderObject ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						pushRenderItem( object, null, object.material, _vector3.z, null );

					} else if ( object.isMesh || object.isLine || object.isPoints ) {

						if ( object.isSkinnedMesh ) {

							object.skeleton.update();

						}

						if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

							var material = object.material;

							if ( material.visible === true ) {

								if ( _this.sortObjects === true ) {

									_vector3.setFromMatrixPosition( object.matrixWorld );
									_vector3.applyProjection( _projScreenMatrix );

								}

								var geometry = objects.update( object );

								if ( material.isMultiMaterial ) {

									var groups = geometry.groups;
									var materials = material.materials;

									for ( var i = 0, l = groups.length; i < l; i ++ ) {

										var group = groups[ i ];
										var groupMaterial = materials[ group.materialIndex ];

										if ( groupMaterial.visible === true ) {

											pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

										}

									}

								} else {

									pushRenderItem( object, geometry, material, _vector3.z, null );

								}

							}

						}

					}

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera );

				}

			}

			function renderObjects( renderList, scene, camera, overrideMaterial ) {

				for ( var i = 0, l = renderList.length; i < l; i ++ ) {

					var renderItem = renderList[ i ];

					var object = renderItem.object;
					var geometry = renderItem.geometry;
					var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
					var group = renderItem.group;

					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

					object.onBeforeRender( _this, scene, camera, geometry, material, group );

					if ( object.isImmediateRenderObject ) {

						setMaterial( material );

						var program = setProgram( camera, scene.fog, material, object );

						_currentGeometryProgram = '';

						object.render( function ( object ) {

							_this.renderBufferImmediate( object, program, material );

						} );

					} else {

						_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

					}

					object.onAfterRender( _this, scene, camera, geometry, material, group );


				}

			}

			function initMaterial( material, fog, object ) {

				var materialProperties = properties.get( material );

				var parameters = programCache.getParameters(
						material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );

				var code = programCache.getProgramCode( material, parameters );

				var program = materialProperties.program;
				var programChange = true;

				if ( program === undefined ) {

					// new material
					material.addEventListener( 'dispose', onMaterialDispose );

				} else if ( program.code !== code ) {

					// changed glsl or parameters
					releaseMaterialProgramReference( material );

				} else if ( parameters.shaderID !== undefined ) {

					// same glsl and uniform list
					return;

				} else {

					// only rebuild uniform list
					programChange = false;

				}

				if ( programChange ) {

					if ( parameters.shaderID ) {

						var shader = ShaderLib[ parameters.shaderID ];

						materialProperties.__webglShader = {
							name: material.type,
							uniforms: UniformsUtils.clone( shader.uniforms ),
							vertexShader: shader.vertexShader,
							fragmentShader: shader.fragmentShader
						};

					} else {

						materialProperties.__webglShader = {
							name: material.type,
							uniforms: material.uniforms,
							vertexShader: material.vertexShader,
							fragmentShader: material.fragmentShader
						};

					}

					material.__webglShader = materialProperties.__webglShader;

					program = programCache.acquireProgram( material, parameters, code );

					materialProperties.program = program;
					material.program = program;

				}

				var attributes = program.getAttributes();

				if ( material.morphTargets ) {

					material.numSupportedMorphTargets = 0;

					for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

						if ( attributes[ 'morphTarget' + i ] >= 0 ) {

							material.numSupportedMorphTargets ++;

						}

					}

				}

				if ( material.morphNormals ) {

					material.numSupportedMorphNormals = 0;

					for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

						if ( attributes[ 'morphNormal' + i ] >= 0 ) {

							material.numSupportedMorphNormals ++;

						}

					}

				}

				var uniforms = materialProperties.__webglShader.uniforms;

				if ( ! material.isShaderMaterial &&
				     ! material.isRawShaderMaterial ||
				       material.clipping === true ) {

					materialProperties.numClippingPlanes = _clipping.numPlanes;
					materialProperties.numIntersection = _clipping.numIntersection;
					uniforms.clippingPlanes = _clipping.uniform;

				}

				materialProperties.fog = fog;

				// store the light setup it was created for

				materialProperties.lightsHash = _lights.hash;

				if ( material.lights ) {

					// wire up the material to this renderer's lighting state

					uniforms.ambientLightColor.value = _lights.ambient;
					uniforms.directionalLights.value = _lights.directional;
					uniforms.spotLights.value = _lights.spot;
					uniforms.pointLights.value = _lights.point;
					uniforms.hemisphereLights.value = _lights.hemi;

					uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
					uniforms.spotShadowMap.value = _lights.spotShadowMap;
					uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
					uniforms.pointShadowMap.value = _lights.pointShadowMap;
					uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

				}

				var progUniforms = materialProperties.program.getUniforms(),
					uniformsList =
							WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

				materialProperties.uniformsList = uniformsList;

			}

			function setMaterial( material ) {

				material.side === DoubleSide
					? state.disable( _gl.CULL_FACE )
					: state.enable( _gl.CULL_FACE );

				state.setFlipSided( material.side === BackSide );

				material.transparent === true
					? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
					: state.setBlending( NoBlending );

				state.setDepthFunc( material.depthFunc );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
				state.setColorWrite( material.colorWrite );
				state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			function setProgram( camera, fog, material, object ) {

				_usedTextureUnits = 0;

				var materialProperties = properties.get( material );

				if ( _clippingEnabled ) {

					if ( _localClippingEnabled || camera !== _currentCamera ) {

						var useCache =
								camera === _currentCamera &&
								material.id === _currentMaterialId;

						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						_clipping.setState(
								material.clippingPlanes, material.clipIntersection, material.clipShadows,
								camera, materialProperties, useCache );

					}

				}

				if ( material.needsUpdate === false ) {

					if ( materialProperties.program === undefined ) {

						material.needsUpdate = true;

					} else if ( material.fog && materialProperties.fog !== fog ) {

						material.needsUpdate = true;

					} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

						material.needsUpdate = true;

					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== _clipping.numPlanes || 
		 				  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {

						material.needsUpdate = true;

					}

				}

				if ( material.needsUpdate ) {

					initMaterial( material, fog, object );
					material.needsUpdate = false;

				}

				var refreshProgram = false;
				var refreshMaterial = false;
				var refreshLights = false;

				var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.__webglShader.uniforms;

				if ( program.id !== _currentProgram ) {

					_gl.useProgram( program.program );
					_currentProgram = program.id;

					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;

				}

				if ( material.id !== _currentMaterialId ) {

					_currentMaterialId = material.id;

					refreshMaterial = true;

				}

				if ( refreshProgram || camera !== _currentCamera ) {

					p_uniforms.set( _gl, camera, 'projectionMatrix' );

					if ( capabilities.logarithmicDepthBuffer ) {

						p_uniforms.setValue( _gl, 'logDepthBufFC',
								2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

					}


					if ( camera !== _currentCamera ) {

						_currentCamera = camera;

						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:

						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done

					}

					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)

					if ( material.isShaderMaterial ||
					     material.isMeshPhongMaterial ||
					     material.isMeshStandardMaterial ||
					     material.envMap ) {

						var uCamPos = p_uniforms.map.cameraPosition;

						if ( uCamPos !== undefined ) {

							uCamPos.setValue( _gl,
									_vector3.setFromMatrixPosition( camera.matrixWorld ) );

						}

					}

					if ( material.isMeshPhongMaterial ||
					     material.isMeshLambertMaterial ||
					     material.isMeshBasicMaterial ||
					     material.isMeshStandardMaterial ||
					     material.isShaderMaterial ||
					     material.skinning ) {

						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

					}

					p_uniforms.set( _gl, _this, 'toneMappingExposure' );
					p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

				}

				// skinning uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone texture must go before other textures
				// not sure why, but otherwise weird things happen

				if ( material.skinning ) {

					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

					var skeleton = object.skeleton;

					if ( skeleton ) {

						if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

							p_uniforms.set( _gl, skeleton, 'boneTexture' );
							p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
							p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

						} else {

							p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

						}

					}

				}

				if ( refreshMaterial ) {

					if ( material.lights ) {

						// the current material requires lighting info

						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required

						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

					}

					// refresh uniforms common to several materials

					if ( fog && material.fog ) {

						refreshUniformsFog( m_uniforms, fog );

					}

					if ( material.isMeshBasicMaterial ||
					     material.isMeshLambertMaterial ||
					     material.isMeshPhongMaterial ||
					     material.isMeshStandardMaterial ||
					     material.isMeshDepthMaterial ) {

						refreshUniformsCommon( m_uniforms, material );

					}

					// refresh single material specific uniforms

					if ( material.isLineBasicMaterial ) {

						refreshUniformsLine( m_uniforms, material );

					} else if ( material.isLineDashedMaterial ) {

						refreshUniformsLine( m_uniforms, material );
						refreshUniformsDash( m_uniforms, material );

					} else if ( material.isPointsMaterial ) {

						refreshUniformsPoints( m_uniforms, material );

					} else if ( material.isMeshLambertMaterial ) {

						refreshUniformsLambert( m_uniforms, material );

					} else if ( material.isMeshPhongMaterial ) {

						refreshUniformsPhong( m_uniforms, material );

					} else if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else if ( material.isMeshStandardMaterial ) {

						refreshUniformsStandard( m_uniforms, material );

					} else if ( material.isMeshDepthMaterial ) {

						if ( material.displacementMap ) {

							m_uniforms.displacementMap.value = material.displacementMap;
							m_uniforms.displacementScale.value = material.displacementScale;
							m_uniforms.displacementBias.value = material.displacementBias;

						}

					} else if ( material.isMeshNormalMaterial ) {

						m_uniforms.opacity.value = material.opacity;

					}

					WebGLUniforms.upload(
							_gl, materialProperties.uniformsList, m_uniforms, _this );

				}


				// common matrices

				p_uniforms.set( _gl, object, 'modelViewMatrix' );
				p_uniforms.set( _gl, object, 'normalMatrix' );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

				return program;

			}

			// Uniforms (refresh uniforms objects)

			function refreshUniformsCommon( uniforms, material ) {

				uniforms.opacity.value = material.opacity;

				uniforms.diffuse.value = material.color;

				if ( material.emissive ) {

					uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

				}

				uniforms.map.value = material.map;
				uniforms.specularMap.value = material.specularMap;
				uniforms.alphaMap.value = material.alphaMap;

				if ( material.aoMap ) {

					uniforms.aoMap.value = material.aoMap;
					uniforms.aoMapIntensity.value = material.aoMapIntensity;

				}

				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map

				var uvScaleMap;

				if ( material.map ) {

					uvScaleMap = material.map;

				} else if ( material.specularMap ) {

					uvScaleMap = material.specularMap;

				} else if ( material.displacementMap ) {

					uvScaleMap = material.displacementMap;

				} else if ( material.normalMap ) {

					uvScaleMap = material.normalMap;

				} else if ( material.bumpMap ) {

					uvScaleMap = material.bumpMap;

				} else if ( material.roughnessMap ) {

					uvScaleMap = material.roughnessMap;

				} else if ( material.metalnessMap ) {

					uvScaleMap = material.metalnessMap;

				} else if ( material.alphaMap ) {

					uvScaleMap = material.alphaMap;

				} else if ( material.emissiveMap ) {

					uvScaleMap = material.emissiveMap;

				}

				if ( uvScaleMap !== undefined ) {

					// backwards compatibility
					if ( uvScaleMap.isWebGLRenderTarget ) {

						uvScaleMap = uvScaleMap.texture;

					}

					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;

					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

				}

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			function refreshUniformsLine( uniforms, material ) {

				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;

			}

			function refreshUniformsDash( uniforms, material ) {

				uniforms.dashSize.value = material.dashSize;
				uniforms.totalSize.value = material.dashSize + material.gapSize;
				uniforms.scale.value = material.scale;

			}

			function refreshUniformsPoints( uniforms, material ) {

				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
				uniforms.size.value = material.size * _pixelRatio;
				uniforms.scale.value = _height * 0.5;

				uniforms.map.value = material.map;

				if ( material.map !== null ) {

					var offset = material.map.offset;
					var repeat = material.map.repeat;

					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

				}

			}

			function refreshUniformsFog( uniforms, fog ) {

				uniforms.fogColor.value = fog.color;

				if ( fog.isFog ) {

					uniforms.fogNear.value = fog.near;
					uniforms.fogFar.value = fog.far;

				} else if ( fog.isFogExp2 ) {

					uniforms.fogDensity.value = fog.density;

				}

			}

			function refreshUniformsLambert( uniforms, material ) {

				if ( material.lightMap ) {

					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

			}

			function refreshUniformsPhong( uniforms, material ) {

				uniforms.specular.value = material.specular;
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

				if ( material.lightMap ) {

					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			function refreshUniformsStandard( uniforms, material ) {

				uniforms.roughness.value = material.roughness;
				uniforms.metalness.value = material.metalness;

				if ( material.roughnessMap ) {

					uniforms.roughnessMap.value = material.roughnessMap;

				}

				if ( material.metalnessMap ) {

					uniforms.metalnessMap.value = material.metalnessMap;

				}

				if ( material.lightMap ) {

					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

				if ( material.envMap ) {

					//uniforms.envMap.value = material.envMap; // part of uniforms common
					uniforms.envMapIntensity.value = material.envMapIntensity;

				}

			}

			function refreshUniformsPhysical( uniforms, material ) {

				uniforms.clearCoat.value = material.clearCoat;
				uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

				refreshUniformsStandard( uniforms, material );

			}

			// If uniforms are marked as clean, they don't need to be loaded to the GPU.

			function markUniformsLightsNeedsUpdate( uniforms, value ) {

				uniforms.ambientLightColor.needsUpdate = value;

				uniforms.directionalLights.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;

			}

			// Lighting

			function setupShadows( lights ) {

				var lightShadowsLength = 0;

				for ( var i = 0, l = lights.length; i < l; i ++ ) {

					var light = lights[ i ];

					if ( light.castShadow ) {

						_lights.shadows[ lightShadowsLength ++ ] = light;

					}

				}

				_lights.shadows.length = lightShadowsLength;

			}

			function setupLights( lights, camera ) {

				var l, ll, light,
				r = 0, g = 0, b = 0,
				color,
				intensity,
				distance,
				shadowMap,

				viewMatrix = camera.matrixWorldInverse,

				directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				hemiLength = 0;

				for ( l = 0, ll = lights.length; l < ll; l ++ ) {

					light = lights[ l ];

					color = light.color;
					intensity = light.intensity;
					distance = light.distance;

					shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

					if ( light.isAmbientLight ) {

						r += color.r * intensity;
						g += color.g * intensity;
						b += color.b * intensity;

					} else if ( light.isDirectionalLight ) {

						var uniforms = lightCache.get( light );

						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;

						}

						_lights.directionalShadowMap[ directionalLength ] = shadowMap;
						_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
						_lights.directional[ directionalLength ++ ] = uniforms;

					} else if ( light.isSpotLight ) {

						var uniforms = lightCache.get( light );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						uniforms.color.copy( color ).multiplyScalar( intensity );
						uniforms.distance = distance;

						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );

						uniforms.coneCos = Math.cos( light.angle );
						uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;

						}

						_lights.spotShadowMap[ spotLength ] = shadowMap;
						_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
						_lights.spot[ spotLength ++ ] = uniforms;

					} else if ( light.isPointLight ) {

						var uniforms = lightCache.get( light );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.distance = light.distance;
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;

						}

						_lights.pointShadowMap[ pointLength ] = shadowMap;

						if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

							_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

						}

						// for point lights we set the shadow matrix to be a translation-only matrix
						// equal to inverse of the light's position
						_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
						_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

						_lights.point[ pointLength ++ ] = uniforms;

					} else if ( light.isHemisphereLight ) {

						var uniforms = lightCache.get( light );

						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						uniforms.direction.transformDirection( viewMatrix );
						uniforms.direction.normalize();

						uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
						uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

						_lights.hemi[ hemiLength ++ ] = uniforms;

					}

				}

				_lights.ambient[ 0 ] = r;
				_lights.ambient[ 1 ] = g;
				_lights.ambient[ 2 ] = b;

				_lights.directional.length = directionalLength;
				_lights.spot.length = spotLength;
				_lights.point.length = pointLength;
				_lights.hemi.length = hemiLength;

				_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

			}

			// GL state setting

			this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

				state.setCullFace( cullFace );
				state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

			};

			// Textures

			function allocTextureUnit() {

				var textureUnit = _usedTextureUnits;

				if ( textureUnit >= capabilities.maxTextures ) {

					console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

				}

				_usedTextureUnits += 1;

				return textureUnit;

			}

			this.allocTextureUnit = allocTextureUnit;

			// this.setTexture2D = setTexture2D;
			this.setTexture2D = ( function() {

				var warned = false;

				// backwards compatibility: peel texture.texture
				return function setTexture2D( texture, slot ) {

					if ( texture && texture.isWebGLRenderTarget ) {

						if ( ! warned ) {

							console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
							warned = true;

						}

						texture = texture.texture;

					}

					textures.setTexture2D( texture, slot );

				};

			}() );

			this.setTexture = ( function() {

				var warned = false;

				return function setTexture( texture, slot ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
						warned = true;

					}

					textures.setTexture2D( texture, slot );

				};

			}() );

			this.setTextureCube = ( function() {

				var warned = false;

				return function setTextureCube( texture, slot ) {

					// backwards compatibility: peel texture.texture
					if ( texture && texture.isWebGLRenderTargetCube ) {

						if ( ! warned ) {

							console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
							warned = true;

						}

						texture = texture.texture;

					}

					// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
					// TODO: unify these code paths
					if ( ( texture && texture.isCubeTexture ) ||
						 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

						// CompressedTexture can have Array in image :/

						// this function alone should take care of cube textures
						textures.setTextureCube( texture, slot );

					} else {

						// assumed: texture property of THREE.WebGLRenderTargetCube

						textures.setTextureCubeDynamic( texture, slot );

					}

				};

			}() );

			this.getCurrentRenderTarget = function() {

				return _currentRenderTarget;

			};

			this.setRenderTarget = function ( renderTarget ) {

				_currentRenderTarget = renderTarget;

				if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				}

				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				var framebuffer;

				if ( renderTarget ) {

					var renderTargetProperties = properties.get( renderTarget );

					if ( isCube ) {

						framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

					} else {

						framebuffer = renderTargetProperties.__webglFramebuffer;

					}

					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;

					_currentViewport.copy( renderTarget.viewport );

				} else {

					framebuffer = null;

					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
					_currentScissorTest = _scissorTest;

					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

				}

				if ( _currentFramebuffer !== framebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
					_currentFramebuffer = framebuffer;

				}

				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );

				state.viewport( _currentViewport );

				if ( isCube ) {

					var textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

				}

			};

			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

				if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;

				}

				var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( framebuffer ) {

					var restore = false;

					if ( framebuffer !== _currentFramebuffer ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

						restore = true;

					}

					try {

						var texture = renderTarget.texture;
						var textureFormat = texture.format;
						var textureType = texture.type;

						if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;

						}

						if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;

						}

						if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

							// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

							if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

								_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

							}

						} else {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

						}

					} finally {

						if ( restore ) {

							_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

						}

					}

				}

			};

			// Map three.js constants to WebGL constants

			function paramThreeToGL( p ) {

				var extension;

				if ( p === RepeatWrapping ) return _gl.REPEAT;
				if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
				if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

				if ( p === NearestFilter ) return _gl.NEAREST;
				if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
				if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

				if ( p === LinearFilter ) return _gl.LINEAR;
				if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
				if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

				if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
				if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
				if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
				if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

				if ( p === ByteType ) return _gl.BYTE;
				if ( p === ShortType ) return _gl.SHORT;
				if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
				if ( p === IntType ) return _gl.INT;
				if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
				if ( p === FloatType ) return _gl.FLOAT;

				if ( p === HalfFloatType ) {

					extension = extensions.get( 'OES_texture_half_float' );

					if ( extension !== null ) return extension.HALF_FLOAT_OES;

				}

				if ( p === AlphaFormat ) return _gl.ALPHA;
				if ( p === RGBFormat ) return _gl.RGB;
				if ( p === RGBAFormat ) return _gl.RGBA;
				if ( p === LuminanceFormat ) return _gl.LUMINANCE;
				if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
				if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
				if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

				if ( p === AddEquation ) return _gl.FUNC_ADD;
				if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
				if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

				if ( p === ZeroFactor ) return _gl.ZERO;
				if ( p === OneFactor ) return _gl.ONE;
				if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
				if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
				if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
				if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
				if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
				if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

				if ( p === DstColorFactor ) return _gl.DST_COLOR;
				if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
				if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

				if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
					p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

					}

				}

				if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
					 p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

					if ( extension !== null ) {

						if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
						if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
						if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
						if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

					}

				}

				if ( p === RGB_ETC1_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

					if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

				}

				if ( p === MinEquation || p === MaxEquation ) {

					extension = extensions.get( 'EXT_blend_minmax' );

					if ( extension !== null ) {

						if ( p === MinEquation ) return extension.MIN_EXT;
						if ( p === MaxEquation ) return extension.MAX_EXT;

					}

				}

				if ( p === UnsignedInt248Type ) {

					extension = extensions.get( 'WEBGL_depth_texture' );

					if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

				}

				return 0;

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function FogExp2 ( color, density ) {

			this.name = '';

			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;

		}

		FogExp2.prototype.isFogExp2 = true;

		FogExp2.prototype.clone = function () {

			return new FogExp2( this.color.getHex(), this.density );

		};

		FogExp2.prototype.toJSON = function ( meta ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Fog ( color, near, far ) {

			this.name = '';

			this.color = new Color( color );

			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;

		}

		Fog.prototype.isFog = true;

		Fog.prototype.clone = function () {

			return new Fog( this.color.getHex(), this.near, this.far );

		};

		Fog.prototype.toJSON = function ( meta ) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Scene () {

			Object3D.call( this );

			this.type = 'Scene';

			this.background = null;
			this.fog = null;
			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

		}

		Scene.prototype = Object.create( Object3D.prototype );

		Scene.prototype.constructor = Scene;

		Scene.prototype.copy = function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		};

		Scene.prototype.toJSON = function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function LensFlare( texture, size, distance, blending, color ) {

			Object3D.call( this );

			this.lensFlares = [];

			this.positionScreen = new Vector3();
			this.customUpdateCallback = undefined;

			if ( texture !== undefined ) {

				this.add( texture, size, distance, blending, color );

			}

		}

		LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: LensFlare,

			isLensFlare: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.positionScreen.copy( source.positionScreen );
				this.customUpdateCallback = source.customUpdateCallback;

				for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

					this.lensFlares.push( source.lensFlares[ i ] );

				}

				return this;

			},

			add: function ( texture, size, distance, blending, color, opacity ) {

				if ( size === undefined ) size = - 1;
				if ( distance === undefined ) distance = 0;
				if ( opacity === undefined ) opacity = 1;
				if ( color === undefined ) color = new Color( 0xffffff );
				if ( blending === undefined ) blending = NormalBlending;

				distance = Math.min( distance, Math.max( 0, distance ) );

				this.lensFlares.push( {
					texture: texture,	// THREE.Texture
					size: size, 		// size in pixels (-1 = use texture.width)
					distance: distance, 	// distance (0-1) from light source (0=at light source)
					x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
					scale: 1, 		// scale
					rotation: 0, 		// rotation
					opacity: opacity,	// opacity
					color: color,		// color
					blending: blending	// blending
				} );

			},

			/*
			 * Update lens flares update positions on all flares based on the screen position
			 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
			 */

			updateLensFlares: function () {

				var f, fl = this.lensFlares.length;
				var flare;
				var vecX = - this.positionScreen.x * 2;
				var vecY = - this.positionScreen.y * 2;

				for ( f = 0; f < fl; f ++ ) {

					flare = this.lensFlares[ f ];

					flare.x = this.positionScreen.x + vecX * flare.distance;
					flare.y = this.positionScreen.y + vecY * flare.distance;

					flare.wantedRotation = flare.x * Math.PI * 0.25;
					flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

				}

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *	uvOffset: new THREE.Vector2(),
		 *	uvScale: new THREE.Vector2()
		 * }
		 */

		function SpriteMaterial( parameters ) {

			Material.call( this );

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );
			this.map = null;

			this.rotation = 0;

			this.fog = false;
			this.lights = false;

			this.setValues( parameters );

		}

		SpriteMaterial.prototype = Object.create( Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;

		SpriteMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.map = source.map;

			this.rotation = source.rotation;

			return this;

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Sprite( material ) {

			Object3D.call( this );

			this.type = 'Sprite';

			this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		}

		Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Sprite,

			isSprite: true,

			raycast: ( function () {

				var matrixPosition = new Vector3();

				return function raycast( raycaster, intersects ) {

					matrixPosition.setFromMatrixPosition( this.matrixWorld );

					var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
					var guessSizeSq = this.scale.x * this.scale.y / 4;

					if ( distanceSq > guessSizeSq ) {

						return;

					}

					intersects.push( {

						distance: Math.sqrt( distanceSq ),
						point: this.position,
						face: null,
						object: this

					} );

				};

			}() ),

			clone: function () {

				return new this.constructor( this.material ).copy( this );

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LOD() {

			Object3D.call( this );

			this.type = 'LOD';

			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				}
			} );

		}


		LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: LOD,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source, false );

				var levels = source.levels;

				for ( var i = 0, l = levels.length; i < l; i ++ ) {

					var level = levels[ i ];

					this.addLevel( level.object.clone(), level.distance );

				}

				return this;

			},

			addLevel: function ( object, distance ) {

				if ( distance === undefined ) distance = 0;

				distance = Math.abs( distance );

				var levels = this.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					if ( distance < levels[ l ].distance ) {

						break;

					}

				}

				levels.splice( l, 0, { distance: distance, object: object } );

				this.add( object );

			},

			getObjectForDistance: function ( distance ) {

				var levels = this.levels;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance < levels[ i ].distance ) {

						break;

					}

				}

				return levels[ i - 1 ].object;

			},

			raycast: ( function () {

				var matrixPosition = new Vector3();

				return function raycast( raycaster, intersects ) {

					matrixPosition.setFromMatrixPosition( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( matrixPosition );

					this.getObjectForDistance( distance ).raycast( raycaster, intersects );

				};

			}() ),

			update: function () {

				var v1 = new Vector3();
				var v2 = new Vector3();

				return function update( camera ) {

					var levels = this.levels;

					if ( levels.length > 1 ) {

						v1.setFromMatrixPosition( camera.matrixWorld );
						v2.setFromMatrixPosition( this.matrixWorld );

						var distance = v1.distanceTo( v2 );

						levels[ 0 ].object.visible = true;

						for ( var i = 1, l = levels.length; i < l; i ++ ) {

							if ( distance >= levels[ i ].distance ) {

								levels[ i - 1 ].object.visible = false;
								levels[ i ].object.visible = true;

							} else {

								break;

							}

						}

						for ( ; i < l; i ++ ) {

							levels[ i ].object.visible = false;

						}

					}

				};

			}(),

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.levels = [];

				var levels = this.levels;

				for ( var i = 0, l = levels.length; i < l; i ++ ) {

					var level = levels[ i ];

					data.object.levels.push( {
						object: level.object.uuid,
						distance: level.distance
					} );

				}

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { data: data, width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.generateMipmaps  = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

		DataTexture.prototype = Object.create( Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;

		DataTexture.prototype.isDataTexture = true;

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author michael guerrero / http://realitymeltdown.com
		 * @author ikerr / http://verold.com
		 */

		function Skeleton( bones, boneInverses, useVertexTexture ) {

			this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

			this.identityMatrix = new Matrix4();

			// copy the bone array

			bones = bones || [];

			this.bones = bones.slice( 0 );

			// create a bone texture or an array of floats

			if ( this.useVertexTexture ) {

				// layout (1 matrix = 4 pixels)
				//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
				//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
				//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
				//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
				//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


				var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
				size = _Math.nextPowerOfTwo( Math.ceil( size ) );
				size = Math.max( size, 4 );

				this.boneTextureWidth = size;
				this.boneTextureHeight = size;

				this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
				this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

			} else {

				this.boneMatrices = new Float32Array( 16 * this.bones.length );

			}

			// use the supplied bone inverses or calculate the inverses

			if ( boneInverses === undefined ) {

				this.calculateInverses();

			} else {

				if ( this.bones.length === boneInverses.length ) {

					this.boneInverses = boneInverses.slice( 0 );

				} else {

					console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

					this.boneInverses = [];

					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

						this.boneInverses.push( new Matrix4() );

					}

				}

			}

		}

		Object.assign( Skeleton.prototype, {

			calculateInverses: function () {

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					var inverse = new Matrix4();

					if ( this.bones[ b ] ) {

						inverse.getInverse( this.bones[ b ].matrixWorld );

					}

					this.boneInverses.push( inverse );

				}

			},

			pose: function () {

				var bone;

				// recover the bind-time world matrices

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					bone = this.bones[ b ];

					if ( bone ) {

						bone.matrixWorld.getInverse( this.boneInverses[ b ] );

					}

				}

				// compute the local matrices, positions, rotations and scales

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					bone = this.bones[ b ];

					if ( bone ) {

						if ( (bone.parent && bone.parent.isBone) ) {

							bone.matrix.getInverse( bone.parent.matrixWorld );
							bone.matrix.multiply( bone.matrixWorld );

						} else {

							bone.matrix.copy( bone.matrixWorld );

						}

						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

					}

				}

			},

			update: ( function () {

				var offsetMatrix = new Matrix4();

				return function update() {

					// flatten bone matrices to array

					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

						// compute the offset between the current and the original transform

						var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

						offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
						offsetMatrix.toArray( this.boneMatrices, b * 16 );

					}

					if ( this.useVertexTexture ) {

						this.boneTexture.needsUpdate = true;

					}

				};

			} )(),

			clone: function () {

				return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */

		function Bone( skin ) {

			Object3D.call( this );

			this.type = 'Bone';

			this.skin = skin;

		}

		Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Bone,

			isBone: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.skin = source.skin;

				return this;

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */

		function SkinnedMesh( geometry, material, useVertexTexture ) {

			Mesh.call( this, geometry, material );

			this.type = 'SkinnedMesh';

			this.bindMode = "attached";
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();

			// init bones

			// TODO: remove bone creation as there is no reason (other than
			// convenience) for THREE.SkinnedMesh to do this.

			var bones = [];

			if ( this.geometry && this.geometry.bones !== undefined ) {

				var bone, gbone;

				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

					gbone = this.geometry.bones[ b ];

					bone = new Bone( this );
					bones.push( bone );

					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

				}

				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

					gbone = this.geometry.bones[ b ];

					if ( gbone.parent !== - 1 && gbone.parent !== null &&
							bones[ gbone.parent ] !== undefined ) {

						bones[ gbone.parent ].add( bones[ b ] );

					} else {

						this.add( bones[ b ] );

					}

				}

			}

			this.normalizeSkinWeights();

			this.updateMatrixWorld( true );
			this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

		}


		SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

			constructor: SkinnedMesh,

			isSkinnedMesh: true,

			bind: function( skeleton, bindMatrix ) {

				this.skeleton = skeleton;

				if ( bindMatrix === undefined ) {

					this.updateMatrixWorld( true );

					this.skeleton.calculateInverses();

					bindMatrix = this.matrixWorld;

				}

				this.bindMatrix.copy( bindMatrix );
				this.bindMatrixInverse.getInverse( bindMatrix );

			},

			pose: function () {

				this.skeleton.pose();

			},

			normalizeSkinWeights: function () {

				if ( (this.geometry && this.geometry.isGeometry) ) {

					for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

						var sw = this.geometry.skinWeights[ i ];

						var scale = 1.0 / sw.lengthManhattan();

						if ( scale !== Infinity ) {

							sw.multiplyScalar( scale );

						} else {

							sw.set( 1, 0, 0, 0 ); // do something reasonable

						}

					}

				} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {

					var vec = new Vector4();

					var skinWeight = this.geometry.attributes.skinWeight;

					for ( var i = 0; i < skinWeight.count; i ++ ) {

						vec.x = skinWeight.getX( i );
						vec.y = skinWeight.getY( i );
						vec.z = skinWeight.getZ( i );
						vec.w = skinWeight.getW( i );

						var scale = 1.0 / vec.lengthManhattan();

						if ( scale !== Infinity ) {

							vec.multiplyScalar( scale );

						} else {

							vec.set( 1, 0, 0, 0 ); // do something reasonable

						}

						skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

					}

				}

			},

			updateMatrixWorld: function( force ) {

				Mesh.prototype.updateMatrixWorld.call( this, true );

				if ( this.bindMode === "attached" ) {

					this.bindMatrixInverse.getInverse( this.matrixWorld );

				} else if ( this.bindMode === "detached" ) {

					this.bindMatrixInverse.getInverse( this.bindMatrix );

				} else {

					console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

				}

			},

			clone: function() {

				return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */

		function LineBasicMaterial( parameters ) {

			Material.call( this );

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.lights = false;

			this.setValues( parameters );

		}

		LineBasicMaterial.prototype = Object.create( Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;

		LineBasicMaterial.prototype.isLineBasicMaterial = true;

		LineBasicMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Line( geometry, material, mode ) {

			if ( mode === 1 ) {

				console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
				return new LineSegments( geometry, material );

			}

			Object3D.call( this );

			this.type = 'Line';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

		}

		Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Line,

			isLine: true,

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				return function raycast( raycaster, intersects ) {

					var precision = raycaster.linePrecision;
					var precisionSq = precision * precision;

					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					var vStart = new Vector3();
					var vEnd = new Vector3();
					var interSegment = new Vector3();
					var interRay = new Vector3();
					var step = (this && this.isLineSegments) ? 2 : 1;

					if ( (geometry && geometry.isBufferGeometry) ) {

						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;

						if ( index !== null ) {

							var indices = index.array;

							for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

								var a = indices[ i ];
								var b = indices[ i + 1 ];

								vStart.fromArray( positions, a * 3 );
								vEnd.fromArray( positions, b * 3 );

								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

								if ( distSq > precisionSq ) continue;

								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

								var distance = raycaster.ray.origin.distanceTo( interRay );

								if ( distance < raycaster.near || distance > raycaster.far ) continue;

								intersects.push( {

									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this

								} );

							}

						} else {

							for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

								vStart.fromArray( positions, 3 * i );
								vEnd.fromArray( positions, 3 * i + 3 );

								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

								if ( distSq > precisionSq ) continue;

								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

								var distance = raycaster.ray.origin.distanceTo( interRay );

								if ( distance < raycaster.near || distance > raycaster.far ) continue;

								intersects.push( {

									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this

								} );

							}

						}

					} else if ( (geometry && geometry.isGeometry) ) {

						var vertices = geometry.vertices;
						var nbVertices = vertices.length;

						for ( var i = 0; i < nbVertices - 1; i += step ) {

							var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LineSegments( geometry, material ) {

			Line.call( this, geometry, material );

			this.type = 'LineSegments';

		}

		LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

			constructor: LineSegments,

			isLineSegments: true

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */

		function PointsMaterial( parameters ) {

			Material.call( this );

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.lights = false;

			this.setValues( parameters );

		}

		PointsMaterial.prototype = Object.create( Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;

		PointsMaterial.prototype.isPointsMaterial = true;

		PointsMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Points( geometry, material ) {

			Object3D.call( this );

			this.type = 'Points';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

		}

		Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Points,

			isPoints: true,

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				return function raycast( raycaster, intersects ) {

					var object = this;
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
					var threshold = raycaster.params.Points.threshold;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
					var localThresholdSq = localThreshold * localThreshold;
					var position = new Vector3();

					function testPoint( point, index ) {

						var rayPointDistanceSq = ray.distanceSqToPoint( point );

						if ( rayPointDistanceSq < localThresholdSq ) {

							var intersectPoint = ray.closestPointToPoint( point );
							intersectPoint.applyMatrix4( matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectPoint );

							if ( distance < raycaster.near || distance > raycaster.far ) return;

							intersects.push( {

								distance: distance,
								distanceToRay: Math.sqrt( rayPointDistanceSq ),
								point: intersectPoint.clone(),
								index: index,
								face: null,
								object: object

							} );

						}

					}

					if ( (geometry && geometry.isBufferGeometry) ) {

						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;

						if ( index !== null ) {

							var indices = index.array;

							for ( var i = 0, il = indices.length; i < il; i ++ ) {

								var a = indices[ i ];

								position.fromArray( positions, a * 3 );

								testPoint( position, a );

							}

						} else {

							for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

								position.fromArray( positions, i * 3 );

								testPoint( position, i );

							}

						}

					} else {

						var vertices = geometry.vertices;

						for ( var i = 0, l = vertices.length; i < l; i ++ ) {

							testPoint( vertices[ i ], i );

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Group() {

			Object3D.call( this );

			this.type = 'Group';

		}

		Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Group

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.generateMipmaps = false;

			var scope = this;

			function update() {

				requestAnimationFrame( update );

				if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

					scope.needsUpdate = true;

				}

			}

			update();

		}

		VideoTexture.prototype = Object.create( Texture.prototype );
		VideoTexture.prototype.constructor = VideoTexture;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false;

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;

		}

		CompressedTexture.prototype = Object.create( Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;

		CompressedTexture.prototype.isCompressedTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.needsUpdate = true;

		}

		CanvasTexture.prototype = Object.create( Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;

		/**
		 * @author Matt DesLauriers / @mattdesl
		 * @author atix / arthursilber.de
		 */

		function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

			format = format !== undefined ? format : DepthFormat;

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

			}

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.image = { width: width, height: height };

			this.type = type !== undefined ? type : UnsignedShortType;

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.flipY = false;
			this.generateMipmaps	= false;

		}

		DepthTexture.prototype = Object.create( Texture.prototype );
		DepthTexture.prototype.constructor = DepthTexture;
		DepthTexture.prototype.isDepthTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WireframeGeometry( geometry ) {

			BufferGeometry.call( this );

			var edge = [ 0, 0 ], hash = {};

			function sortFunction( a, b ) {

				return a - b;

			}

			var keys = [ 'a', 'b', 'c' ];

			if ( (geometry && geometry.isGeometry) ) {

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var numEdges = 0;

				// allocate maximal size
				var edges = new Uint32Array( 6 * faces.length );

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = face[ keys[ j ] ];
						edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var vertex = vertices[ edges [ 2 * i + j ] ];

						var index = 6 * i + 3 * j;
						coords[ index + 0 ] = vertex.x;
						coords[ index + 1 ] = vertex.y;
						coords[ index + 2 ] = vertex.z;

					}

				}

				this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

			} else if ( (geometry && geometry.isBufferGeometry) ) {

				if ( geometry.index !== null ) {

					// Indexed BufferGeometry

					var indices = geometry.index.array;
					var vertices = geometry.attributes.position;
					var groups = geometry.groups;
					var numEdges = 0;

					if ( groups.length === 0 ) {

						geometry.addGroup( 0, indices.length );

					}

					// allocate maximal size
					var edges = new Uint32Array( 2 * indices.length );

					for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

						var group = groups[ o ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							for ( var j = 0; j < 3; j ++ ) {

								edge[ 0 ] = indices[ i + j ];
								edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
								edge.sort( sortFunction );

								var key = edge.toString();

								if ( hash[ key ] === undefined ) {

									edges[ 2 * numEdges ] = edge[ 0 ];
									edges[ 2 * numEdges + 1 ] = edge[ 1 ];
									hash[ key ] = true;
									numEdges ++;

								}

							}

						}

					}

					var coords = new Float32Array( numEdges * 2 * 3 );

					for ( var i = 0, l = numEdges; i < l; i ++ ) {

						for ( var j = 0; j < 2; j ++ ) {

							var index = 6 * i + 3 * j;
							var index2 = edges[ 2 * i + j ];

							coords[ index + 0 ] = vertices.getX( index2 );
							coords[ index + 1 ] = vertices.getY( index2 );
							coords[ index + 2 ] = vertices.getZ( index2 );

						}

					}

					this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

				} else {

					// non-indexed BufferGeometry

					var vertices = geometry.attributes.position.array;
					var numEdges = vertices.length / 3;
					var numTris = numEdges / 3;

					var coords = new Float32Array( numEdges * 2 * 3 );

					for ( var i = 0, l = numTris; i < l; i ++ ) {

						for ( var j = 0; j < 3; j ++ ) {

							var index = 18 * i + 6 * j;

							var index1 = 9 * i + 3 * j;
							coords[ index + 0 ] = vertices[ index1 ];
							coords[ index + 1 ] = vertices[ index1 + 1 ];
							coords[ index + 2 ] = vertices[ index1 + 2 ];

							var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
							coords[ index + 3 ] = vertices[ index2 ];
							coords[ index + 4 ] = vertices[ index2 + 1 ];
							coords[ index + 5 ] = vertices[ index2 + 2 ];

						}

					}

					this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

				}

			}

		}

		WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
		WireframeGeometry.prototype.constructor = WireframeGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */

		function ParametricBufferGeometry( func, slices, stacks ) {

			BufferGeometry.call( this );

			this.type = 'ParametricBufferGeometry';

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};

			// generate vertices and uvs

			var vertices = [];
			var uvs = [];

			var i, j, p;
			var u, v;

			var sliceCount = slices + 1;

			for ( i = 0; i <= stacks; i ++ ) {

				v = i / stacks;

				for ( j = 0; j <= slices; j ++ ) {

					u = j / slices;

					p = func( u, v );
					vertices.push( p.x, p.y, p.z );

					uvs.push( u, v );

				}

			}

			// generate indices

			var indices = [];
			var a, b, c, d;

			for ( i = 0; i < stacks; i ++ ) {

				for ( j = 0; j < slices; j ++ ) {

					a = i * sliceCount + j;
					b = i * sliceCount + j + 1;
					c = ( i + 1 ) * sliceCount + j + 1;
					d = ( i + 1 ) * sliceCount + j;

					// faces one and two

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', Float32Attribute( vertices, 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );

			// generate normals

			this.computeVertexNormals();

		}

		ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

		/**
		 * @author zz85 / https://github.com/zz85
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */

		function ParametricGeometry( func, slices, stacks ) {

			Geometry.call( this );

			this.type = 'ParametricGeometry';

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};

			this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
			this.mergeVertices();

		}

		ParametricGeometry.prototype = Object.create( Geometry.prototype );
		ParametricGeometry.prototype.constructor = ParametricGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

			BufferGeometry.call( this );

			this.type = 'PolyhedronBufferGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			radius = radius || 1;
			detail = detail || 0;

			// default buffer data

			var vertexBuffer = [];
			var uvBuffer = [];

			// the subdivision creates the vertex buffer data

			subdivide( detail );

			// all vertices should lie on a conceptual sphere with a given radius

			appplyRadius( radius );

			// finally, create the uv data

			generateUVs();

			// build non-indexed geometry

			this.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );
			this.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );
			this.normalizeNormals();

			this.boundingSphere = new Sphere( new Vector3(), radius );

			// helper functions

			function subdivide( detail ) {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				// iterate over all faces and apply a subdivison with the given detail value

				for ( var i = 0; i < indices.length; i += 3 ) {

					// get the vertices of the face

					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );

					// perform subdivision

					subdivideFace( a, b, c, detail );

				}

			}

			function subdivideFace( a, b, c, detail ) {

				var cols = Math.pow( 2, detail );

				// we use this multidimensional array as a data structure for creating the subdivision

				var v = [];

				var i, j;

				// construct all of the vertices for this subdivision

				for ( i = 0 ; i <= cols; i ++ ) {

					v[ i ] = [];

					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );

					var rows = cols - i;

					for ( j = 0; j <= rows; j ++ ) {

						if ( j === 0 && i === cols ) {

							v[ i ][ j ] = aj;

						} else {

							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

						}

					}

				}

				// construct all of the faces

				for ( i = 0; i < cols ; i ++ ) {

					for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

						var k = Math.floor( j / 2 );

						if ( j % 2 === 0 ) {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );

						} else {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );

						}

					}

				}

			}

			function appplyRadius( radius ) {

				var vertex = new Vector3();

				// iterate over the entire buffer and apply the radius to each vertex

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					vertex.normalize().multiplyScalar( radius );

					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;

				}

			}

			function generateUVs() {

				var vertex = new Vector3();

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );

				}

				correctUVs();

				correctSeam();

			}

			function correctSeam() {

				// handle case when face straddles the seam, see #3269

				for ( var i = 0; i < uvBuffer.length; i += 6 ) {

					// uv data of a single face

					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];

					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );

					// 0.9 is somewhat arbitrary

					if ( max > 0.9 && min < 0.1 ) {

						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

					}

				}

			}

			function pushVertex( vertex ) {

				vertexBuffer.push( vertex.x, vertex.y, vertex.z );

			}

			function getVertexByIndex( index, vertex ) {

				var stride = index * 3;

				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];

			}

			function correctUVs() {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				var centroid = new Vector3();

				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

					var azi = azimuth( centroid );

					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );

				}

			}

			function correctUV( uv, stride, vector, azimuth  ) {

				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

					uvBuffer[ stride ] =  uv.x - 1;

				}

				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth( vector ) {

				return Math.atan2( vector.z, - vector.x );

			}


			// Angle above the XZ plane.

			function inclination( vector ) {

				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

			}

		}

		PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function TetrahedronBufferGeometry( radius, detail ) {

			var vertices = [
				1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
			];

			var indices = [
				2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'TetrahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function TetrahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'TetrahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
		TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function OctahedronBufferGeometry( radius,detail ) {

			var vertices = [
				1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
			];

			var indices = [
				0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'OctahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function OctahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'OctahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		OctahedronGeometry.prototype = Object.create( Geometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function IcosahedronBufferGeometry( radius, detail ) {

			var t = ( 1 + Math.sqrt( 5 ) ) / 2;

			var vertices = [
				- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
				 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
				 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
			];

			var indices = [
				 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
				 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
				 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
				 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'IcosahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function IcosahedronGeometry( radius, detail ) {

		 	Geometry.call( this );

			this.type = 'IcosahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
		IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function DodecahedronBufferGeometry( radius, detail ) {

			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
			var r = 1 / t;

			var vertices = [

				// (±1, ±1, ±1)
				- 1, - 1, - 1,    - 1, - 1,  1,
				- 1,  1, - 1,    - 1,  1,  1,
				 1, - 1, - 1,     1, - 1,  1,
				 1,  1, - 1,     1,  1,  1,

				// (0, ±1/φ, ±φ)
				 0, - r, - t,     0, - r,  t,
				 0,  r, - t,     0,  r,  t,

				// (±1/φ, ±φ, 0)
				- r, - t,  0,    - r,  t,  0,
				 r, - t,  0,     r,  t,  0,

				// (±φ, 0, ±1/φ)
				- t,  0, - r,     t,  0, - r,
				- t,  0,  r,     t,  0,  r
			];

			var indices = [
				 3, 11,  7,      3,  7, 15,      3, 15, 13,
				 7, 19, 17,      7, 17,  6,      7,  6, 15,
				17,  4,  8,     17,  8, 10,     17, 10,  6,
				 8,  0, 16,      8, 16,  2,      8,  2, 10,
				 0, 12,  1,      0,  1, 18,      0, 18, 16,
				 6, 10,  2,      6,  2, 13,      6, 13, 15,
				 2, 16, 18,      2, 18,  3,      2,  3, 13,
				18,  1,  9,     18,  9, 11,     18, 11,  3,
				 4, 14, 12,      4, 12,  0,      4,  0,  8,
				11,  9,  5,     11,  5, 19,     11, 19,  7,
				19,  5, 14,     19, 14,  4,     19,  4, 17,
				 1, 12, 14,      1, 14,  5,      1,  5,  9
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'DodecahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

		/**
		 * @author Abe Pazos / https://hamoid.com
		 */

		function DodecahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'DodecahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
		DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

		/**
		 * @author clockworkgeek / https://github.com/clockworkgeek
		 * @author timothypratley / https://github.com/timothypratley
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function PolyhedronGeometry( vertices, indices, radius, detail ) {

			Geometry.call( this );

			this.type = 'PolyhedronGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
			this.mergeVertices();

		}

		PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 *
		 */

		function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

			BufferGeometry.call( this );

			this.type = 'TubeBufferGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			tubularSegments = tubularSegments || 64;
			radius = radius || 1;
			radialSegments = radialSegments || 8;
			closed = closed || false;

			var frames = path.computeFrenetFrames( tubularSegments, closed );

			// expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;

			// helper variables

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();

			var i, j;

			// buffer

			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];

			// create buffer data

			generateBufferData();

			// build geometry

			this.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', Float32Attribute( vertices, 3 ) );
			this.addAttribute( 'normal', Float32Attribute( normals, 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );

			// functions

			function generateBufferData() {

				for ( i = 0; i < tubularSegments; i ++ ) {

					generateSegment( i );

				}

				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

				generateSegment( ( closed === false ) ? tubularSegments : 0 );

				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs();

				// finally create faces

				generateIndices();

			}

			function generateSegment( i ) {

				// we use getPointAt to sample evenly distributed points from the given path

				var P = path.getPointAt( i / tubularSegments );

				// retrieve corresponding normal and binormal

				var N = frames.normals[ i ];
				var B = frames.binormals[ i ];

				// generate normals and vertices for the current segment

				for ( j = 0; j <= radialSegments; j ++ ) {

					var v = j / radialSegments * Math.PI * 2;

					var sin =   Math.sin( v );
					var cos = - Math.cos( v );

					// normal

					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();

					normals.push( normal.x, normal.y, normal.z );

					// vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;

					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

			function generateIndices() {

				for ( j = 1; j <= tubularSegments; j ++ ) {

					for ( i = 1; i <= radialSegments; i ++ ) {

						var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						var b = ( radialSegments + 1 ) * j + ( i - 1 );
						var c = ( radialSegments + 1 ) * j + i;
						var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

					}

				}

			}

			function generateUVs() {

				for ( i = 0; i <= tubularSegments; i ++ ) {

					for ( j = 0; j <= radialSegments; j ++ ) {

						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;

						uvs.push( uv.x, uv.y );

					}

				}

			}

		}

		TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

		/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 */

		function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

			Geometry.call( this );

			this.type = 'TubeGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

			var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

			// expose internals

			this.tangents = bufferGeometry.tangents;
			this.normals = bufferGeometry.normals;
			this.binormals = bufferGeometry.binormals;

			// create geometry

			this.fromBufferGeometry( bufferGeometry );
			this.mergeVertices();

		}

		TubeGeometry.prototype = Object.create( Geometry.prototype );
		TubeGeometry.prototype.constructor = TubeGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * see: http://www.blackpawn.com/texts/pqtorus/
		 */
		function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

			BufferGeometry.call( this );

			this.type = 'TorusKnotBufferGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			radius = radius || 100;
			tube = tube || 40;
			tubularSegments = Math.floor( tubularSegments ) || 64;
			radialSegments = Math.floor( radialSegments ) || 8;
			p = p || 2;
			q = q || 3;

			// used to calculate buffer length
			var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
			var indexCount = radialSegments * tubularSegments * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables
			var i, j, index = 0, indexOffset = 0;

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();

			var P1 = new Vector3();
			var P2 = new Vector3();

			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3();

			// generate vertices, normals and uvs

			for ( i = 0; i <= tubularSegments; ++ i ) {

				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

				var u = i / tubularSegments * p * Math.PI * 2;

				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

				// calculate orthonormal basis

				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );

				// normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for ( j = 0; j <= radialSegments; ++ j ) {

					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

					var v = j / radialSegments * Math.PI * 2;
					var cx = - tube * Math.cos( v );
					var cy = tube * Math.sin( v );

					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );

					// vertex
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
					normal.subVectors( vertex, P1 ).normalize();
					normals.setXYZ( index, normal.x, normal.y, normal.z );

					// uv
					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

			}

			// generate indices

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					// indices
					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

					// face two
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			// this function calculates the current position on the torus curve

			function calculatePositionOnCurve( u, p, q, radius, position ) {

				var cu = Math.cos( u );
				var su = Math.sin( u );
				var quOverP = q / p * u;
				var cs = Math.cos( quOverP );

				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;

			}

		}

		TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

		/**
		 * @author oosmoxiecode
		 */

		function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

			Geometry.call( this );

			this.type = 'TorusKnotGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

			this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
			this.mergeVertices();

		}

		TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
		TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

			BufferGeometry.call( this );

			this.type = 'TorusBufferGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			radius = radius || 100;
			tube = tube || 40;
			radialSegments = Math.floor( radialSegments ) || 8;
			tubularSegments = Math.floor( tubularSegments ) || 6;
			arc = arc || Math.PI * 2;

			// used to calculate buffer length
			var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
			var indexCount = radialSegments * tubularSegments * 2 * 3;

			// buffers
			var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
			var vertices = new Float32Array( vertexCount * 3 );
			var normals = new Float32Array( vertexCount * 3 );
			var uvs = new Float32Array( vertexCount * 2 );

			// offset variables
			var vertexBufferOffset = 0;
			var uvBufferOffset = 0;
			var indexBufferOffset = 0;

			// helper variables
			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3();

			var j, i;

			// generate vertices, normals and uvs

			for ( j = 0; j <= radialSegments; j ++ ) {

				for ( i = 0; i <= tubularSegments; i ++ ) {

					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2;

					// vertex
					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );

					vertices[ vertexBufferOffset ] = vertex.x;
					vertices[ vertexBufferOffset + 1 ] = vertex.y;
					vertices[ vertexBufferOffset + 2 ] = vertex.z;

					// this vector is used to calculate the normal
					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );

					// normal
					normal.subVectors( vertex, center ).normalize();

					normals[ vertexBufferOffset ] = normal.x;
					normals[ vertexBufferOffset + 1 ] = normal.y;
					normals[ vertexBufferOffset + 2 ] = normal.z;

					// uv
					uvs[ uvBufferOffset ] = i / tubularSegments;
					uvs[ uvBufferOffset + 1 ] = j / radialSegments;

					// update offsets
					vertexBufferOffset += 3;
					uvBufferOffset += 2;

				}

			}

			// generate indices

			for ( j = 1; j <= radialSegments; j ++ ) {

				for ( i = 1; i <= tubularSegments; i ++ ) {

					// indices
					var a = ( tubularSegments + 1 ) * j + i - 1;
					var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					var d = ( tubularSegments + 1 ) * j + i;

					// face one
					indices[ indexBufferOffset ] = a;
					indices[ indexBufferOffset + 1 ] = b;
					indices[ indexBufferOffset + 2 ] = d;

					// face two
					indices[ indexBufferOffset + 3 ] = b;
					indices[ indexBufferOffset + 4 ] = c;
					indices[ indexBufferOffset + 5 ] = d;

					// update offset
					indexBufferOffset += 6;

				}

			}

			// build geometry
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

		}

		TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

		/**
		 * @author oosmoxiecode
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
		 */

		function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

			Geometry.call( this );

			this.type = 'TorusGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

		}

		TorusGeometry.prototype = Object.create( Geometry.prototype );
		TorusGeometry.prototype.constructor = TorusGeometry;

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		var ShapeUtils = {

			// calculate area of the contour polygon

			area: function ( contour ) {

				var n = contour.length;
				var a = 0.0;

				for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

					a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

				}

				return a * 0.5;

			},

			triangulate: ( function () {

				/**
				 * This code is a quick port of code written in C++ which was submitted to
				 * flipcode.com by John W. Ratcliff  // July 22, 2000
				 * See original code and more information here:
				 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
				 *
				 * ported to actionscript by Zevan Rosser
				 * www.actionsnippet.com
				 *
				 * ported to javascript by Joshua Koo
				 * http://www.lab4games.net/zz85/blog
				 *
				 */

				function snip( contour, u, v, w, n, verts ) {

					var p;
					var ax, ay, bx, by;
					var cx, cy, px, py;

					ax = contour[ verts[ u ] ].x;
					ay = contour[ verts[ u ] ].y;

					bx = contour[ verts[ v ] ].x;
					by = contour[ verts[ v ] ].y;

					cx = contour[ verts[ w ] ].x;
					cy = contour[ verts[ w ] ].y;

					if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;

					var aX, aY, bX, bY, cX, cY;
					var apx, apy, bpx, bpy, cpx, cpy;
					var cCROSSap, bCROSScp, aCROSSbp;

					aX = cx - bx;  aY = cy - by;
					bX = ax - cx;  bY = ay - cy;
					cX = bx - ax;  cY = by - ay;

					for ( p = 0; p < n; p ++ ) {

						px = contour[ verts[ p ] ].x;
						py = contour[ verts[ p ] ].y;

						if ( ( ( px === ax ) && ( py === ay ) ) ||
							 ( ( px === bx ) && ( py === by ) ) ||
							 ( ( px === cx ) && ( py === cy ) ) )	continue;

						apx = px - ax;  apy = py - ay;
						bpx = px - bx;  bpy = py - by;
						cpx = px - cx;  cpy = py - cy;

						// see if p is inside triangle abc

						aCROSSbp = aX * bpy - aY * bpx;
						cCROSSap = cX * apy - cY * apx;
						bCROSScp = bX * cpy - bY * cpx;

						if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

					}

					return true;

				}

				// takes in an contour array and returns

				return function triangulate( contour, indices ) {

					var n = contour.length;

					if ( n < 3 ) return null;

					var result = [],
						verts = [],
						vertIndices = [];

					/* we want a counter-clockwise polygon in verts */

					var u, v, w;

					if ( ShapeUtils.area( contour ) > 0.0 ) {

						for ( v = 0; v < n; v ++ ) verts[ v ] = v;

					} else {

						for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

					}

					var nv = n;

					/*  remove nv - 2 vertices, creating 1 triangle every time */

					var count = 2 * nv;   /* error detection */

					for ( v = nv - 1; nv > 2; ) {

						/* if we loop, it is probably a non-simple polygon */

						if ( ( count -- ) <= 0 ) {

							//** Triangulate: ERROR - probable bad polygon!

							//throw ( "Warning, unable to triangulate polygon!" );
							//return null;
							// Sometimes warning is fine, especially polygons are triangulated in reverse.
							console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

							if ( indices ) return vertIndices;
							return result;

						}

						/* three consecutive vertices in current polygon, <u,v,w> */

						u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
						v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
						w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

						if ( snip( contour, u, v, w, nv, verts ) ) {

							var a, b, c, s, t;

							/* true names of the vertices */

							a = verts[ u ];
							b = verts[ v ];
							c = verts[ w ];

							/* output Triangle */

							result.push( [ contour[ a ],
								contour[ b ],
								contour[ c ] ] );


							vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

							/* remove v from the remaining polygon */

							for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

								verts[ s ] = verts[ t ];

							}

							nv --;

							/* reset error detection counter */

							count = 2 * nv;

						}

					}

					if ( indices ) return vertIndices;
					return result;

				}

			} )(),

			triangulateShape: function ( contour, holes ) {

				function removeDupEndPts(points) {

					var l = points.length;

					if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

						points.pop();

					}

				}

				removeDupEndPts( contour );
				holes.forEach( removeDupEndPts );

				function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

					// inOtherPt needs to be collinear to the inSegment
					if ( inSegPt1.x !== inSegPt2.x ) {

						if ( inSegPt1.x < inSegPt2.x ) {

							return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

						} else {

							return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

						}

					} else {

						if ( inSegPt1.y < inSegPt2.y ) {

							return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

						} else {

							return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

						}

					}

				}

				function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

					var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
					var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

					var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
					var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

					var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
					var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

					if ( Math.abs( limit ) > Number.EPSILON ) {

						// not parallel

						var perpSeg2;
						if ( limit > 0 ) {

							if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

						} else {

							if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

						}

						// i.e. to reduce rounding errors
						// intersection at endpoint of segment#1?
						if ( perpSeg2 === 0 ) {

							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt1 ];

						}
						if ( perpSeg2 === limit ) {

							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt2 ];

						}
						// intersection at endpoint of segment#2?
						if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
						if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

						// return real intersection point
						var factorSeg1 = perpSeg2 / limit;
						return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
									y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

					} else {

						// parallel or collinear
						if ( ( perpSeg1 !== 0 ) ||
							 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

						// they are collinear or degenerate
						var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
						var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
						// both segments are points
						if ( seg1Pt && seg2Pt ) {

							if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
								 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
							return [ inSeg1Pt1 ];                 						// they are the same point

						}
						// segment#1  is a single point
						if ( seg1Pt ) {

							if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
							return [ inSeg1Pt1 ];

						}
						// segment#2  is a single point
						if ( seg2Pt ) {

							if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
							return [ inSeg2Pt1 ];

						}

						// they are collinear segments, which might overlap
						var seg1min, seg1max, seg1minVal, seg1maxVal;
						var seg2min, seg2max, seg2minVal, seg2maxVal;
						if ( seg1dx !== 0 ) {

							// the segments are NOT on a vertical line
							if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

							} else {

								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

							}
							if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

							} else {

								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

							}

						} else {

							// the segments are on a vertical line
							if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

							} else {

								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

							}
							if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

							} else {

								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

							}

						}
						if ( seg1minVal <= seg2minVal ) {

							if ( seg1maxVal <  seg2minVal )	return [];
							if ( seg1maxVal === seg2minVal )	{

								if ( inExcludeAdjacentSegs )		return [];
								return [ seg2min ];

							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
							return	[ seg2min, seg2max ];

						} else {

							if ( seg1minVal >  seg2maxVal )	return [];
							if ( seg1minVal === seg2maxVal )	{

								if ( inExcludeAdjacentSegs )		return [];
								return [ seg1min ];

							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
							return	[ seg1min, seg2max ];

						}

					}

				}

				function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

					// The order of legs is important

					// translation of all points, so that Vertex is at (0,0)
					var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
					var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
					var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

					// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
					var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
					var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

					if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

						// angle != 180 deg.

						var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
						// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

						if ( from2toAngle > 0 ) {

							// main angle < 180 deg.
							return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

						} else {

							// main angle > 180 deg.
							return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

						}

					} else {

						// angle == 180 deg.
						// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
						return	( from2otherAngle > 0 );

					}

				}


				function removeHoles( contour, holes ) {

					var shape = contour.concat(); // work on this shape
					var hole;

					function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

						// Check if hole point lies within angle around shape point
						var lastShapeIdx = shape.length - 1;

						var prevShapeIdx = inShapeIdx - 1;
						if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

						var nextShapeIdx = inShapeIdx + 1;
						if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

						var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
						if ( ! insideAngle ) {

							// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
							return	false;

						}

						// Check if shape point lies within angle around hole point
						var lastHoleIdx = hole.length - 1;

						var prevHoleIdx = inHoleIdx - 1;
						if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

						var nextHoleIdx = inHoleIdx + 1;
						if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

						insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
						if ( ! insideAngle ) {

							// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
							return	false;

						}

						return	true;

					}

					function intersectsShapeEdge( inShapePt, inHolePt ) {

						// checks for intersections with shape edges
						var sIdx, nextIdx, intersection;
						for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

							nextIdx = sIdx + 1; nextIdx %= shape.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;

						}

						return	false;

					}

					var indepHoles = [];

					function intersectsHoleEdge( inShapePt, inHolePt ) {

						// checks for intersections with hole edges
						var ihIdx, chkHole,
							hIdx, nextIdx, intersection;
						for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

							chkHole = holes[ indepHoles[ ihIdx ]];
							for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

								nextIdx = hIdx + 1; nextIdx %= chkHole.length;
								intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
								if ( intersection.length > 0 )		return	true;

							}

						}
						return	false;

					}

					var holeIndex, shapeIndex,
						shapePt, holePt,
						holeIdx, cutKey, failedCuts = [],
						tmpShape1, tmpShape2,
						tmpHole1, tmpHole2;

					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

						indepHoles.push( h );

					}

					var minShapeIndex = 0;
					var counter = indepHoles.length * 2;
					while ( indepHoles.length > 0 ) {

						counter --;
						if ( counter < 0 ) {

							console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
							break;

						}

						// search for shape-vertex and hole-vertex,
						// which can be connected without intersections
						for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

							shapePt = shape[ shapeIndex ];
							holeIndex	= - 1;

							// search for hole which can be reached without intersections
							for ( var h = 0; h < indepHoles.length; h ++ ) {

								holeIdx = indepHoles[ h ];

								// prevent multiple checks
								cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
								if ( failedCuts[ cutKey ] !== undefined )			continue;

								hole = holes[ holeIdx ];
								for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

									holePt = hole[ h2 ];
									if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
									if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
									if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

									holeIndex = h2;
									indepHoles.splice( h, 1 );

									tmpShape1 = shape.slice( 0, shapeIndex + 1 );
									tmpShape2 = shape.slice( shapeIndex );
									tmpHole1 = hole.slice( holeIndex );
									tmpHole2 = hole.slice( 0, holeIndex + 1 );

									shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

									minShapeIndex = shapeIndex;

									// Debug only, to show the selected cuts
									// glob_CutLines.push( [ shapePt, holePt ] );

									break;

								}
								if ( holeIndex >= 0 )	break;		// hole-vertex found

								failedCuts[ cutKey ] = true;			// remember failure

							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

						}

					}

					return shape; 			/* shape with no holes */

				}


				var i, il, f, face,
					key, index,
					allPointsMap = {};

				// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

				var allpoints = contour.concat();

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					Array.prototype.push.apply( allpoints, holes[ h ] );

				}

				//console.log( "allpoints",allpoints, allpoints.length );

				// prepare all points map

				for ( i = 0, il = allpoints.length; i < il; i ++ ) {

					key = allpoints[ i ].x + ":" + allpoints[ i ].y;

					if ( allPointsMap[ key ] !== undefined ) {

						console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

					}

					allPointsMap[ key ] = i;

				}

				// remove holes by cutting paths to holes and adding them to the shape
				var shapeWithoutHoles = removeHoles( contour, holes );

				var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
				//console.log( "triangles",triangles, triangles.length );

				// check all face vertices against all points map

				for ( i = 0, il = triangles.length; i < il; i ++ ) {

					face = triangles[ i ];

					for ( f = 0; f < 3; f ++ ) {

						key = face[ f ].x + ":" + face[ f ].y;

						index = allPointsMap[ key ];

						if ( index !== undefined ) {

							face[ f ] = index;

						}

					}

				}

				return triangles.concat();

			},

			isClockWise: function ( pts ) {

				return ShapeUtils.area( pts ) < 0;

			},

			// Bezier Curves formulas obtained from
			// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

			// Quad Bezier Functions

			b2: ( function () {

				function b2p0( t, p ) {

					var k = 1 - t;
					return k * k * p;

				}

				function b2p1( t, p ) {

					return 2 * ( 1 - t ) * t * p;

				}

				function b2p2( t, p ) {

					return t * t * p;

				}

				return function b2( t, p0, p1, p2 ) {

					return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

				};

			} )(),

			// Cubic Bezier Functions

			b3: ( function () {

				function b3p0( t, p ) {

					var k = 1 - t;
					return k * k * k * p;

				}

				function b3p1( t, p ) {

					var k = 1 - t;
					return 3 * k * k * t * p;

				}

				function b3p2( t, p ) {

					var k = 1 - t;
					return 3 * k * t * t * p;

				}

				function b3p3( t, p ) {

					return t * t * t * p;

				}

				return function b3( t, p0, p1, p2, p3 ) {

					return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

				};

			} )()

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  amount: <int>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline is bevel
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
		 *  frames: <Object> // containing arrays of tangents, normals, binormals
		 *
		 *  uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/

		function ExtrudeGeometry( shapes, options ) {

			if ( typeof( shapes ) === "undefined" ) {

				shapes = [];
				return;

			}

			Geometry.call( this );

			this.type = 'ExtrudeGeometry';

			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

			this.addShapeList( shapes, options );

			this.computeFaceNormals();

			// can't really use automatic vertex normals
			// as then front and back sides get smoothed too
			// should do separate smoothing just for sides

			//this.computeVertexNormals();

			//console.log( "took", ( Date.now() - startTime ) );

		}

		ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

		ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

			var sl = shapes.length;

			for ( var s = 0; s < sl; s ++ ) {

				var shape = shapes[ s ];
				this.addShape( shape, options );

			}

		};

		ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

			var amount = options.amount !== undefined ? options.amount : 100;

			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

			var steps = options.steps !== undefined ? options.steps : 1;

			var extrudePath = options.extrudePath;
			var extrudePts, extrudeByPath = false;

			// Use default WorldUVGenerator if no UV generators are specified.
			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

			var splineTube, binormal, normal, position2;
			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;

			}

			// Variables initialization

			var ahole, h, hl; // looping of holes
			var scope = this;

			var shapesOffset = this.vertices.length;

			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

				reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

			}


			var faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			var contour = vertices; // vertices has all points but contour has only points of circumference

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
							  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return	new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					var direction_eq = false;		// assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y =  v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			var contourMovements = [];

			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				oneHoleMovements = [];

				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y,  - z );

					}

				}

			}

			bs = bevelSize;

			// Back facing vertices

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			var s;

			for ( s = 1; s <= steps; s ++ ) {

				for ( i = 0; i < vlen; i ++ ) {

					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, amount / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos ( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y,  amount + z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y,  amount + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				if ( bevelEnabled ) {

					var layer = 0; // steps + 1
					var offset = vlen * layer;

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}

			}

			function sidewalls( contour, layeroffset ) {

				var j, k;
				i = contour.length;

				while ( -- i >= 0 ) {

					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					var s = 0, sl = steps  + bevelSegments * 2;

					for ( s = 0; s < sl; s ++ ) {

						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );

						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d, contour, s, sl, j, k );

					}

				}

			}


			function v( x, y, z ) {

				scope.vertices.push( new Vector3( x, y, z ) );

			}

			function f3( a, b, c ) {

				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;

				scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

				var uvs = uvgen.generateTopUV( scope, a, b, c );

				scope.faceVertexUvs[ 0 ].push( uvs );

			}

			function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
				d += shapesOffset;

				scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
				scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

				var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

				scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

			}

		};

		ExtrudeGeometry.WorldUVGenerator = {

			generateTopUV: function ( geometry, indexA, indexB, indexC ) {

				var vertices = geometry.vertices;

				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];

				return [
					new Vector2( a.x, a.y ),
					new Vector2( b.x, b.y ),
					new Vector2( c.x, c.y )
				];

			},

			generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

				var vertices = geometry.vertices;

				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
				var d = vertices[ indexD ];

				if ( Math.abs( a.y - b.y ) < 0.01 ) {

					return [
						new Vector2( a.x, 1 - a.z ),
						new Vector2( b.x, 1 - b.z ),
						new Vector2( c.x, 1 - c.z ),
						new Vector2( d.x, 1 - d.z )
					];

				} else {

					return [
						new Vector2( a.y, 1 - a.z ),
						new Vector2( b.y, 1 - b.z ),
						new Vector2( c.y, 1 - c.z ),
						new Vector2( d.y, 1 - d.z )
					];

				}

			}
		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * Text = 3D Text
		 *
		 * parameters = {
		 *  font: <THREE.Font>, // font
		 *
		 *  size: <float>, // size of the text
		 *  height: <float>, // thickness to extrude text
		 *  curveSegments: <int>, // number of points on the curves
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into text bevel goes
		 *  bevelSize: <float> // how far from text outline is bevel
		 * }
		 */

		function TextGeometry( text, parameters ) {

			parameters = parameters || {};

			var font = parameters.font;

			if ( (font && font.isFont) === false ) {

				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new Geometry();

			}

			var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

			// translate parameters to ExtrudeGeometry API

			parameters.amount = parameters.height !== undefined ? parameters.height : 50;

			// defaults

			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

			ExtrudeGeometry.call( this, shapes, parameters );

			this.type = 'TextGeometry';

		}

		TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
		TextGeometry.prototype.constructor = TextGeometry;

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * based on THREE.SphereGeometry
		 */

		function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'SphereBufferGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			radius = radius || 50;

			widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

			phiStart = phiStart !== undefined ? phiStart : 0;
			phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

			var thetaEnd = thetaStart + thetaLength;

			var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

			var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			var index = 0, vertices = [], normal = new Vector3();

			for ( var y = 0; y <= heightSegments; y ++ ) {

				var verticesRow = [];

				var v = y / heightSegments;

				for ( var x = 0; x <= widthSegments; x ++ ) {

					var u = x / widthSegments;

					var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					var py = radius * Math.cos( thetaStart + v * thetaLength );
					var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					normal.set( px, py, pz ).normalize();

					positions.setXYZ( index, px, py, pz );
					normals.setXYZ( index, normal.x, normal.y, normal.z );
					uvs.setXY( index, u, 1 - v );

					verticesRow.push( index );

					index ++;

				}

				vertices.push( verticesRow );

			}

			var indices = [];

			for ( var y = 0; y < heightSegments; y ++ ) {

				for ( var x = 0; x < widthSegments; x ++ ) {

					var v1 = vertices[ y ][ x + 1 ];
					var v2 = vertices[ y ][ x ];
					var v3 = vertices[ y + 1 ][ x ];
					var v4 = vertices[ y + 1 ][ x + 1 ];

					if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
					if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

				}

			}

			this.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', positions );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			this.boundingSphere = new Sphere( new Vector3(), radius );

		}

		SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

		}

		SphereGeometry.prototype = Object.create( Geometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'RingBufferGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			innerRadius = innerRadius || 20;
			outerRadius = outerRadius || 50;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
			phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

			// these are used to calculate buffer length
			var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
			var indexCount = thetaSegments * phiSegments * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// some helper variables
			var index = 0, indexOffset = 0, segment;
			var radius = innerRadius;
			var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			var vertex = new Vector3();
			var uv = new Vector2();
			var j, i;

			// generate vertices, normals and uvs

			// values are generate from the inside of the ring to the outside

			for ( j = 0; j <= phiSegments; j ++ ) {

				for ( i = 0; i <= thetaSegments; i ++ ) {

					segment = thetaStart + i / thetaSegments * thetaLength;

					// vertex
					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal
					normals.setXYZ( index, 0, 0, 1 );

					// uv
					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index++;

				}

				// increase the radius for next row of vertices
				radius += radiusStep;

			}

			// generate indices

			for ( j = 0; j < phiSegments; j ++ ) {

				var thetaSegmentLevel = j * ( thetaSegments + 1 );

				for ( i = 0; i < thetaSegments; i ++ ) {

					segment = i + thetaSegmentLevel;

					// indices
					var a = segment;
					var b = segment + thetaSegments + 1;
					var c = segment + thetaSegments + 2;
					var d = segment + 1;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;

					// face two
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

		}

		RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		RingBufferGeometry.prototype.constructor = RingBufferGeometry;

		/**
		 * @author Kaleb Murphy
		 */

		function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'RingGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

		}

		RingGeometry.prototype = Object.create( Geometry.prototype );
		RingGeometry.prototype.constructor = RingGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */

		function PlaneGeometry( width, height, widthSegments, heightSegments ) {

			Geometry.call( this );

			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

		}

		PlaneGeometry.prototype = Object.create( Geometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		 // points - to create a closed torus, one must use a set of points
		 //    like so: [ a, b, c, d, a ], see first is the same as last.
		 // segments - the number of circumference segments to create
		 // phiStart - the starting radian
		 // phiLength - the radian (0 to 2PI) range of the lathed section
		 //    2PI is a closed lathe, less than 2PI is a portion.

		function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

			BufferGeometry.call( this );

			this.type = 'LatheBufferGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			segments = Math.floor( segments ) || 12;
			phiStart = phiStart || 0;
			phiLength = phiLength || Math.PI * 2;

			// clamp phiLength so it's in range of [ 0, 2PI ]
			phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );

			// these are used to calculate buffer length
			var vertexCount = ( segments + 1 ) * points.length;
			var indexCount = segments * points.length * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables
			var index = 0, indexOffset = 0, base;
			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2();
			var i, j;

			// generate vertices and uvs

			for ( i = 0; i <= segments; i ++ ) {

				var phi = phiStart + i * inverseSegments * phiLength;

				var sin = Math.sin( phi );
				var cos = Math.cos( phi );

				for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

					// vertex
					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// uv
					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

			}

			// generate indices

			for ( i = 0; i < segments; i ++ ) {

				for ( j = 0; j < ( points.length - 1 ); j ++ ) {

					base = j + i * points.length;

					// indices
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

					// face two
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'uv', uvs );

			// generate normals

			this.computeVertexNormals();

			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if( phiLength === Math.PI * 2 ) {

				var normals = this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3();

				// this is the buffer offset for the last line of vertices
				base = segments * points.length * 3;

				for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

					// select the normal of the vertex in the first line
					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];

					// select the normal of the vertex in the last line
					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];

					// average normals
					n.addVectors( n1, n2 ).normalize();

					// assign the new values to both normals
					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

				} // next row

			}

		}

		LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

		/**
		 * @author astrodud / http://astrodud.isgreat.org/
		 * @author zz85 / https://github.com/zz85
		 * @author bhouston / http://clara.io
		 */

		// points - to create a closed torus, one must use a set of points
		//    like so: [ a, b, c, d, a ], see first is the same as last.
		// segments - the number of circumference segments to create
		// phiStart - the starting radian
		// phiLength - the radian (0 to 2PI) range of the lathed section
		//    2PI is a closed lathe, less than 2PI is a portion.

		function LatheGeometry( points, segments, phiStart, phiLength ) {

			Geometry.call( this );

			this.type = 'LatheGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
			this.mergeVertices();

		}

		LatheGeometry.prototype = Object.create( Geometry.prototype );
		LatheGeometry.prototype.constructor = LatheGeometry;

		/**
		 * @author jonobr1 / http://jonobr1.com
		 *
		 * Creates a one-sided polygonal geometry from a path shape. Similar to
		 * ExtrudeGeometry.
		 *
		 * parameters = {
		 *
		 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
		 *
		 *	material: <int> // material index for front and back faces
		 *	uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/

		function ShapeGeometry( shapes, options ) {

			Geometry.call( this );

			this.type = 'ShapeGeometry';

			if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

			this.addShapeList( shapes, options );

			this.computeFaceNormals();

		}

		ShapeGeometry.prototype = Object.create( Geometry.prototype );
		ShapeGeometry.prototype.constructor = ShapeGeometry;

		/**
		 * Add an array of shapes to THREE.ShapeGeometry.
		 */
		ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				this.addShape( shapes[ i ], options );

			}

			return this;

		};

		/**
		 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
		 */
		ShapeGeometry.prototype.addShape = function ( shape, options ) {

			if ( options === undefined ) options = {};
			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

			var material = options.material;
			var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

			//

			var i, l, hole;

			var shapesOffset = this.vertices.length;
			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe...

				for ( i = 0, l = holes.length; i < l; i ++ ) {

					hole = holes[ i ];

					if ( ShapeUtils.isClockWise( hole ) ) {

						holes[ i ] = hole.reverse();

					}

				}

				reverse = false;

			}

			var faces = ShapeUtils.triangulateShape( vertices, holes );

			// Vertices

			for ( i = 0, l = holes.length; i < l; i ++ ) {

				hole = holes[ i ];
				vertices = vertices.concat( hole );

			}

			//

			var vert, vlen = vertices.length;
			var face, flen = faces.length;

			for ( i = 0; i < vlen; i ++ ) {

				vert = vertices[ i ];

				this.vertices.push( new Vector3( vert.x, vert.y, 0 ) );

			}

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];

				var a = face[ 0 ] + shapesOffset;
				var b = face[ 1 ] + shapesOffset;
				var c = face[ 2 ] + shapesOffset;

				this.faces.push( new Face3( a, b, c, null, null, material ) );
				this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

			}

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function EdgesGeometry( geometry, thresholdAngle ) {

			BufferGeometry.call( this );

			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

			var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );

			var edge = [ 0, 0 ], hash = {};

			function sortFunction( a, b ) {

				return a - b;

			}

			var keys = [ 'a', 'b', 'c' ];

			var geometry2;

			if ( (geometry && geometry.isBufferGeometry) ) {

				geometry2 = new Geometry();
				geometry2.fromBufferGeometry( geometry );

			} else {

				geometry2 = geometry.clone();

			}

			geometry2.mergeVertices();
			geometry2.computeFaceNormals();

			var vertices = geometry2.vertices;
			var faces = geometry2.faces;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

					} else {

						hash[ key ].face2 = i;

					}

				}

			}

			var coords = [];

			for ( var key in hash ) {

				var h = hash[ key ];

				if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

					var vertex = vertices[ h.vert1 ];
					coords.push( vertex.x );
					coords.push( vertex.y );
					coords.push( vertex.z );

					vertex = vertices[ h.vert2 ];
					coords.push( vertex.x );
					coords.push( vertex.y );
					coords.push( vertex.z );

				}

			}

			this.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );

		}

		EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
		EdgesGeometry.prototype.constructor = EdgesGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'CylinderBufferGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			var scope = this;

			radiusTop = radiusTop !== undefined ? radiusTop : 20;
			radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
			height = height !== undefined ? height : 100;

			radialSegments = Math.floor( radialSegments ) || 8;
			heightSegments = Math.floor( heightSegments ) || 1;

			openEnded = openEnded !== undefined ? openEnded : false;
			thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
			thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

			// used to calculate buffer length

			var nbCap = 0;

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) nbCap ++;
				if ( radiusBottom > 0 ) nbCap ++;

			}

			var vertexCount = calculateVertexCount();
			var indexCount = calculateIndexCount();

			// buffers

			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables

			var index = 0,
			    indexOffset = 0,
			    indexArray = [],
			    halfHeight = height / 2;

			// group variables
			var groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			// helper functions

			function calculateVertexCount() {

				var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

				if ( openEnded === false ) {

					count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

				}

				return count;

			}

			function calculateIndexCount() {

				var count = radialSegments * heightSegments * 2 * 3;

				if ( openEnded === false ) {

					count += radialSegments * nbCap * 3;

				}

				return count;

			}

			function generateTorso() {

				var x, y;
				var normal = new Vector3();
				var vertex = new Vector3();

				var groupCount = 0;

				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( y = 0; y <= heightSegments; y ++ ) {

					var indexRow = [];

					var v = y / heightSegments;

					// calculate the radius of the current row
					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( x = 0; x <= radialSegments; x ++ ) {

						var u = x / radialSegments;

						var theta = u * thetaLength + thetaStart;

						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );

						// vertex
						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

						// normal
						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.setXYZ( index, normal.x, normal.y, normal.z );

						// uv
						uvs.setXY( index, u, 1 - v );

						// save index of vertex in respective row
						indexRow.push( index );

						// increase index
						index ++;

					}

					// now save vertices of the row in our index array
					indexArray.push( indexRow );

				}

				// generate indices

				for ( x = 0; x < radialSegments; x ++ ) {

					for ( y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices
						var i1 = indexArray[ y ][ x ];
						var i2 = indexArray[ y + 1 ][ x ];
						var i3 = indexArray[ y + 1 ][ x + 1 ];
						var i4 = indexArray[ y ][ x + 1 ];

						// face one
						indices.setX( indexOffset, i1 ); indexOffset ++;
						indices.setX( indexOffset, i2 ); indexOffset ++;
						indices.setX( indexOffset, i4 ); indexOffset ++;

						// face two
						indices.setX( indexOffset, i2 ); indexOffset ++;
						indices.setX( indexOffset, i3 ); indexOffset ++;
						indices.setX( indexOffset, i4 ); indexOffset ++;

						// update counters
						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups
				groupStart += groupCount;

			}

			function generateCap( top ) {

				var x, centerIndexStart, centerIndexEnd;

				var uv = new Vector2();
				var vertex = new Vector3();

				var groupCount = 0;

				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;

				// save the index of the first center vertex
				centerIndexStart = index;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( x = 1; x <= radialSegments; x ++ ) {

					// vertex
					vertices.setXYZ( index, 0, halfHeight * sign, 0 );

					// normal
					normals.setXYZ( index, 0, sign, 0 );

					// uv
					uv.x = 0.5;
					uv.y = 0.5;

					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

				// save the index of the last center vertex
				centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;
					var theta = u * thetaLength + thetaStart;

					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );

					// vertex
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal
					normals.setXYZ( index, 0, sign, 0 );

					// uv
					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

				// generate indices

				for ( x = 0; x < radialSegments; x ++ ) {

					var c = centerIndexStart + x;
					var i = centerIndexEnd + x;

					if ( top === true ) {

						// face top
						indices.setX( indexOffset, i ); indexOffset ++;
						indices.setX( indexOffset, i + 1 ); indexOffset ++;
						indices.setX( indexOffset, c ); indexOffset ++;

					} else {

						// face bottom
						indices.setX( indexOffset, i + 1 ); indexOffset ++;
						indices.setX( indexOffset, i ); indexOffset ++;
						indices.setX( indexOffset, c ); indexOffset ++;

					}

					// update counters
					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups
				groupStart += groupCount;

			}

		}

		CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
			this.mergeVertices();

		}

		CylinderGeometry.prototype = Object.create( Geometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;

		/**
		 * @author abelnation / http://github.com/abelnation
		 */

		function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
		ConeGeometry.prototype.constructor = ConeGeometry;

		/**
		 * @author: abelnation / http://github.com/abelnation
		 */

		function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeBufferGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
		ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'CircleBufferGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			radius = radius || 50;
			segments = segments !== undefined ? Math.max( 3, segments ) : 8;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			var vertices = segments + 2;

			var positions = new Float32Array( vertices * 3 );
			var normals = new Float32Array( vertices * 3 );
			var uvs = new Float32Array( vertices * 2 );

			// center data is already zero, but need to set a few extras
			normals[ 2 ] = 1.0;
			uvs[ 0 ] = 0.5;
			uvs[ 1 ] = 0.5;

			for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

				var segment = thetaStart + s / segments * thetaLength;

				positions[ i ] = radius * Math.cos( segment );
				positions[ i + 1 ] = radius * Math.sin( segment );

				normals[ i + 2 ] = 1; // normal z

				uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
				uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

			}

			var indices = [];

			for ( var i = 1; i <= segments; i ++ ) {

				indices.push( i, i + 1, 0 );

			}

			this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

			this.boundingSphere = new Sphere( new Vector3(), radius );

		}

		CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

		/**
		 * @author hughes
		 */

		function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'CircleGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

		}

		CircleGeometry.prototype = Object.create( Geometry.prototype );
		CircleGeometry.prototype.constructor = CircleGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
		 */

		function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

			Geometry.call( this );

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
			this.mergeVertices();

		}

		BoxGeometry.prototype = Object.create( Geometry.prototype );
		BoxGeometry.prototype.constructor = BoxGeometry;



		var Geometries = Object.freeze({
			WireframeGeometry: WireframeGeometry,
			ParametricGeometry: ParametricGeometry,
			ParametricBufferGeometry: ParametricBufferGeometry,
			TetrahedronGeometry: TetrahedronGeometry,
			TetrahedronBufferGeometry: TetrahedronBufferGeometry,
			OctahedronGeometry: OctahedronGeometry,
			OctahedronBufferGeometry: OctahedronBufferGeometry,
			IcosahedronGeometry: IcosahedronGeometry,
			IcosahedronBufferGeometry: IcosahedronBufferGeometry,
			DodecahedronGeometry: DodecahedronGeometry,
			DodecahedronBufferGeometry: DodecahedronBufferGeometry,
			PolyhedronGeometry: PolyhedronGeometry,
			PolyhedronBufferGeometry: PolyhedronBufferGeometry,
			TubeGeometry: TubeGeometry,
			TubeBufferGeometry: TubeBufferGeometry,
			TorusKnotGeometry: TorusKnotGeometry,
			TorusKnotBufferGeometry: TorusKnotBufferGeometry,
			TorusGeometry: TorusGeometry,
			TorusBufferGeometry: TorusBufferGeometry,
			TextGeometry: TextGeometry,
			SphereBufferGeometry: SphereBufferGeometry,
			SphereGeometry: SphereGeometry,
			RingGeometry: RingGeometry,
			RingBufferGeometry: RingBufferGeometry,
			PlaneBufferGeometry: PlaneBufferGeometry,
			PlaneGeometry: PlaneGeometry,
			LatheGeometry: LatheGeometry,
			LatheBufferGeometry: LatheBufferGeometry,
			ShapeGeometry: ShapeGeometry,
			ExtrudeGeometry: ExtrudeGeometry,
			EdgesGeometry: EdgesGeometry,
			ConeGeometry: ConeGeometry,
			ConeBufferGeometry: ConeBufferGeometry,
			CylinderGeometry: CylinderGeometry,
			CylinderBufferGeometry: CylinderBufferGeometry,
			CircleBufferGeometry: CircleBufferGeometry,
			CircleGeometry: CircleGeometry,
			BoxBufferGeometry: BoxBufferGeometry,
			BoxGeometry: BoxGeometry
		});

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ShadowMaterial() {

			ShaderMaterial.call( this, {
				uniforms: UniformsUtils.merge( [
					UniformsLib[ "lights" ],
					{
						opacity: { value: 1.0 }
					}
				] ),
				vertexShader: ShaderChunk[ 'shadow_vert' ],
				fragmentShader: ShaderChunk[ 'shadow_frag' ]
			} );

			this.lights = true;
			this.transparent = true;

			Object.defineProperties( this, {
				opacity: {
					enumerable: true,
					get: function () {
						return this.uniforms.opacity.value;
					},
					set: function ( value ) {
						this.uniforms.opacity.value = value;
					}
				}
			} );

		}

		ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;

		ShadowMaterial.prototype.isShadowMaterial = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function RawShaderMaterial( parameters ) {

			ShaderMaterial.call( this, parameters );

			this.type = 'RawShaderMaterial';

		}

		RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;

		RawShaderMaterial.prototype.isRawShaderMaterial = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function MultiMaterial( materials ) {

			this.uuid = _Math.generateUUID();

			this.type = 'MultiMaterial';

			this.materials = materials instanceof Array ? materials : [];

			this.visible = true;

		}

		MultiMaterial.prototype = {

			constructor: MultiMaterial,

			isMultiMaterial: true,

			toJSON: function ( meta ) {

				var output = {
					metadata: {
						version: 4.2,
						type: 'material',
						generator: 'MaterialExporter'
					},
					uuid: this.uuid,
					type: this.type,
					materials: []
				};

				var materials = this.materials;

				for ( var i = 0, l = materials.length; i < l; i ++ ) {

					var material = materials[ i ].toJSON( meta );
					delete material.metadata;

					output.materials.push( material );

				}

				output.visible = this.visible;

				return output;

			},

			clone: function () {

				var material = new this.constructor();

				for ( var i = 0; i < this.materials.length; i ++ ) {

					material.materials.push( this.materials[ i ].clone() );

				}

				material.visible = this.visible;

				return material;

			}

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  roughness: <float>,
		 *  metalness: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  roughnessMap: new THREE.Texture( <Image> ),
		 *
		 *  metalnessMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  envMapIntensity: <float>
		 *
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshStandardMaterial( parameters ) {

			Material.call( this );

			this.defines = { 'STANDARD': '' };

			this.type = 'MeshStandardMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 0.5;
			this.metalness = 0.5;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.roughnessMap = null;

			this.metalnessMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.envMapIntensity = 1.0;

			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshStandardMaterial.prototype = Object.create( Material.prototype );
		MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

		MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

		MeshStandardMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.defines = { 'STANDARD': '' };

			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.roughnessMap = source.roughnessMap;

			this.metalnessMap = source.metalnessMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;

			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  reflectivity: <float>
		 * }
		 */

		function MeshPhysicalMaterial( parameters ) {

			MeshStandardMaterial.call( this );

			this.defines = { 'PHYSICAL': '' };

			this.type = 'MeshPhysicalMaterial';

			this.reflectivity = 0.5; // maps to F0 = 0.04

			this.clearCoat = 0.0;
			this.clearCoatRoughness = 0.0;

			this.setValues( parameters );

		}

		MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

		MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

		MeshPhysicalMaterial.prototype.copy = function ( source ) {

			MeshStandardMaterial.prototype.copy.call( this, source );

			this.defines = { 'PHYSICAL': '' };

			this.reflectivity = source.reflectivity;

			this.clearCoat = source.clearCoat;
			this.clearCoatRoughness = source.clearCoatRoughness;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshPhongMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshPhongMaterial.prototype = Object.create( Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

		MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

		MeshPhongMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * parameters = {
		 *  opacity: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */

		function MeshNormalMaterial( parameters ) {

			Material.call( this, parameters );

			this.type = 'MeshNormalMaterial';

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;
			this.lights = false;
			this.morphTargets = false;

			this.setValues( parameters );

		}

		MeshNormalMaterial.prototype = Object.create( Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

		MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

		MeshNormalMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshLambertMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshLambertMaterial.prototype = Object.create( Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

		MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

		MeshLambertMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *
		 *  scale: <float>,
		 *  dashSize: <float>,
		 *  gapSize: <float>
		 * }
		 */

		function LineDashedMaterial( parameters ) {

			Material.call( this );

			this.type = 'LineDashedMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;

			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;

			this.lights = false;

			this.setValues( parameters );

		}

		LineDashedMaterial.prototype = Object.create( Material.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;

		LineDashedMaterial.prototype.isLineDashedMaterial = true;

		LineDashedMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;

			return this;

		};



		var Materials = Object.freeze({
			ShadowMaterial: ShadowMaterial,
			SpriteMaterial: SpriteMaterial,
			RawShaderMaterial: RawShaderMaterial,
			ShaderMaterial: ShaderMaterial,
			PointsMaterial: PointsMaterial,
			MultiMaterial: MultiMaterial,
			MeshPhysicalMaterial: MeshPhysicalMaterial,
			MeshStandardMaterial: MeshStandardMaterial,
			MeshPhongMaterial: MeshPhongMaterial,
			MeshNormalMaterial: MeshNormalMaterial,
			MeshLambertMaterial: MeshLambertMaterial,
			MeshDepthMaterial: MeshDepthMaterial,
			MeshBasicMaterial: MeshBasicMaterial,
			LineDashedMaterial: LineDashedMaterial,
			LineBasicMaterial: LineBasicMaterial,
			Material: Material
		});

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var Cache = {

			enabled: false,

			files: {},

			add: function ( key, file ) {

				if ( this.enabled === false ) return;

				// console.log( 'THREE.Cache', 'Adding key:', key );

				this.files[ key ] = file;

			},

			get: function ( key ) {

				if ( this.enabled === false ) return;

				// console.log( 'THREE.Cache', 'Checking key:', key );

				return this.files[ key ];

			},

			remove: function ( key ) {

				delete this.files[ key ];

			},

			clear: function () {

				this.files = {};

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LoadingManager( onLoad, onProgress, onError ) {

			var scope = this;

			var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function ( url ) {

				itemsTotal ++;

				if ( isLoading === false ) {

					if ( scope.onStart !== undefined ) {

						scope.onStart( url, itemsLoaded, itemsTotal );

					}

				}

				isLoading = true;

			};

			this.itemEnd = function ( url ) {

				itemsLoaded ++;

				if ( scope.onProgress !== undefined ) {

					scope.onProgress( url, itemsLoaded, itemsTotal );

				}

				if ( itemsLoaded === itemsTotal ) {

					isLoading = false;

					if ( scope.onLoad !== undefined ) {

						scope.onLoad();

					}

				}

			};

			this.itemError = function ( url ) {

				if ( scope.onError !== undefined ) {

					scope.onError( url );

				}

			};

		}

		var DefaultLoadingManager = new LoadingManager();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function XHRLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( XHRLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				if ( url === undefined ) url = '';

				if ( this.path !== undefined ) url = this.path + url;

				var scope = this;

				var cached = Cache.get( url );

				if ( cached !== undefined ) {

					scope.manager.itemStart( url );

					setTimeout( function () {

						if ( onLoad ) onLoad( cached );

						scope.manager.itemEnd( url );

					}, 0 );

					return cached;

				}

				// Check for data: URI
				var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
				var dataUriRegexResult = url.match( dataUriRegex );

				// Safari can not handle Data URIs through XMLHttpRequest so process manually
				if ( dataUriRegexResult ) {

					var mimeType = dataUriRegexResult[1];
					var isBase64 = !!dataUriRegexResult[2];
					var data = dataUriRegexResult[3];

					data = window.decodeURIComponent(data);

					if( isBase64 ) {
						data = window.atob(data);
					}

					try {

						var response;
						var responseType = ( this.responseType || '' ).toLowerCase();

						switch ( responseType ) {

							case 'arraybuffer':
							case 'blob':

							 	response = new ArrayBuffer( data.length );
								var view = new Uint8Array( response );
								for ( var i = 0; i < data.length; i ++ ) {

										view[ i ] = data.charCodeAt( i );

								}

								if ( responseType === 'blob' ) {

									response = new Blob( [ response ], { "type" : mimeType } );

								}

								break;

							case 'document':

								var parser = new DOMParser();
								response = parser.parseFromString( data, mimeType );

								break;

							case 'json':

								response = JSON.parse( data );

								break;

							default: // 'text' or other

								response = data;

								break;

						}

						// Wait for next browser tick
						window.setTimeout( function() {

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						}, 0);

					} catch ( error ) {

						// Wait for next browser tick
						window.setTimeout( function() {

							if ( onError ) onError( error );

							scope.manager.itemError( url );

						}, 0);

					}

				} else {

					var request = new XMLHttpRequest();
					request.open( 'GET', url, true );

					request.addEventListener( 'load', function ( event ) {

						var response = event.target.response;

						Cache.add( url, response );

						if ( this.status === 200 ) {

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						} else if ( this.status === 0 ) {

							// Some browsers return HTTP Status 0 when using non-http protocol
							// e.g. 'file://' or 'data://'. Handle as success.

							console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						} else {

							if ( onError ) onError( event );

							scope.manager.itemError( url );

						}

					}, false );

					if ( onProgress !== undefined ) {

						request.addEventListener( 'progress', function ( event ) {

							onProgress( event );

						}, false );

					}

					request.addEventListener( 'error', function ( event ) {

						if ( onError ) onError( event );

						scope.manager.itemError( url );

					}, false );

					if ( this.responseType !== undefined ) request.responseType = this.responseType;
					if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

					if ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );

					request.send( null );

				}

				scope.manager.itemStart( url );

				return request;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			},

			setResponseType: function ( value ) {

				this.responseType = value;
				return this;

			},

			setWithCredentials: function ( value ) {

				this.withCredentials = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Abstract Base class to block based textures loader (dds, pvr, ...)
		 */

		function CompressedTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			// override in sub classes
			this._parser = null;

		}

		Object.assign( CompressedTextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var images = [];

				var texture = new CompressedTexture();
				texture.image = images;

				var loader = new XHRLoader( this.manager );
				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );

				function loadTexture( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if ( texDatas.mipmapCount === 1 )
								texture.minFilter = LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, onProgress, onError );

				}

				if ( Array.isArray( url ) ) {

					var loaded = 0;

					for ( var i = 0, il = url.length; i < il; ++ i ) {

						loadTexture( i );

					}

				} else {

					// compressed cubemap texture stored in a single DDS file

					loader.load( url, function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						if ( texDatas.isCubemap ) {

							var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

							for ( var f = 0; f < faces; f ++ ) {

								images[ f ] = { mipmaps : [] };

								for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

									images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
									images[ f ].format = texDatas.format;
									images[ f ].width = texDatas.width;
									images[ f ].height = texDatas.height;

								}

							}

						} else {

							texture.image.width = texDatas.width;
							texture.image.height = texDatas.height;
							texture.mipmaps = texDatas.mipmaps;

						}

						if ( texDatas.mipmapCount === 1 ) {

							texture.minFilter = LinearFilter;

						}

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}, onProgress, onError );

				}

				return texture;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author Nikos M. / https://github.com/foo123/
		 *
		 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
		 */

		var DataTextureLoader = BinaryTextureLoader;
		function BinaryTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			// override in sub classes
			this._parser = null;

		}

		Object.assign( BinaryTextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var texture = new DataTexture();

				var loader = new XHRLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );

				loader.load( url, function ( buffer ) {

					var texData = scope._parser( buffer );

					if ( ! texData ) return;

					if ( undefined !== texData.image ) {

						texture.image = texData.image;

					} else if ( undefined !== texData.data ) {

						texture.image.width = texData.width;
						texture.image.height = texData.height;
						texture.image.data = texData.data;

					}

					texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
					texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

					texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
					texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

					texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

					if ( undefined !== texData.format ) {

						texture.format = texData.format;

					}
					if ( undefined !== texData.type ) {

						texture.type = texData.type;

					}

					if ( undefined !== texData.mipmaps ) {

						texture.mipmaps = texData.mipmaps;

					}

					if ( 1 === texData.mipmapCount ) {

						texture.minFilter = LinearFilter;

					}

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture, texData );

				}, onProgress, onError );


				return texture;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ImageLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( ImageLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
				image.onload = function () {

					image.onload = null;

					URL.revokeObjectURL( image.src );

					if ( onLoad ) onLoad( image );

					scope.manager.itemEnd( url );

				};
				image.onerror = onError;

				if ( url.indexOf( 'data:' ) === 0 ) {

					image.src = url;

				} else {

					var loader = new XHRLoader();
					loader.setPath( this.path );
					loader.setResponseType( 'blob' );
					loader.setWithCredentials( this.withCredentials );
					loader.load( url, function ( blob ) {

						image.src = URL.createObjectURL( blob );

					}, onProgress, onError );

				}

				scope.manager.itemStart( url );

				return image;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setWithCredentials: function ( value ) {

				this.withCredentials = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CubeTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( CubeTextureLoader.prototype, {

			load: function ( urls, onLoad, onProgress, onError ) {

				var texture = new CubeTexture();

				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );

				var loaded = 0;

				function loadTexture( i ) {

					loader.load( urls[ i ], function ( image ) {

						texture.images[ i ] = image;

						loaded ++;

						if ( loaded === 6 ) {

							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, undefined, onError );

				}

				for ( var i = 0; i < urls.length; ++ i ) {

					loadTexture( i );

				}

				return texture;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function TextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( TextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var texture = new Texture();

				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setWithCredentials( this.withCredentials );
				loader.setPath( this.path );
				loader.load( url, function ( image ) {

					// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
					var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

					texture.format = isJPEG ? RGBFormat : RGBAFormat;
					texture.image = image;
					texture.needsUpdate = true;

					if ( onLoad !== undefined ) {

						onLoad( texture );

					}

				}, onProgress, onError );

				return texture;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setWithCredentials: function ( value ) {

				this.withCredentials = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}



		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Light( color, intensity ) {

			Object3D.call( this );

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity !== undefined ? intensity : 1;

			this.receiveShadow = undefined;

		}

		Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Light,

			isLight: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.color.copy( source.color );
				this.intensity = source.intensity;

				return this;

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.color = this.color.getHex();
				data.object.intensity = this.intensity;

				if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

				if ( this.distance !== undefined ) data.object.distance = this.distance;
				if ( this.angle !== undefined ) data.object.angle = this.angle;
				if ( this.decay !== undefined ) data.object.decay = this.decay;
				if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

				if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function HemisphereLight( skyColor, groundColor, intensity ) {

			Light.call( this, skyColor, intensity );

			this.type = 'HemisphereLight';

			this.castShadow = undefined;

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: HemisphereLight,

			isHemisphereLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.groundColor.copy( source.groundColor );

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LightShadow( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.radius = 1;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.matrix = new Matrix4();

		}

		Object.assign( LightShadow.prototype, {

			copy: function ( source ) {

				this.camera = source.camera.clone();

				this.bias = source.bias;
				this.radius = source.radius;

				this.mapSize.copy( source.mapSize );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			toJSON: function () {

				var object = {};

				if ( this.bias !== 0 ) object.bias = this.bias;
				if ( this.radius !== 1 ) object.radius = this.radius;
				if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

				object.camera = this.camera.toJSON( false ).object;
				delete object.camera.matrix;

				return object;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function SpotLightShadow() {

			LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		}

		SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: SpotLightShadow,

			isSpotLightShadow: true,

			update: function ( light ) {

				var fov = _Math.RAD2DEG * 2 * light.angle;
				var aspect = this.mapSize.width / this.mapSize.height;
				var far = light.distance || 500;

				var camera = this.camera;

				if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

					camera.fov = fov;
					camera.aspect = aspect;
					camera.far = far;
					camera.updateProjectionMatrix();

				}

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

			Light.call( this, color, intensity );

			this.type = 'SpotLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * Math.PI;
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / Math.PI;
				}
			} );

			this.distance = ( distance !== undefined ) ? distance : 0;
			this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
			this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();

		}

		SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: SpotLight,

			isSpotLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.distance = source.distance;
				this.angle = source.angle;
				this.penumbra = source.penumbra;
				this.decay = source.decay;

				this.target = source.target.clone();

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */


		function PointLight( color, intensity, distance, decay ) {

			Light.call( this, color, intensity );

			this.type = 'PointLight';

			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * 4 * Math.PI;

				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / ( 4 * Math.PI );
				}
			} );

			this.distance = ( distance !== undefined ) ? distance : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

			this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		}

		PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: PointLight,

			isPointLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.distance = source.distance;
				this.decay = source.decay;

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function DirectionalLightShadow( light ) {

			LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		}

		DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: DirectionalLightShadow

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function DirectionalLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: DirectionalLight,

			isDirectionalLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.target = source.target.clone();

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AmbientLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'AmbientLight';

			this.castShadow = undefined;

		}

		AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: AmbientLight,

			isAmbientLight: true,

		} );

		/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */

		var AnimationUtils = {

			// same as Array.prototype.slice, but also works on typed arrays
			arraySlice: function( array, from, to ) {

				if ( AnimationUtils.isTypedArray( array ) ) {

					return new array.constructor( array.subarray( from, to ) );

				}

				return array.slice( from, to );

			},

			// converts an array to a specific type
			convertArray: function( array, type, forceClone ) {

				if ( ! array || // let 'undefined' and 'null' pass
						! forceClone && array.constructor === type ) return array;

				if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

					return new type( array ); // create typed array

				}

				return Array.prototype.slice.call( array ); // create Array

			},

			isTypedArray: function( object ) {

				return ArrayBuffer.isView( object ) &&
						! ( object instanceof DataView );

			},

			// returns an array by which times and values can be sorted
			getKeyframeOrder: function( times ) {

				function compareTime( i, j ) {

					return times[ i ] - times[ j ];

				}

				var n = times.length;
				var result = new Array( n );
				for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

				result.sort( compareTime );

				return result;

			},

			// uses the array previously returned by 'getKeyframeOrder' to sort data
			sortedArray: function( values, stride, order ) {

				var nValues = values.length;
				var result = new values.constructor( nValues );

				for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

					var srcOffset = order[ i ] * stride;

					for ( var j = 0; j !== stride; ++ j ) {

						result[ dstOffset ++ ] = values[ srcOffset + j ];

					}

				}

				return result;

			},

			// function for parsing AOS keyframe formats
			flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

				var i = 1, key = jsonKeys[ 0 ];

				while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

					key = jsonKeys[ i ++ ];

				}

				if ( key === undefined ) return; // no data

				var value = key[ valuePropertyName ];
				if ( value === undefined ) return; // no data

				if ( Array.isArray( value ) ) {

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							values.push.apply( values, value ); // push all elements

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				} else if ( value.toArray !== undefined ) {
					// ...assume THREE.Math-ish

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							value.toArray( values, values.length );

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				} else {
					// otherwise push as-is

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							values.push( value );

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				}

			}

		};

		/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */

		function Interpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;

			this.resultBuffer = resultBuffer !== undefined ?
					resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;

		}

		Interpolant.prototype = {

			constructor: Interpolant,

			evaluate: function( t ) {

				var pp = this.parameterPositions,
					i1 = this._cachedIndex,

					t1 = pp[   i1   ],
					t0 = pp[ i1 - 1 ];

				validate_interval: {

					seek: {

						var right;

						linear_scan: {
		//- See http://jsperf.com/comparison-to-undefined/3
		//- slower code:
		//-
		//- 				if ( t >= t1 || t1 === undefined ) {
							forward_scan: if ( ! ( t < t1 ) ) {

								for ( var giveUpAt = i1 + 2; ;) {

									if ( t1 === undefined ) {

										if ( t < t0 ) break forward_scan;

										// after end

										i1 = pp.length;
										this._cachedIndex = i1;
										return this.afterEnd_( i1 - 1, t, t0 );

									}

									if ( i1 === giveUpAt ) break; // this loop

									t0 = t1;
									t1 = pp[ ++ i1 ];

									if ( t < t1 ) {

										// we have arrived at the sought interval
										break seek;

									}

								}

								// prepare binary search on the right side of the index
								right = pp.length;
								break linear_scan;

							}

		//- slower code:
		//-					if ( t < t0 || t0 === undefined ) {
							if ( ! ( t >= t0 ) ) {

								// looping?

								var t1global = pp[ 1 ];

								if ( t < t1global ) {

									i1 = 2; // + 1, using the scan for the details
									t0 = t1global;

								}

								// linear reverse scan

								for ( var giveUpAt = i1 - 2; ;) {

									if ( t0 === undefined ) {

										// before start

										this._cachedIndex = 0;
										return this.beforeStart_( 0, t, t1 );

									}

									if ( i1 === giveUpAt ) break; // this loop

									t1 = t0;
									t0 = pp[ -- i1 - 1 ];

									if ( t >= t0 ) {

										// we have arrived at the sought interval
										break seek;

									}

								}

								// prepare binary search on the left side of the index
								right = i1;
								i1 = 0;
								break linear_scan;

							}

							// the interval is valid

							break validate_interval;

						} // linear scan

						// binary search

						while ( i1 < right ) {

							var mid = ( i1 + right ) >>> 1;

							if ( t < pp[ mid ] ) {

								right = mid;

							} else {

								i1 = mid + 1;

							}

						}

						t1 = pp[   i1   ];
						t0 = pp[ i1 - 1 ];

						// check boundary cases, again

						if ( t0 === undefined ) {

							this._cachedIndex = 0;
							return this.beforeStart_( 0, t, t1 );

						}

						if ( t1 === undefined ) {

							i1 = pp.length;
							this._cachedIndex = i1;
							return this.afterEnd_( i1 - 1, t0, t );

						}

					} // seek

					this._cachedIndex = i1;

					this.intervalChanged_( i1, t0, t1 );

				} // validate_interval

				return this.interpolate_( i1, t0, t, t1 );

			},

			settings: null, // optional, subclass-specific settings structure
			// Note: The indirection allows central control of many interpolants.

			// --- Protected interface

			DefaultSettings_: {},

			getSettings_: function() {

				return this.settings || this.DefaultSettings_;

			},

			copySampleValue_: function( index ) {

				// copies a sample value to the result buffer

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] = values[ offset + i ];

				}

				return result;

			},

			// Template methods for derived classes:

			interpolate_: function( i1, t0, t, t1 ) {

				throw new Error( "call to abstract method" );
				// implementations shall return this.resultBuffer

			},

			intervalChanged_: function( i1, t0, t1 ) {

				// empty

			}

		};

		Object.assign( Interpolant.prototype, {

			beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_,

			afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_

		} );

		/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */

		function CubicInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;

		}

		CubicInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: CubicInterpolant,

			DefaultSettings_: {

				endingStart: 	ZeroCurvatureEnding,
				endingEnd:		ZeroCurvatureEnding

			},

			intervalChanged_: function( i1, t0, t1 ) {

				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,

					tPrev = pp[ iPrev ],
					tNext = pp[ iNext ];

				if ( tPrev === undefined ) {

					switch ( this.getSettings_().endingStart ) {

						case ZeroSlopeEnding:

							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;

							break;

						case WrapAroundEnding:

							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

							break;

						default: // ZeroCurvatureEnding

							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;

					}

				}

				if ( tNext === undefined ) {

					switch ( this.getSettings_().endingEnd ) {

						case ZeroSlopeEnding:

							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;

							break;

						case WrapAroundEnding:

							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[ 1 ] - pp[ 0 ];

							break;

						default: // ZeroCurvatureEnding

							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;

					}

				}

				var halfDt = ( t1 - t0 ) * 0.5,
					stride = this.valueSize;

				this._weightPrev = halfDt / ( t0 - tPrev );
				this._weightNext = halfDt / ( tNext - t1 );
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;

			},

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					o1 = i1 * stride,		o0 = o1 - stride,
					oP = this._offsetPrev, 	oN = this._offsetNext,
					wP = this._weightPrev,	wN = this._weightNext,

					p = ( t - t0 ) / ( t1 - t0 ),
					pp = p * p,
					ppp = pp * p;

				// evaluate polynomials

				var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
				var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
				var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
				var sN =       wN   * ppp   -           wN      * pp;

				// combine data linearly

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] =
							sP * values[ oP + i ] +
							s0 * values[ o0 + i ] +
							s1 * values[ o1 + i ] +
							sN * values[ oN + i ];

				}

				return result;

			}

		} );

		/**
		 * @author tschw
		 */

		function LinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		LinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: LinearInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset1 = i1 * stride,
					offset0 = offset1 - stride,

					weight1 = ( t - t0 ) / ( t1 - t0 ),
					weight0 = 1 - weight1;

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] =
							values[ offset0 + i ] * weight0 +
							values[ offset1 + i ] * weight1;

				}

				return result;

			}

		} );

		/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */

		function DiscreteInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		DiscreteInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: DiscreteInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				return this.copySampleValue_( i1 - 1 );

			}

		} );

		var KeyframeTrackPrototype;

		KeyframeTrackPrototype = {

			TimeBufferType: Float32Array,
			ValueBufferType: Float32Array,

			DefaultInterpolation: InterpolateLinear,

			InterpolantFactoryMethodDiscrete: function( result ) {

				return new DiscreteInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodLinear: function( result ) {

				return new LinearInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodSmooth: function( result ) {

				return new CubicInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			setInterpolation: function( interpolation ) {

				var factoryMethod;

				switch ( interpolation ) {

					case InterpolateDiscrete:

						factoryMethod = this.InterpolantFactoryMethodDiscrete;

						break;

					case InterpolateLinear:

						factoryMethod = this.InterpolantFactoryMethodLinear;

						break;

					case InterpolateSmooth:

						factoryMethod = this.InterpolantFactoryMethodSmooth;

						break;

				}

				if ( factoryMethod === undefined ) {

					var message = "unsupported interpolation for " +
							this.ValueTypeName + " keyframe track named " + this.name;

					if ( this.createInterpolant === undefined ) {

						// fall back to default, unless the default itself is messed up
						if ( interpolation !== this.DefaultInterpolation ) {

							this.setInterpolation( this.DefaultInterpolation );

						} else {

							throw new Error( message ); // fatal, in this case

						}

					}

					console.warn( message );
					return;

				}

				this.createInterpolant = factoryMethod;

			},

			getInterpolation: function() {

				switch ( this.createInterpolant ) {

					case this.InterpolantFactoryMethodDiscrete:

						return InterpolateDiscrete;

					case this.InterpolantFactoryMethodLinear:

						return InterpolateLinear;

					case this.InterpolantFactoryMethodSmooth:

						return InterpolateSmooth;

				}

			},

			getValueSize: function() {

				return this.values.length / this.times.length;

			},

			// move all keyframes either forwards or backwards in time
			shift: function( timeOffset ) {

				if( timeOffset !== 0.0 ) {

					var times = this.times;

					for( var i = 0, n = times.length; i !== n; ++ i ) {

						times[ i ] += timeOffset;

					}

				}

				return this;

			},

			// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
			scale: function( timeScale ) {

				if( timeScale !== 1.0 ) {

					var times = this.times;

					for( var i = 0, n = times.length; i !== n; ++ i ) {

						times[ i ] *= timeScale;

					}

				}

				return this;

			},

			// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
			// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
			trim: function( startTime, endTime ) {

				var times = this.times,
					nKeys = times.length,
					from = 0,
					to = nKeys - 1;

				while ( from !== nKeys && times[ from ] < startTime ) ++ from;
				while ( to !== -1 && times[ to ] > endTime ) -- to;

				++ to; // inclusive -> exclusive bound

				if( from !== 0 || to !== nKeys ) {

					// empty tracks are forbidden, so keep at least one keyframe
					if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;

					var stride = this.getValueSize();
					this.times = AnimationUtils.arraySlice( times, from, to );
					this.values = AnimationUtils.
							arraySlice( this.values, from * stride, to * stride );

				}

				return this;

			},

			// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
			validate: function() {

				var valid = true;

				var valueSize = this.getValueSize();
				if ( valueSize - Math.floor( valueSize ) !== 0 ) {

					console.error( "invalid value size in track", this );
					valid = false;

				}

				var times = this.times,
					values = this.values,

					nKeys = times.length;

				if( nKeys === 0 ) {

					console.error( "track is empty", this );
					valid = false;

				}

				var prevTime = null;

				for( var i = 0; i !== nKeys; i ++ ) {

					var currTime = times[ i ];

					if ( typeof currTime === 'number' && isNaN( currTime ) ) {

						console.error( "time is not a valid number", this, i, currTime );
						valid = false;
						break;

					}

					if( prevTime !== null && prevTime > currTime ) {

						console.error( "out of order keys", this, i, currTime, prevTime );
						valid = false;
						break;

					}

					prevTime = currTime;

				}

				if ( values !== undefined ) {

					if ( AnimationUtils.isTypedArray( values ) ) {

						for ( var i = 0, n = values.length; i !== n; ++ i ) {

							var value = values[ i ];

							if ( isNaN( value ) ) {

								console.error( "value is not a valid number", this, i, value );
								valid = false;
								break;

							}

						}

					}

				}

				return valid;

			},

			// removes equivalent sequential keys as common in morph target sequences
			// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
			optimize: function() {

				var times = this.times,
					values = this.values,
					stride = this.getValueSize(),

					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

					writeIndex = 1,
					lastIndex = times.length - 1;

				for( var i = 1; i < lastIndex; ++ i ) {

					var keep = false;

					var time = times[ i ];
					var timeNext = times[ i + 1 ];

					// remove adjacent keyframes scheduled at the same time

					if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

						if ( ! smoothInterpolation ) {

							// remove unnecessary keyframes same as their neighbors

							var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;

							for ( var j = 0; j !== stride; ++ j ) {

								var value = values[ offset + j ];

								if ( value !== values[ offsetP + j ] ||
										value !== values[ offsetN + j ] ) {

									keep = true;
									break;

								}

							}

						} else keep = true;

					}

					// in-place compaction

					if ( keep ) {

						if ( i !== writeIndex ) {

							times[ writeIndex ] = times[ i ];

							var readOffset = i * stride,
								writeOffset = writeIndex * stride;

							for ( var j = 0; j !== stride; ++ j )

								values[ writeOffset + j ] = values[ readOffset + j ];

						}

						++ writeIndex;

					}

				}

				// flush last keyframe (compaction looks ahead)

				if ( lastIndex > 0 ) {

					times[ writeIndex ] = times[ lastIndex ];

					for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

						values[ writeOffset + j ] = values[ readOffset + j ];

					++ writeIndex;

				}

				if ( writeIndex !== times.length ) {

					this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
					this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

				}

				return this;

			}

		};

		function KeyframeTrackConstructor( name, times, values, interpolation ) {

			if( name === undefined ) throw new Error( "track name is undefined" );

			if( times === undefined || times.length === 0 ) {

				throw new Error( "no keyframes in track named " + name );

			}

			this.name = name;

			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

			this.setInterpolation( interpolation || this.DefaultInterpolation );

			this.validate();
			this.optimize();

		}

		/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function VectorKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		VectorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: VectorKeyframeTrack,

			ValueTypeName: 'vector'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		} );

		/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */

		function QuaternionLinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		QuaternionLinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: QuaternionLinearInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset = i1 * stride,

					alpha = ( t - t0 ) / ( t1 - t0 );

				for ( var end = offset + stride; offset !== end; offset += 4 ) {

					Quaternion.slerpFlat( result, 0,
							values, offset - stride, values, offset, alpha );

				}

				return result;

			}

		} );

		/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function QuaternionKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		QuaternionKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: QuaternionKeyframeTrack,

			ValueTypeName: 'quaternion',

			// ValueBufferType is inherited

			DefaultInterpolation: InterpolateLinear,

			InterpolantFactoryMethodLinear: function( result ) {

				return new QuaternionLinearInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodSmooth: undefined // not yet implemented

		} );

		/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function NumberKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		NumberKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: NumberKeyframeTrack,

			ValueTypeName: 'number',

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		} );

		/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function StringKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		StringKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: StringKeyframeTrack,

			ValueTypeName: 'string',
			ValueBufferType: Array,

			DefaultInterpolation: InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,

			InterpolantFactoryMethodSmooth: undefined

		} );

		/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function BooleanKeyframeTrack( name, times, values ) {

			KeyframeTrackConstructor.call( this, name, times, values );

		}

		BooleanKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: BooleanKeyframeTrack,

			ValueTypeName: 'bool',
			ValueBufferType: Array,

			DefaultInterpolation: InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined

			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".

		} );

		/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function ColorKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		ColorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: ColorKeyframeTrack,

			ValueTypeName: 'color'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited


			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.

		} );

		/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function KeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.apply( this, arguments );

		}

		KeyframeTrack.prototype = KeyframeTrackPrototype;
		KeyframeTrackPrototype.constructor = KeyframeTrack;

		// Static methods:

		Object.assign( KeyframeTrack, {

			// Serialization (in static context, because of constructor invocation
			// and automatic invocation of .toJSON):

			parse: function( json ) {

				if( json.type === undefined ) {

					throw new Error( "track type undefined, can not parse" );

				}

				var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

				if ( json.times === undefined ) {

					var times = [], values = [];

					AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

					json.times = times;
					json.values = values;

				}

				// derived classes can define a static parse method
				if ( trackType.parse !== undefined ) {

					return trackType.parse( json );

				} else {

					// by default, we asssume a constructor compatible with the base
					return new trackType(
							json.name, json.times, json.values, json.interpolation );

				}

			},

			toJSON: function( track ) {

				var trackType = track.constructor;

				var json;

				// derived classes can define a static toJSON method
				if ( trackType.toJSON !== undefined ) {

					json = trackType.toJSON( track );

				} else {

					// by default, we assume the data can be serialized as-is
					json = {

						'name': track.name,
						'times': AnimationUtils.convertArray( track.times, Array ),
						'values': AnimationUtils.convertArray( track.values, Array )

					};

					var interpolation = track.getInterpolation();

					if ( interpolation !== track.DefaultInterpolation ) {

						json.interpolation = interpolation;

					}

				}

				json.type = track.ValueTypeName; // mandatory

				return json;

			},

			_getTrackTypeForValueTypeName: function( typeName ) {

				switch( typeName.toLowerCase() ) {

					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":

						return NumberKeyframeTrack;

					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":

						return VectorKeyframeTrack;

					case "color":

						return ColorKeyframeTrack;

					case "quaternion":

						return QuaternionKeyframeTrack;

					case "bool":
					case "boolean":

						return BooleanKeyframeTrack;

					case "string":

						return StringKeyframeTrack;

				}

				throw new Error( "Unsupported typeName: " + typeName );

			}

		} );

		/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */

		function AnimationClip( name, duration, tracks ) {

			this.name = name;
			this.tracks = tracks;
			this.duration = ( duration !== undefined ) ? duration : -1;

			this.uuid = _Math.generateUUID();

			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {

				this.resetDuration();

			}

			this.optimize();

		}

		AnimationClip.prototype = {

			constructor: AnimationClip,

			resetDuration: function() {

				var tracks = this.tracks,
					duration = 0;

				for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

					var track = this.tracks[ i ];

					duration = Math.max(
							duration, track.times[ track.times.length - 1 ] );

				}

				this.duration = duration;

			},

			trim: function() {

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					this.tracks[ i ].trim( 0, this.duration );

				}

				return this;

			},

			optimize: function() {

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					this.tracks[ i ].optimize();

				}

				return this;

			}

		};

		// Static methods:

		Object.assign( AnimationClip, {

			parse: function( json ) {

				var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / ( json.fps || 1.0 );

				for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

					tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

				}

				return new AnimationClip( json.name, json.duration, tracks );

			},


			toJSON: function( clip ) {

				var tracks = [],
					clipTracks = clip.tracks;

				var json = {

					'name': clip.name,
					'duration': clip.duration,
					'tracks': tracks

				};

				for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

					tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

				}

				return json;

			},


			CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

				var numMorphTargets = morphTargetSequence.length;
				var tracks = [];

				for ( var i = 0; i < numMorphTargets; i ++ ) {

					var times = [];
					var values = [];

					times.push(
							( i + numMorphTargets - 1 ) % numMorphTargets,
							i,
							( i + 1 ) % numMorphTargets );

					values.push( 0, 1, 0 );

					var order = AnimationUtils.getKeyframeOrder( times );
					times = AnimationUtils.sortedArray( times, 1, order );
					values = AnimationUtils.sortedArray( values, 1, order );

					// if there is a key at the first frame, duplicate it as the
					// last frame as well for perfect loop.
					if ( ! noLoop && times[ 0 ] === 0 ) {

						times.push( numMorphTargets );
						values.push( values[ 0 ] );

					}

					tracks.push(
							new NumberKeyframeTrack(
								'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
								times, values
							).scale( 1.0 / fps ) );
				}

				return new AnimationClip( name, -1, tracks );

			},

			findByName: function( objectOrClipArray, name ) {

				var clipArray = objectOrClipArray;

				if ( ! Array.isArray( objectOrClipArray ) ) {

					var o = objectOrClipArray;
					clipArray = o.geometry && o.geometry.animations || o.animations;

				}

				for ( var i = 0; i < clipArray.length; i ++ ) {

					if ( clipArray[ i ].name === name ) {

						return clipArray[ i ];

					}
				}

				return null;

			},

			CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

				var animationToMorphTargets = {};

				// tested with https://regex101.com/ on trick sequences
				// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
				var pattern = /^([\w-]*?)([\d]+)$/;

				// sort morph target names into animation groups based
				// patterns like Walk_001, Walk_002, Run_001, Run_002
				for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

					var morphTarget = morphTargets[ i ];
					var parts = morphTarget.name.match( pattern );

					if ( parts && parts.length > 1 ) {

						var name = parts[ 1 ];

						var animationMorphTargets = animationToMorphTargets[ name ];
						if ( ! animationMorphTargets ) {

							animationToMorphTargets[ name ] = animationMorphTargets = [];

						}

						animationMorphTargets.push( morphTarget );

					}

				}

				var clips = [];

				for ( var name in animationToMorphTargets ) {

					clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

				}

				return clips;

			},

			// parse the animation.hierarchy format
			parseAnimation: function( animation, bones ) {

				if ( ! animation ) {

					console.error( "  no animation in JSONLoader data" );
					return null;

				}

				var addNonemptyTrack = function(
						trackType, trackName, animationKeys, propertyName, destTracks ) {

					// only return track if there are actually keys.
					if ( animationKeys.length !== 0 ) {

						var times = [];
						var values = [];

						AnimationUtils.flattenJSON(
								animationKeys, times, values, propertyName );

						// empty keys are filtered out, so check again
						if ( times.length !== 0 ) {

							destTracks.push( new trackType( trackName, times, values ) );

						}

					}

				};

				var tracks = [];

				var clipName = animation.name || 'default';
				// automatic length determination in AnimationClip.
				var duration = animation.length || -1;
				var fps = animation.fps || 30;

				var hierarchyTracks = animation.hierarchy || [];

				for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

					var animationKeys = hierarchyTracks[ h ].keys;

					// skip empty tracks
					if ( ! animationKeys || animationKeys.length === 0 ) continue;

					// process morph targets in a way exactly compatible
					// with AnimationHandler.init( animation )
					if ( animationKeys[0].morphTargets ) {

						// figure out all morph targets used in this track
						var morphTargetNames = {};
						for ( var k = 0; k < animationKeys.length; k ++ ) {

							if ( animationKeys[k].morphTargets ) {

								for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

									morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
								}

							}

						}

						// create a track for each morph target with all zero
						// morphTargetInfluences except for the keys in which
						// the morphTarget is named.
						for ( var morphTargetName in morphTargetNames ) {

							var times = [];
							var values = [];

							for ( var m = 0;
									m !== animationKeys[k].morphTargets.length; ++ m ) {

								var animationKey = animationKeys[k];

								times.push( animationKey.time );
								values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

							}

							tracks.push( new NumberKeyframeTrack(
									'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

						}

						duration = morphTargetNames.length * ( fps || 1.0 );

					} else {
						// ...assume skeletal animation

						var boneName = '.bones[' + bones[ h ].name + ']';

						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.position',
								animationKeys, 'pos', tracks );

						addNonemptyTrack(
								QuaternionKeyframeTrack, boneName + '.quaternion',
								animationKeys, 'rot', tracks );

						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.scale',
								animationKeys, 'scl', tracks );

					}

				}

				if ( tracks.length === 0 ) {

					return null;

				}

				var clip = new AnimationClip( clipName, duration, tracks );

				return clip;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function MaterialLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.textures = {};

		}

		Object.assign( MaterialLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			setTextures: function ( value ) {

				this.textures = value;

			},

			parse: function ( json ) {

				var textures = this.textures;

				function getTexture( name ) {

					if ( textures[ name ] === undefined ) {

						console.warn( 'THREE.MaterialLoader: Undefined texture', name );

					}

					return textures[ name ];

				}

				var material = new Materials[ json.type ]();

				if ( json.uuid !== undefined ) material.uuid = json.uuid;
				if ( json.name !== undefined ) material.name = json.name;
				if ( json.color !== undefined ) material.color.setHex( json.color );
				if ( json.roughness !== undefined ) material.roughness = json.roughness;
				if ( json.metalness !== undefined ) material.metalness = json.metalness;
				if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
				if ( json.specular !== undefined ) material.specular.setHex( json.specular );
				if ( json.shininess !== undefined ) material.shininess = json.shininess;
				if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
				if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
				if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
				if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
				if ( json.fog !== undefined ) material.fog = json.fog;
				if ( json.shading !== undefined ) material.shading = json.shading;
				if ( json.blending !== undefined ) material.blending = json.blending;
				if ( json.side !== undefined ) material.side = json.side;
				if ( json.opacity !== undefined ) material.opacity = json.opacity;
				if ( json.transparent !== undefined ) material.transparent = json.transparent;
				if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
				if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
				if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
				if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
				if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
				if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
				if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
				if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
				if ( json.skinning !== undefined ) material.skinning = json.skinning;
				if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

				// for PointsMaterial

				if ( json.size !== undefined ) material.size = json.size;
				if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

				// maps

				if ( json.map !== undefined ) material.map = getTexture( json.map );

				if ( json.alphaMap !== undefined ) {

					material.alphaMap = getTexture( json.alphaMap );
					material.transparent = true;

				}

				if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
				if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

				if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
				if ( json.normalScale !== undefined ) {

					var normalScale = json.normalScale;

					if ( Array.isArray( normalScale ) === false ) {

						// Blender exporter used to export a scalar. See #7459

						normalScale = [ normalScale, normalScale ];

					}

					material.normalScale = new Vector2().fromArray( normalScale );

				}

				if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
				if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
				if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

				if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
				if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

				if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
				if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

				if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

				if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

				if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

				if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
				if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

				if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
				if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

				// MultiMaterial

				if ( json.materials !== undefined ) {

					for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

						material.materials.push( this.parse( json.materials[ i ] ) );

					}

				}

				return material;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferGeometryLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( BufferGeometryLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				var geometry = new BufferGeometry();

				var index = json.data.index;

				var TYPED_ARRAYS = {
					'Int8Array': Int8Array,
					'Uint8Array': Uint8Array,
					'Uint8ClampedArray': Uint8ClampedArray,
					'Int16Array': Int16Array,
					'Uint16Array': Uint16Array,
					'Int32Array': Int32Array,
					'Uint32Array': Uint32Array,
					'Float32Array': Float32Array,
					'Float64Array': Float64Array
				};

				if ( index !== undefined ) {

					var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
					geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

				}

				var attributes = json.data.attributes;

				for ( var key in attributes ) {

					var attribute = attributes[ key ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

					geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

				}

				var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

				if ( groups !== undefined ) {

					for ( var i = 0, n = groups.length; i !== n; ++ i ) {

						var group = groups[ i ];

						geometry.addGroup( group.start, group.count, group.materialIndex );

					}

				}

				var boundingSphere = json.data.boundingSphere;

				if ( boundingSphere !== undefined ) {

					var center = new Vector3();

					if ( boundingSphere.center !== undefined ) {

						center.fromArray( boundingSphere.center );

					}

					geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

				}

				return geometry;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Loader() {

			this.onLoadStart = function () {};
			this.onLoadProgress = function () {};
			this.onLoadComplete = function () {};

		}

		Loader.prototype = {

			constructor: Loader,

			crossOrigin: undefined,

			extractUrlBase: function ( url ) {

				var parts = url.split( '/' );

				if ( parts.length === 1 ) return './';

				parts.pop();

				return parts.join( '/' ) + '/';

			},

			initMaterials: function ( materials, texturePath, crossOrigin ) {

				var array = [];

				for ( var i = 0; i < materials.length; ++ i ) {

					array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

				}

				return array;

			},

			createMaterial: ( function () {

				var color, textureLoader, materialLoader;

				return function createMaterial( m, texturePath, crossOrigin ) {

					if ( color === undefined ) color = new Color();
					if ( textureLoader === undefined ) textureLoader = new TextureLoader();
					if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

					// convert from old material format

					var textures = {};

					function loadTexture( path, repeat, offset, wrap, anisotropy ) {

						var fullPath = texturePath + path;
						var loader = Loader.Handlers.get( fullPath );

						var texture;

						if ( loader !== null ) {

							texture = loader.load( fullPath );

						} else {

							textureLoader.setCrossOrigin( crossOrigin );
							texture = textureLoader.load( fullPath );

						}

						if ( repeat !== undefined ) {

							texture.repeat.fromArray( repeat );

							if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
							if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

						}

						if ( offset !== undefined ) {

							texture.offset.fromArray( offset );

						}

						if ( wrap !== undefined ) {

							if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
							if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

							if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
							if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

						}

						if ( anisotropy !== undefined ) {

							texture.anisotropy = anisotropy;

						}

						var uuid = _Math.generateUUID();

						textures[ uuid ] = texture;

						return uuid;

					}

					//

					var json = {
						uuid: _Math.generateUUID(),
						type: 'MeshLambertMaterial'
					};

					for ( var name in m ) {

						var value = m[ name ];

						switch ( name ) {
							case 'DbgColor':
							case 'DbgIndex':
							case 'opticalDensity':
							case 'illumination':
								break;
							case 'DbgName':
								json.name = value;
								break;
							case 'blending':
								json.blending = BlendingMode[ value ];
								break;
							case 'colorAmbient':
							case 'mapAmbient':
								console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
								break;
							case 'colorDiffuse':
								json.color = color.fromArray( value ).getHex();
								break;
							case 'colorSpecular':
								json.specular = color.fromArray( value ).getHex();
								break;
							case 'colorEmissive':
								json.emissive = color.fromArray( value ).getHex();
								break;
							case 'specularCoef':
								json.shininess = value;
								break;
							case 'shading':
								if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
								if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
								if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
								break;
							case 'mapDiffuse':
								json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
								break;
							case 'mapDiffuseRepeat':
							case 'mapDiffuseOffset':
							case 'mapDiffuseWrap':
							case 'mapDiffuseAnisotropy':
								break;
							case 'mapEmissive':
								json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
								break;
							case 'mapEmissiveRepeat':
							case 'mapEmissiveOffset':
							case 'mapEmissiveWrap':
							case 'mapEmissiveAnisotropy':
								break;
							case 'mapLight':
								json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
								break;
							case 'mapLightRepeat':
							case 'mapLightOffset':
							case 'mapLightWrap':
							case 'mapLightAnisotropy':
								break;
							case 'mapAO':
								json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
								break;
							case 'mapAORepeat':
							case 'mapAOOffset':
							case 'mapAOWrap':
							case 'mapAOAnisotropy':
								break;
							case 'mapBump':
								json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
								break;
							case 'mapBumpScale':
								json.bumpScale = value;
								break;
							case 'mapBumpRepeat':
							case 'mapBumpOffset':
							case 'mapBumpWrap':
							case 'mapBumpAnisotropy':
								break;
							case 'mapNormal':
								json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
								break;
							case 'mapNormalFactor':
								json.normalScale = [ value, value ];
								break;
							case 'mapNormalRepeat':
							case 'mapNormalOffset':
							case 'mapNormalWrap':
							case 'mapNormalAnisotropy':
								break;
							case 'mapSpecular':
								json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
								break;
							case 'mapSpecularRepeat':
							case 'mapSpecularOffset':
							case 'mapSpecularWrap':
							case 'mapSpecularAnisotropy':
								break;
							case 'mapMetalness':
								json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
								break;
							case 'mapMetalnessRepeat':
							case 'mapMetalnessOffset':
							case 'mapMetalnessWrap':
							case 'mapMetalnessAnisotropy':
								break;
							case 'mapRoughness':
								json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
								break;
							case 'mapRoughnessRepeat':
							case 'mapRoughnessOffset':
							case 'mapRoughnessWrap':
							case 'mapRoughnessAnisotropy':
								break;
							case 'mapAlpha':
								json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
								break;
							case 'mapAlphaRepeat':
							case 'mapAlphaOffset':
							case 'mapAlphaWrap':
							case 'mapAlphaAnisotropy':
								break;
							case 'flipSided':
								json.side = BackSide;
								break;
							case 'doubleSided':
								json.side = DoubleSide;
								break;
							case 'transparency':
								console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
								json.opacity = value;
								break;
							case 'depthTest':
							case 'depthWrite':
							case 'colorWrite':
							case 'opacity':
							case 'reflectivity':
							case 'transparent':
							case 'visible':
							case 'wireframe':
								json[ name ] = value;
								break;
							case 'vertexColors':
								if ( value === true ) json.vertexColors = VertexColors;
								if ( value === 'face' ) json.vertexColors = FaceColors;
								break;
							default:
								console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
								break;
						}

					}

					if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
					if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

					if ( json.opacity < 1 ) json.transparent = true;

					materialLoader.setTextures( textures );

					return materialLoader.parse( json );

				};

			} )()

		};

		Loader.Handlers = {

			handlers: [],

			add: function ( regex, loader ) {

				this.handlers.push( regex, loader );

			},

			get: function ( file ) {

				var handlers = this.handlers;

				for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

					var regex = handlers[ i ];
					var loader  = handlers[ i + 1 ];

					if ( regex.test( file ) ) {

						return loader;

					}

				}

				return null;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function JSONLoader( manager ) {

			if ( typeof manager === 'boolean' ) {

				console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
				manager = undefined;

			}

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			this.withCredentials = false;

		}

		Object.assign( JSONLoader.prototype, {

			load: function( url, onLoad, onProgress, onError ) {

				var scope = this;

				var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

				var loader = new XHRLoader( this.manager );
				loader.setWithCredentials( this.withCredentials );
				loader.load( url, function ( text ) {

					var json = JSON.parse( text );
					var metadata = json.metadata;

					if ( metadata !== undefined ) {

						var type = metadata.type;

						if ( type !== undefined ) {

							if ( type.toLowerCase() === 'object' ) {

								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;

							}

							if ( type.toLowerCase() === 'scene' ) {

								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
								return;

							}

						}

					}

					var object = scope.parse( json, texturePath );
					onLoad( object.geometry, object.materials );

				}, onProgress, onError );

			},

			setTexturePath: function ( value ) {

				this.texturePath = value;

			},

			parse: function ( json, texturePath ) {

				var geometry = new Geometry(),
				scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

				parseModel( scale );

				parseSkin();
				parseMorphing( scale );
				parseAnimations();

				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();

				function parseModel( scale ) {

					function isBitSet( value, position ) {

						return value & ( 1 << position );

					}

					var i, j, fi,

					offset, zLength,

				colorIndex, normalIndex, uvIndex, materialIndex,

					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,

				vertex, face, faceA, faceB, hex, normal,

					uvLayer, uv, u, v,

					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,

					nUvLayers = 0;

					if ( json.uvs !== undefined ) {

						// disregard empty arrays

						for ( i = 0; i < json.uvs.length; i ++ ) {

							if ( json.uvs[ i ].length ) nUvLayers ++;

						}

						for ( i = 0; i < nUvLayers; i ++ ) {

							geometry.faceVertexUvs[ i ] = [];

						}

					}

					offset = 0;
					zLength = vertices.length;

					while ( offset < zLength ) {

						vertex = new Vector3();

						vertex.x = vertices[ offset ++ ] * scale;
						vertex.y = vertices[ offset ++ ] * scale;
						vertex.z = vertices[ offset ++ ] * scale;

						geometry.vertices.push( vertex );

					}

					offset = 0;
					zLength = faces.length;

					while ( offset < zLength ) {

						type = faces[ offset ++ ];


						isQuad              = isBitSet( type, 0 );
						hasMaterial         = isBitSet( type, 1 );
						hasFaceVertexUv     = isBitSet( type, 3 );
						hasFaceNormal       = isBitSet( type, 4 );
						hasFaceVertexNormal = isBitSet( type, 5 );
						hasFaceColor	     = isBitSet( type, 6 );
						hasFaceVertexColor  = isBitSet( type, 7 );

						// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

						if ( isQuad ) {

							faceA = new Face3();
							faceA.a = faces[ offset ];
							faceA.b = faces[ offset + 1 ];
							faceA.c = faces[ offset + 3 ];

							faceB = new Face3();
							faceB.a = faces[ offset + 1 ];
							faceB.b = faces[ offset + 2 ];
							faceB.c = faces[ offset + 3 ];

							offset += 4;

							if ( hasMaterial ) {

								materialIndex = faces[ offset ++ ];
								faceA.materialIndex = materialIndex;
								faceB.materialIndex = materialIndex;

							}

							// to get face <=> uv index correspondence

							fi = geometry.faces.length;

							if ( hasFaceVertexUv ) {

								for ( i = 0; i < nUvLayers; i ++ ) {

									uvLayer = json.uvs[ i ];

									geometry.faceVertexUvs[ i ][ fi ] = [];
									geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

									for ( j = 0; j < 4; j ++ ) {

										uvIndex = faces[ offset ++ ];

										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];

										uv = new Vector2( u, v );

										if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
										if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

									}

								}

							}

							if ( hasFaceNormal ) {

								normalIndex = faces[ offset ++ ] * 3;

								faceA.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								faceB.normal.copy( faceA.normal );

							}

							if ( hasFaceVertexNormal ) {

								for ( i = 0; i < 4; i ++ ) {

									normalIndex = faces[ offset ++ ] * 3;

									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);


									if ( i !== 2 ) faceA.vertexNormals.push( normal );
									if ( i !== 0 ) faceB.vertexNormals.push( normal );

								}

							}


							if ( hasFaceColor ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								faceA.color.setHex( hex );
								faceB.color.setHex( hex );

							}


							if ( hasFaceVertexColor ) {

								for ( i = 0; i < 4; i ++ ) {

									colorIndex = faces[ offset ++ ];
									hex = colors[ colorIndex ];

									if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
									if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

								}

							}

							geometry.faces.push( faceA );
							geometry.faces.push( faceB );

						} else {

							face = new Face3();
							face.a = faces[ offset ++ ];
							face.b = faces[ offset ++ ];
							face.c = faces[ offset ++ ];

							if ( hasMaterial ) {

								materialIndex = faces[ offset ++ ];
								face.materialIndex = materialIndex;

							}

							// to get face <=> uv index correspondence

							fi = geometry.faces.length;

							if ( hasFaceVertexUv ) {

								for ( i = 0; i < nUvLayers; i ++ ) {

									uvLayer = json.uvs[ i ];

									geometry.faceVertexUvs[ i ][ fi ] = [];

									for ( j = 0; j < 3; j ++ ) {

										uvIndex = faces[ offset ++ ];

										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];

										uv = new Vector2( u, v );

										geometry.faceVertexUvs[ i ][ fi ].push( uv );

									}

								}

							}

							if ( hasFaceNormal ) {

								normalIndex = faces[ offset ++ ] * 3;

								face.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

							}

							if ( hasFaceVertexNormal ) {

								for ( i = 0; i < 3; i ++ ) {

									normalIndex = faces[ offset ++ ] * 3;

									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);

									face.vertexNormals.push( normal );

								}

							}


							if ( hasFaceColor ) {

								colorIndex = faces[ offset ++ ];
								face.color.setHex( colors[ colorIndex ] );

							}


							if ( hasFaceVertexColor ) {

								for ( i = 0; i < 3; i ++ ) {

									colorIndex = faces[ offset ++ ];
									face.vertexColors.push( new Color( colors[ colorIndex ] ) );

								}

							}

							geometry.faces.push( face );

						}

					}

				}

				function parseSkin() {

					var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

					if ( json.skinWeights ) {

						for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

							var x =                               json.skinWeights[ i ];
							var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
							var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
							var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

							geometry.skinWeights.push( new Vector4( x, y, z, w ) );

						}

					}

					if ( json.skinIndices ) {

						for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

							var a =                               json.skinIndices[ i ];
							var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

							geometry.skinIndices.push( new Vector4( a, b, c, d ) );

						}

					}

					geometry.bones = json.bones;

					if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

						console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
							geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

					}

				}

				function parseMorphing( scale ) {

					if ( json.morphTargets !== undefined ) {

						for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

							geometry.morphTargets[ i ] = {};
							geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
							geometry.morphTargets[ i ].vertices = [];

							var dstVertices = geometry.morphTargets[ i ].vertices;
							var srcVertices = json.morphTargets[ i ].vertices;

							for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

								var vertex = new Vector3();
								vertex.x = srcVertices[ v ] * scale;
								vertex.y = srcVertices[ v + 1 ] * scale;
								vertex.z = srcVertices[ v + 2 ] * scale;

								dstVertices.push( vertex );

							}

						}

					}

					if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

						console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

						var faces = geometry.faces;
						var morphColors = json.morphColors[ 0 ].colors;

						for ( var i = 0, l = faces.length; i < l; i ++ ) {

							faces[ i ].color.fromArray( morphColors, i * 3 );

						}

					}

				}

				function parseAnimations() {

					var outputAnimations = [];

					// parse old style Bone/Hierarchy animations
					var animations = [];

					if ( json.animation !== undefined ) {

						animations.push( json.animation );

					}

					if ( json.animations !== undefined ) {

						if ( json.animations.length ) {

							animations = animations.concat( json.animations );

						} else {

							animations.push( json.animations );

						}

					}

					for ( var i = 0; i < animations.length; i ++ ) {

						var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
						if ( clip ) outputAnimations.push( clip );

					}

					// parse implicit morph animations
					if ( geometry.morphTargets ) {

						// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
						var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
						outputAnimations = outputAnimations.concat( morphAnimationClips );

					}

					if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

				}

				if ( json.materials === undefined || json.materials.length === 0 ) {

					return { geometry: geometry };

				} else {

					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

					return { geometry: geometry, materials: materials };

				}

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ObjectLoader ( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.texturePath = '';

		}

		Object.assign( ObjectLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				if ( this.texturePath === '' ) {

					this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

				}

				var scope = this;

				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {

					scope.parse( JSON.parse( text ), onLoad );

				}, onProgress, onError );

			},

			setTexturePath: function ( value ) {

				this.texturePath = value;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;

			},

			parse: function ( json, onLoad ) {

				var geometries = this.parseGeometries( json.geometries );

				var images = this.parseImages( json.images, function () {

					if ( onLoad !== undefined ) onLoad( object );

				} );

				var textures  = this.parseTextures( json.textures, images );
				var materials = this.parseMaterials( json.materials, textures );

				var object = this.parseObject( json.object, geometries, materials );

				if ( json.animations ) {

					object.animations = this.parseAnimations( json.animations );

				}

				if ( json.images === undefined || json.images.length === 0 ) {

					if ( onLoad !== undefined ) onLoad( object );

				}

				return object;

			},

			parseGeometries: function ( json ) {

				var geometries = {};

				if ( json !== undefined ) {

					var geometryLoader = new JSONLoader();
					var bufferGeometryLoader = new BufferGeometryLoader();

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var geometry;
						var data = json[ i ];

						switch ( data.type ) {

							case 'PlaneGeometry':
							case 'PlaneBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.widthSegments,
									data.heightSegments
								);

								break;

							case 'BoxGeometry':
							case 'BoxBufferGeometry':
							case 'CubeGeometry': // backwards compatible

								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.depth,
									data.widthSegments,
									data.heightSegments,
									data.depthSegments
								);

								break;

							case 'CircleGeometry':
							case 'CircleBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.segments,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'CylinderGeometry':
							case 'CylinderBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radiusTop,
									data.radiusBottom,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'ConeGeometry':
							case 'ConeBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'SphereGeometry':
							case 'SphereBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.widthSegments,
									data.heightSegments,
									data.phiStart,
									data.phiLength,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'DodecahedronGeometry':
							case 'IcosahedronGeometry':
							case 'OctahedronGeometry':
							case 'TetrahedronGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.detail
								);

								break;

							case 'RingGeometry':
							case 'RingBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.innerRadius,
									data.outerRadius,
									data.thetaSegments,
									data.phiSegments,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'TorusGeometry':
							case 'TorusBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.radialSegments,
									data.tubularSegments,
									data.arc
								);

								break;

							case 'TorusKnotGeometry':
							case 'TorusKnotBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.tubularSegments,
									data.radialSegments,
									data.p,
									data.q
								);

								break;

							case 'LatheGeometry':
							case 'LatheBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.points,
									data.segments,
									data.phiStart,
									data.phiLength
								);

								break;

							case 'BufferGeometry':

								geometry = bufferGeometryLoader.parse( data );

								break;

							case 'Geometry':

								geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

								break;

							default:

								console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

								continue;

						}

						geometry.uuid = data.uuid;

						if ( data.name !== undefined ) geometry.name = data.name;

						geometries[ data.uuid ] = geometry;

					}

				}

				return geometries;

			},

			parseMaterials: function ( json, textures ) {

				var materials = {};

				if ( json !== undefined ) {

					var loader = new MaterialLoader();
					loader.setTextures( textures );

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var material = loader.parse( json[ i ] );
						materials[ material.uuid ] = material;

					}

				}

				return materials;

			},

			parseAnimations: function ( json ) {

				var animations = [];

				for ( var i = 0; i < json.length; i ++ ) {

					var clip = AnimationClip.parse( json[ i ] );

					animations.push( clip );

				}

				return animations;

			},

			parseImages: function ( json, onLoad ) {

				var scope = this;
				var images = {};

				function loadImage( url ) {

					scope.manager.itemStart( url );

					return loader.load( url, function () {

						scope.manager.itemEnd( url );

					}, undefined, function () {

						scope.manager.itemError( url );

					} );

				}

				if ( json !== undefined && json.length > 0 ) {

					var manager = new LoadingManager( onLoad );

					var loader = new ImageLoader( manager );
					loader.setCrossOrigin( this.crossOrigin );

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var image = json[ i ];
						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

						images[ image.uuid ] = loadImage( path );

					}

				}

				return images;

			},

			parseTextures: function ( json, images ) {

				function parseConstant( value, type ) {

					if ( typeof( value ) === 'number' ) return value;

					console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

					return type[ value ];

				}

				var textures = {};

				if ( json !== undefined ) {

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var data = json[ i ];

						if ( data.image === undefined ) {

							console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

						}

						if ( images[ data.image ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

						}

						var texture = new Texture( images[ data.image ] );
						texture.needsUpdate = true;

						texture.uuid = data.uuid;

						if ( data.name !== undefined ) texture.name = data.name;

						if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

						if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
						if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
						if ( data.wrap !== undefined ) {

							texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
							texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

						}

						if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
						if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
						if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

						if ( data.flipY !== undefined ) texture.flipY = data.flipY;

						textures[ data.uuid ] = texture;

					}

				}

				return textures;

			},

			parseObject: function () {

				var matrix = new Matrix4();

				return function parseObject( data, geometries, materials ) {

					var object;

					function getGeometry( name ) {

						if ( geometries[ name ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

						}

						return geometries[ name ];

					}

					function getMaterial( name ) {

						if ( name === undefined ) return undefined;

						if ( materials[ name ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', name );

						}

						return materials[ name ];

					}

					switch ( data.type ) {

						case 'Scene':

							object = new Scene();

							if ( data.background !== undefined ) {

								if ( Number.isInteger( data.background ) ) {

									object.background = new Color( data.background );

								}

							}

							if ( data.fog !== undefined ) {

								if ( data.fog.type === 'Fog' ) {

									object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

								} else if ( data.fog.type === 'FogExp2' ) {

									object.fog = new FogExp2( data.fog.color, data.fog.density );

								}

							}

							break;

						case 'PerspectiveCamera':

							object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

							if ( data.focus !== undefined ) object.focus = data.focus;
							if ( data.zoom !== undefined ) object.zoom = data.zoom;
							if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
							if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
							if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

							break;

						case 'OrthographicCamera':

							object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

							break;

						case 'AmbientLight':

							object = new AmbientLight( data.color, data.intensity );

							break;

						case 'DirectionalLight':

							object = new DirectionalLight( data.color, data.intensity );

							break;

						case 'PointLight':

							object = new PointLight( data.color, data.intensity, data.distance, data.decay );

							break;

						case 'SpotLight':

							object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

							break;

						case 'HemisphereLight':

							object = new HemisphereLight( data.color, data.groundColor, data.intensity );

							break;

						case 'Mesh':

							var geometry = getGeometry( data.geometry );
							var material = getMaterial( data.material );

							if ( geometry.bones && geometry.bones.length > 0 ) {

								object = new SkinnedMesh( geometry, material );

							} else {

								object = new Mesh( geometry, material );

							}

							break;

						case 'LOD':

							object = new LOD();

							break;

						case 'Line':

							object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

							break;

						case 'LineSegments':

							object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

							break;

						case 'PointCloud':
						case 'Points':

							object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

							break;

						case 'Sprite':

							object = new Sprite( getMaterial( data.material ) );

							break;

						case 'Group':

							object = new Group();

							break;

						default:

							object = new Object3D();

					}

					object.uuid = data.uuid;

					if ( data.name !== undefined ) object.name = data.name;
					if ( data.matrix !== undefined ) {

						matrix.fromArray( data.matrix );
						matrix.decompose( object.position, object.quaternion, object.scale );

					} else {

						if ( data.position !== undefined ) object.position.fromArray( data.position );
						if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
						if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
						if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

					}

					if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
					if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

					if ( data.shadow ) {

						if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
						if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
						if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
						if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

					}

					if ( data.visible !== undefined ) object.visible = data.visible;
					if ( data.userData !== undefined ) object.userData = data.userData;

					if ( data.children !== undefined ) {

						for ( var child in data.children ) {

							object.add( this.parseObject( data.children[ child ], geometries, materials ) );

						}

					}

					if ( data.type === 'LOD' ) {

						var levels = data.levels;

						for ( var l = 0; l < levels.length; l ++ ) {

							var level = levels[ l ];
							var child = object.getObjectByProperty( 'uuid', level.object );

							if ( child !== undefined ) {

								object.addLevel( child, level.distance );

							}

						}

					}

					return object;

				};

			}()

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of Curve methods
		 * .getPoint(t), getTangent(t)
		 * .getPointAt(u), getTangentAt(u)
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following classes subclasses THREE.Curve:
		 *
		 * -- 2d classes --
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.CubicBezierCurve
		 * THREE.SplineCurve
		 * THREE.ArcCurve
		 * THREE.EllipseCurve
		 *
		 * -- 3d classes --
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.SplineCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath
		 *
		 **/

		/**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/

		function Curve() {}

		Curve.prototype = {

			constructor: Curve,

			// Virtual base class method to overwrite and implement in subclasses
			//	- t [0 .. 1]

			getPoint: function ( t ) {

				console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
				return null;

			},

			// Get point at relative position in curve according to arc length
			// - u [0 .. 1]

			getPointAt: function ( u ) {

				var t = this.getUtoTmapping( u );
				return this.getPoint( t );

			},

			// Get sequence of points using getPoint( t )

			getPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 5;

				var points = [];

				for ( var d = 0; d <= divisions; d ++ ) {

					points.push( this.getPoint( d / divisions ) );

				}

				return points;

			},

			// Get sequence of points using getPointAt( u )

			getSpacedPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 5;

				var points = [];

				for ( var d = 0; d <= divisions; d ++ ) {

					points.push( this.getPointAt( d / divisions ) );

				}

				return points;

			},

			// Get total curve arc length

			getLength: function () {

				var lengths = this.getLengths();
				return lengths[ lengths.length - 1 ];

			},

			// Get list of cumulative segment lengths

			getLengths: function ( divisions ) {

				if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

				if ( this.cacheArcLengths
					&& ( this.cacheArcLengths.length === divisions + 1 )
					&& ! this.needsUpdate ) {

					//console.log( "cached", this.cacheArcLengths );
					return this.cacheArcLengths;

				}

				this.needsUpdate = false;

				var cache = [];
				var current, last = this.getPoint( 0 );
				var p, sum = 0;

				cache.push( 0 );

				for ( p = 1; p <= divisions; p ++ ) {

					current = this.getPoint ( p / divisions );
					sum += current.distanceTo( last );
					cache.push( sum );
					last = current;

				}

				this.cacheArcLengths = cache;

				return cache; // { sums: cache, sum:sum }; Sum is in the last element.

			},

			updateArcLengths: function() {

				this.needsUpdate = true;
				this.getLengths();

			},

			// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

			getUtoTmapping: function ( u, distance ) {

				var arcLengths = this.getLengths();

				var i = 0, il = arcLengths.length;

				var targetArcLength; // The targeted u distance value to get

				if ( distance ) {

					targetArcLength = distance;

				} else {

					targetArcLength = u * arcLengths[ il - 1 ];

				}

				//var time = Date.now();

				// binary search for the index with largest value smaller than target u distance

				var low = 0, high = il - 1, comparison;

				while ( low <= high ) {

					i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

					comparison = arcLengths[ i ] - targetArcLength;

					if ( comparison < 0 ) {

						low = i + 1;

					} else if ( comparison > 0 ) {

						high = i - 1;

					} else {

						high = i;
						break;

						// DONE

					}

				}

				i = high;

				//console.log('b' , i, low, high, Date.now()- time);

				if ( arcLengths[ i ] === targetArcLength ) {

					var t = i / ( il - 1 );
					return t;

				}

				// we could get finer grain at lengths, or use simple interpolation between two points

				var lengthBefore = arcLengths[ i ];
				var lengthAfter = arcLengths[ i + 1 ];

				var segmentLength = lengthAfter - lengthBefore;

				// determine where we are between the 'before' and 'after' points

				var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

				// add that fractional amount to t

				var t = ( i + segmentFraction ) / ( il - 1 );

				return t;

			},

			// Returns a unit vector tangent at t
			// In case any sub curve does not implement its tangent derivation,
			// 2 points a small delta apart will be used to find its gradient
			// which seems to give a reasonable approximation

			getTangent: function( t ) {

				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;

				// Capping in case of danger

				if ( t1 < 0 ) t1 = 0;
				if ( t2 > 1 ) t2 = 1;

				var pt1 = this.getPoint( t1 );
				var pt2 = this.getPoint( t2 );

				var vec = pt2.clone().sub( pt1 );
				return vec.normalize();

			},

			getTangentAt: function ( u ) {

				var t = this.getUtoTmapping( u );
				return this.getTangent( t );

			},

			computeFrenetFrames: function ( segments, closed ) {

				// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

				var normal = new Vector3();

				var tangents = [];
				var normals = [];
				var binormals = [];

				var vec = new Vector3();
				var mat = new Matrix4();

				var i, u, theta;

				// compute the tangent vectors for each segment on the curve

				for ( i = 0; i <= segments; i ++ ) {

					u = i / segments;

					tangents[ i ] = this.getTangentAt( u );
					tangents[ i ].normalize();

				}

				// select an initial normal vector perpendicular to the first tangent vector,
				// and in the direction of the minimum tangent xyz component

				normals[ 0 ] = new Vector3();
				binormals[ 0 ] = new Vector3();
				var min = Number.MAX_VALUE;
				var tx = Math.abs( tangents[ 0 ].x );
				var ty = Math.abs( tangents[ 0 ].y );
				var tz = Math.abs( tangents[ 0 ].z );

				if ( tx <= min ) {

					min = tx;
					normal.set( 1, 0, 0 );

				}

				if ( ty <= min ) {

					min = ty;
					normal.set( 0, 1, 0 );

				}

				if ( tz <= min ) {

					normal.set( 0, 0, 1 );

				}

				vec.crossVectors( tangents[ 0 ], normal ).normalize();

				normals[ 0 ].crossVectors( tangents[ 0 ], vec );
				binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


				// compute the slowly-varying normal and binormal vectors for each segment on the curve

				for ( i = 1; i <= segments; i ++ ) {

					normals[ i ] = normals[ i - 1 ].clone();

					binormals[ i ] = binormals[ i - 1 ].clone();

					vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

					if ( vec.length() > Number.EPSILON ) {

						vec.normalize();

						theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

						normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

					}

					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

				// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

				if ( closed === true ) {

					theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
					theta /= segments;

					if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

						theta = - theta;

					}

					for ( i = 1; i <= segments; i ++ ) {

						// twist a little...
						normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
						binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

					}

				}

				return {
					tangents: tangents,
					normals: normals,
					binormals: binormals
				};

			}

		};

		// TODO: Transformation for Curves?

		/**************************************************************
		 *	3D Curves
		 **************************************************************/

		// A Factory method for creating new curve subclasses

		Curve.create = function ( constructor, getPointFunc ) {

			constructor.prototype = Object.create( Curve.prototype );
			constructor.prototype.constructor = constructor;
			constructor.prototype.getPoint = getPointFunc;

			return constructor;

		};

		/**************************************************************
		 *	Line
		 **************************************************************/

		function LineCurve( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		}

		LineCurve.prototype = Object.create( Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;

		LineCurve.prototype.isLineCurve = true;

		LineCurve.prototype.getPoint = function ( t ) {

			if ( t === 1 ) {

				return this.v2.clone();

			}

			var point = this.v2.clone().sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

			return point;

		};

		// Line curve is linear, so we can overwrite default getPointAt

		LineCurve.prototype.getPointAt = function ( u ) {

			return this.getPoint( u );

		};

		LineCurve.prototype.getTangent = function( t ) {

			var tangent = this.v2.clone().sub( this.v1 );

			return tangent.normalize();

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **/

		/**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/

		function CurvePath() {

			this.curves = [];

			this.autoClose = false; // Automatically closes the path

		}

		CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

			constructor: CurvePath,

			add: function ( curve ) {

				this.curves.push( curve );

			},

			closePath: function () {

				// Add a line curve if start and end of lines are not connected
				var startPoint = this.curves[ 0 ].getPoint( 0 );
				var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

				if ( ! startPoint.equals( endPoint ) ) {

					this.curves.push( new LineCurve( endPoint, startPoint ) );

				}

			},

			// To get accurate point with reference to
			// entire path distance at time t,
			// following has to be done:

			// 1. Length of each sub path have to be known
			// 2. Locate and identify type of curve
			// 3. Get t for the curve
			// 4. Return curve.getPointAt(t')

			getPoint: function ( t ) {

				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;

				// To think about boundaries points.

				while ( i < curveLengths.length ) {

					if ( curveLengths[ i ] >= d ) {

						var diff = curveLengths[ i ] - d;
						var curve = this.curves[ i ];

						var segmentLength = curve.getLength();
						var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

						return curve.getPointAt( u );

					}

					i ++;

				}

				return null;

				// loop where sum != 0, sum > d , sum+1 <d

			},

			// We cannot use the default THREE.Curve getPoint() with getLength() because in
			// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
			// getPoint() depends on getLength

			getLength: function () {

				var lens = this.getCurveLengths();
				return lens[ lens.length - 1 ];

			},

			// cacheLengths must be recalculated.
			updateArcLengths: function () {

				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getLengths();

			},

			// Compute lengths and cache them
			// We cannot overwrite getLengths() because UtoT mapping uses it.

			getCurveLengths: function () {

				// We use cache values if curves and cache array are same length

				if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

					return this.cacheLengths;

				}

				// Get length of sub-curve
				// Push sums into cached array

				var lengths = [], sums = 0;

				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

					sums += this.curves[ i ].getLength();
					lengths.push( sums );

				}

				this.cacheLengths = lengths;

				return lengths;

			},

			getSpacedPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 40;

				var points = [];

				for ( var i = 0; i <= divisions; i ++ ) {

					points.push( this.getPoint( i / divisions ) );

				}

				if ( this.autoClose ) {

					points.push( points[ 0 ] );

				}

				return points;

			},

			getPoints: function ( divisions ) {

				divisions = divisions || 12;

				var points = [], last;

				for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

					var curve = curves[ i ];
					var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
						: (curve && curve.isLineCurve) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
						: divisions;

					var pts = curve.getPoints( resolution );

					for ( var j = 0; j < pts.length; j++ ) {

						var point = pts[ j ];

						if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

						points.push( point );
						last = point;

					}

				}

				if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

					points.push( points[ 0 ] );

				}

				return points;

			},

			/**************************************************************
			 *	Create Geometries Helpers
			 **************************************************************/

			/// Generate geometry from path points (for Line or Points objects)

			createPointsGeometry: function ( divisions ) {

				var pts = this.getPoints( divisions );
				return this.createGeometry( pts );

			},

			// Generate geometry from equidistant sampling along the path

			createSpacedPointsGeometry: function ( divisions ) {

				var pts = this.getSpacedPoints( divisions );
				return this.createGeometry( pts );

			},

			createGeometry: function ( points ) {

				var geometry = new Geometry();

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					var point = points[ i ];
					geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

				}

				return geometry;

			}

		} );

		/**************************************************************
		 *	Ellipse curve
		 **************************************************************/

		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			this.aX = aX;
			this.aY = aY;

			this.xRadius = xRadius;
			this.yRadius = yRadius;

			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;

			this.aClockwise = aClockwise;

			this.aRotation = aRotation || 0;

		}

		EllipseCurve.prototype = Object.create( Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;

		EllipseCurve.prototype.isEllipseCurve = true;

		EllipseCurve.prototype.getPoint = function( t ) {

			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

			if ( deltaAngle < Number.EPSILON ) {

				if ( samePoints ) {

					deltaAngle = 0;

				} else {

					deltaAngle = twoPi;

				}

			}

			if ( this.aClockwise === true && ! samePoints ) {

				if ( deltaAngle === twoPi ) {

					deltaAngle = - twoPi;

				} else {

					deltaAngle = deltaAngle - twoPi;

				}

			}

			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );

			if ( this.aRotation !== 0 ) {

				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );

				var tx = x - this.aX;
				var ty = y - this.aY;

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;

			}

			return new Vector2( x, y );

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		var CurveUtils = {

			tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

				return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

			},

			// Puay Bing, thanks for helping with this derivative!

			tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

				return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
					3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
					6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
					3 * t * t * p3;

			},

			tangentSpline: function ( t, p0, p1, p2, p3 ) {

				// To check if my formulas are correct

				var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
				var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
				var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
				var h11 = 3 * t * t - 2 * t;	// t3 − t2

				return h00 + h10 + h01 + h11;

			},

			// Catmull-Rom

			interpolate: function( p0, p1, p2, p3, t ) {

				var v0 = ( p2 - p0 ) * 0.5;
				var v1 = ( p3 - p1 ) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;
				return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			}

		};

		/**************************************************************
		 *	Spline curve
		 **************************************************************/

		function SplineCurve( points /* array of Vector2 */ ) {

			this.points = ( points === undefined ) ? [] : points;

		}

		SplineCurve.prototype = Object.create( Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;

		SplineCurve.prototype.isSplineCurve = true;

		SplineCurve.prototype.getPoint = function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			var interpolate = CurveUtils.interpolate;

			return new Vector2(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight )
			);

		};

		/**************************************************************
		 *	Cubic Bezier curve
		 **************************************************************/

		function CubicBezierCurve( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		CubicBezierCurve.prototype = Object.create( Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;

		CubicBezierCurve.prototype.getPoint = function ( t ) {

			var b3 = ShapeUtils.b3;

			return new Vector2(
				b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
			);

		};

		CubicBezierCurve.prototype.getTangent = function( t ) {

			var tangentCubicBezier = CurveUtils.tangentCubicBezier;

			return new Vector2(
				tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
			).normalize();

		};

		/**************************************************************
		 *	Quadratic Bezier curve
		 **************************************************************/


		function QuadraticBezierCurve( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;


		QuadraticBezierCurve.prototype.getPoint = function ( t ) {

			var b2 = ShapeUtils.b2;

			return new Vector2(
				b2( t, this.v0.x, this.v1.x, this.v2.x ),
				b2( t, this.v0.y, this.v1.y, this.v2.y )
			);

		};


		QuadraticBezierCurve.prototype.getTangent = function( t ) {

			var tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;

			return new Vector2(
				tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
				tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
			).normalize();

		};

		var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

			fromPoints: function ( vectors ) {

				this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

				for ( var i = 1, l = vectors.length; i < l; i ++ ) {

					this.lineTo( vectors[ i ].x, vectors[ i ].y );

				}

			},

			moveTo: function ( x, y ) {

				this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

			},

			lineTo: function ( x, y ) {

				var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
				this.curves.push( curve );

				this.currentPoint.set( x, y );

			},

			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

				var curve = new QuadraticBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCPx, aCPy ),
					new Vector2( aX, aY )
				);

				this.curves.push( curve );

				this.currentPoint.set( aX, aY );

			},

			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

				var curve = new CubicBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCP1x, aCP1y ),
					new Vector2( aCP2x, aCP2y ),
					new Vector2( aX, aY )
				);

				this.curves.push( curve );

				this.currentPoint.set( aX, aY );

			},

			splineThru: function ( pts /*Array of Vector*/ ) {

				var npts = [ this.currentPoint.clone() ].concat( pts );

				var curve = new SplineCurve( npts );
				this.curves.push( curve );

				this.currentPoint.copy( pts[ pts.length - 1 ] );

			},

			arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;

				this.absarc( aX + x0, aY + y0, aRadius,
					aStartAngle, aEndAngle, aClockwise );

			},

			absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

				this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			},

			ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;

				this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			},

			absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

				var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

				if ( this.curves.length > 0 ) {

					// if a previous curve is present, attempt to join
					var firstPoint = curve.getPoint( 0 );

					if ( ! firstPoint.equals( this.currentPoint ) ) {

						this.lineTo( firstPoint.x, firstPoint.y );

					}

				}

				this.curves.push( curve );

				var lastPoint = curve.getPoint( 1 );
				this.currentPoint.copy( lastPoint );

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/

		// STEP 1 Create a path.
		// STEP 2 Turn path into shape.
		// STEP 3 ExtrudeGeometry takes in Shape/Shapes
		// STEP 3a - Extract points from each shape, turn to vertices
		// STEP 3b - Triangulate each shape, add faces.

		function Shape() {

			Path.apply( this, arguments );

			this.holes = [];

		}

		Shape.prototype = Object.assign( Object.create( PathPrototype ), {

			constructor: Shape,

			getPointsHoles: function ( divisions ) {

				var holesPts = [];

				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

					holesPts[ i ] = this.holes[ i ].getPoints( divisions );

				}

				return holesPts;

			},

			// Get points of shape and holes (keypoints based on segments parameter)

			extractAllPoints: function ( divisions ) {

				return {

					shape: this.getPoints( divisions ),
					holes: this.getPointsHoles( divisions )

				};

			},

			extractPoints: function ( divisions ) {

				return this.extractAllPoints( divisions );

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 *
		 **/

		function Path( points ) {

			CurvePath.call( this );
			this.currentPoint = new Vector2();

			if ( points ) {

				this.fromPoints( points );

			}

		}

		Path.prototype = PathPrototype;
		PathPrototype.constructor = Path;


		// minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		function ShapePath() {
			this.subPaths = [];
			this.currentPath = null;
		}

		ShapePath.prototype = {
			moveTo: function ( x, y ) {
				this.currentPath = new Path();
				this.subPaths.push(this.currentPath);
				this.currentPath.moveTo( x, y );
			},
			lineTo: function ( x, y ) {
				this.currentPath.lineTo( x, y );
			},
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
				this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
			},
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
				this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
			},
			splineThru: function ( pts ) {
				this.currentPath.splineThru( pts );
			},

			toShapes: function ( isCCW, noHoles ) {

				function toShapesNoHoles( inSubpaths ) {

					var shapes = [];

					for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

						var tmpPath = inSubpaths[ i ];

						var tmpShape = new Shape();
						tmpShape.curves = tmpPath.curves;

						shapes.push( tmpShape );

					}

					return shapes;

				}

				function isPointInsidePolygon( inPt, inPolygon ) {

					var polyLen = inPolygon.length;

					// inPt on polygon contour => immediate success    or
					// toggling of inside/outside at every single! intersection point of an edge
					//  with the horizontal line through inPt, left of inPt
					//  not counting lowerY endpoints of edges and whole edges on that line
					var inside = false;
					for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

						var edgeLowPt  = inPolygon[ p ];
						var edgeHighPt = inPolygon[ q ];

						var edgeDx = edgeHighPt.x - edgeLowPt.x;
						var edgeDy = edgeHighPt.y - edgeLowPt.y;

						if ( Math.abs( edgeDy ) > Number.EPSILON ) {

							// not parallel
							if ( edgeDy < 0 ) {

								edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
								edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

							}
							if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

							if ( inPt.y === edgeLowPt.y ) {

								if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
								// continue;				// no intersection or edgeLowPt => doesn't count !!!

							} else {

								var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
								if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
								if ( perpEdge < 0 ) 				continue;
								inside = ! inside;		// true intersection left of inPt

							}

						} else {

							// parallel or collinear
							if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
							// edge lies on the same horizontal line as inPt
							if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
								 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
							// continue;

						}

					}

					return	inside;

				}

				var isClockWise = ShapeUtils.isClockWise;

				var subPaths = this.subPaths;
				if ( subPaths.length === 0 ) return [];

				if ( noHoles === true )	return	toShapesNoHoles( subPaths );


				var solid, tmpPath, tmpShape, shapes = [];

				if ( subPaths.length === 1 ) {

					tmpPath = subPaths[ 0 ];
					tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push( tmpShape );
					return shapes;

				}

				var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
				holesFirst = isCCW ? ! holesFirst : holesFirst;

				// console.log("Holes first", holesFirst);

				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;

				newShapes[ mainIdx ] = undefined;
				newShapeHoles[ mainIdx ] = [];

				for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

					tmpPath = subPaths[ i ];
					tmpPoints = tmpPath.getPoints();
					solid = isClockWise( tmpPoints );
					solid = isCCW ? ! solid : solid;

					if ( solid ) {

						if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

						newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
						newShapes[ mainIdx ].s.curves = tmpPath.curves;

						if ( holesFirst )	mainIdx ++;
						newShapeHoles[ mainIdx ] = [];

						//console.log('cw', i);

					} else {

						newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

						//console.log('ccw', i);

					}

				}

				// only Holes? -> probably all Shapes with wrong orientation
				if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


				if ( newShapes.length > 1 ) {

					var ambiguous = false;
					var toChange = [];

					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

						betterShapeHoles[ sIdx ] = [];

					}

					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

						var sho = newShapeHoles[ sIdx ];

						for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

							var ho = sho[ hIdx ];
							var hole_unassigned = true;

							for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

								if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

									if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
									if ( hole_unassigned ) {

										hole_unassigned = false;
										betterShapeHoles[ s2Idx ].push( ho );

									} else {

										ambiguous = true;

									}

								}

							}
							if ( hole_unassigned ) {

								betterShapeHoles[ sIdx ].push( ho );

							}

						}

					}
					// console.log("ambiguous: ", ambiguous);
					if ( toChange.length > 0 ) {

						// console.log("to change: ", toChange);
						if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

					}

				}

				var tmpHoles;

				for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

					tmpShape = newShapes[ i ].s;
					shapes.push( tmpShape );
					tmpHoles = newShapeHoles[ i ];

					for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

						tmpShape.holes.push( tmpHoles[ j ].h );

					}

				}

				//console.log("shape", shapes);

				return shapes;

			}
		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Font( data ) {

			this.data = data;

		}

		Object.assign( Font.prototype, {

			isFont: true,

			generateShapes: function ( text, size, divisions ) {

				function createPaths( text ) {

					var chars = String( text ).split( '' );
					var scale = size / data.resolution;
					var offset = 0;

					var paths = [];

					for ( var i = 0; i < chars.length; i ++ ) {

						var ret = createPath( chars[ i ], scale, offset );
						offset += ret.offset;

						paths.push( ret.path );

					}

					return paths;

				}

				function createPath( c, scale, offset ) {

					var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

					if ( ! glyph ) return;

					var path = new ShapePath();

					var pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;
					var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

					if ( glyph.o ) {

						var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

						for ( var i = 0, l = outline.length; i < l; ) {

							var action = outline[ i ++ ];

							switch ( action ) {

								case 'm': // moveTo

									x = outline[ i ++ ] * scale + offset;
									y = outline[ i ++ ] * scale;

									path.moveTo( x, y );

									break;

								case 'l': // lineTo

									x = outline[ i ++ ] * scale + offset;
									y = outline[ i ++ ] * scale;

									path.lineTo( x, y );

									break;

								case 'q': // quadraticCurveTo

									cpx  = outline[ i ++ ] * scale + offset;
									cpy  = outline[ i ++ ] * scale;
									cpx1 = outline[ i ++ ] * scale + offset;
									cpy1 = outline[ i ++ ] * scale;

									path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

									laste = pts[ pts.length - 1 ];

									if ( laste ) {

										cpx0 = laste.x;
										cpy0 = laste.y;

										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

											var t = i2 / divisions;
											b2( t, cpx0, cpx1, cpx );
											b2( t, cpy0, cpy1, cpy );

										}

									}

									break;

								case 'b': // bezierCurveTo

									cpx  = outline[ i ++ ] * scale + offset;
									cpy  = outline[ i ++ ] * scale;
									cpx1 = outline[ i ++ ] * scale + offset;
									cpy1 = outline[ i ++ ] * scale;
									cpx2 = outline[ i ++ ] * scale + offset;
									cpy2 = outline[ i ++ ] * scale;

									path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

									laste = pts[ pts.length - 1 ];

									if ( laste ) {

										cpx0 = laste.x;
										cpy0 = laste.y;

										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

											var t = i2 / divisions;
											b3( t, cpx0, cpx1, cpx2, cpx );
											b3( t, cpy0, cpy1, cpy2, cpy );

										}

									}

									break;

							}

						}

					}

					return { offset: glyph.ha * scale, path: path };

				}

				//

				if ( size === undefined ) size = 100;
				if ( divisions === undefined ) divisions = 4;

				var data = this.data;

				var paths = createPaths( text );
				var shapes = [];

				for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

					Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

				}

				return shapes;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function FontLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( FontLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new XHRLoader( this.manager );
				loader.load( url, function ( text ) {

					var json;

					try {

						json = JSON.parse( text );

					} catch ( e ) {

						console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
						json = JSON.parse( text.substring( 65, text.length - 2 ) );

					}

					var font = scope.parse( json );

					if ( onLoad ) onLoad( font );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				return new Font( json );

			}

		} );

		var context;

		function getAudioContext() {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		}

		/**
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */

		function AudioLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( AudioLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var loader = new XHRLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.load( url, function ( buffer ) {

					var context = getAudioContext();

					context.decodeAudioData( buffer, function ( audioBuffer ) {

						onLoad( audioBuffer );

					} );

				}, onProgress, onError );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function StereoCamera() {

			this.type = 'StereoCamera';

			this.aspect = 1;

			this.eyeSep = 0.064;

			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;

			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;

		}

		Object.assign( StereoCamera.prototype, {

			update: ( function () {

				var instance, focus, fov, aspect, near, far, zoom;

				var eyeRight = new Matrix4();
				var eyeLeft = new Matrix4();

				return function update( camera ) {

					var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
														aspect !== camera.aspect * this.aspect || near !== camera.near ||
														far !== camera.far || zoom !== camera.zoom;

					if ( needsUpdate ) {

						instance = this;
						focus = camera.focus;
						fov = camera.fov;
						aspect = camera.aspect * this.aspect;
						near = camera.near;
						far = camera.far;
						zoom = camera.zoom;

						// Off-axis stereoscopic effect based on
						// http://paulbourke.net/stereographics/stereorender/

						var projectionMatrix = camera.projectionMatrix.clone();
						var eyeSep = this.eyeSep / 2;
						var eyeSepOnProjection = eyeSep * near / focus;
						var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
						var xmin, xmax;

						// translate xOffset

						eyeLeft.elements[ 12 ] = - eyeSep;
						eyeRight.elements[ 12 ] = eyeSep;

						// for left eye

						xmin = - ymax * aspect + eyeSepOnProjection;
						xmax = ymax * aspect + eyeSepOnProjection;

						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

						this.cameraL.projectionMatrix.copy( projectionMatrix );

						// for right eye

						xmin = - ymax * aspect - eyeSepOnProjection;
						xmax = ymax * aspect - eyeSepOnProjection;

						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

						this.cameraR.projectionMatrix.copy( projectionMatrix );

					}

					this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
					this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

				};

			} )()

		} );

		/**
		 * Camera for rendering cube maps
		 *	- renders scene into axis-aligned cube
		 *
		 * @author alteredq / http://alteredqualia.com/
		 */

		function CubeCamera( near, far, cubeResolution ) {

			Object3D.call( this );

			this.type = 'CubeCamera';

			var fov = 90, aspect = 1;

			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );

			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );

			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );

			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );

			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );

			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );

			var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

			this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

			this.updateCubeMap = function ( renderer, scene ) {

				if ( this.parent === null ) this.updateMatrixWorld();

				var renderTarget = this.renderTarget;
				var generateMipmaps = renderTarget.texture.generateMipmaps;

				renderTarget.texture.generateMipmaps = false;

				renderTarget.activeCubeFace = 0;
				renderer.render( scene, cameraPX, renderTarget );

				renderTarget.activeCubeFace = 1;
				renderer.render( scene, cameraNX, renderTarget );

				renderTarget.activeCubeFace = 2;
				renderer.render( scene, cameraPY, renderTarget );

				renderTarget.activeCubeFace = 3;
				renderer.render( scene, cameraNY, renderTarget );

				renderTarget.activeCubeFace = 4;
				renderer.render( scene, cameraPZ, renderTarget );

				renderTarget.texture.generateMipmaps = generateMipmaps;

				renderTarget.activeCubeFace = 5;
				renderer.render( scene, cameraNZ, renderTarget );

				renderer.setRenderTarget( null );

			};

		}

		CubeCamera.prototype = Object.create( Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AudioListener() {

			Object3D.call( this );

			this.type = 'AudioListener';

			this.context = getAudioContext();

			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );

			this.filter = null;

		}

		AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: AudioListener,

			getInput: function () {

				return this.gain;

			},

			removeFilter: function ( ) {

				if ( this.filter !== null ) {

					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
					this.gain.connect( this.context.destination );
					this.filter = null;

				}

			},

			getFilter: function () {

				return this.filter;

			},

			setFilter: function ( value ) {

				if ( this.filter !== null ) {

					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );

				} else {

					this.gain.disconnect( this.context.destination );

				}

				this.filter = value;
				this.gain.connect( this.filter );
				this.filter.connect( this.context.destination );

			},

			getMasterVolume: function () {

				return this.gain.gain.value;

			},

			setMasterVolume: function ( value ) {

				this.gain.gain.value = value;

			},

			updateMatrixWorld: ( function () {

				var position = new Vector3();
				var quaternion = new Quaternion();
				var scale = new Vector3();

				var orientation = new Vector3();

				return function updateMatrixWorld( force ) {

					Object3D.prototype.updateMatrixWorld.call( this, force );

					var listener = this.context.listener;
					var up = this.up;

					this.matrixWorld.decompose( position, quaternion, scale );

					orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

				};

			} )()

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */

		function Audio( listener ) {

			Object3D.call( this );

			this.type = 'Audio';

			this.context = listener.context;
			this.source = this.context.createBufferSource();
			this.source.onended = this.onEnded.bind( this );

			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );

			this.autoplay = false;

			this.startTime = 0;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.sourceType = 'empty';

			this.filters = [];

		}

		Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Audio,

			getOutput: function () {

				return this.gain;

			},

			setNodeSource: function ( audioNode ) {

				this.hasPlaybackControl = false;
				this.sourceType = 'audioNode';
				this.source = audioNode;
				this.connect();

				return this;

			},

			setBuffer: function ( audioBuffer ) {

				this.source.buffer = audioBuffer;
				this.sourceType = 'buffer';

				if ( this.autoplay ) this.play();

				return this;

			},

			play: function () {

				if ( this.isPlaying === true ) {

					console.warn( 'THREE.Audio: Audio is already playing.' );
					return;

				}

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				var source = this.context.createBufferSource();

				source.buffer = this.source.buffer;
				source.loop = this.source.loop;
				source.onended = this.source.onended;
				source.start( 0, this.startTime );
				source.playbackRate.value = this.playbackRate;

				this.isPlaying = true;

				this.source = source;

				return this.connect();

			},

			pause: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.source.stop();
				this.startTime = this.context.currentTime;
				this.isPlaying = false;

				return this;

			},

			stop: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.source.stop();
				this.startTime = 0;
				this.isPlaying = false;

				return this;

			},

			connect: function () {

				if ( this.filters.length > 0 ) {

					this.source.connect( this.filters[ 0 ] );

					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

						this.filters[ i - 1 ].connect( this.filters[ i ] );

					}

					this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

				} else {

					this.source.connect( this.getOutput() );

				}

				return this;

			},

			disconnect: function () {

				if ( this.filters.length > 0 ) {

					this.source.disconnect( this.filters[ 0 ] );

					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

						this.filters[ i - 1 ].disconnect( this.filters[ i ] );

					}

					this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

				} else {

					this.source.disconnect( this.getOutput() );

				}

				return this;

			},

			getFilters: function () {

				return this.filters;

			},

			setFilters: function ( value ) {

				if ( ! value ) value = [];

				if ( this.isPlaying === true ) {

					this.disconnect();
					this.filters = value;
					this.connect();

				} else {

					this.filters = value;

				}

				return this;

			},

			getFilter: function () {

				return this.getFilters()[ 0 ];

			},

			setFilter: function ( filter ) {

				return this.setFilters( filter ? [ filter ] : [] );

			},

			setPlaybackRate: function ( value ) {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.playbackRate = value;

				if ( this.isPlaying === true ) {

					this.source.playbackRate.value = this.playbackRate;

				}

				return this;

			},

			getPlaybackRate: function () {

				return this.playbackRate;

			},

			onEnded: function () {

				this.isPlaying = false;

			},

			getLoop: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return false;

				}

				return this.source.loop;

			},

			setLoop: function ( value ) {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.source.loop = value;

			},

			getVolume: function () {

				return this.gain.gain.value;

			},


			setVolume: function ( value ) {

				this.gain.gain.value = value;

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function PositionalAudio( listener ) {

			Audio.call( this, listener );

			this.panner = this.context.createPanner();
			this.panner.connect( this.gain );

		}

		PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

			constructor: PositionalAudio,

			getOutput: function () {

				return this.panner;

			},

			getRefDistance: function () {

				return this.panner.refDistance;

			},

			setRefDistance: function ( value ) {

				this.panner.refDistance = value;

			},

			getRolloffFactor: function () {

				return this.panner.rolloffFactor;

			},

			setRolloffFactor: function ( value ) {

				this.panner.rolloffFactor = value;

			},

			getDistanceModel: function () {

				return this.panner.distanceModel;

			},

			setDistanceModel: function ( value ) {

				this.panner.distanceModel = value;

			},

			getMaxDistance: function () {

				return this.panner.maxDistance;

			},

			setMaxDistance: function ( value ) {

				this.panner.maxDistance = value;

			},

			updateMatrixWorld: ( function () {

				var position = new Vector3();

				return function updateMatrixWorld( force ) {

					Object3D.prototype.updateMatrixWorld.call( this, force );

					position.setFromMatrixPosition( this.matrixWorld );

					this.panner.setPosition( position.x, position.y, position.z );

				};

			} )()


		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AudioAnalyser( audio, fftSize ) {

			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

			this.data = new Uint8Array( this.analyser.frequencyBinCount );

			audio.getOutput().connect( this.analyser );

		}

		Object.assign( AudioAnalyser.prototype, {

			getFrequencyData: function () {

				this.analyser.getByteFrequencyData( this.data );

				return this.data;

			},

			getAverageFrequency: function () {

				var value = 0, data = this.getFrequencyData();

				for ( var i = 0; i < data.length; i ++ ) {

					value += data[ i ];

				}

				return value / data.length;

			}

		} );

		/**
		 *
		 * Buffered scene graph property that allows weighted accumulation.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function PropertyMixer( binding, typeName, valueSize ) {

			this.binding = binding;
			this.valueSize = valueSize;

			var bufferType = Float64Array,
				mixFunction;

			switch ( typeName ) {

				case 'quaternion':			mixFunction = this._slerp;		break;

				case 'string':
				case 'bool':

					bufferType = Array,		mixFunction = this._select;		break;

				default:					mixFunction = this._lerp;

			}

			this.buffer = new bufferType( valueSize * 4 );
			// layout: [ incoming | accu0 | accu1 | orig ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property

			this._mixBufferRegion = mixFunction;

			this.cumulativeWeight = 0;

			this.useCount = 0;
			this.referenceCount = 0;

		}

		PropertyMixer.prototype = {

			constructor: PropertyMixer,

			// accumulate data in the 'incoming' region into 'accu<i>'
			accumulate: function( accuIndex, weight ) {

				// note: happily accumulating nothing when weight = 0, the caller knows
				// the weight and shouldn't have made the call in the first place

				var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride,

					currentWeight = this.cumulativeWeight;

				if ( currentWeight === 0 ) {

					// accuN := incoming * weight

					for ( var i = 0; i !== stride; ++ i ) {

						buffer[ offset + i ] = buffer[ i ];

					}

					currentWeight = weight;

				} else {

					// accuN := accuN + incoming * weight

					currentWeight += weight;
					var mix = weight / currentWeight;
					this._mixBufferRegion( buffer, offset, 0, mix, stride );

				}

				this.cumulativeWeight = currentWeight;

			},

			// apply the state of 'accu<i>' to the binding when accus differ
			apply: function( accuIndex ) {

				var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,

					weight = this.cumulativeWeight,

					binding = this.binding;

				this.cumulativeWeight = 0;

				if ( weight < 1 ) {

					// accuN := accuN + original * ( 1 - cumulativeWeight )

					var originalValueOffset = stride * 3;

					this._mixBufferRegion(
							buffer, offset, originalValueOffset, 1 - weight, stride );

				}

				for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

					if ( buffer[ i ] !== buffer[ i + stride ] ) {

						// value has changed -> update scene graph

						binding.setValue( buffer, offset );
						break;

					}

				}

			},

			// remember the state of the bound property and copy it to both accus
			saveOriginalState: function() {

				var binding = this.binding;

				var buffer = this.buffer,
					stride = this.valueSize,

					originalValueOffset = stride * 3;

				binding.getValue( buffer, originalValueOffset );

				// accu[0..1] := orig -- initially detect changes against the original
				for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

					buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

				}

				this.cumulativeWeight = 0;

			},

			// apply the state previously taken via 'saveOriginalState' to the binding
			restoreOriginalState: function() {

				var originalValueOffset = this.valueSize * 3;
				this.binding.setValue( this.buffer, originalValueOffset );

			},


			// mix functions

			_select: function( buffer, dstOffset, srcOffset, t, stride ) {

				if ( t >= 0.5 ) {

					for ( var i = 0; i !== stride; ++ i ) {

						buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

					}

				}

			},

			_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

				Quaternion.slerpFlat( buffer, dstOffset,
						buffer, dstOffset, buffer, srcOffset, t );

			},

			_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

				var s = 1 - t;

				for ( var i = 0; i !== stride; ++ i ) {

					var j = dstOffset + i;

					buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

				}

			}

		};

		/**
		 *
		 * A reference to a real property in the scene graph.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function PropertyBinding( rootNode, path, parsedPath ) {

			this.path = path;
			this.parsedPath = parsedPath ||
					PropertyBinding.parseTrackName( path );

			this.node = PropertyBinding.findNode(
					rootNode, this.parsedPath.nodeName ) || rootNode;

			this.rootNode = rootNode;

		}

		PropertyBinding.prototype = {

			constructor: PropertyBinding,

			getValue: function getValue_unbound( targetArray, offset ) {

				this.bind();
				this.getValue( targetArray, offset );

				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.

			},

			setValue: function getValue_unbound( sourceArray, offset ) {

				this.bind();
				this.setValue( sourceArray, offset );

			},

			// create getter / setter pair for a property in the scene graph
			bind: function() {

				var targetObject = this.node,
					parsedPath = this.parsedPath,

					objectName = parsedPath.objectName,
					propertyName = parsedPath.propertyName,
					propertyIndex = parsedPath.propertyIndex;

				if ( ! targetObject ) {

					targetObject = PropertyBinding.findNode(
							this.rootNode, parsedPath.nodeName ) || this.rootNode;

					this.node = targetObject;

				}

				// set fail state so we can just 'return' on error
				this.getValue = this._getValue_unavailable;
				this.setValue = this._setValue_unavailable;

		 		// ensure there is a value node
				if ( ! targetObject ) {

					console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
					return;

				}

				if ( objectName ) {

					var objectIndex = parsedPath.objectIndex;

					// special cases were we need to reach deeper into the hierarchy to get the face materials....
					switch ( objectName ) {

						case 'materials':

							if ( ! targetObject.material ) {

								console.error( '  can not bind to material as node does not have a material', this );
								return;

							}

							if ( ! targetObject.material.materials ) {

								console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
								return;

							}

							targetObject = targetObject.material.materials;

							break;

						case 'bones':

							if ( ! targetObject.skeleton ) {

								console.error( '  can not bind to bones as node does not have a skeleton', this );
								return;

							}

							// potential future optimization: skip this if propertyIndex is already an integer
							// and convert the integer string to a true integer.

							targetObject = targetObject.skeleton.bones;

							// support resolving morphTarget names into indices.
							for ( var i = 0; i < targetObject.length; i ++ ) {

								if ( targetObject[ i ].name === objectIndex ) {

									objectIndex = i;
									break;

								}

							}

							break;

						default:

							if ( targetObject[ objectName ] === undefined ) {

								console.error( '  can not bind to objectName of node, undefined', this );
								return;

							}

							targetObject = targetObject[ objectName ];

					}


					if ( objectIndex !== undefined ) {

						if ( targetObject[ objectIndex ] === undefined ) {

							console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
							return;

						}

						targetObject = targetObject[ objectIndex ];

					}

				}

				// resolve property
				var nodeProperty = targetObject[ propertyName ];

				if ( nodeProperty === undefined ) {

					var nodeName = parsedPath.nodeName;

					console.error( "  trying to update property for track: " + nodeName +
							'.' + propertyName + " but it wasn't found.", targetObject );
					return;

				}

				// determine versioning scheme
				var versioning = this.Versioning.None;

				if ( targetObject.needsUpdate !== undefined ) { // material

					versioning = this.Versioning.NeedsUpdate;
					this.targetObject = targetObject;

				} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

					versioning = this.Versioning.MatrixWorldNeedsUpdate;
					this.targetObject = targetObject;

				}

				// determine how the property gets bound
				var bindingType = this.BindingType.Direct;

				if ( propertyIndex !== undefined ) {
					// access a sub element of the property array (only primitives are supported right now)

					if ( propertyName === "morphTargetInfluences" ) {
						// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

						// support resolving morphTarget names into indices.
						if ( ! targetObject.geometry ) {

							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
							return;

						}

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

					bindingType = this.BindingType.ArrayElement;

					this.resolvedProperty = nodeProperty;
					this.propertyIndex = propertyIndex;

				} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
					// must use copy for Object3D.Euler/Quaternion

					bindingType = this.BindingType.HasFromToArray;

					this.resolvedProperty = nodeProperty;

				} else if ( nodeProperty.length !== undefined ) {

					bindingType = this.BindingType.EntireArray;

					this.resolvedProperty = nodeProperty;

				} else {

					this.propertyName = propertyName;

				}

				// select getter / setter
				this.getValue = this.GetterByBindingType[ bindingType ];
				this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

			},

			unbind: function() {

				this.node = null;

				// back to the prototype version of getValue / setValue
				// note: avoiding to mutate the shape of 'this' via 'delete'
				this.getValue = this._getValue_unbound;
				this.setValue = this._setValue_unbound;

			}

		};

		Object.assign( PropertyBinding.prototype, { // prototype, continued

			// these are used to "bind" a nonexistent property
			_getValue_unavailable: function() {},
			_setValue_unavailable: function() {},

			// initial state of these methods that calls 'bind'
			_getValue_unbound: PropertyBinding.prototype.getValue,
			_setValue_unbound: PropertyBinding.prototype.setValue,

			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			},

			Versioning: {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			},

			GetterByBindingType: [

				function getValue_direct( buffer, offset ) {

					buffer[ offset ] = this.node[ this.propertyName ];

				},

				function getValue_array( buffer, offset ) {

					var source = this.resolvedProperty;

					for ( var i = 0, n = source.length; i !== n; ++ i ) {

						buffer[ offset ++ ] = source[ i ];

					}

				},

				function getValue_arrayElement( buffer, offset ) {

					buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

				},

				function getValue_toArray( buffer, offset ) {

					this.resolvedProperty.toArray( buffer, offset );

				}

			],

			SetterByBindingTypeAndVersioning: [

				[
					// Direct

					function setValue_direct( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];

					},

					function setValue_direct_setNeedsUpdate( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;

					},

					function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// EntireArray

					function setValue_array( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

					},

					function setValue_array_setNeedsUpdate( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

						this.targetObject.needsUpdate = true;

					},

					function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// ArrayElement

					function setValue_arrayElement( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

					},

					function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;

					},

					function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// HasToFromArray

					function setValue_fromArray( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );

					},

					function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.needsUpdate = true;

					},

					function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				]

			]

		} );

		PropertyBinding.Composite =
				function( targetGroup, path, optionalParsedPath ) {

			var parsedPath = optionalParsedPath ||
					PropertyBinding.parseTrackName( path );

			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );

		};

		PropertyBinding.Composite.prototype = {

			constructor: PropertyBinding.Composite,

			getValue: function( array, offset ) {

				this.bind(); // bind all binding

				var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[ firstValidIndex ];

				// and only call .getValue on the first
				if ( binding !== undefined ) binding.getValue( array, offset );

			},

			setValue: function( array, offset ) {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].setValue( array, offset );

				}

			},

			bind: function() {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].bind();

				}

			},

			unbind: function() {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].unbind();

				}

			}

		};

		PropertyBinding.create = function( root, path, parsedPath ) {

			if ( ! ( (root && root.isAnimationObjectGroup) ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		};

		PropertyBinding.parseTrackName = function( trackName ) {

			// matches strings in the form of:
			//    nodeName.property
			//    nodeName.property[accessor]
			//    nodeName.material.property[accessor]
			//    uuid.property[accessor]
			//    uuid.objectName[objectIndex].propertyName[propertyIndex]
			//    parentName/nodeName.property
			//    parentName/parentName/nodeName.property[index]
			//    .bone[Armature.DEF_cog].position
			//    scene:helium_balloon_model:helium_balloon_model.position
			// created and tested via https://regex101.com/#javascript

			var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
			var matches = re.exec( trackName );

			if ( ! matches ) {

				throw new Error( "cannot parse trackName at all: " + trackName );

			}

			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ],
				propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
			};

			if ( results.propertyName === null || results.propertyName.length === 0 ) {

				throw new Error( "can not parse propertyName from trackName: " + trackName );

			}

			return results;

		};

		PropertyBinding.findNode = function( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var searchSkeleton = function( skeleton ) {

					for( var i = 0; i < skeleton.bones.length; i ++ ) {

						var bone = skeleton.bones[ i ];

						if ( bone.name === nodeName ) {

							return bone;

						}
					}

					return null;

				};

				var bone = searchSkeleton( root.skeleton );

				if ( bone ) {

					return bone;

				}
			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function( children ) {

					for( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		};

		/**
		 *
		 * A group of objects that receives a shared animation state.
		 *
		 * Usage:
		 *
		 * 	-	Add objects you would otherwise pass as 'root' to the
		 * 		constructor or the .clipAction method of AnimationMixer.
		 *
		 * 	-	Instead pass this object as 'root'.
		 *
		 * 	-	You can also add and remove objects later when the mixer
		 * 		is running.
		 *
		 * Note:
		 *
		 *  	Objects of this class appear as one object to the mixer,
		 *  	so cache control of the individual objects must be done
		 *  	on the group.
		 *
		 * Limitation:
		 *
		 * 	- 	The animated properties must be compatible among the
		 * 		all objects in the group.
		 *
		 *  -	A single property can either be controlled through a
		 *  	target group or directly, but not both.
		 *
		 * @author tschw
		 */

		function AnimationObjectGroup( var_args ) {

			this.uuid = _Math.generateUUID();

			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );

			this.nCachedObjects_ = 0;			// threshold
			// note: read by PropertyBinding.Composite

			var indices = {};
			this._indicesByUUID = indices;		// for bookkeeping

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				indices[ arguments[ i ].uuid ] = i;

			}

			this._paths = [];					// inside: string
			this._parsedPaths = [];				// inside: { we don't care, here }
			this._bindings = []; 				// inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

			var scope = this;

			this.stats = {

				objects: {
					get total() { return scope._objects.length; },
					get inUse() { return this.total - scope.nCachedObjects_;  }
				},

				get bindingsPerObject() { return scope._bindings.length; }

			};

		}

		AnimationObjectGroup.prototype = {

			constructor: AnimationObjectGroup,

			isAnimationObjectGroup: true,

			add: function( var_args ) {

				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index === undefined ) {

						// unknown object -> add it to the ACTIVE region

						index = nObjects ++;
						indicesByUUID[ uuid ] = index;
						objects.push( object );

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							bindings[ j ].push(
									new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] ) );

						}

					} else if ( index < nCachedObjects ) {

						var knownObject = objects[ index ];

						// move existing object to the ACTIVE region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ];

						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						indicesByUUID[ uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = object;

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								binding = bindingsForPath[ index ];

							bindingsForPath[ index ] = lastCached;

							if ( binding === undefined ) {

								// since we do not bother to create new bindings
								// for objects that are cached, the binding may
								// or may not exist

								binding = new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] );

							}

							bindingsForPath[ firstActiveIndex ] = binding;

						}

					} else if ( objects[ index ] !== knownObject) {

						console.error( "Different objects with the same UUID " +
								"detected. Clean the caches or recreate your " +
								"infrastructure when reloading scenes..." );

					} // else the object is already where we want it to be

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			remove: function( var_args ) {

				var objects = this._objects,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index !== undefined && index >= nCachedObjects ) {

						// move existing object into the CACHED region

						var lastCachedIndex = nCachedObjects ++,
							firstActiveObject = objects[ lastCachedIndex ];

						indicesByUUID[ firstActiveObject.uuid ] = index;
						objects[ index ] = firstActiveObject;

						indicesByUUID[ uuid ] = lastCachedIndex;
						objects[ lastCachedIndex ] = object;

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								firstActive = bindingsForPath[ lastCachedIndex ],
								binding = bindingsForPath[ index ];

							bindingsForPath[ index ] = firstActive;
							bindingsForPath[ lastCachedIndex ] = binding;

						}

					}

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			// remove & forget
			uncache: function( var_args ) {

				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index !== undefined ) {

						delete indicesByUUID[ uuid ];

						if ( index < nCachedObjects ) {

							// object is cached, shrink the CACHED region

							var firstActiveIndex = -- nCachedObjects,
								lastCachedObject = objects[ firstActiveIndex ],
								lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];

							// last cached object takes this object's place
							indicesByUUID[ lastCachedObject.uuid ] = index;
							objects[ index ] = lastCachedObject;

							// last object goes to the activated slot and pop
							indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
							objects[ firstActiveIndex ] = lastObject;
							objects.pop();

							// accounting is done, now do the same for all bindings

							for ( var j = 0, m = nBindings; j !== m; ++ j ) {

								var bindingsForPath = bindings[ j ],
									lastCached = bindingsForPath[ firstActiveIndex ],
									last = bindingsForPath[ lastIndex ];

								bindingsForPath[ index ] = lastCached;
								bindingsForPath[ firstActiveIndex ] = last;
								bindingsForPath.pop();

							}

						} else {

							// object is active, just swap with the last and pop

							var lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];

							indicesByUUID[ lastObject.uuid ] = index;
							objects[ index ] = lastObject;
							objects.pop();

							// accounting is done, now do the same for all bindings

							for ( var j = 0, m = nBindings; j !== m; ++ j ) {

								var bindingsForPath = bindings[ j ];

								bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
								bindingsForPath.pop();

							}

						} // cached or active

					} // if object is known

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			// Internal interface used by befriended PropertyBinding.Composite:

			subscribe_: function( path, parsedPath ) {
				// returns an array of bindings for the given path that is changed
				// according to the contained objects in the group

				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ],
					bindings = this._bindings;

				if ( index !== undefined ) return bindings[ index ];

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array( nObjects );

				index = bindings.length;

				indicesByPath[ path ] = index;

				paths.push( path );
				parsedPaths.push( parsedPath );
				bindings.push( bindingsForPath );

				for ( var i = nCachedObjects,
						n = objects.length; i !== n; ++ i ) {

					var object = objects[ i ];

					bindingsForPath[ i ] =
							new PropertyBinding( object, path, parsedPath );

				}

				return bindingsForPath;

			},

			unsubscribe_: function( path ) {
				// tells the group to forget about a property path and no longer
				// update the array previously obtained with 'subscribe_'

				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ];

				if ( index !== undefined ) {

					var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[ lastBindingsIndex ],
						lastBindingsPath = path[ lastBindingsIndex ];

					indicesByPath[ lastBindingsPath ] = index;

					bindings[ index ] = lastBindings;
					bindings.pop();

					parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
					parsedPaths.pop();

					paths[ index ] = paths[ lastBindingsIndex ];
					paths.pop();

				}

			}

		};

		/**
		 *
		 * Action provided by AnimationMixer for scheduling clip playback on specific
		 * objects.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 *
		 */

		function AnimationAction( mixer, clip, localRoot ) {

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;

			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );

			var interpolantSettings = {
					endingStart: 	ZeroCurvatureEnding,
					endingEnd:		ZeroCurvatureEnding
			};

			for ( var i = 0; i !== nTracks; ++ i ) {

				var interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;

			}

			this._interpolantSettings = interpolantSettings;

			this._interpolants = interpolants;	// bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );

			this._cacheIndex = null;			// for the memory manager
			this._byClipCacheIndex = null;		// for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;

			this.loop = LoopRepeat;
			this._loopCount = -1;

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;

			this.timeScale = 1;
			this._effectiveTimeScale = 1;

			this.weight = 1;
			this._effectiveWeight = 1;

			this.repetitions = Infinity; 		// no. of repetitions when looping

			this.paused = false;				// false -> zero effective time scale
			this.enabled = true;				// true -> zero effective weight

			this.clampWhenFinished 	= false;	// keep feeding the last frame?

			this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

		}

		AnimationAction.prototype = {

			constructor: AnimationAction,

			// State & Scheduling

			play: function() {

				this._mixer._activateAction( this );

				return this;

			},

			stop: function() {

				this._mixer._deactivateAction( this );

				return this.reset();

			},

			reset: function() {

				this.paused = false;
				this.enabled = true;

				this.time = 0;			// restart clip
				this._loopCount = -1;	// forget previous loops
				this._startTime = null;	// forget scheduling

				return this.stopFading().stopWarping();

			},

			isRunning: function() {

				return this.enabled && ! this.paused && this.timeScale !== 0 &&
						this._startTime === null && this._mixer._isActiveAction( this );

			},

			// return true when play has been called
			isScheduled: function() {

				return this._mixer._isActiveAction( this );

			},

			startAt: function( time ) {

				this._startTime = time;

				return this;

			},

			setLoop: function( mode, repetitions ) {

				this.loop = mode;
				this.repetitions = repetitions;

				return this;

			},

			// Weight

			// set the weight stopping any scheduled fading
			// although .enabled = false yields an effective weight of zero, this
			// method does *not* change .enabled, because it would be confusing
			setEffectiveWeight: function( weight ) {

				this.weight = weight;

				// note: same logic as when updated at runtime
				this._effectiveWeight = this.enabled ? weight : 0;

				return this.stopFading();

			},

			// return the weight considering fading and .enabled
			getEffectiveWeight: function() {

				return this._effectiveWeight;

			},

			fadeIn: function( duration ) {

				return this._scheduleFading( duration, 0, 1 );

			},

			fadeOut: function( duration ) {

				return this._scheduleFading( duration, 1, 0 );

			},

			crossFadeFrom: function( fadeOutAction, duration, warp ) {

				fadeOutAction.fadeOut( duration );
				this.fadeIn( duration );

				if( warp ) {

					var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,

						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;

					fadeOutAction.warp( 1.0, startEndRatio, duration );
					this.warp( endStartRatio, 1.0, duration );

				}

				return this;

			},

			crossFadeTo: function( fadeInAction, duration, warp ) {

				return fadeInAction.crossFadeFrom( this, duration, warp );

			},

			stopFading: function() {

				var weightInterpolant = this._weightInterpolant;

				if ( weightInterpolant !== null ) {

					this._weightInterpolant = null;
					this._mixer._takeBackControlInterpolant( weightInterpolant );

				}

				return this;

			},

			// Time Scale Control

			// set the weight stopping any scheduled warping
			// although .paused = true yields an effective time scale of zero, this
			// method does *not* change .paused, because it would be confusing
			setEffectiveTimeScale: function( timeScale ) {

				this.timeScale = timeScale;
				this._effectiveTimeScale = this.paused ? 0 :timeScale;

				return this.stopWarping();

			},

			// return the time scale considering warping and .paused
			getEffectiveTimeScale: function() {

				return this._effectiveTimeScale;

			},

			setDuration: function( duration ) {

				this.timeScale = this._clip.duration / duration;

				return this.stopWarping();

			},

			syncWith: function( action ) {

				this.time = action.time;
				this.timeScale = action.timeScale;

				return this.stopWarping();

			},

			halt: function( duration ) {

				return this.warp( this._effectiveTimeScale, 0, duration );

			},

			warp: function( startTimeScale, endTimeScale, duration ) {

				var mixer = this._mixer, now = mixer.time,
					interpolant = this._timeScaleInterpolant,

					timeScale = this.timeScale;

				if ( interpolant === null ) {

					interpolant = mixer._lendControlInterpolant(),
					this._timeScaleInterpolant = interpolant;

				}

				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;

				times[ 0 ] = now;
				times[ 1 ] = now + duration;

				values[ 0 ] = startTimeScale / timeScale;
				values[ 1 ] = endTimeScale / timeScale;

				return this;

			},

			stopWarping: function() {

				var timeScaleInterpolant = this._timeScaleInterpolant;

				if ( timeScaleInterpolant !== null ) {

					this._timeScaleInterpolant = null;
					this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

				}

				return this;

			},

			// Object Accessors

			getMixer: function() {

				return this._mixer;

			},

			getClip: function() {

				return this._clip;

			},

			getRoot: function() {

				return this._localRoot || this._mixer._root;

			},

			// Interna

			_update: function( time, deltaTime, timeDirection, accuIndex ) {
				// called by the mixer

				var startTime = this._startTime;

				if ( startTime !== null ) {

					// check for scheduled start of action

					var timeRunning = ( time - startTime ) * timeDirection;
					if ( timeRunning < 0 || timeDirection === 0 ) {

						return; // yet to come / don't decide when delta = 0

					}

					// start

					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;

				}

				// apply time scale and advance time

				deltaTime *= this._updateTimeScale( time );
				var clipTime = this._updateTime( deltaTime );

				// note: _updateTime may disable the action resulting in
				// an effective weight of 0

				var weight = this._updateWeight( time );

				if ( weight > 0 ) {

					var interpolants = this._interpolants;
					var propertyMixers = this._propertyBindings;

					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

				}

			},

			_updateWeight: function( time ) {

				var weight = 0;

				if ( this.enabled ) {

					weight = this.weight;
					var interpolant = this._weightInterpolant;

					if ( interpolant !== null ) {

						var interpolantValue = interpolant.evaluate( time )[ 0 ];

						weight *= interpolantValue;

						if ( time > interpolant.parameterPositions[ 1 ] ) {

							this.stopFading();

							if ( interpolantValue === 0 ) {

								// faded out, disable
								this.enabled = false;

							}

						}

					}

				}

				this._effectiveWeight = weight;
				return weight;

			},

			_updateTimeScale: function( time ) {

				var timeScale = 0;

				if ( ! this.paused ) {

					timeScale = this.timeScale;

					var interpolant = this._timeScaleInterpolant;

					if ( interpolant !== null ) {

						var interpolantValue = interpolant.evaluate( time )[ 0 ];

						timeScale *= interpolantValue;

						if ( time > interpolant.parameterPositions[ 1 ] ) {

							this.stopWarping();

							if ( timeScale === 0 ) {

								// motion has halted, pause
								this.paused = true;

							} else {

								// warp done - apply final time scale
								this.timeScale = timeScale;

							}

						}

					}

				}

				this._effectiveTimeScale = timeScale;
				return timeScale;

			},

			_updateTime: function( deltaTime ) {

				var time = this.time + deltaTime;

				if ( deltaTime === 0 ) return time;

				var duration = this._clip.duration,

					loop = this.loop,
					loopCount = this._loopCount;

				if ( loop === LoopOnce ) {

					if ( loopCount === -1 ) {
						// just started

						this.loopCount = 0;
						this._setEndings( true, true, false );

					}

					handle_stop: {

						if ( time >= duration ) {

							time = duration;

						} else if ( time < 0 ) {

							time = 0;

						} else break handle_stop;

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime < 0 ? -1 : 1
						} );

					}

				} else { // repetitive Repeat or PingPong

					var pingPong = ( loop === LoopPingPong );

					if ( loopCount === -1 ) {
						// just started

						if ( deltaTime >= 0 ) {

							loopCount = 0;

							this._setEndings(
									true, this.repetitions === 0, pingPong );

						} else {

							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1

							this._setEndings(
									this.repetitions === 0, true, pingPong );

						}

					}

					if ( time >= duration || time < 0 ) {
						// wrap around

						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;

						loopCount += Math.abs( loopDelta );

						var pending = this.repetitions - loopCount;

						if ( pending < 0 ) {
							// have to stop (switch state, clamp time, fire event)

							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;

							time = deltaTime > 0 ? duration : 0;

							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );

						} else {
							// keep running

							if ( pending === 0 ) {
								// entering the last round

								var atStart = deltaTime < 0;
								this._setEndings( atStart, ! atStart, pingPong );

							} else {

								this._setEndings( false, false, pingPong );

							}

							this._loopCount = loopCount;

							this._mixer.dispatchEvent( {
								type: 'loop', action: this, loopDelta: loopDelta
							} );

						}

					}

					if ( pingPong && ( loopCount & 1 ) === 1 ) {
						// invert time for the "pong round"

						this.time = time;
						return duration - time;

					}

				}

				this.time = time;
				return time;

			},

			_setEndings: function( atStart, atEnd, pingPong ) {

				var settings = this._interpolantSettings;

				if ( pingPong ) {

					settings.endingStart 	= ZeroSlopeEnding;
					settings.endingEnd		= ZeroSlopeEnding;

				} else {

					// assuming for LoopOnce atStart == atEnd == true

					if ( atStart ) {

						settings.endingStart = this.zeroSlopeAtStart ?
								ZeroSlopeEnding : ZeroCurvatureEnding;

					} else {

						settings.endingStart = WrapAroundEnding;

					}

					if ( atEnd ) {

						settings.endingEnd = this.zeroSlopeAtEnd ?
								ZeroSlopeEnding : ZeroCurvatureEnding;

					} else {

						settings.endingEnd 	 = WrapAroundEnding;

					}

				}

			},

			_scheduleFading: function( duration, weightNow, weightThen ) {

				var mixer = this._mixer, now = mixer.time,
					interpolant = this._weightInterpolant;

				if ( interpolant === null ) {

					interpolant = mixer._lendControlInterpolant(),
					this._weightInterpolant = interpolant;

				}

				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;

				times[ 0 ] = now; 				values[ 0 ] = weightNow;
				times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

				return this;

			}

		};

		/**
		 *
		 * Player for AnimationClips.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function AnimationMixer( root ) {

			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;

			this.time = 0;

			this.timeScale = 1.0;

		}

		Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

			// return an action for a clip optionally using a custom root target
			// object (this method allocates a lot of dynamic memory in case a
			// previously unknown clip/root combination is specified)
			clipAction: function( clip, optionalRoot ) {

				var root = optionalRoot || this._root,
					rootUuid = root.uuid,

					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,

					clipUuid = clipObject !== null ? clipObject.uuid : clip,

					actionsForClip = this._actionsByClip[ clipUuid ],
					prototypeAction = null;

				if ( actionsForClip !== undefined ) {

					var existingAction =
							actionsForClip.actionByRoot[ rootUuid ];

					if ( existingAction !== undefined ) {

						return existingAction;

					}

					// we know the clip, so we don't have to parse all
					// the bindings again but can just copy
					prototypeAction = actionsForClip.knownActions[ 0 ];

					// also, take the clip from the prototype action
					if ( clipObject === null )
						clipObject = prototypeAction._clip;

				}

				// clip must be known when specified via string
				if ( clipObject === null ) return null;

				// allocate all resources required to run it
				var newAction = new AnimationAction( this, clipObject, optionalRoot );

				this._bindAction( newAction, prototypeAction );

				// and make the action known to the memory manager
				this._addInactiveAction( newAction, clipUuid, rootUuid );

				return newAction;

			},

			// get an existing action
			existingAction: function( clip, optionalRoot ) {

				var root = optionalRoot || this._root,
					rootUuid = root.uuid,

					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,

					clipUuid = clipObject ? clipObject.uuid : clip,

					actionsForClip = this._actionsByClip[ clipUuid ];

				if ( actionsForClip !== undefined ) {

					return actionsForClip.actionByRoot[ rootUuid ] || null;

				}

				return null;

			},

			// deactivates all previously scheduled actions
			stopAllAction: function() {

				var actions = this._actions,
					nActions = this._nActiveActions,
					bindings = this._bindings,
					nBindings = this._nActiveBindings;

				this._nActiveActions = 0;
				this._nActiveBindings = 0;

				for ( var i = 0; i !== nActions; ++ i ) {

					actions[ i ].reset();

				}

				for ( var i = 0; i !== nBindings; ++ i ) {

					bindings[ i ].useCount = 0;

				}

				return this;

			},

			// advance the time and update apply the animation
			update: function( deltaTime ) {

				deltaTime *= this.timeScale;

				var actions = this._actions,
					nActions = this._nActiveActions,

					time = this.time += deltaTime,
					timeDirection = Math.sign( deltaTime ),

					accuIndex = this._accuIndex ^= 1;

				// run active actions

				for ( var i = 0; i !== nActions; ++ i ) {

					var action = actions[ i ];

					if ( action.enabled ) {

						action._update( time, deltaTime, timeDirection, accuIndex );

					}

				}

				// update scene graph

				var bindings = this._bindings,
					nBindings = this._nActiveBindings;

				for ( var i = 0; i !== nBindings; ++ i ) {

					bindings[ i ].apply( accuIndex );

				}

				return this;

			},

			// return this mixer's root target object
			getRoot: function() {

				return this._root;

			},

			// free all resources specific to a particular clip
			uncacheClip: function( clip ) {

				var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];

				if ( actionsForClip !== undefined ) {

					// note: just calling _removeInactiveAction would mess up the
					// iteration state and also require updating the state we can
					// just throw away

					var actionsToRemove = actionsForClip.knownActions;

					for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

						var action = actionsToRemove[ i ];

						this._deactivateAction( action );

						var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[ actions.length - 1 ];

						action._cacheIndex = null;
						action._byClipCacheIndex = null;

						lastInactiveAction._cacheIndex = cacheIndex;
						actions[ cacheIndex ] = lastInactiveAction;
						actions.pop();

						this._removeInactiveBindingsForAction( action );

					}

					delete actionsByClip[ clipUuid ];

				}

			},

			// free all resources specific to a particular root target object
			uncacheRoot: function( root ) {

				var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;

				for ( var clipUuid in actionsByClip ) {

					var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
						action = actionByRoot[ rootUuid ];

					if ( action !== undefined ) {

						this._deactivateAction( action );
						this._removeInactiveAction( action );

					}

				}

				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ];

				if ( bindingByName !== undefined ) {

					for ( var trackName in bindingByName ) {

						var binding = bindingByName[ trackName ];
						binding.restoreOriginalState();
						this._removeInactiveBinding( binding );

					}

				}

			},

			// remove a targeted clip from the cache
			uncacheAction: function( clip, optionalRoot ) {

				var action = this.existingAction( clip, optionalRoot );

				if ( action !== null ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

		} );

		// Implementation details:

		Object.assign( AnimationMixer.prototype, {

			_bindAction: function( action, prototypeAction ) {

				var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingsByName = bindingsByRoot[ rootUuid ];

				if ( bindingsByName === undefined ) {

					bindingsByName = {};
					bindingsByRoot[ rootUuid ] = bindingsByName;

				}

				for ( var i = 0; i !== nTracks; ++ i ) {

					var track = tracks[ i ],
						trackName = track.name,
						binding = bindingsByName[ trackName ];

					if ( binding !== undefined ) {

						bindings[ i ] = binding;

					} else {

						binding = bindings[ i ];

						if ( binding !== undefined ) {

							// existing binding, make sure the cache knows

							if ( binding._cacheIndex === null ) {

								++ binding.referenceCount;
								this._addInactiveBinding( binding, rootUuid, trackName );

							}

							continue;

						}

						var path = prototypeAction && prototypeAction.
								_propertyBindings[ i ].binding.parsedPath;

						binding = new PropertyMixer(
								PropertyBinding.create( root, trackName, path ),
								track.ValueTypeName, track.getValueSize() );

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

						bindings[ i ] = binding;

					}

					interpolants[ i ].resultBuffer = binding.buffer;

				}

			},

			_activateAction: function( action ) {

				if ( ! this._isActiveAction( action ) ) {

					if ( action._cacheIndex === null ) {

						// this action has been forgotten by the cache, but the user
						// appears to be still using it -> rebind

						var rootUuid = ( action._localRoot || this._root ).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[ clipUuid ];

						this._bindAction( action,
								actionsForClip && actionsForClip.knownActions[ 0 ] );

						this._addInactiveAction( action, clipUuid, rootUuid );

					}

					var bindings = action._propertyBindings;

					// increment reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

						var binding = bindings[ i ];

						if ( binding.useCount ++ === 0 ) {

							this._lendBinding( binding );
							binding.saveOriginalState();

						}

					}

					this._lendAction( action );

				}

			},

			_deactivateAction: function( action ) {

				if ( this._isActiveAction( action ) ) {

					var bindings = action._propertyBindings;

					// decrement reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

						var binding = bindings[ i ];

						if ( -- binding.useCount === 0 ) {

							binding.restoreOriginalState();
							this._takeBackBinding( binding );

						}

					}

					this._takeBackAction( action );

				}

			},

			// Memory manager

			_initMemoryManager: function() {

				this._actions = []; // 'nActiveActions' followed by inactive ones
				this._nActiveActions = 0;

				this._actionsByClip = {};
				// inside:
				// {
				// 		knownActions: Array< AnimationAction >	- used as prototypes
				// 		actionByRoot: AnimationAction			- lookup
				// }


				this._bindings = []; // 'nActiveBindings' followed by inactive ones
				this._nActiveBindings = 0;

				this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


				this._controlInterpolants = []; // same game as above
				this._nActiveControlInterpolants = 0;

				var scope = this;

				this.stats = {

					actions: {
						get total() { return scope._actions.length; },
						get inUse() { return scope._nActiveActions; }
					},
					bindings: {
						get total() { return scope._bindings.length; },
						get inUse() { return scope._nActiveBindings; }
					},
					controlInterpolants: {
						get total() { return scope._controlInterpolants.length; },
						get inUse() { return scope._nActiveControlInterpolants; }
					}

				};

			},

			// Memory management for AnimationAction objects

			_isActiveAction: function( action ) {

				var index = action._cacheIndex;
				return index !== null && index < this._nActiveActions;

			},

			_addInactiveAction: function( action, clipUuid, rootUuid ) {

				var actions = this._actions,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];

				if ( actionsForClip === undefined ) {

					actionsForClip = {

						knownActions: [ action ],
						actionByRoot: {}

					};

					action._byClipCacheIndex = 0;

					actionsByClip[ clipUuid ] = actionsForClip;

				} else {

					var knownActions = actionsForClip.knownActions;

					action._byClipCacheIndex = knownActions.length;
					knownActions.push( action );

				}

				action._cacheIndex = actions.length;
				actions.push( action );

				actionsForClip.actionByRoot[ rootUuid ] = action;

			},

			_removeInactiveAction: function( action ) {

				var actions = this._actions,
					lastInactiveAction = actions[ actions.length - 1 ],
					cacheIndex = action._cacheIndex;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				action._cacheIndex = null;


				var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ],
					knownActionsForClip = actionsForClip.knownActions,

					lastKnownAction =
						knownActionsForClip[ knownActionsForClip.length - 1 ],

					byClipCacheIndex = action._byClipCacheIndex;

				lastKnownAction._byClipCacheIndex = byClipCacheIndex;
				knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
				knownActionsForClip.pop();

				action._byClipCacheIndex = null;


				var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = ( actions._localRoot || this._root ).uuid;

				delete actionByRoot[ rootUuid ];

				if ( knownActionsForClip.length === 0 ) {

					delete actionsByClip[ clipUuid ];

				}

				this._removeInactiveBindingsForAction( action );

			},

			_removeInactiveBindingsForAction: function( action ) {

				var bindings = action._propertyBindings;
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.referenceCount === 0 ) {

						this._removeInactiveBinding( binding );

					}

				}

			},

			_lendAction: function( action ) {

				// [ active actions |  inactive actions  ]
				// [  active actions >| inactive actions ]
				//                 s        a
				//                  <-swap->
				//                 a        s

				var actions = this._actions,
					prevIndex = action._cacheIndex,

					lastActiveIndex = this._nActiveActions ++,

					firstInactiveAction = actions[ lastActiveIndex ];

				action._cacheIndex = lastActiveIndex;
				actions[ lastActiveIndex ] = action;

				firstInactiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = firstInactiveAction;

			},

			_takeBackAction: function( action ) {

				// [  active actions  | inactive actions ]
				// [ active actions |< inactive actions  ]
				//        a        s
				//         <-swap->
				//        s        a

				var actions = this._actions,
					prevIndex = action._cacheIndex,

					firstInactiveIndex = -- this._nActiveActions,

					lastActiveAction = actions[ firstInactiveIndex ];

				action._cacheIndex = firstInactiveIndex;
				actions[ firstInactiveIndex ] = action;

				lastActiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = lastActiveAction;

			},

			// Memory management for PropertyMixer objects

			_addInactiveBinding: function( binding, rootUuid, trackName ) {

				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],

					bindings = this._bindings;

				if ( bindingByName === undefined ) {

					bindingByName = {};
					bindingsByRoot[ rootUuid ] = bindingByName;

				}

				bindingByName[ trackName ] = binding;

				binding._cacheIndex = bindings.length;
				bindings.push( binding );

			},

			_removeInactiveBinding: function( binding ) {

				var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],

					lastInactiveBinding = bindings[ bindings.length - 1 ],
					cacheIndex = binding._cacheIndex;

				lastInactiveBinding._cacheIndex = cacheIndex;
				bindings[ cacheIndex ] = lastInactiveBinding;
				bindings.pop();

				delete bindingByName[ trackName ];

				remove_empty_map: {

					for ( var _ in bindingByName ) break remove_empty_map;

					delete bindingsByRoot[ rootUuid ];

				}

			},

			_lendBinding: function( binding ) {

				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,

					lastActiveIndex = this._nActiveBindings ++,

					firstInactiveBinding = bindings[ lastActiveIndex ];

				binding._cacheIndex = lastActiveIndex;
				bindings[ lastActiveIndex ] = binding;

				firstInactiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = firstInactiveBinding;

			},

			_takeBackBinding: function( binding ) {

				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,

					firstInactiveIndex = -- this._nActiveBindings,

					lastActiveBinding = bindings[ firstInactiveIndex ];

				binding._cacheIndex = firstInactiveIndex;
				bindings[ firstInactiveIndex ] = binding;

				lastActiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = lastActiveBinding;

			},


			// Memory management of Interpolants for weight and time scale

			_lendControlInterpolant: function() {

				var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants ++,
					interpolant = interpolants[ lastActiveIndex ];

				if ( interpolant === undefined ) {

					interpolant = new LinearInterpolant(
							new Float32Array( 2 ), new Float32Array( 2 ),
								1, this._controlInterpolantsResultBuffer );

					interpolant.__cacheIndex = lastActiveIndex;
					interpolants[ lastActiveIndex ] = interpolant;

				}

				return interpolant;

			},

			_takeBackControlInterpolant: function( interpolant ) {

				var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,

					firstInactiveIndex = -- this._nActiveControlInterpolants,

					lastActiveInterpolant = interpolants[ firstInactiveIndex ];

				interpolant.__cacheIndex = firstInactiveIndex;
				interpolants[ firstInactiveIndex ] = interpolant;

				lastActiveInterpolant.__cacheIndex = prevIndex;
				interpolants[ prevIndex ] = lastActiveInterpolant;

			},

			_controlInterpolantsResultBuffer: new Float32Array( 1 )

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Uniform( value ) {

			if ( typeof value === 'string' ) {

				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];

			}

			this.value = value;

		}

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedBufferGeometry() {

			BufferGeometry.call( this );

			this.type = 'InstancedBufferGeometry';
			this.maxInstancedCount = undefined;

		}

		InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

		InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

		InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		};

		InstancedBufferGeometry.prototype.copy = function ( source ) {

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			var attributes = source.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			var groups = source.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			return this;

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

			this.uuid = _Math.generateUUID();

			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;

			this.normalized = normalized === true;

		}


		InterleavedBufferAttribute.prototype = {

			constructor: InterleavedBufferAttribute,

			isInterleavedBufferAttribute: true,

			get count() {

				return this.data.count;

			},

			get array() {

				return this.data.array;

			},

			setX: function ( index, x ) {

				this.data.array[ index * this.data.stride + this.offset ] = x;

				return this;

			},

			setY: function ( index, y ) {

				this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

				return this;

			},

			setZ: function ( index, z ) {

				this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

				return this;

			},

			setW: function ( index, w ) {

				this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

				return this;

			},

			getX: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset ];

			},

			getY: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 1 ];

			},

			getZ: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 2 ];

			},

			getW: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 3 ];

			},

			setXY: function ( index, x, y ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;

				return this;

			},

			setXYZ: function ( index, x, y, z ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;

				return this;

			},

			setXYZW: function ( index, x, y, z, w ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
				this.data.array[ index + 3 ] = w;

				return this;

			}

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InterleavedBuffer( array, stride ) {

			this.uuid = _Math.generateUUID();

			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;

			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

		}

		InterleavedBuffer.prototype = {

			constructor: InterleavedBuffer,

			isInterleavedBuffer: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			setArray: function ( array ) {

				if ( Array.isArray( array ) ) {

					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

				}

				this.count = array !== undefined ? array.length / this.stride : 0;
				this.array = array;

			},

			setDynamic: function ( value ) {

				this.dynamic = value;

				return this;

			},

			copy: function ( source ) {

				this.array = new source.array.constructor( source.array );
				this.count = source.count;
				this.stride = source.stride;
				this.dynamic = source.dynamic;

				return this;

			},

			copyAt: function ( index1, attribute, index2 ) {

				index1 *= this.stride;
				index2 *= attribute.stride;

				for ( var i = 0, l = this.stride; i < l; i ++ ) {

					this.array[ index1 + i ] = attribute.array[ index2 + i ];

				}

				return this;

			},

			set: function ( value, offset ) {

				if ( offset === undefined ) offset = 0;

				this.array.set( value, offset );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			}

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

			InterleavedBuffer.call( this, array, stride );

			this.meshPerAttribute = meshPerAttribute || 1;

		}

		InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
		InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

		InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

		InstancedInterleavedBuffer.prototype.copy = function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

			BufferAttribute.call( this, array, itemSize );

			this.meshPerAttribute = meshPerAttribute || 1;

		}

		InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

		InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

		InstancedBufferAttribute.prototype.copy = function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */

		function Raycaster( origin, direction, near, far ) {

			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );

		}

		function ascSort( a, b ) {

			return a.distance - b.distance;

		}

		function intersectObject( object, raycaster, intersects, recursive ) {

			if ( object.visible === false ) return;

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		}

		//

		Raycaster.prototype = {

			constructor: Raycaster,

			linePrecision: 1,

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				if ( (camera && camera.isPerspectiveCamera) ) {

					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

				} else if ( (camera && camera.isOrthographicCamera) ) {

					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

				} else {

					console.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( ascSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( Array.isArray( objects ) === false ) {

					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( ascSort );

				return intersects;

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Clock( autoStart ) {

			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;

			this.running = false;

		}

		Clock.prototype = {

			constructor: Clock,

			start: function () {

				this.startTime = ( performance || Date ).now();

				this.oldTime = this.startTime;
				this.elapsedTime = 0;
				this.running = true;

			},

			stop: function () {

				this.getElapsedTime();
				this.running = false;

			},

			getElapsedTime: function () {

				this.getDelta();
				return this.elapsedTime;

			},

			getDelta: function () {

				var diff = 0;

				if ( this.autoStart && ! this.running ) {

					this.start();

				}

				if ( this.running ) {

					var newTime = ( performance || Date ).now();

					diff = ( newTime - this.oldTime ) / 1000;
					this.oldTime = newTime;

					this.elapsedTime += diff;

				}

				return diff;

			}

		};

		/**
		 * Spline from Tween.js, slightly optimized (and trashed)
		 * http://sole.github.com/tween.js/examples/05_spline.html
		 *
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Spline( points ) {

			this.points = points;

			var c = [], v3 = { x: 0, y: 0, z: 0 },
			point, intPoint, weight, w2, w3,
			pa, pb, pc, pd;

			this.initFromArray = function ( a ) {

				this.points = [];

				for ( var i = 0; i < a.length; i ++ ) {

					this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

				}

			};

			this.getPoint = function ( k ) {

				point = ( this.points.length - 1 ) * k;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
				c[ 1 ] = intPoint;
				c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
				c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

				pa = this.points[ c[ 0 ] ];
				pb = this.points[ c[ 1 ] ];
				pc = this.points[ c[ 2 ] ];
				pd = this.points[ c[ 3 ] ];

				w2 = weight * weight;
				w3 = weight * w2;

				v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
				v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
				v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

				return v3;

			};

			this.getControlPointsArray = function () {

				var i, p, l = this.points.length,
					coords = [];

				for ( i = 0; i < l; i ++ ) {

					p = this.points[ i ];
					coords[ i ] = [ p.x, p.y, p.z ];

				}

				return coords;

			};

			// approximate length by summing linear segments

			this.getLength = function ( nSubDivisions ) {

				var i, index, nSamples, position,
					point = 0, intPoint = 0, oldIntPoint = 0,
					oldPosition = new Vector3(),
					tmpVec = new Vector3(),
					chunkLengths = [],
					totalLength = 0;

				// first point has 0 length

				chunkLengths[ 0 ] = 0;

				if ( ! nSubDivisions ) nSubDivisions = 100;

				nSamples = this.points.length * nSubDivisions;

				oldPosition.copy( this.points[ 0 ] );

				for ( i = 1; i < nSamples; i ++ ) {

					index = i / nSamples;

					position = this.getPoint( index );
					tmpVec.copy( position );

					totalLength += tmpVec.distanceTo( oldPosition );

					oldPosition.copy( position );

					point = ( this.points.length - 1 ) * index;
					intPoint = Math.floor( point );

					if ( intPoint !== oldIntPoint ) {

						chunkLengths[ intPoint ] = totalLength;
						oldIntPoint = intPoint;

					}

				}

				// last point ends with total length

				chunkLengths[ chunkLengths.length ] = totalLength;

				return { chunks: chunkLengths, total: totalLength };

			};

			this.reparametrizeByArcLength = function ( samplingCoef ) {

				var i, j,
					index, indexCurrent, indexNext,
					realDistance,
					sampling, position,
					newpoints = [],
					tmpVec = new Vector3(),
					sl = this.getLength();

				newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

				for ( i = 1; i < this.points.length; i ++ ) {

					//tmpVec.copy( this.points[ i - 1 ] );
					//linearDistance = tmpVec.distanceTo( this.points[ i ] );

					realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

					sampling = Math.ceil( samplingCoef * realDistance / sl.total );

					indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
					indexNext = i / ( this.points.length - 1 );

					for ( j = 1; j < sampling - 1; j ++ ) {

						index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

						position = this.getPoint( index );
						newpoints.push( tmpVec.copy( position ).clone() );

					}

					newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

				}

				this.points = newpoints;

			};

			// Catmull-Rom

			function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

				var v0 = ( p2 - p0 ) * 0.5,
					v1 = ( p3 - p1 ) * 0.5;

				return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			}

		}

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The poles (phi) are at the positive and negative y axis.
		 * The equator starts at positive z.
		 */

		function Spherical( radius, phi, theta ) {

			this.radius = ( radius !== undefined ) ? radius : 1.0;
			this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
			this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

			return this;

		}

		Spherical.prototype = {

			constructor: Spherical,

			set: function ( radius, phi, theta ) {

				this.radius = radius;
				this.phi = phi;
				this.theta = theta;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( other ) {

				this.radius = other.radius;
				this.phi = other.phi;
				this.theta = other.theta;

				return this;

			},

			// restrict phi to be betwee EPS and PI-EPS
			makeSafe: function() {

				var EPS = 0.000001;
				this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

				return this;

			},

			setFromVector3: function( vec3 ) {

				this.radius = vec3.length();

				if ( this.radius === 0 ) {

					this.theta = 0;
					this.phi = 0;

				} else {

					this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
					this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

				}

				return this;

			},

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function MorphBlendMesh( geometry, material ) {

			Mesh.call( this, geometry, material );

			this.animationsMap = {};
			this.animationsList = [];

			// prepare default animation
			// (all frames played together in 1 second)

			var numFrames = this.geometry.morphTargets.length;

			var name = "__default";

			var startFrame = 0;
			var endFrame = numFrames - 1;

			var fps = numFrames / 1;

			this.createAnimation( name, startFrame, endFrame, fps );
			this.setAnimationWeight( name, 1 );

		}

		MorphBlendMesh.prototype = Object.create( Mesh.prototype );
		MorphBlendMesh.prototype.constructor = MorphBlendMesh;

		MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

			var animation = {

				start: start,
				end: end,

				length: end - start + 1,

				fps: fps,
				duration: ( end - start ) / fps,

				lastFrame: 0,
				currentFrame: 0,

				active: false,

				time: 0,
				direction: 1,
				weight: 1,

				directionBackwards: false,
				mirroredLoop: false

			};

			this.animationsMap[ name ] = animation;
			this.animationsList.push( animation );

		};

		MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

			var pattern = /([a-z]+)_?(\d+)/i;

			var firstAnimation, frameRanges = {};

			var geometry = this.geometry;

			for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

				var morph = geometry.morphTargets[ i ];
				var chunks = morph.name.match( pattern );

				if ( chunks && chunks.length > 1 ) {

					var name = chunks[ 1 ];

					if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

					var range = frameRanges[ name ];

					if ( i < range.start ) range.start = i;
					if ( i > range.end ) range.end = i;

					if ( ! firstAnimation ) firstAnimation = name;

				}

			}

			for ( var name in frameRanges ) {

				var range = frameRanges[ name ];
				this.createAnimation( name, range.start, range.end, fps );

			}

			this.firstAnimation = firstAnimation;

		};

		MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.direction = 1;
				animation.directionBackwards = false;

			}

		};

		MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.direction = - 1;
				animation.directionBackwards = true;

			}

		};

		MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.fps = fps;
				animation.duration = ( animation.end - animation.start ) / animation.fps;

			}

		};

		MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.duration = duration;
				animation.fps = ( animation.end - animation.start ) / animation.duration;

			}

		};

		MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.weight = weight;

			}

		};

		MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.time = time;

			}

		};

		MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

			var time = 0;

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				time = animation.time;

			}

			return time;

		};

		MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

			var duration = - 1;

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				duration = animation.duration;

			}

			return duration;

		};

		MorphBlendMesh.prototype.playAnimation = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.time = 0;
				animation.active = true;

			} else {

				console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

			}

		};

		MorphBlendMesh.prototype.stopAnimation = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.active = false;

			}

		};

		MorphBlendMesh.prototype.update = function ( delta ) {

			for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

				var animation = this.animationsList[ i ];

				if ( ! animation.active ) continue;

				var frameTime = animation.duration / animation.length;

				animation.time += animation.direction * delta;

				if ( animation.mirroredLoop ) {

					if ( animation.time > animation.duration || animation.time < 0 ) {

						animation.direction *= - 1;

						if ( animation.time > animation.duration ) {

							animation.time = animation.duration;
							animation.directionBackwards = true;

						}

						if ( animation.time < 0 ) {

							animation.time = 0;
							animation.directionBackwards = false;

						}

					}

				} else {

					animation.time = animation.time % animation.duration;

					if ( animation.time < 0 ) animation.time += animation.duration;

				}

				var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
				var weight = animation.weight;

				if ( keyframe !== animation.currentFrame ) {

					this.morphTargetInfluences[ animation.lastFrame ] = 0;
					this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

					this.morphTargetInfluences[ keyframe ] = 0;

					animation.lastFrame = animation.currentFrame;
					animation.currentFrame = keyframe;

				}

				var mix = ( animation.time % frameTime ) / frameTime;

				if ( animation.directionBackwards ) mix = 1 - mix;

				if ( animation.currentFrame !== animation.lastFrame ) {

					this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
					this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

				} else {

					this.morphTargetInfluences[ animation.currentFrame ] = weight;

				}

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function ImmediateRenderObject( material ) {

			Object3D.call( this );

			this.material = material;
			this.render = function ( renderCallback ) {};

		}

		ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
		ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

		ImmediateRenderObject.prototype.isImmediateRenderObject = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function VertexNormalsHelper( object, size, hex, linewidth ) {

			this.object = object;

			this.size = ( size !== undefined ) ? size : 1;

			var color = ( hex !== undefined ) ? hex : 0xff0000;

			var width = ( linewidth !== undefined ) ? linewidth : 1;

			//

			var nNormals = 0;

			var objGeometry = this.object.geometry;

			if ( (objGeometry && objGeometry.isGeometry) ) {

				nNormals = objGeometry.faces.length * 3;

			} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

				nNormals = objGeometry.attributes.normal.count;

			}

			//

			var geometry = new BufferGeometry();

			var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

			geometry.addAttribute( 'position', positions );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

			//

			this.matrixAutoUpdate = false;

			this.update();

		}

		VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
		VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

		VertexNormalsHelper.prototype.update = ( function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();

			return function update() {

				var keys = [ 'a', 'b', 'c' ];

				this.object.updateMatrixWorld( true );

				normalMatrix.getNormalMatrix( this.object.matrixWorld );

				var matrixWorld = this.object.matrixWorld;

				var position = this.geometry.attributes.position;

				//

				var objGeometry = this.object.geometry;

				if ( (objGeometry && objGeometry.isGeometry) ) {

					var vertices = objGeometry.vertices;

					var faces = objGeometry.faces;

					var idx = 0;

					for ( var i = 0, l = faces.length; i < l; i ++ ) {

						var face = faces[ i ];

						for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

							var vertex = vertices[ face[ keys[ j ] ] ];

							var normal = face.vertexNormals[ j ];

							v1.copy( vertex ).applyMatrix4( matrixWorld );

							v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

							position.setXYZ( idx, v1.x, v1.y, v1.z );

							idx = idx + 1;

							position.setXYZ( idx, v2.x, v2.y, v2.z );

							idx = idx + 1;

						}

					}

				} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

					var objPos = objGeometry.attributes.position;

					var objNorm = objGeometry.attributes.normal;

					var idx = 0;

					// for simplicity, ignore index and drawcalls, and render every normal

					for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

						v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

						v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

						v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

				position.needsUpdate = true;

				return this;

			};

		}() );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function SpotLightHelper( light ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			var geometry = new BufferGeometry();

			var positions = [
				0, 0, 0,   0,   0,   1,
				0, 0, 0,   1,   0,   1,
				0, 0, 0, - 1,   0,   1,
				0, 0, 0,   0,   1,   1,
				0, 0, 0,   0, - 1,   1
			];

			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;

				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);

			}

			geometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );

			var material = new LineBasicMaterial( { fog: false } );

			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );

			this.update();

		}

		SpotLightHelper.prototype = Object.create( Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;

		SpotLightHelper.prototype.dispose = function () {

			this.cone.geometry.dispose();
			this.cone.material.dispose();

		};

		SpotLightHelper.prototype.update = function () {

			var vector = new Vector3();
			var vector2 = new Vector3();

			return function update() {

				var coneLength = this.light.distance ? this.light.distance : 1000;
				var coneWidth = coneLength * Math.tan( this.light.angle );

				this.cone.scale.set( coneWidth, coneWidth, coneLength );

				vector.setFromMatrixPosition( this.light.matrixWorld );
				vector2.setFromMatrixPosition( this.light.target.matrixWorld );

				this.cone.lookAt( vector2.sub( vector ) );

				this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			};

		}();

		/**
		 * @author Sean Griffin / http://twitter.com/sgrif
		 * @author Michael Guerrero / http://realitymeltdown.com
		 * @author mrdoob / http://mrdoob.com/
		 * @author ikerr / http://verold.com
		 */

		function SkeletonHelper( object ) {

			this.bones = this.getBoneList( object );

			var geometry = new Geometry();

			for ( var i = 0; i < this.bones.length; i ++ ) {

				var bone = this.bones[ i ];

				if ( (bone.parent && bone.parent.isBone) ) {

					geometry.vertices.push( new Vector3() );
					geometry.vertices.push( new Vector3() );
					geometry.colors.push( new Color( 0, 0, 1 ) );
					geometry.colors.push( new Color( 0, 1, 0 ) );

				}

			}

			geometry.dynamic = true;

			var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

			LineSegments.call( this, geometry, material );

			this.root = object;

			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;

			this.update();

		}


		SkeletonHelper.prototype = Object.create( LineSegments.prototype );
		SkeletonHelper.prototype.constructor = SkeletonHelper;

		SkeletonHelper.prototype.getBoneList = function( object ) {

			var boneList = [];

			if ( (object && object.isBone) ) {

				boneList.push( object );

			}

			for ( var i = 0; i < object.children.length; i ++ ) {

				boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

			}

			return boneList;

		};

		SkeletonHelper.prototype.update = function () {

			var geometry = this.geometry;

			var matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );

			var boneMatrix = new Matrix4();

			var j = 0;

			for ( var i = 0; i < this.bones.length; i ++ ) {

				var bone = this.bones[ i ];

				if ( (bone.parent && bone.parent.isBone) ) {

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

					j += 2;

				}

			}

			geometry.verticesNeedUpdate = true;

			geometry.computeBoundingSphere();

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function PointLightHelper( light, sphereSize ) {

			this.light = light;
			this.light.updateMatrixWorld();

			var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
			material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			Mesh.call( this, geometry, material );

			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;

			/*
			var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
			var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

			var d = light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.scale.set( d, d, d );

			}

			this.add( this.lightDistance );
			*/

		}

		PointLightHelper.prototype = Object.create( Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;

		PointLightHelper.prototype.dispose = function () {

			this.geometry.dispose();
			this.material.dispose();

		};

		PointLightHelper.prototype.update = function () {

			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			/*
			var d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function HemisphereLightHelper( light, sphereSize ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.colors = [ new Color(), new Color() ];

			var geometry = new SphereGeometry( sphereSize, 4, 2 );
			geometry.rotateX( - Math.PI / 2 );

			for ( var i = 0, il = 8; i < il; i ++ ) {

				geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

			}

			var material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );

			this.lightSphere = new Mesh( geometry, material );
			this.add( this.lightSphere );

			this.update();

		}

		HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

		HemisphereLightHelper.prototype.dispose = function () {

			this.lightSphere.geometry.dispose();
			this.lightSphere.material.dispose();

		};

		HemisphereLightHelper.prototype.update = function () {

			var vector = new Vector3();

			return function update() {

				this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
				this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

				this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
				this.lightSphere.geometry.colorsNeedUpdate = true;

			};

		}();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function GridHelper( size, divisions, color1, color2 ) {

			divisions = divisions || 1;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

			var center = divisions / 2;
			var step = ( size * 2 ) / divisions;
			var vertices = [], colors = [];

			for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {

				vertices.push( - size, 0, k, size, 0, k );
				vertices.push( k, 0, - size, k, 0, size );

				var color = i === center ? color1 : color2;

				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;

			}

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: VertexColors } );

			LineSegments.call( this, geometry, material );

		}

		GridHelper.prototype = Object.create( LineSegments.prototype );
		GridHelper.prototype.constructor = GridHelper;

		GridHelper.prototype.setColors = function () {

			console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function FaceNormalsHelper( object, size, hex, linewidth ) {

			// FaceNormalsHelper only supports THREE.Geometry

			this.object = object;

			this.size = ( size !== undefined ) ? size : 1;

			var color = ( hex !== undefined ) ? hex : 0xffff00;

			var width = ( linewidth !== undefined ) ? linewidth : 1;

			//

			var nNormals = 0;

			var objGeometry = this.object.geometry;

			if ( (objGeometry && objGeometry.isGeometry) ) {

				nNormals = objGeometry.faces.length;

			} else {

				console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

			}

			//

			var geometry = new BufferGeometry();

			var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

			geometry.addAttribute( 'position', positions );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

			//

			this.matrixAutoUpdate = false;
			this.update();

		}

		FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
		FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

		FaceNormalsHelper.prototype.update = ( function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();

			return function update() {

				this.object.updateMatrixWorld( true );

				normalMatrix.getNormalMatrix( this.object.matrixWorld );

				var matrixWorld = this.object.matrixWorld;

				var position = this.geometry.attributes.position;

				//

				var objGeometry = this.object.geometry;

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					var normal = face.normal;

					v1.copy( vertices[ face.a ] )
						.add( vertices[ face.b ] )
						.add( vertices[ face.c ] )
						.divideScalar( 3 )
						.applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

				position.needsUpdate = true;

				return this;

			};

		}() );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function DirectionalLightHelper( light, size ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			if ( size === undefined ) size = 1;

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( [
				- size,   size, 0,
				  size,   size, 0,
				  size, - size, 0,
				- size, - size, 0,
				- size,   size, 0
			], 3 ) );

			var material = new LineBasicMaterial( { fog: false } );

			this.add( new Line( geometry, material ) );

			geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

			this.add( new Line( geometry, material ));

			this.update();

		}

		DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

		DirectionalLightHelper.prototype.dispose = function () {

			var lightPlane = this.children[ 0 ];
			var targetLine = this.children[ 1 ];

			lightPlane.geometry.dispose();
			lightPlane.material.dispose();
			targetLine.geometry.dispose();
			targetLine.material.dispose();

		};

		DirectionalLightHelper.prototype.update = function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var v3 = new Vector3();

			return function update() {

				v1.setFromMatrixPosition( this.light.matrixWorld );
				v2.setFromMatrixPosition( this.light.target.matrixWorld );
				v3.subVectors( v2, v1 );

				var lightPlane = this.children[ 0 ];
				var targetLine = this.children[ 1 ];

				lightPlane.lookAt( v3 );
				lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

				targetLine.lookAt( v3 );
				targetLine.scale.z = v3.length();

			};

		}();

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 *	- shows frustum, line of sight and up of the camera
		 *	- suitable for fast updates
		 * 	- based on frustum visualization in lightgl.js shadowmap example
		 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
		 */

		function CameraHelper( camera ) {

			var geometry = new Geometry();
			var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

			var pointMap = {};

			// colors

			var hexFrustum = 0xffaa00;
			var hexCone = 0xff0000;
			var hexUp = 0x00aaff;
			var hexTarget = 0xffffff;
			var hexCross = 0x333333;

			// near

			addLine( "n1", "n2", hexFrustum );
			addLine( "n2", "n4", hexFrustum );
			addLine( "n4", "n3", hexFrustum );
			addLine( "n3", "n1", hexFrustum );

			// far

			addLine( "f1", "f2", hexFrustum );
			addLine( "f2", "f4", hexFrustum );
			addLine( "f4", "f3", hexFrustum );
			addLine( "f3", "f1", hexFrustum );

			// sides

			addLine( "n1", "f1", hexFrustum );
			addLine( "n2", "f2", hexFrustum );
			addLine( "n3", "f3", hexFrustum );
			addLine( "n4", "f4", hexFrustum );

			// cone

			addLine( "p", "n1", hexCone );
			addLine( "p", "n2", hexCone );
			addLine( "p", "n3", hexCone );
			addLine( "p", "n4", hexCone );

			// up

			addLine( "u1", "u2", hexUp );
			addLine( "u2", "u3", hexUp );
			addLine( "u3", "u1", hexUp );

			// target

			addLine( "c", "t", hexTarget );
			addLine( "p", "c", hexCross );

			// cross

			addLine( "cn1", "cn2", hexCross );
			addLine( "cn3", "cn4", hexCross );

			addLine( "cf1", "cf2", hexCross );
			addLine( "cf3", "cf4", hexCross );

			function addLine( a, b, hex ) {

				addPoint( a, hex );
				addPoint( b, hex );

			}

			function addPoint( id, hex ) {

				geometry.vertices.push( new Vector3() );
				geometry.colors.push( new Color( hex ) );

				if ( pointMap[ id ] === undefined ) {

					pointMap[ id ] = [];

				}

				pointMap[ id ].push( geometry.vertices.length - 1 );

			}

			LineSegments.call( this, geometry, material );

			this.camera = camera;
			if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;

			this.pointMap = pointMap;

			this.update();

		}

		CameraHelper.prototype = Object.create( LineSegments.prototype );
		CameraHelper.prototype.constructor = CameraHelper;

		CameraHelper.prototype.update = function () {

			var geometry, pointMap;

			var vector = new Vector3();
			var camera = new Camera();

			function setPoint( point, x, y, z ) {

				vector.set( x, y, z ).unproject( camera );

				var points = pointMap[ point ];

				if ( points !== undefined ) {

					for ( var i = 0, il = points.length; i < il; i ++ ) {

						geometry.vertices[ points[ i ] ].copy( vector );

					}

				}

			}

			return function update() {

				geometry = this.geometry;
				pointMap = this.pointMap;

				var w = 1, h = 1;

				// we need just camera projection matrix
				// world matrix must be identity

				camera.projectionMatrix.copy( this.camera.projectionMatrix );

				// center / target

				setPoint( "c", 0, 0, - 1 );
				setPoint( "t", 0, 0,  1 );

				// near

				setPoint( "n1", - w, - h, - 1 );
				setPoint( "n2",   w, - h, - 1 );
				setPoint( "n3", - w,   h, - 1 );
				setPoint( "n4",   w,   h, - 1 );

				// far

				setPoint( "f1", - w, - h, 1 );
				setPoint( "f2",   w, - h, 1 );
				setPoint( "f3", - w,   h, 1 );
				setPoint( "f4",   w,   h, 1 );

				// up

				setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
				setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
				setPoint( "u3",         0, h * 2,   - 1 );

				// cross

				setPoint( "cf1", - w,   0, 1 );
				setPoint( "cf2",   w,   0, 1 );
				setPoint( "cf3",   0, - h, 1 );
				setPoint( "cf4",   0,   h, 1 );

				setPoint( "cn1", - w,   0, - 1 );
				setPoint( "cn2",   w,   0, - 1 );
				setPoint( "cn3",   0, - h, - 1 );
				setPoint( "cn4",   0,   h, - 1 );

				geometry.verticesNeedUpdate = true;

			};

		}();

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		// a helper to show the world-axis-aligned bounding box for an object

		function BoundingBoxHelper( object, hex ) {

			var color = ( hex !== undefined ) ? hex : 0x888888;

			this.object = object;

			this.box = new Box3();

			Mesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );

		}

		BoundingBoxHelper.prototype = Object.create( Mesh.prototype );
		BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;

		BoundingBoxHelper.prototype.update = function () {

			this.box.setFromObject( this.object );

			this.box.getSize( this.scale );

			this.box.getCenter( this.position );

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BoxHelper( object, color ) {

			if ( color === undefined ) color = 0xffff00;

			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			var positions = new Float32Array( 8 * 3 );

			var geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

			if ( object !== undefined ) {

				this.update( object );

			}

		}

		BoxHelper.prototype = Object.create( LineSegments.prototype );
		BoxHelper.prototype.constructor = BoxHelper;

		BoxHelper.prototype.update = ( function () {

			var box = new Box3();

			return function update( object ) {

				if ( (object && object.isBox3) ) {

					box.copy( object );

				} else {

					box.setFromObject( object );

				}

				if ( box.isEmpty() ) return;

				var min = box.min;
				var max = box.max;

				/*
				  5____4
				1/___0/|
				| 6__|_7
				2/___3/

				0: max.x, max.y, max.z
				1: min.x, max.y, max.z
				2: min.x, min.y, max.z
				3: max.x, min.y, max.z
				4: max.x, max.y, min.z
				5: min.x, max.y, min.z
				6: min.x, min.y, min.z
				7: max.x, min.y, min.z
				*/

				var position = this.geometry.attributes.position;
				var array = position.array;

				array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
				array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
				array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
				array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
				array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
				array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
				array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
				array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

				position.needsUpdate = true;

				this.geometry.computeBoundingSphere();

			};

		} )();

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author zz85 / http://github.com/zz85
		 * @author bhouston / http://clara.io
		 *
		 * Creates an arrow for visualizing directions
		 *
		 * Parameters:
		 *  dir - Vector3
		 *  origin - Vector3
		 *  length - Number
		 *  color - color in hex value
		 *  headLength - Number
		 *  headWidth - Number
		 */

		var lineGeometry = new BufferGeometry();
		lineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

		var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );

		function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );

			this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );

			this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

		ArrowHelper.prototype = Object.create( Object3D.prototype );
		ArrowHelper.prototype.constructor = ArrowHelper;

		ArrowHelper.prototype.setDirection = ( function () {

			var axis = new Vector3();
			var radians;

			return function setDirection( dir ) {

				// dir is assumed to be normalized

				if ( dir.y > 0.99999 ) {

					this.quaternion.set( 0, 0, 0, 1 );

				} else if ( dir.y < - 0.99999 ) {

					this.quaternion.set( 1, 0, 0, 0 );

				} else {

					axis.set( dir.z, 0, - dir.x ).normalize();

					radians = Math.acos( dir.y );

					this.quaternion.setFromAxisAngle( axis, radians );

				}

			};

		}() );

		ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
			this.line.updateMatrix();

			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();

		};

		ArrowHelper.prototype.setColor = function ( color ) {

			this.line.material.color.copy( color );
			this.cone.material.color.copy( color );

		};

		/**
		 * @author sroucheray / http://sroucheray.org/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AxisHelper( size ) {

			size = size || 1;

			var vertices = new Float32Array( [
				0, 0, 0,  size, 0, 0,
				0, 0, 0,  0, size, 0,
				0, 0, 0,  0, 0, size
			] );

			var colors = new Float32Array( [
				1, 0, 0,  1, 0.6, 0,
				0, 1, 0,  0.6, 1, 0,
				0, 0, 1,  0, 0.6, 1
			] );

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: VertexColors } );

			LineSegments.call( this, geometry, material );

		}

		AxisHelper.prototype = Object.create( LineSegments.prototype );
		AxisHelper.prototype.constructor = AxisHelper;

		/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 */

		var CatmullRomCurve3 = ( function() {

			var
				tmp = new Vector3(),
				px = new CubicPoly(),
				py = new CubicPoly(),
				pz = new CubicPoly();

			/*
			Based on an optimized c++ solution in
			 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
			 - http://ideone.com/NoEbVM

			This CubicPoly class could be used for reusing some variables and calculations,
			but for three.js curve use, it could be possible inlined and flatten into a single function call
			which can be placed in CurveUtils.
			*/

			function CubicPoly() {}

			/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */
			CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

				this.c0 = x0;
				this.c1 = t0;
				this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
				this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

			};

			CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				// initCubicPoly
				this.init( x1, x2, t1, t2 );

			};

			// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
			CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

				this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			};

			CubicPoly.prototype.calc = function( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

			};

			// Subclass Three.js curve
			return Curve.create(

				function ( p /* array of Vector3 */ ) {

					this.points = p || [];
					this.closed = false;

				},

				function ( t ) {

					var points = this.points,
						point, intPoint, weight, l;

					l = points.length;

					if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

					point = ( l - ( this.closed ? 0 : 1 ) ) * t;
					intPoint = Math.floor( point );
					weight = point - intPoint;

					if ( this.closed ) {

						intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

					} else if ( weight === 0 && intPoint === l - 1 ) {

						intPoint = l - 2;
						weight = 1;

					}

					var p0, p1, p2, p3; // 4 points

					if ( this.closed || intPoint > 0 ) {

						p0 = points[ ( intPoint - 1 ) % l ];

					} else {

						// extrapolate first point
						tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
						p0 = tmp;

					}

					p1 = points[ intPoint % l ];
					p2 = points[ ( intPoint + 1 ) % l ];

					if ( this.closed || intPoint + 2 < l ) {

						p3 = points[ ( intPoint + 2 ) % l ];

					} else {

						// extrapolate last point
						tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
						p3 = tmp;

					}

					if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

						// init Centripetal / Chordal Catmull-Rom
						var pow = this.type === 'chordal' ? 0.5 : 0.25;
						var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
						var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
						var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

						// safety check for repeated points
						if ( dt1 < 1e-4 ) dt1 = 1.0;
						if ( dt0 < 1e-4 ) dt0 = dt1;
						if ( dt2 < 1e-4 ) dt2 = dt1;

						px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
						py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
						pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

					} else if ( this.type === 'catmullrom' ) {

						var tension = this.tension !== undefined ? this.tension : 0.5;
						px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
						py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
						pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

					}

					var v = new Vector3(
						px.calc( weight ),
						py.calc( weight ),
						pz.calc( weight )
					);

					return v;

				}

			);

		} )();

		/**************************************************************
		 *	Closed Spline 3D curve
		 **************************************************************/


		function ClosedSplineCurve3( points ) {

			console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
			this.closed = true;

		}

		ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

		/**************************************************************
		 *	Spline 3D curve
		 **************************************************************/


		var SplineCurve3 = Curve.create(

			function ( points /* array of Vector3 */ ) {

				console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
				this.points = ( points === undefined ) ? [] : points;

			},

			function ( t ) {

				var points = this.points;
				var point = ( points.length - 1 ) * t;

				var intPoint = Math.floor( point );
				var weight = point - intPoint;

				var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
				var point1 = points[ intPoint ];
				var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
				var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

				var interpolate = CurveUtils.interpolate;

				return new Vector3(
					interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
					interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
					interpolate( point0.z, point1.z, point2.z, point3.z, weight )
				);

			}

		);

		/**************************************************************
		 *	Cubic Bezier 3D curve
		 **************************************************************/

		var CubicBezierCurve3 = Curve.create(

			function ( v0, v1, v2, v3 ) {

				this.v0 = v0;
				this.v1 = v1;
				this.v2 = v2;
				this.v3 = v3;

			},

			function ( t ) {

				var b3 = ShapeUtils.b3;

				return new Vector3(
					b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
					b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
					b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
				);

			}

		);

		/**************************************************************
		 *	Quadratic Bezier 3D curve
		 **************************************************************/

		var QuadraticBezierCurve3 = Curve.create(

			function ( v0, v1, v2 ) {

				this.v0 = v0;
				this.v1 = v1;
				this.v2 = v2;

			},

			function ( t ) {

				var b2 = ShapeUtils.b2;

				return new Vector3(
					b2( t, this.v0.x, this.v1.x, this.v2.x ),
					b2( t, this.v0.y, this.v1.y, this.v2.y ),
					b2( t, this.v0.z, this.v1.z, this.v2.z )
				);

			}

		);

		/**************************************************************
		 *	Line3D
		 **************************************************************/

		var LineCurve3 = Curve.create(

			function ( v1, v2 ) {

				this.v1 = v1;
				this.v2 = v2;

			},

			function ( t ) {

				if ( t === 1 ) {

					return this.v2.clone();

				}

				var vector = new Vector3();

				vector.subVectors( this.v2, this.v1 ); // diff
				vector.multiplyScalar( t );
				vector.add( this.v1 );

				return vector;

			}

		);

		/**************************************************************
		 *	Arc curve
		 **************************************************************/

		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		}

		ArcCurve.prototype = Object.create( EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		var SceneUtils = {

			createMultiMaterialObject: function ( geometry, materials ) {

				var group = new Group();

				for ( var i = 0, l = materials.length; i < l; i ++ ) {

					group.add( new Mesh( geometry, materials[ i ] ) );

				}

				return group;

			},

			detach: function ( child, parent, scene ) {

				child.applyMatrix( parent.matrixWorld );
				parent.remove( child );
				scene.add( child );

			},

			attach: function ( child, scene, parent ) {

				var matrixWorldInverse = new Matrix4();
				matrixWorldInverse.getInverse( parent.matrixWorld );
				child.applyMatrix( matrixWorldInverse );

				scene.remove( child );
				parent.add( child );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Face4 ( a, b, c, d, normal, color, materialIndex ) {
			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new Face3( a, b, c, normal, color, materialIndex );
		}

		var LineStrip = 0;

		var LinePieces = 1;

		function PointCloud ( geometry, material ) {
			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new Points( geometry, material );
		}

		function ParticleSystem ( geometry, material ) {
			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new Points( geometry, material );
		}

		function PointCloudMaterial ( parameters ) {
			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}

		function ParticleBasicMaterial ( parameters ) {
			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}

		function ParticleSystemMaterial ( parameters ) {
			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}

		function Vertex ( x, y, z ) {
			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new Vector3( x, y, z );
		}

		//

		function EdgesHelper( object, hex ) {
			console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
			return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
		}

		function WireframeHelper( object, hex ) {
			console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
			return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
		}

		//

		Object.assign( Box2.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			},
			empty: function () {
				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			},
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			size: function ( optionalTarget ) {
				console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
			}
		} );

		Object.assign( Box3.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			},
			empty: function () {
				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			},
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			isIntersectionSphere: function ( sphere ) {
				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			},
			size: function ( optionalTarget ) {
				console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
			}
		} );

		Object.assign( Line3.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			}
		} );

		Object.assign( Matrix3.prototype, {
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );
			},
			multiplyVector3Array: function ( a ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			}
		} );

		Object.assign( Matrix4.prototype, {
			extractPosition: function ( m ) {
				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );
			},
			setRotationFromQuaternion: function ( q ) {
				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );
			},
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
				return vector.applyProjection( this );
			},
			multiplyVector4: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			},
			multiplyVector3Array: function ( a ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			},
			rotateAxis: function ( v ) {
				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );
			},
			crossVector: function ( vector ) {
				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			},
			translate: function ( v ) {
				console.error( 'THREE.Matrix4: .translate() has been removed.' );
			},
			rotateX: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
			},
			rotateY: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
			},
			rotateZ: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
			},
			rotateByAxis: function ( axis, angle ) {
				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
			}
		} );

		Object.assign( Plane.prototype, {
			isIntersectionLine: function ( line ) {
				console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
				return this.intersectsLine( line );
			}
		} );

		Object.assign( Quaternion.prototype, {
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
				return vector.applyQuaternion( this );
			}
		} );

		Object.assign( Ray.prototype, {
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			isIntersectionPlane: function ( plane ) {
				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );
			},
			isIntersectionSphere: function ( sphere ) {
				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			}
		} );

		Object.assign( Shape.prototype, {
			extrude: function ( options ) {
				console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
				return new ExtrudeGeometry( this, options );
			},
			makeGeometry: function ( options ) {
				console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
				return new ShapeGeometry( this, options );
			}
		} );

		Object.assign( Vector3.prototype, {
			setEulerFromRotationMatrix: function () {
				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
			},
			setEulerFromQuaternion: function () {
				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
			},
			getPositionFromMatrix: function ( m ) {
				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );
			},
			getScaleFromMatrix: function ( m ) {
				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );
			},
			getColumnFromMatrix: function ( index, matrix ) {
				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( matrix, index );
			}
		} );

		//

		Object.assign( Object3D.prototype, {
			getChildByName: function ( name ) {
				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );
			},
			renderDepth: function ( value ) {
				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
			},
			translate: function ( distance, axis ) {
				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );
			}
		} );

		Object.defineProperties( Object3D.prototype, {
			eulerOrder: {
				get: function () {
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					return this.rotation.order;
				},
				set: function ( value ) {
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					this.rotation.order = value;
				}
			},
			useQuaternion: {
				get: function () {
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
				},
				set: function ( value ) {
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
				}
			}
		} );

		Object.defineProperties( LOD.prototype, {
			objects: {
				get: function () {
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
				}
			}
		} );

		//

		PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

			console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
					"Use .setFocalLength and .filmGauge for a photographic setup." );

			if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
			this.setFocalLength( focalLength );

		};

		//

		Object.defineProperties( Light.prototype, {
			onlyShadow: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .onlyShadow has been removed.' );
				}
			},
			shadowCameraFov: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
					this.shadow.camera.fov = value;
				}
			},
			shadowCameraLeft: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
					this.shadow.camera.left = value;
				}
			},
			shadowCameraRight: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
					this.shadow.camera.right = value;
				}
			},
			shadowCameraTop: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
					this.shadow.camera.top = value;
				}
			},
			shadowCameraBottom: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
					this.shadow.camera.bottom = value;
				}
			},
			shadowCameraNear: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
					this.shadow.camera.near = value;
				}
			},
			shadowCameraFar: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
					this.shadow.camera.far = value;
				}
			},
			shadowCameraVisible: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
				}
			},
			shadowBias: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
					this.shadow.bias = value;
				}
			},
			shadowDarkness: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
				}
			},
			shadowMapWidth: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
					this.shadow.mapSize.width = value;
				}
			},
			shadowMapHeight: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
					this.shadow.mapSize.height = value;
				}
			}
		} );

		//

		Object.defineProperties( BufferAttribute.prototype, {
			length: {
				get: function () {
					console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
					return this.array.length;
				}
			}
		} );

		Object.assign( BufferGeometry.prototype, {
			addIndex: function ( index ) {
				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );
			},
			addDrawCall: function ( start, count, indexOffset ) {
				if ( indexOffset !== undefined ) {
					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );
			},
			clearDrawCalls: function () {
				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();
			},
			computeTangents: function () {
				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
			},
			computeOffsets: function () {
				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
			}
		} );

		Object.defineProperties( BufferGeometry.prototype, {
			drawcalls: {
				get: function () {
					console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
					return this.groups;
				}
			},
			offsets: {
				get: function () {
					console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
					return this.groups;
				}
			}
		} );

		//

		Object.defineProperties( Material.prototype, {
			wrapAround: {
				get: function () {
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
				},
				set: function ( value ) {
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
				}
			},
			wrapRGB: {
				get: function () {
					console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
					return new Color();
				}
			}
		} );

		Object.defineProperties( MeshPhongMaterial.prototype, {
			metal: {
				get: function () {
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
					return false;
				},
				set: function ( value ) {
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
				}
			}
		} );

		Object.defineProperties( ShaderMaterial.prototype, {
			derivatives: {
				get: function () {
					console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					return this.extensions.derivatives;
				},
				set: function ( value ) {
					console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					this.extensions.derivatives = value;
				}
			}
		} );

		//

		EventDispatcher.prototype = Object.assign( Object.create( {

			// Note: Extra base ensures these properties are not 'assign'ed.

			constructor: EventDispatcher,

			apply: function ( target ) {

				console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
						"just inherit or Object.assign the prototype to mix-in." );

				Object.assign( target, this );

			}

		} ), EventDispatcher.prototype );

		//

		Object.defineProperties( Uniform.prototype, {
			dynamic: {
				set: function ( value ) {
					console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
				}
			},
			onUpdate: {
				value: function () {
					console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
					return this;
				}
			}
		} );

		//

		Object.assign( WebGLRenderer.prototype, {
			supportsFloatTextures: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );
			},
			supportsHalfFloatTextures: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );
			},
			supportsStandardDerivatives: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );
			},
			supportsCompressedTextureS3TC: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
			},
			supportsCompressedTexturePVRTC: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
			},
			supportsBlendMinMax: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );
			},
			supportsVertexTextures: function () {
				return this.capabilities.vertexTextures;
			},
			supportsInstancedArrays: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );
			},
			enableScissorTest: function ( boolean ) {
				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );
			},
			initMaterial: function () {
				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
			},
			addPrePlugin: function () {
				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
			},
			addPostPlugin: function () {
				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
			},
			updateShadowMap: function () {
				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
			}
		} );

		Object.defineProperties( WebGLRenderer.prototype, {
			shadowMapEnabled: {
				get: function () {
					return this.shadowMap.enabled;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					this.shadowMap.enabled = value;
				}
			},
			shadowMapType: {
				get: function () {
					return this.shadowMap.type;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					this.shadowMap.type = value;
				}
			},
			shadowMapCullFace: {
				get: function () {
					return this.shadowMap.cullFace;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					this.shadowMap.cullFace = value;
				}
			}
		} );

		Object.defineProperties( WebGLShadowMap.prototype, {
			cullFace: {
				get: function () {
					return this.renderReverseSided ? CullFaceFront : CullFaceBack;
				},
				set: function ( cullFace ) {
					var value = ( cullFace !== CullFaceBack );
					console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
					this.renderReverseSided = value;
				}
			}
		} );

		//

		Object.defineProperties( WebGLRenderTarget.prototype, {
			wrapS: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					return this.texture.wrapS;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					this.texture.wrapS = value;
				}
			},
			wrapT: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					return this.texture.wrapT;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					this.texture.wrapT = value;
				}
			},
			magFilter: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					return this.texture.magFilter;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					this.texture.magFilter = value;
				}
			},
			minFilter: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					return this.texture.minFilter;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					this.texture.minFilter = value;
				}
			},
			anisotropy: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					return this.texture.anisotropy;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					this.texture.anisotropy = value;
				}
			},
			offset: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					return this.texture.offset;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					this.texture.offset = value;
				}
			},
			repeat: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					return this.texture.repeat;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					this.texture.repeat = value;
				}
			},
			format: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					return this.texture.format;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					this.texture.format = value;
				}
			},
			type: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					return this.texture.type;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					this.texture.type = value;
				}
			},
			generateMipmaps: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					return this.texture.generateMipmaps;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					this.texture.generateMipmaps = value;
				}
			}
		} );

		//

		Object.assign( Audio.prototype, {
			load: function ( file ) {
				console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
				var scope = this;
				var audioLoader = new AudioLoader();
				audioLoader.load( file, function ( buffer ) {
					scope.setBuffer( buffer );
				} );
				return this;
			}
		} );

		Object.assign( AudioAnalyser.prototype, {
			getData: function ( file ) {
				console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
				return this.getFrequencyData();
			}
		} );

		//

		var GeometryUtils = {

			merge: function ( geometry1, geometry2, materialIndexOffset ) {

				console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

				var matrix;

				if ( geometry2.isMesh ) {

					geometry2.matrixAutoUpdate && geometry2.updateMatrix();

					matrix = geometry2.matrix;
					geometry2 = geometry2.geometry;

				}

				geometry1.merge( geometry2, matrix, materialIndexOffset );

			},

			center: function ( geometry ) {

				console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
				return geometry.center();

			}

		};

		var ImageUtils = {

			crossOrigin: undefined,

			loadTexture: function ( url, mapping, onLoad, onError ) {

				console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

				var loader = new TextureLoader();
				loader.setCrossOrigin( this.crossOrigin );

				var texture = loader.load( url, onLoad, undefined, onError );

				if ( mapping ) texture.mapping = mapping;

				return texture;

			},

			loadTextureCube: function ( urls, mapping, onLoad, onError ) {

				console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

				var loader = new CubeTextureLoader();
				loader.setCrossOrigin( this.crossOrigin );

				var texture = loader.load( urls, onLoad, undefined, onError );

				if ( mapping ) texture.mapping = mapping;

				return texture;

			},

			loadCompressedTexture: function () {

				console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

			},

			loadCompressedTextureCube: function () {

				console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

			}

		};

		//

		function Projector () {

			console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

			this.projectVector = function ( vector, camera ) {

				console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
				vector.project( camera );

			};

			this.unprojectVector = function ( vector, camera ) {

				console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
				vector.unproject( camera );

			};

			this.pickingRay = function ( vector, camera ) {

				console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

			};

		}

		//

		function CanvasRenderer () {

			console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

			this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			this.clear = function () {};
			this.render = function () {};
			this.setClearColor = function () {};
			this.setSize = function () {};

		}

		exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
		exports.WebGLRenderTarget = WebGLRenderTarget;
		exports.WebGLRenderer = WebGLRenderer;
		exports.ShaderLib = ShaderLib;
		exports.UniformsLib = UniformsLib;
		exports.UniformsUtils = UniformsUtils;
		exports.ShaderChunk = ShaderChunk;
		exports.FogExp2 = FogExp2;
		exports.Fog = Fog;
		exports.Scene = Scene;
		exports.LensFlare = LensFlare;
		exports.Sprite = Sprite;
		exports.LOD = LOD;
		exports.SkinnedMesh = SkinnedMesh;
		exports.Skeleton = Skeleton;
		exports.Bone = Bone;
		exports.Mesh = Mesh;
		exports.LineSegments = LineSegments;
		exports.Line = Line;
		exports.Points = Points;
		exports.Group = Group;
		exports.VideoTexture = VideoTexture;
		exports.DataTexture = DataTexture;
		exports.CompressedTexture = CompressedTexture;
		exports.CubeTexture = CubeTexture;
		exports.CanvasTexture = CanvasTexture;
		exports.DepthTexture = DepthTexture;
		exports.TextureIdCount = TextureIdCount;
		exports.Texture = Texture;
		exports.MaterialIdCount = MaterialIdCount;
		exports.CompressedTextureLoader = CompressedTextureLoader;
		exports.BinaryTextureLoader = BinaryTextureLoader;
		exports.DataTextureLoader = DataTextureLoader;
		exports.CubeTextureLoader = CubeTextureLoader;
		exports.TextureLoader = TextureLoader;
		exports.ObjectLoader = ObjectLoader;
		exports.MaterialLoader = MaterialLoader;
		exports.BufferGeometryLoader = BufferGeometryLoader;
		exports.DefaultLoadingManager = DefaultLoadingManager;
		exports.LoadingManager = LoadingManager;
		exports.JSONLoader = JSONLoader;
		exports.ImageLoader = ImageLoader;
		exports.FontLoader = FontLoader;
		exports.XHRLoader = XHRLoader;
		exports.Loader = Loader;
		exports.Cache = Cache;
		exports.AudioLoader = AudioLoader;
		exports.SpotLightShadow = SpotLightShadow;
		exports.SpotLight = SpotLight;
		exports.PointLight = PointLight;
		exports.HemisphereLight = HemisphereLight;
		exports.DirectionalLightShadow = DirectionalLightShadow;
		exports.DirectionalLight = DirectionalLight;
		exports.AmbientLight = AmbientLight;
		exports.LightShadow = LightShadow;
		exports.Light = Light;
		exports.StereoCamera = StereoCamera;
		exports.PerspectiveCamera = PerspectiveCamera;
		exports.OrthographicCamera = OrthographicCamera;
		exports.CubeCamera = CubeCamera;
		exports.Camera = Camera;
		exports.AudioListener = AudioListener;
		exports.PositionalAudio = PositionalAudio;
		exports.getAudioContext = getAudioContext;
		exports.AudioAnalyser = AudioAnalyser;
		exports.Audio = Audio;
		exports.VectorKeyframeTrack = VectorKeyframeTrack;
		exports.StringKeyframeTrack = StringKeyframeTrack;
		exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
		exports.NumberKeyframeTrack = NumberKeyframeTrack;
		exports.ColorKeyframeTrack = ColorKeyframeTrack;
		exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
		exports.PropertyMixer = PropertyMixer;
		exports.PropertyBinding = PropertyBinding;
		exports.KeyframeTrack = KeyframeTrack;
		exports.AnimationUtils = AnimationUtils;
		exports.AnimationObjectGroup = AnimationObjectGroup;
		exports.AnimationMixer = AnimationMixer;
		exports.AnimationClip = AnimationClip;
		exports.Uniform = Uniform;
		exports.InstancedBufferGeometry = InstancedBufferGeometry;
		exports.BufferGeometry = BufferGeometry;
		exports.GeometryIdCount = GeometryIdCount;
		exports.Geometry = Geometry;
		exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
		exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
		exports.InterleavedBuffer = InterleavedBuffer;
		exports.InstancedBufferAttribute = InstancedBufferAttribute;
		exports.DynamicBufferAttribute = DynamicBufferAttribute;
		exports.Float64Attribute = Float64Attribute;
		exports.Float32Attribute = Float32Attribute;
		exports.Uint32Attribute = Uint32Attribute;
		exports.Int32Attribute = Int32Attribute;
		exports.Uint16Attribute = Uint16Attribute;
		exports.Int16Attribute = Int16Attribute;
		exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
		exports.Uint8Attribute = Uint8Attribute;
		exports.Int8Attribute = Int8Attribute;
		exports.BufferAttribute = BufferAttribute;
		exports.Face3 = Face3;
		exports.Object3DIdCount = Object3DIdCount;
		exports.Object3D = Object3D;
		exports.Raycaster = Raycaster;
		exports.Layers = Layers;
		exports.EventDispatcher = EventDispatcher;
		exports.Clock = Clock;
		exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
		exports.LinearInterpolant = LinearInterpolant;
		exports.DiscreteInterpolant = DiscreteInterpolant;
		exports.CubicInterpolant = CubicInterpolant;
		exports.Interpolant = Interpolant;
		exports.Triangle = Triangle;
		exports.Spline = Spline;
		exports.Math = _Math;
		exports.Spherical = Spherical;
		exports.Plane = Plane;
		exports.Frustum = Frustum;
		exports.Sphere = Sphere;
		exports.Ray = Ray;
		exports.Matrix4 = Matrix4;
		exports.Matrix3 = Matrix3;
		exports.Box3 = Box3;
		exports.Box2 = Box2;
		exports.Line3 = Line3;
		exports.Euler = Euler;
		exports.Vector4 = Vector4;
		exports.Vector3 = Vector3;
		exports.Vector2 = Vector2;
		exports.Quaternion = Quaternion;
		exports.ColorKeywords = ColorKeywords;
		exports.Color = Color;
		exports.MorphBlendMesh = MorphBlendMesh;
		exports.ImmediateRenderObject = ImmediateRenderObject;
		exports.VertexNormalsHelper = VertexNormalsHelper;
		exports.SpotLightHelper = SpotLightHelper;
		exports.SkeletonHelper = SkeletonHelper;
		exports.PointLightHelper = PointLightHelper;
		exports.HemisphereLightHelper = HemisphereLightHelper;
		exports.GridHelper = GridHelper;
		exports.FaceNormalsHelper = FaceNormalsHelper;
		exports.DirectionalLightHelper = DirectionalLightHelper;
		exports.CameraHelper = CameraHelper;
		exports.BoundingBoxHelper = BoundingBoxHelper;
		exports.BoxHelper = BoxHelper;
		exports.ArrowHelper = ArrowHelper;
		exports.AxisHelper = AxisHelper;
		exports.ClosedSplineCurve3 = ClosedSplineCurve3;
		exports.CatmullRomCurve3 = CatmullRomCurve3;
		exports.SplineCurve3 = SplineCurve3;
		exports.CubicBezierCurve3 = CubicBezierCurve3;
		exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
		exports.LineCurve3 = LineCurve3;
		exports.ArcCurve = ArcCurve;
		exports.EllipseCurve = EllipseCurve;
		exports.SplineCurve = SplineCurve;
		exports.CubicBezierCurve = CubicBezierCurve;
		exports.QuadraticBezierCurve = QuadraticBezierCurve;
		exports.LineCurve = LineCurve;
		exports.Shape = Shape;
		exports.ShapePath = ShapePath;
		exports.Path = Path;
		exports.Font = Font;
		exports.CurvePath = CurvePath;
		exports.Curve = Curve;
		exports.ShapeUtils = ShapeUtils;
		exports.SceneUtils = SceneUtils;
		exports.CurveUtils = CurveUtils;
		exports.WireframeGeometry = WireframeGeometry;
		exports.ParametricGeometry = ParametricGeometry;
		exports.ParametricBufferGeometry = ParametricBufferGeometry;
		exports.TetrahedronGeometry = TetrahedronGeometry;
		exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
		exports.OctahedronGeometry = OctahedronGeometry;
		exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
		exports.IcosahedronGeometry = IcosahedronGeometry;
		exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
		exports.DodecahedronGeometry = DodecahedronGeometry;
		exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
		exports.PolyhedronGeometry = PolyhedronGeometry;
		exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
		exports.TubeGeometry = TubeGeometry;
		exports.TubeBufferGeometry = TubeBufferGeometry;
		exports.TorusKnotGeometry = TorusKnotGeometry;
		exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
		exports.TorusGeometry = TorusGeometry;
		exports.TorusBufferGeometry = TorusBufferGeometry;
		exports.TextGeometry = TextGeometry;
		exports.SphereBufferGeometry = SphereBufferGeometry;
		exports.SphereGeometry = SphereGeometry;
		exports.RingGeometry = RingGeometry;
		exports.RingBufferGeometry = RingBufferGeometry;
		exports.PlaneBufferGeometry = PlaneBufferGeometry;
		exports.PlaneGeometry = PlaneGeometry;
		exports.LatheGeometry = LatheGeometry;
		exports.LatheBufferGeometry = LatheBufferGeometry;
		exports.ShapeGeometry = ShapeGeometry;
		exports.ExtrudeGeometry = ExtrudeGeometry;
		exports.EdgesGeometry = EdgesGeometry;
		exports.ConeGeometry = ConeGeometry;
		exports.ConeBufferGeometry = ConeBufferGeometry;
		exports.CylinderGeometry = CylinderGeometry;
		exports.CylinderBufferGeometry = CylinderBufferGeometry;
		exports.CircleBufferGeometry = CircleBufferGeometry;
		exports.CircleGeometry = CircleGeometry;
		exports.BoxBufferGeometry = BoxBufferGeometry;
		exports.BoxGeometry = BoxGeometry;
		exports.ShadowMaterial = ShadowMaterial;
		exports.SpriteMaterial = SpriteMaterial;
		exports.RawShaderMaterial = RawShaderMaterial;
		exports.ShaderMaterial = ShaderMaterial;
		exports.PointsMaterial = PointsMaterial;
		exports.MultiMaterial = MultiMaterial;
		exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
		exports.MeshStandardMaterial = MeshStandardMaterial;
		exports.MeshPhongMaterial = MeshPhongMaterial;
		exports.MeshNormalMaterial = MeshNormalMaterial;
		exports.MeshLambertMaterial = MeshLambertMaterial;
		exports.MeshDepthMaterial = MeshDepthMaterial;
		exports.MeshBasicMaterial = MeshBasicMaterial;
		exports.LineDashedMaterial = LineDashedMaterial;
		exports.LineBasicMaterial = LineBasicMaterial;
		exports.Material = Material;
		exports.REVISION = REVISION;
		exports.MOUSE = MOUSE;
		exports.CullFaceNone = CullFaceNone;
		exports.CullFaceBack = CullFaceBack;
		exports.CullFaceFront = CullFaceFront;
		exports.CullFaceFrontBack = CullFaceFrontBack;
		exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
		exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
		exports.BasicShadowMap = BasicShadowMap;
		exports.PCFShadowMap = PCFShadowMap;
		exports.PCFSoftShadowMap = PCFSoftShadowMap;
		exports.FrontSide = FrontSide;
		exports.BackSide = BackSide;
		exports.DoubleSide = DoubleSide;
		exports.FlatShading = FlatShading;
		exports.SmoothShading = SmoothShading;
		exports.NoColors = NoColors;
		exports.FaceColors = FaceColors;
		exports.VertexColors = VertexColors;
		exports.NoBlending = NoBlending;
		exports.NormalBlending = NormalBlending;
		exports.AdditiveBlending = AdditiveBlending;
		exports.SubtractiveBlending = SubtractiveBlending;
		exports.MultiplyBlending = MultiplyBlending;
		exports.CustomBlending = CustomBlending;
		exports.BlendingMode = BlendingMode;
		exports.AddEquation = AddEquation;
		exports.SubtractEquation = SubtractEquation;
		exports.ReverseSubtractEquation = ReverseSubtractEquation;
		exports.MinEquation = MinEquation;
		exports.MaxEquation = MaxEquation;
		exports.ZeroFactor = ZeroFactor;
		exports.OneFactor = OneFactor;
		exports.SrcColorFactor = SrcColorFactor;
		exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
		exports.SrcAlphaFactor = SrcAlphaFactor;
		exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
		exports.DstAlphaFactor = DstAlphaFactor;
		exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
		exports.DstColorFactor = DstColorFactor;
		exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
		exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
		exports.NeverDepth = NeverDepth;
		exports.AlwaysDepth = AlwaysDepth;
		exports.LessDepth = LessDepth;
		exports.LessEqualDepth = LessEqualDepth;
		exports.EqualDepth = EqualDepth;
		exports.GreaterEqualDepth = GreaterEqualDepth;
		exports.GreaterDepth = GreaterDepth;
		exports.NotEqualDepth = NotEqualDepth;
		exports.MultiplyOperation = MultiplyOperation;
		exports.MixOperation = MixOperation;
		exports.AddOperation = AddOperation;
		exports.NoToneMapping = NoToneMapping;
		exports.LinearToneMapping = LinearToneMapping;
		exports.ReinhardToneMapping = ReinhardToneMapping;
		exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
		exports.CineonToneMapping = CineonToneMapping;
		exports.UVMapping = UVMapping;
		exports.CubeReflectionMapping = CubeReflectionMapping;
		exports.CubeRefractionMapping = CubeRefractionMapping;
		exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
		exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
		exports.SphericalReflectionMapping = SphericalReflectionMapping;
		exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
		exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
		exports.TextureMapping = TextureMapping;
		exports.RepeatWrapping = RepeatWrapping;
		exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
		exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
		exports.TextureWrapping = TextureWrapping;
		exports.NearestFilter = NearestFilter;
		exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
		exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
		exports.LinearFilter = LinearFilter;
		exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
		exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
		exports.TextureFilter = TextureFilter;
		exports.UnsignedByteType = UnsignedByteType;
		exports.ByteType = ByteType;
		exports.ShortType = ShortType;
		exports.UnsignedShortType = UnsignedShortType;
		exports.IntType = IntType;
		exports.UnsignedIntType = UnsignedIntType;
		exports.FloatType = FloatType;
		exports.HalfFloatType = HalfFloatType;
		exports.UnsignedShort4444Type = UnsignedShort4444Type;
		exports.UnsignedShort5551Type = UnsignedShort5551Type;
		exports.UnsignedShort565Type = UnsignedShort565Type;
		exports.UnsignedInt248Type = UnsignedInt248Type;
		exports.AlphaFormat = AlphaFormat;
		exports.RGBFormat = RGBFormat;
		exports.RGBAFormat = RGBAFormat;
		exports.LuminanceFormat = LuminanceFormat;
		exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
		exports.RGBEFormat = RGBEFormat;
		exports.DepthFormat = DepthFormat;
		exports.DepthStencilFormat = DepthStencilFormat;
		exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
		exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
		exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
		exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
		exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
		exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
		exports.RGB_ETC1_Format = RGB_ETC1_Format;
		exports.LoopOnce = LoopOnce;
		exports.LoopRepeat = LoopRepeat;
		exports.LoopPingPong = LoopPingPong;
		exports.InterpolateDiscrete = InterpolateDiscrete;
		exports.InterpolateLinear = InterpolateLinear;
		exports.InterpolateSmooth = InterpolateSmooth;
		exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
		exports.ZeroSlopeEnding = ZeroSlopeEnding;
		exports.WrapAroundEnding = WrapAroundEnding;
		exports.TrianglesDrawMode = TrianglesDrawMode;
		exports.TriangleStripDrawMode = TriangleStripDrawMode;
		exports.TriangleFanDrawMode = TriangleFanDrawMode;
		exports.LinearEncoding = LinearEncoding;
		exports.sRGBEncoding = sRGBEncoding;
		exports.GammaEncoding = GammaEncoding;
		exports.RGBEEncoding = RGBEEncoding;
		exports.LogLuvEncoding = LogLuvEncoding;
		exports.RGBM7Encoding = RGBM7Encoding;
		exports.RGBM16Encoding = RGBM16Encoding;
		exports.RGBDEncoding = RGBDEncoding;
		exports.BasicDepthPacking = BasicDepthPacking;
		exports.RGBADepthPacking = RGBADepthPacking;
		exports.CubeGeometry = BoxGeometry;
		exports.Face4 = Face4;
		exports.LineStrip = LineStrip;
		exports.LinePieces = LinePieces;
		exports.MeshFaceMaterial = MultiMaterial;
		exports.PointCloud = PointCloud;
		exports.Particle = Sprite;
		exports.ParticleSystem = ParticleSystem;
		exports.PointCloudMaterial = PointCloudMaterial;
		exports.ParticleBasicMaterial = ParticleBasicMaterial;
		exports.ParticleSystemMaterial = ParticleSystemMaterial;
		exports.Vertex = Vertex;
		exports.EdgesHelper = EdgesHelper;
		exports.WireframeHelper = WireframeHelper;
		exports.GeometryUtils = GeometryUtils;
		exports.ImageUtils = ImageUtils;
		exports.Projector = Projector;
		exports.CanvasRenderer = CanvasRenderer;

		Object.defineProperty(exports, '__esModule', { value: true });

		Object.defineProperty( exports, 'AudioContext', {
			get: function () {
				return exports.getAudioContext();
			}
		});

	})));


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define("Navigo", [], factory);
		else if(typeof exports === 'object')
			exports["Navigo"] = factory();
		else
			root["Navigo"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports) {

		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }
		
		var PARAMETER_REGEXP = /([:*])(\w+)/g;
		var WILDCARD_REGEXP = /\*/g;
		var REPLACE_VARIABLE_REGEXP = '([^\/]+)';
		var REPLACE_WILDCARD = '(?:.*)';
		var FOLLOWED_BY_SLASH_REGEXP = '(?:\/$|$)';
		
		function clean(s) {
		  if (s instanceof RegExp) return s;
		  return s.replace(/\/+$/, '').replace(/^\/+/, '/');
		}
		
		function regExpResultToParams(match, names) {
		  if (names.length === 0) return null;
		  if (!match) return null;
		  return match.slice(1, match.length).reduce(function (params, value, index) {
		    if (params === null) params = {};
		    params[names[index]] = value;
		    return params;
		  }, null);
		}
		
		function replaceDynamicURLParts(route) {
		  var paramNames = [],
		      regexp;
		
		  if (route instanceof RegExp) {
		    regexp = route;
		  } else {
		    regexp = new RegExp(clean(route).replace(PARAMETER_REGEXP, function (full, dots, name) {
		      paramNames.push(name);
		      return REPLACE_VARIABLE_REGEXP;
		    }).replace(WILDCARD_REGEXP, REPLACE_WILDCARD) + FOLLOWED_BY_SLASH_REGEXP);
		  }
		  return { regexp: regexp, paramNames: paramNames };
		}
		
		function getUrlDepth(url) {
		  return url.replace(/\/$/, '').split('/').length;
		}
		
		function compareUrlDepth(urlA, urlB) {
		  return getUrlDepth(urlA) < getUrlDepth(urlB);
		}
		
		function findMatchedRoutes(url) {
		  var routes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		
		  return routes.map(function (route) {
		    var _replaceDynamicURLPar = replaceDynamicURLParts(route.route),
		        regexp = _replaceDynamicURLPar.regexp,
		        paramNames = _replaceDynamicURLPar.paramNames;
		
		    var match = url.match(regexp);
		    var params = regExpResultToParams(match, paramNames);
		
		    return match ? { match: match, route: route, params: params } : false;
		  }).filter(function (m) {
		    return m;
		  });
		}
		
		function match(url, routes) {
		  return findMatchedRoutes(url, routes)[0] || false;
		}
		
		function root(url, routes) {
		  var matched = findMatchedRoutes(url, routes.filter(function (route) {
		    var u = clean(route.route);
		
		    return u !== '' && u !== '*';
		  }));
		  var fallbackURL = clean(url);
		
		  if (matched.length > 0) {
		    return matched.map(function (m) {
		      return clean(url.substr(0, m.match.index));
		    }).reduce(function (root, current) {
		      return current.length < root.length ? current : root;
		    }, fallbackURL);
		  }
		  return fallbackURL;
		}
		
		function isPushStateAvailable() {
		  return !!(typeof window !== 'undefined' && window.history && window.history.pushState);
		}
		
		function isHashChangeAPIAvailable() {
		  return !!(typeof window !== 'undefined' && 'onhashchange' in window);
		}
		
		function extractGETParameters(url, useHash) {
		  var _url$split = url.split(/\?(.*)?$/),
		      _url$split2 = _toArray(_url$split),
		      onlyURL = _url$split2[0],
		      query = _url$split2.slice(1);
		
		  if (!useHash) {
		    onlyURL = onlyURL.split('#')[0];
		  }
		  return { onlyURL: onlyURL, GETParameters: query.join('') };
		}
		
		function manageHooks(handler, route) {
		  if (route && route.hooks && _typeof(route.hooks) === 'object') {
		    if (route.hooks.before) {
		      route.hooks.before(function () {
		        var shouldRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
		
		        if (!shouldRoute) return;
		        handler();
		        route.hooks.after && route.hooks.after();
		      });
		    } else if (route.hooks.after) {
		      handler();
		      route.hooks.after && route.hooks.after();
		    }
		    return;
		  }
		  handler();
		};
		
		function Navigo(r, useHash) {
		  this._routes = [];
		  this.root = useHash && r ? r.replace(/\/$/, '/#') : r || null;
		  this._useHash = useHash;
		  this._paused = false;
		  this._destroyed = false;
		  this._lastRouteResolved = null;
		  this._notFoundHandler = null;
		  this._defaultHandler = null;
		  this._usePushState = !useHash && isPushStateAvailable();
		  this._listen();
		  this.updatePageLinks();
		}
		
		Navigo.prototype = {
		  helpers: {
		    match: match,
		    root: root,
		    clean: clean
		  },
		  navigate: function navigate(path, absolute) {
		    var to;
		
		    path = path || '';
		    if (this._usePushState) {
		      to = (!absolute ? this._getRoot() + '/' : '') + path.replace(/^\/+/, '/');
		      to = to.replace(/([^:])(\/{2,})/g, '$1/');
		      history[this._paused ? 'replaceState' : 'pushState']({}, '', to);
		      this.resolve();
		    } else if (typeof window !== 'undefined') {
		      window.location.href = window.location.href.replace(/#(.*)$/, '') + '#' + path;
		    }
		    return this;
		  },
		  on: function on() {
		    var _this = this;
		
		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }
		
		    if (typeof args[0] === 'function') {
		      this._defaultHandler = { handler: args[0], hooks: args[1] };
		    } else if (args.length >= 2) {
		      if (args[0] === '/') {
		        this._defaultHandler = { handler: args[1], hooks: args[2] };
		      } else {
		        this._add(args[0], args[1], args[2]);
		      }
		    } else if (_typeof(args[0]) === 'object') {
		      var orderedRoutes = Object.keys(args[0]).sort(compareUrlDepth);
		
		      orderedRoutes.forEach(function (route) {
		        _this._add(route, args[0][route]);
		      });
		    }
		    return this;
		  },
		  notFound: function notFound(handler, hooks) {
		    this._notFoundHandler = { handler: handler, hooks: hooks };
		    return this;
		  },
		  resolve: function resolve(current) {
		    var _this2 = this;
		
		    var handler, m;
		    var url = (current || this._cLoc()).replace(this._getRoot(), '');
		
		    if (this._useHash) {
		      url = url.replace(/^\/#/, '/');
		    }
		
		    var _extractGETParameters = extractGETParameters(url, this._useHash),
		        onlyURL = _extractGETParameters.onlyURL,
		        GETParameters = _extractGETParameters.GETParameters;
		
		    if (this._paused || this._lastRouteResolved && onlyURL === this._lastRouteResolved.url && GETParameters === this._lastRouteResolved.query) {
		      return false;
		    }
		
		    m = match(onlyURL, this._routes);
		
		    if (m) {
		      this._lastRouteResolved = { url: onlyURL, query: GETParameters };
		      handler = m.route.handler;
		      manageHooks(function () {
		        m.route.route instanceof RegExp ? handler.apply(undefined, _toConsumableArray(m.match.slice(1, m.match.length))) : handler(m.params, GETParameters);
		      }, m.route);
		      return m;
		    } else if (this._defaultHandler && (onlyURL === '' || onlyURL === '/')) {
		      manageHooks(function () {
		        _this2._lastRouteResolved = { url: onlyURL, query: GETParameters };
		        _this2._defaultHandler.handler(GETParameters);
		      }, this._defaultHandler);
		      return true;
		    } else if (this._notFoundHandler) {
		      manageHooks(function () {
		        _this2._lastRouteResolved = { url: onlyURL, query: GETParameters };
		        _this2._notFoundHandler.handler(GETParameters);
		      }, this._notFoundHandler);
		    }
		    return false;
		  },
		  destroy: function destroy() {
		    this._routes = [];
		    this._destroyed = true;
		    clearTimeout(this._listenningInterval);
		    typeof window !== 'undefined' ? window.onpopstate = null : null;
		  },
		  updatePageLinks: function updatePageLinks() {
		    var self = this;
		
		    if (typeof document === 'undefined') return;
		
		    this._findLinks().forEach(function (link) {
		      if (!link.hasListenerAttached) {
		        link.addEventListener('click', function (e) {
		          var location = link.getAttribute('href');
		
		          if (!self._destroyed) {
		            e.preventDefault();
		            self.navigate(clean(location));
		          }
		        });
		        link.hasListenerAttached = true;
		      }
		    });
		  },
		  generate: function generate(name) {
		    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		
		    return this._routes.reduce(function (result, route) {
		      var key;
		
		      if (route.name === name) {
		        result = route.route;
		        for (key in data) {
		          result = result.replace(':' + key, data[key]);
		        }
		      }
		      return result;
		    }, '');
		  },
		  link: function link(path) {
		    return this._getRoot() + path;
		  },
		  pause: function pause(status) {
		    this._paused = status;
		  },
		  disableIfAPINotAvailable: function disableIfAPINotAvailable() {
		    if (!isPushStateAvailable()) {
		      this.destroy();
		    }
		  },
		  _add: function _add(route) {
		    var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
		    var hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
		
		    if ((typeof handler === 'undefined' ? 'undefined' : _typeof(handler)) === 'object') {
		      this._routes.push({
		        route: route,
		        handler: handler.uses,
		        name: handler.as,
		        hooks: hooks || handler.hooks
		      });
		    } else {
		      this._routes.push({ route: route, handler: handler, hooks: hooks });
		    }
		    return this._add;
		  },
		  _getRoot: function _getRoot() {
		    if (this.root !== null) return this.root;
		    this.root = root(this._cLoc(), this._routes);
		    return this.root;
		  },
		  _listen: function _listen() {
		    var _this3 = this;
		
		    if (this._usePushState) {
		      window.onpopstate = function () {
		        _this3.resolve();
		      };
		    } else if (isHashChangeAPIAvailable()) {
		      window.onhashchange = function () {
		        _this3.resolve();
		      };
		    } else {
		      (function () {
		        var cached = _this3._cLoc(),
		            current = void 0,
		            _check = void 0;
		
		        _check = function check() {
		          current = _this3._cLoc();
		          if (cached !== current) {
		            cached = current;
		            _this3.resolve();
		          }
		          _this3._listenningInterval = setTimeout(_check, 200);
		        };
		        _check();
		      })();
		    }
		  },
		  _cLoc: function _cLoc() {
		    if (typeof window !== 'undefined') {
		      return clean(window.location.href);
		    }
		    return '';
		  },
		  _findLinks: function _findLinks() {
		    return [].slice.call(document.querySelectorAll('[data-navigo]'));
		  }
		};
		
		exports.default = Navigo;
		module.exports = exports['default'];

	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=navigo.js.map

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.routes = undefined;

	var _guide = __webpack_require__(8);

	var _locationsList = __webpack_require__(190);

	var _locationsMap = __webpack_require__(194);

	var _location = __webpack_require__(508);

	var _locationMap = __webpack_require__(516);

	var _locationCamera = __webpack_require__(518);

	// NOTE: the order of these _do_ matter


	// Import all route handlers
	var routes = exports.routes = [_locationMap.locationMap, _locationCamera.locationCamera, _location.location, _locationsMap.locationsMap, _locationsList.locationsList, _guide.guide];

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.guide = undefined;

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(39);

	var _app = __webpack_require__(185);

	var _app2 = _interopRequireDefault(_app);

	var _guide = __webpack_require__(186);

	var _guide2 = _interopRequireDefault(_guide);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Before
	function before(state) {
	    return function (done) {
	        (0, _reactDom.unmountComponentAtNode)(state.reactMountNode);
	        state.argonMountNode.style.display = 'none';
	        state.documentRootNode.style.background = 'rgba(255, 255, 255, 0.8)';
	        done();
	    };
	}

	// After
	function after() {
	    return function () {};
	}

	// Guide route
	function route(state) {
	    return function () {
	        console.log('Guide:', state);

	        (0, _reactDom.render)(_react2.default.createElement(
	            _app2.default,
	            { state: state },
	            _react2.default.createElement(_guide2.default, null)
	        ), state.reactMountNode);
	    };
	}

	// Export the route handlers
	var guide = exports.guide = {
	    urls: ['/*'],
	    route: route,
	    hooks: function hooks(state) {
	        return { before: before(state), after: after(state) };
	    }
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(10);


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var ReactChildren = __webpack_require__(12);
	var ReactComponent = __webpack_require__(25);
	var ReactPureComponent = __webpack_require__(28);
	var ReactClass = __webpack_require__(29);
	var ReactDOMFactories = __webpack_require__(31);
	var ReactElement = __webpack_require__(16);
	var ReactPropTypes = __webpack_require__(36);
	var ReactVersion = __webpack_require__(37);

	var onlyChild = __webpack_require__(38);
	var warning = __webpack_require__(18);

	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;

	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(32);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}

	var __spread = _assign;

	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function () {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}

	var React = {

	  // Modern

	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },

	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,

	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,

	  // Classic

	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },

	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,

	  version: ReactVersion,

	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};

	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var PooledClass = __webpack_require__(13);
	var ReactElement = __webpack_require__(16);

	var emptyFunction = __webpack_require__(19);
	var traverseAllChildren = __webpack_require__(22);

	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;

	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;

	  func.call(context, child, bookKeeping.count++);
	}

	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;


	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}

	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}

	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}

	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}

	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}

	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}

	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};

	module.exports = ReactChildren;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(14);

	var invariant = __webpack_require__(15);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};

	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 14 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';

	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */

	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;

	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }

	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

	  throw error;
	}

	module.exports = reactProdInvariant;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var ReactCurrentOwner = __webpack_require__(17);

	var warning = __webpack_require__(18);
	var canDefineProperty = __webpack_require__(20);
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	var REACT_ELEMENT_TYPE = __webpack_require__(21);

	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};

	var specialPropKeyWarningShown, specialPropRefWarningShown;

	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}

	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}

	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}

	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}

	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,

	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,

	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};

	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }

	  return element;
	};

	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;

	  // Reserved names are extracted
	  var props = {};

	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }

	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};

	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};

	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

	  return newElement;
	};

	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;

	  // Original props are copied
	  var props = _assign({}, element.props);

	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;

	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};

	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};

	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 17 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {

	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null

	};

	module.exports = ReactCurrentOwner;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyFunction = __webpack_require__(19);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };

	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }

	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }

	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }

	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}

	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    // $FlowFixMe https://github.com/facebook/flow/issues/285
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}

	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.

	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(14);

	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(21);

	var getIteratorFn = __webpack_require__(23);
	var invariant = __webpack_require__(15);
	var KeyEscapeUtils = __webpack_require__(24);
	var warning = __webpack_require__(18);

	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';

	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var didWarnAboutMaps = false;

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 23 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/* global Symbol */

	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;

/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */

	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });

	  return '$' + escapedString;
	}

	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}

	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};

	module.exports = KeyEscapeUtils;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(14);

	var ReactNoopUpdateQueue = __webpack_require__(26);

	var canDefineProperty = __webpack_require__(20);
	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	ReactComponent.prototype.isReactComponent = {};

	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};

	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};

	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}

	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var warning = __webpack_require__(18);

	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}

	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};

	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyObject = {};

	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}

	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var ReactComponent = __webpack_require__(25);
	var ReactNoopUpdateQueue = __webpack_require__(26);

	var emptyObject = __webpack_require__(27);

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;

	module.exports = ReactPureComponent;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(14),
	    _assign = __webpack_require__(11);

	var ReactComponent = __webpack_require__(25);
	var ReactElement = __webpack_require__(16);
	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactNoopUpdateQueue = __webpack_require__(26);

	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	var MIXINS_KEY = 'mixins';

	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}

	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */


	var injectedMixins = [];

	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {

	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: 'DEFINE_MANY',

	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: 'DEFINE_MANY',

	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: 'DEFINE_MANY',

	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: 'DEFINE_MANY',

	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: 'DEFINE_MANY',

	  // ==== Definition methods ====

	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: 'DEFINE_MANY_MERGED',

	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: 'DEFINE_MANY_MERGED',

	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: 'DEFINE_MANY_MERGED',

	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: 'DEFINE_ONCE',

	  // ==== Delegate methods ====

	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: 'DEFINE_MANY',

	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: 'DEFINE_MANY',

	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: 'DEFINE_MANY',

	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: 'DEFINE_ONCE',

	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: 'DEFINE_MANY',

	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: 'DEFINE_MANY',

	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: 'DEFINE_MANY',

	  // ==== Advanced methods ====

	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: 'OVERRIDE_BASE'

	};

	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, 'childContext');
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, 'context');
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, 'prop');
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };

	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}

	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }

	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}

	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec;
	      var isMixinValid = typeofSpec === 'object' && spec !== null;

	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }

	    return;
	  }

	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;

	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }

	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }

	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }

	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);

	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];

	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === 'DEFINE_MANY_MERGED') {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === 'DEFINE_MANY') {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}

	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }

	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}

	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}

	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}

	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}

	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}

	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}

	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {

	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  }
	};

	var ReactClassComponent = function () {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {

	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.

	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }

	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }

	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;

	      this.state = null;

	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.

	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];

	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

	    mixSpecIntoComponent(Constructor, spec);

	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }

	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }

	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }

	    return Constructor;
	  },

	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }

	};

	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactElement = __webpack_require__(16);

	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(32);
	  createDOMFactory = ReactElementValidator.createFactory;
	}

	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),

	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};

	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */

	'use strict';

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactComponentTreeHook = __webpack_require__(33);
	var ReactElement = __webpack_require__(16);

	var checkReactTypeSpec = __webpack_require__(34);

	var canDefineProperty = __webpack_require__(20);
	var getIteratorFn = __webpack_require__(23);
	var warning = __webpack_require__(18);

	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};

	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();

	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}

	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;

	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;

	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }

	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}

	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}

	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}

	var ReactElementValidator = {

	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }

	    var element = ReactElement.createElement.apply(this, arguments);

	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }

	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }

	    validatePropTypes(element);

	    return element;
	  },

	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;

	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }

	    return validatedFactory;
	  },

	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }

	};

	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(14);

	var ReactCurrentOwner = __webpack_require__(17);

	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}

	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

	if (canUseCollections) {
	  var itemMap = new Map();
	  var rootIDSet = new Set();

	  var setItem = function (id, item) {
	    itemMap.set(id, item);
	  };
	  var getItem = function (id) {
	    return itemMap.get(id);
	  };
	  var removeItem = function (id) {
	    itemMap['delete'](id);
	  };
	  var getItemIDs = function () {
	    return Array.from(itemMap.keys());
	  };

	  var addRoot = function (id) {
	    rootIDSet.add(id);
	  };
	  var removeRoot = function (id) {
	    rootIDSet['delete'](id);
	  };
	  var getRootIDs = function () {
	    return Array.from(rootIDSet.keys());
	  };
	} else {
	  var itemByKey = {};
	  var rootByKey = {};

	  // Use non-numeric keys to prevent V8 performance issues:
	  // https://github.com/facebook/react/pull/7232
	  var getKeyFromID = function (id) {
	    return '.' + id;
	  };
	  var getIDFromKey = function (key) {
	    return parseInt(key.substr(1), 10);
	  };

	  var setItem = function (id, item) {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  };
	  var getItem = function (id) {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  };
	  var removeItem = function (id) {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  };
	  var getItemIDs = function () {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  };

	  var addRoot = function (id) {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  };
	  var removeRoot = function (id) {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  };
	  var getRootIDs = function () {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  };
	}

	var unmountedIDs = [];

	function purgeDeep(id) {
	  var item = getItem(id);
	  if (item) {
	    var childIDs = item.childIDs;

	    removeItem(id);
	    childIDs.forEach(purgeDeep);
	  }
	}

	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}

	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}

	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}

	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.childIDs = nextChildIDs;

	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = getItem(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent id is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    var item = {
	      element: element,
	      parentID: parentID,
	      text: null,
	      childIDs: [],
	      isMounted: false,
	      updateCount: 0
	    };
	    setItem(id, item);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = getItem(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }

	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = getItem(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var name = getDisplayName(topElement);
	      var owner = topElement._owner;
	      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
	    }

	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;

	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = getItem(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = getItem(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = getItem(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = getItem(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = getItem(id);
	    return item ? item.updateCount : 0;
	  },


	  getRootIDs: getRootIDs,
	  getRegisteredIDs: getItemIDs
	};

	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(14);

	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactPropTypesSecret = __webpack_require__(35);

	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}

	var loggedTypeFailures = {};

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var componentStackInfo = '';

	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(33);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }

	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}

	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 35 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactElement = __webpack_require__(16);
	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactPropTypesSecret = __webpack_require__(35);

	var emptyFunction = __webpack_require__(19);
	var getIteratorFn = __webpack_require__(23);
	var warning = __webpack_require__(18);

	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */

	var ANONYMOUS = '<<anonymous>>';

	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),

	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/

	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;

	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        if (props[propName] === null) {
	          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	        }
	        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }

	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);

	  return chainedCheckType;
	}

	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);

	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}

	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }

	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }

	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}

	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }

	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }

	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}

	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }

	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }

	      return true;
	    default:
	      return false;
	  }
	}

	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }

	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }

	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }

	  return false;
	}

	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}

	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}

	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}

	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 37 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	module.exports = '15.4.0';

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	'use strict';

	var _prodInvariant = __webpack_require__(14);

	var ReactElement = __webpack_require__(16);

	var invariant = __webpack_require__(15);

	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}

	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(40);


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

	'use strict';

	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDefaultInjection = __webpack_require__(45);
	var ReactMount = __webpack_require__(173);
	var ReactReconciler = __webpack_require__(66);
	var ReactUpdates = __webpack_require__(63);
	var ReactVersion = __webpack_require__(178);

	var findDOMNode = __webpack_require__(179);
	var getHostComponentFromComposite = __webpack_require__(180);
	var renderSubtreeIntoContainer = __webpack_require__(181);
	var warning = __webpack_require__(18);

	ReactDefaultInjection.inject();

	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,

	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};

	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}

	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(55);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }

	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}

	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(69);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(182);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(183);
	  var ReactDOMInvalidARIAHook = __webpack_require__(184);

	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}

	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var DOMProperty = __webpack_require__(43);
	var ReactDOMComponentFlags = __webpack_require__(44);

	var invariant = __webpack_require__(15);

	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;

	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}

	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}

	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}

	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}

	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }

	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }

	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }

	  return closest;
	}

	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}

	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

	  if (inst._hostNode) {
	    return inst._hostNode;
	  }

	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }

	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }

	  return inst._hostNode;
	}

	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};

	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';

	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */

	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;

	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }

	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

	  throw error;
	}

	module.exports = reactProdInvariant;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var invariant = __webpack_require__(15);

	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}

	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }

	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];

	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,

	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }

	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }

	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }

	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }

	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }

	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};

	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */

	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {

	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},

	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,

	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],

	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },

	  injection: DOMPropertyInjection
	};

	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};

	module.exports = ReactDOMComponentFlags;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ARIADOMPropertyConfig = __webpack_require__(46);
	var BeforeInputEventPlugin = __webpack_require__(47);
	var ChangeEventPlugin = __webpack_require__(62);
	var DefaultEventPluginOrder = __webpack_require__(79);
	var EnterLeaveEventPlugin = __webpack_require__(80);
	var HTMLDOMPropertyConfig = __webpack_require__(85);
	var ReactComponentBrowserEnvironment = __webpack_require__(86);
	var ReactDOMComponent = __webpack_require__(99);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMEmptyComponent = __webpack_require__(144);
	var ReactDOMTreeTraversal = __webpack_require__(145);
	var ReactDOMTextComponent = __webpack_require__(146);
	var ReactDefaultBatchingStrategy = __webpack_require__(147);
	var ReactEventListener = __webpack_require__(148);
	var ReactInjection = __webpack_require__(151);
	var ReactReconcileTransaction = __webpack_require__(152);
	var SVGDOMPropertyConfig = __webpack_require__(160);
	var SelectEventPlugin = __webpack_require__(161);
	var SimpleEventPlugin = __webpack_require__(162);

	var alreadyInjected = false;

	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;

	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });

	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });

	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}

	module.exports = {
	  inject: inject
	};

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};

	module.exports = ARIADOMPropertyConfig;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var FallbackCompositionState = __webpack_require__(56);
	var SyntheticCompositionEvent = __webpack_require__(59);
	var SyntheticInputEvent = __webpack_require__(61);

	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;

	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}

	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}

	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};

	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;

	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}

	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}

	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}

	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}

	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}

	// Track the current IME composition fallback object, if any.
	var currentComposition = null;

	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;

	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }

	  if (!eventType) {
	    return null;
	  }

	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }

	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }

	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }

	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;

	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;

	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }

	      return chars;

	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}

	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }

	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}

	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;

	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }

	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }

	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {

	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};

	module.exports = BeforeInputEventPlugin;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(49);
	var EventPluginUtils = __webpack_require__(51);

	var accumulateInto = __webpack_require__(53);
	var forEachAccumulated = __webpack_require__(54);
	var warning = __webpack_require__(18);

	var getListener = EventPluginHub.getListener;

	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}

	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}

	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}

	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}

	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}

	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}

	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}

	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}

	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};

	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var EventPluginRegistry = __webpack_require__(50);
	var EventPluginUtils = __webpack_require__(51);
	var ReactErrorUtils = __webpack_require__(52);

	var accumulateInto = __webpack_require__(53);
	var forEachAccumulated = __webpack_require__(54);
	var invariant = __webpack_require__(15);

	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};

	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;

	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);

	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};

	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};

	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {

	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {

	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

	  },

	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;

	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },

	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },

	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }

	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },

	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }

	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }

	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }

	      delete listenerBank[registrationName][key];
	    }
	  },

	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },

	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },

	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },

	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },

	  __getListenerBank: function () {
	    return listenerBank;
	  }

	};

	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var invariant = __webpack_require__(15);

	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;

	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};

	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}

	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}

	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}

	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {

	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],

	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},

	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},

	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},

	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__

	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (injectedEventPluginOrder) {
	    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },

	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },

	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },

	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;

	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }

	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }

	};

	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var ReactErrorUtils = __webpack_require__(52);

	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	/**
	 * Injected dependencies:
	 */

	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};

	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}

	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}

	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;

	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}

	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}

	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}

	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}

	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}

	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,

	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,

	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },

	  injection: injection
	};

	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var caughtError = null;

	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}

	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,

	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};

	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = func.bind(null, a);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      // $FlowFixMe https://github.com/facebook/flow/issues/2336
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}

	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var invariant = __webpack_require__(15);

	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */

	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

	  if (current == null) {
	    return next;
	  }

	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }

	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }

	  return [current, next];
	}

	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 54 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */

	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}

	module.exports = forEachAccumulated;

/***/ },
/* 55 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {

	  canUseDOM: canUseDOM,

	  canUseWorkers: typeof Worker !== 'undefined',

	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

	  canUseViewport: canUseDOM && !!window.screen,

	  isInWorker: !canUseDOM // For now, this is true - might change in the future.

	};

	module.exports = ExecutionEnvironment;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var PooledClass = __webpack_require__(57);

	var getTextContentAccessor = __webpack_require__(58);

	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}

	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },

	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },

	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }

	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;

	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }

	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }

	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});

	PooledClass.addPoolingTo(FallbackCompositionState);

	module.exports = FallbackCompositionState;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var invariant = __webpack_require__(15);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};

	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(55);

	var contentKey = null;

	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}

	module.exports = getTextContentAccessor;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(60);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

	module.exports = SyntheticCompositionEvent;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var PooledClass = __webpack_require__(57);

	var emptyFunction = __webpack_require__(19);
	var warning = __webpack_require__(18);

	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';

	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};

	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }

	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;

	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }

	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}

	_assign(SyntheticEvent.prototype, {

	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }

	    if (event.preventDefault) {
	      event.preventDefault();
	    } else if (typeof event.returnValue !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },

	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }

	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }

	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,

	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }

	});

	SyntheticEvent.Interface = EventInterface;

	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;

	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();

	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;

	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;

	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};

	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

	module.exports = SyntheticEvent;

	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };

	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }

	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }

	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(60);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

	module.exports = SyntheticInputEvent;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(49);
	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	var SyntheticEvent = __webpack_require__(60);

	var getEventTarget = __webpack_require__(76);
	var isEventSupported = __webpack_require__(77);
	var isTextInputElement = __webpack_require__(78);

	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};

	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;

	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}

	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}

	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);

	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}

	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}

	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}

	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}

	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}

	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
	}

	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};

	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}

	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }

	  // delete restores the original property definition
	  delete activeElement.value;

	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }

	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}

	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;

	  manualDispatchChangeEvent(nativeEvent);
	}

	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topInput') {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}

	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}

	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}

	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}

	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topClick') {
	    return targetInst;
	  }
	}

	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {

	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }

	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }

	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }

	};

	module.exports = ChangeEventPlugin;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);

	var CallbackQueue = __webpack_require__(64);
	var PooledClass = __webpack_require__(57);
	var ReactFeatureFlags = __webpack_require__(65);
	var ReactReconciler = __webpack_require__(66);
	var Transaction = __webpack_require__(75);

	var invariant = __webpack_require__(15);

	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;

	var batchingStrategy = null;

	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}

	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};

	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};

	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}

	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },

	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});

	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}

	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}

	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);

	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;

	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];

	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;

	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }

	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

	    if (markerName) {
	      console.timeEnd(markerName);
	    }

	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}

	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }

	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};

	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();

	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)

	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }

	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}

	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}

	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },

	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};

	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,

	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};

	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var PooledClass = __webpack_require__(57);

	var invariant = __webpack_require__(15);

	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */

	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);

	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }

	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */


	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };

	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */


	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };

	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };

	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };

	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */


	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };

	  /**
	   * `PooledClass` looks for this.
	   */


	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };

	  return CallbackQueue;
	}();

	module.exports = PooledClass.addPoolingTo(CallbackQueue);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 65 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};

	module.exports = ReactFeatureFlags;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactRef = __webpack_require__(67);
	var ReactInstrumentation = __webpack_require__(69);

	var warning = __webpack_require__(18);

	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}

	var ReactReconciler = {

	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },

	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },

	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;

	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.

	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }

	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }

	    internalInstance.receiveComponent(nextElement, transaction, context);

	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },

	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }

	};

	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactOwner = __webpack_require__(68);

	var ReactRef = {};

	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}

	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}

	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};

	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.

	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.

	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && typeof prevElement === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }

	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && typeof nextElement === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }

	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};

	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};

	module.exports = ReactRef;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var invariant = __webpack_require__(15);

	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}

	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },

	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }

	};

	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	// Trust the developer to only use ReactInstrumentation with a __DEV__ check

	var debugTool = null;

	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(70);
	  debugTool = ReactDebugTool;
	}

	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactInvalidSetStateWarningHook = __webpack_require__(71);
	var ReactHostOperationHistoryHook = __webpack_require__(72);
	var ReactComponentTreeHook = __webpack_require__(33);
	var ExecutionEnvironment = __webpack_require__(55);

	var performanceNow = __webpack_require__(73);
	var warning = __webpack_require__(18);

	var hooks = [];
	var didHookThrowForEvent = {};

	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}

	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}

	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = [];
	var currentFlushStartTime = 0;
	var currentTimerDebugID = null;
	var currentTimerStartTime = 0;
	var currentTimerNestedFlushDuration = 0;
	var currentTimerType = null;

	var lifeCycleTimerHasWarned = false;

	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}

	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}

	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements;
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();

	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = 0;
	    currentFlushMeasurements = [];
	    clearHistory();
	    return;
	  }

	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }

	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}

	function checkDebugID(debugID) {
	  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}

	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}

	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}

	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}

	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
	      startTime = _lifeCycleTimerStack$.startTime,
	      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
	      debugID = _lifeCycleTimerStack$.debugID,
	      timerType = _lifeCycleTimerStack$.timerType;

	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}

	var lastMarkTimeStamp = 0;
	var canUsePerformanceMeasure =
	// $FlowFixMe https://github.com/facebook/flow/issues/2345
	typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

	function shouldMark(debugID) {
	  if (!isProfiling || !canUsePerformanceMeasure) {
	    return false;
	  }
	  var element = ReactComponentTreeHook.getElement(debugID);
	  if (element == null || typeof element !== 'object') {
	    return false;
	  }
	  var isHostElement = typeof element.type === 'string';
	  if (isHostElement) {
	    return false;
	  }
	  return true;
	}

	function markBegin(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }

	  var markName = debugID + '::' + markType;
	  lastMarkTimeStamp = performanceNow();
	  performance.mark(markName);
	}

	function markEnd(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }

	  var markName = debugID + '::' + markType;
	  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

	  // Chrome has an issue of dropping markers recorded too fast:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
	  // To work around this, we will not report very small measurements.
	  // I determined the magic number by tweaking it back and forth.
	  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
	  // When the bug is fixed, we can `measure()` unconditionally if we want to.
	  var timeStamp = performanceNow();
	  if (timeStamp - lastMarkTimeStamp > 0.1) {
	    var measurementName = displayName + ' [' + markType + ']';
	    performance.measure(measurementName, markName);
	  }

	  performance.clearMarks(markName);
	  performance.clearMeasures(measurementName);
	}

	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }

	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }

	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    markBegin(debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    markEnd(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (operation) {
	    checkDebugID(operation.instanceID);
	    emitEvent('onHostOperation', operation);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	    markBegin(debugID, 'mount');
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'mount');
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	    markBegin(debugID, 'update');
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'update');
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	    markBegin(debugID, 'unmount');
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'unmount');
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};

	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}

	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var warning = __webpack_require__(18);

	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;

	  var warnInvalidSetState = function () {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}

	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};

	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var history = [];

	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (operation) {
	    history.push(operation);
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }

	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};

	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var performance = __webpack_require__(74);

	var performanceNow;

	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}

	module.exports = performanceNow;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(55);

	var performance;

	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}

	module.exports = performance || {};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var invariant = __webpack_require__(15);

	var OBSERVED_ERROR = {};

	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },

	  _isInTransaction: false,

	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,

	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },

	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },

	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },

	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};

	module.exports = TransactionImpl;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 76 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */

	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;

	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }

	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}

	module.exports = getEventTarget;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(55);

	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}

	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }

	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;

	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }

	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }

	  return isSupported;
	}

	module.exports = isEventSupported;

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */

	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};

	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }

	  if (nodeName === 'textarea') {
	    return true;
	  }

	  return false;
	}

	module.exports = isTextInputElement;

/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */

	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

	module.exports = DefaultEventPluginOrder;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(48);
	var ReactDOMComponentTree = __webpack_require__(41);
	var SyntheticMouseEvent = __webpack_require__(81);

	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};

	var EnterLeaveEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }

	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }

	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }

	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }

	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;

	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;

	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

	    return [leave, enter];
	  }

	};

	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(82);
	var ViewportMetrics = __webpack_require__(83);

	var getEventModifierState = __webpack_require__(84);

	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

	module.exports = SyntheticMouseEvent;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(60);

	var getEventTarget = __webpack_require__(76);

	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }

	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }

	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

	module.exports = SyntheticUIEvent;

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ViewportMetrics = {

	  currentScrollLeft: 0,

	  currentScrollTop: 0,

	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }

	};

	module.exports = ViewportMetrics;

/***/ },
/* 84 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */

	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};

	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}

	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}

	module.exports = getEventModifierState;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(43);

	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,

	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,

	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};

	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMChildrenOperations = __webpack_require__(87);
	var ReactDOMIDOperations = __webpack_require__(98);

	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {

	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

	};

	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMLazyTree = __webpack_require__(88);
	var Danger = __webpack_require__(94);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstrumentation = __webpack_require__(69);

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	var setInnerHTML = __webpack_require__(90);
	var setTextContent = __webpack_require__(92);

	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}

	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});

	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}

	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}

	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}

	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}

	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}

	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}

	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}

	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {

	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

	  replaceDelimitedText: replaceDelimitedText,

	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }

	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: { toIndex: update.toIndex, content: update.content.toString() }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }

	};

	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMNamespaces = __webpack_require__(89);
	var setInnerHTML = __webpack_require__(90);

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	var setTextContent = __webpack_require__(92);

	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}

	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});

	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}

	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}

	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}

	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}

	function toString() {
	  return this.node.nodeName;
	}

	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}

	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;

	module.exports = DOMLazyTree;

/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};

	module.exports = DOMNamespaces;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(55);
	var DOMNamespaces = __webpack_require__(89);

	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);

	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;

	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});

	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }

	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;

	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}

	module.exports = setInnerHTML;

/***/ },
/* 91 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/* globals MSApp */

	'use strict';

	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */

	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};

	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(55);
	var escapeTextContentForBrowser = __webpack_require__(93);
	var setInnerHTML = __webpack_require__(90);

	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;

	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};

	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}

	module.exports = setTextContent;

/***/ },
/* 93 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */

	'use strict';

	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */

	var matchHtmlRegExp = /["'&<>]/;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html


	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}

	module.exports = escapeTextContentForBrowser;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var DOMLazyTree = __webpack_require__(88);
	var ExecutionEnvironment = __webpack_require__(55);

	var createNodesFromMarkup = __webpack_require__(95);
	var emptyFunction = __webpack_require__(19);
	var invariant = __webpack_require__(15);

	var Danger = {

	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }

	};

	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	/*eslint-disable fb-www/unsafe-html*/

	var ExecutionEnvironment = __webpack_require__(55);

	var createArrayFromMixed = __webpack_require__(96);
	var getMarkupWrap = __webpack_require__(97);
	var invariant = __webpack_require__(15);

	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;

	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}

	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);

	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];

	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }

	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }

	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}

	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var invariant = __webpack_require__(15);

	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;

	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }

	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}

	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}

	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}

	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/*eslint-disable fb-www/unsafe-html */

	var ExecutionEnvironment = __webpack_require__(55);

	var invariant = __webpack_require__(15);

	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */

	var shouldWrap = {};

	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],

	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],

	  'optgroup': selectWrap,
	  'option': selectWrap,

	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,

	  'td': trWrap,
	  'th': trWrap
	};

	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});

	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}

	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMChildrenOperations = __webpack_require__(87);
	var ReactDOMComponentTree = __webpack_require__(41);

	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {

	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};

	module.exports = ReactDOMIDOperations;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/* global hasOwnProperty:true */

	'use strict';

	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);

	var AutoFocusUtils = __webpack_require__(100);
	var CSSPropertyOperations = __webpack_require__(102);
	var DOMLazyTree = __webpack_require__(88);
	var DOMNamespaces = __webpack_require__(89);
	var DOMProperty = __webpack_require__(43);
	var DOMPropertyOperations = __webpack_require__(110);
	var EventPluginHub = __webpack_require__(49);
	var EventPluginRegistry = __webpack_require__(50);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactDOMComponentFlags = __webpack_require__(44);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMInput = __webpack_require__(115);
	var ReactDOMOption = __webpack_require__(118);
	var ReactDOMSelect = __webpack_require__(119);
	var ReactDOMTextarea = __webpack_require__(120);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactMultiChild = __webpack_require__(121);
	var ReactServerRenderingTransaction = __webpack_require__(140);

	var emptyFunction = __webpack_require__(19);
	var escapeTextContentForBrowser = __webpack_require__(93);
	var invariant = __webpack_require__(15);
	var isEventSupported = __webpack_require__(77);
	var shallowEqual = __webpack_require__(130);
	var validateDOMNesting = __webpack_require__(143);
	var warning = __webpack_require__(18);

	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;

	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };

	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};

	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;

	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}

	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}

	var styleMutationWarning = {};

	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }

	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }

	  var hash = ownerName + '|' + componentName;

	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }

	  styleMutationWarning[hash] = true;

	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}

	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}

	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}

	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}

	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}

	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}

	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}

	var setAndValidateContentChildDev = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setAndValidateContentChildDev = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;

	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }

	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}

	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};

	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':

	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}

	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}

	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.

	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};

	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};

	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.

	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);

	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name

	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;

	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}

	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}

	var globalIdCounter = 1;

	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}

	ReactDOMComponent.displayName = 'ReactDOMComponent';

	ReactDOMComponent.Mixin = {

	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var props = this._currentElement.props;

	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }

	    assertValidProps(this, props);

	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;

	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }

	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }

	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }

	    return mountImage;
	  },

	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;

	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }

	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }

	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },

	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';

	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },

	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },

	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },

	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;

	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }

	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);

	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },

	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },

	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;

	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }

	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setAndValidateContentChildDev.call(this, null);
	      }

	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },

	  getHostNode: function () {
	    return getNode(this);
	  },

	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }

	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;

	    if (process.env.NODE_ENV !== 'production') {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },

	  getPublicInstance: function () {
	    return getNode(this);
	  }

	};

	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMComponentTree = __webpack_require__(41);

	var focusNode = __webpack_require__(101);

	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};

	module.exports = AutoFocusUtils;

/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * @param {DOMElement} node input/textarea to focus
	 */

	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}

	module.exports = focusNode;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var CSSProperty = __webpack_require__(103);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactInstrumentation = __webpack_require__(69);

	var camelizeStyleName = __webpack_require__(104);
	var dangerousStyleValue = __webpack_require__(106);
	var hyphenateStyleName = __webpack_require__(107);
	var memoizeStringOnly = __webpack_require__(109);
	var warning = __webpack_require__(18);

	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});

	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}

	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;

	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;

	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };

	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };

	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }

	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };

	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }

	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };

	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };

	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }

	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}

	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {

	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },

	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }

	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }

	};

	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */

	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,

	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};

	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}

	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});

	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};

	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};

	module.exports = CSSProperty;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	'use strict';

	var camelize = __webpack_require__(105);

	var msPattern = /^-ms-/;

	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}

	module.exports = camelizeStyleName;

/***/ },
/* 105 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var _hyphenPattern = /-(.)/g;

	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}

	module.exports = camelize;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var CSSProperty = __webpack_require__(103);
	var warning = __webpack_require__(18);

	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};

	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901

	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }

	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }

	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}

	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	'use strict';

	var hyphenate = __webpack_require__(108);

	var msPattern = /^ms-/;

	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}

	module.exports = hyphenateStyleName;

/***/ },
/* 108 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var _uppercasePattern = /([A-Z])/g;

	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}

	module.exports = hyphenate;

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */

	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}

	module.exports = memoizeStringOnly;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(43);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstrumentation = __webpack_require__(69);

	var quoteAttributeValueForBrowser = __webpack_require__(111);
	var warning = __webpack_require__(18);

	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};

	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}

	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}

	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {

	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },

	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },

	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },

	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },

	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },

	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },

	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },

	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },

	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },

	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }

	};

	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var escapeTextContentForBrowser = __webpack_require__(93);

	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}

	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var EventPluginRegistry = __webpack_require__(50);
	var ReactEventEmitterMixin = __webpack_require__(113);
	var ViewportMetrics = __webpack_require__(83);

	var getVendorPrefixedEventName = __webpack_require__(114);
	var isEventSupported = __webpack_require__(77);

	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */

	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;

	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};

	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}

	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,

	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },

	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },

	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },

	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {

	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }

	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }

	        isListening[dependency] = true;
	      }
	    }
	  },

	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },

	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },

	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function () {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },

	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }

	});

	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(49);

	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}

	var ReactEventEmitterMixin = {

	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};

	module.exports = ReactEventEmitterMixin;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(55);

	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};

	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

	  return prefixes;
	}

	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};

	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};

	/**
	 * Element to check for prefixes on.
	 */
	var style = {};

	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;

	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }

	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}

	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }

	  var prefixMap = vendorPrefixes[eventName];

	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }

	  return '';
	}

	module.exports = getVendorPrefixedEventName;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);

	var DOMPropertyOperations = __webpack_require__(110);
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);

	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}

	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}

	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);

	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });

	    return hostProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

	      var owner = inst._currentElement._owner;

	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }

	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };

	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;

	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }

	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }

	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {

	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;

	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },

	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.

	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }

	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;

	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);

	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;

	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }

	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }

	  return returnValue;
	}

	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var React = __webpack_require__(10);
	var ReactPropTypesSecret = __webpack_require__(117);

	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};

	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}

	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}

	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: React.PropTypes.func
	};

	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};

	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var React = __webpack_require__(10);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMSelect = __webpack_require__(119);

	var warning = __webpack_require__(18);
	var didWarnInvalidOptionChildren = false;

	function flattenChildren(children) {
	  var content = '';

	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });

	  return content;
	}

	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }

	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;

	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }

	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }

	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }

	    inst._wrapperState = { selected: selected };
	  },

	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },

	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);

	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }

	    var content = flattenChildren(props.children);

	    if (content) {
	      hostProps.children = content;
	    }

	    return hostProps;
	  }

	};

	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);

	var warning = __webpack_require__(18);

	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;

	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;

	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);

	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	var valuePropNames = ['value', 'defaultValue'];

	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);

	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }

	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}

	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}

	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }

	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };

	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },

	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },

	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;

	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);

	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);

	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);

	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}

	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });

	    return hostProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }

	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;

	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }

	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }

	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;

	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },

	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactReconciler = __webpack_require__(66);
	var ReactChildReconciler = __webpack_require__(124);

	var emptyFunction = __webpack_require__(19);
	var flattenChildren = __webpack_require__(139);
	var invariant = __webpack_require__(15);

	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}

	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}

	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}

	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}

	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}

	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {

	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {

	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },

	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },

	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;

	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }

	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }

	      return mountImages;
	    },

	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },

	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },

	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },

	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;

	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },

	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },

	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },

	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },

	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },

	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },

	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }

	  }

	};

	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var invariant = __webpack_require__(15);

	var injected = false;

	var ReactComponentEnvironment = {

	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,

	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,

	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }

	};

	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 123 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */

	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

	var ReactInstanceMap = {

	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },

	  get: function (key) {
	    return key._reactInternalInstance;
	  },

	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },

	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }

	};

	module.exports = ReactInstanceMap;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactReconciler = __webpack_require__(66);

	var instantiateReactComponent = __webpack_require__(125);
	var KeyEscapeUtils = __webpack_require__(135);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var traverseAllChildren = __webpack_require__(136);
	var warning = __webpack_require__(18);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}

	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(33);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}

	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};

	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },

	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },

	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }

	};

	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);

	var ReactCompositeComponent = __webpack_require__(126);
	var ReactEmptyComponent = __webpack_require__(132);
	var ReactHostComponent = __webpack_require__(133);

	var getNextDebugID = __webpack_require__(134);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}

	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;

	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;

	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);

	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }

	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;

	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }

	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }

	  return instance;
	}

	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);

	var React = __webpack_require__(10);
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(52);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactNodeTypes = __webpack_require__(127);
	var ReactReconciler = __webpack_require__(66);

	if (process.env.NODE_ENV !== 'production') {
	  var checkReactTypeSpec = __webpack_require__(128);
	}

	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var shallowEqual = __webpack_require__(130);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var warning = __webpack_require__(18);

	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};

	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};

	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}

	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}

	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}

	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }

	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}

	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */

	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;

	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {

	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;

	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;

	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;

	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;

	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },

	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;

	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);

	    var Component = this._currentElement.type;

	    var updateQueue = transaction.getUpdateQueue();

	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;

	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }

	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';

	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }

	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;

	    this._instance = inst;

	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);

	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }

	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }

	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }

	    return markup;
	  },

	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },

	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;

	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }

	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (process.env.NODE_ENV !== 'production') {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },

	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();

	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);

	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },

	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;

	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }

	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }

	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }

	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;

	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

	    if (process.env.NODE_ENV !== 'production') {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }

	    return markup;
	  },

	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }

	    var inst = this._instance;

	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;

	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }

	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }

	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;

	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;

	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);

	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },

	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;

	    if (inst.getChildContext) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }

	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },

	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },

	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;

	    this._pendingElement = null;

	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },

	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },

	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

	    var willReceive = false;
	    var nextContext;

	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }

	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;

	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }

	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }

	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;

	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }

	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },

	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;

	    if (!queue) {
	      return inst.state;
	    }

	    if (replace && queue.length === 1) {
	      return queue[0];
	    }

	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }

	    return nextState;
	  },

	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;

	    var inst = this._instance;

	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }

	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }

	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;

	    this._updateRenderedComponent(transaction, unmaskedContext);

	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },

	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();

	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }

	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);

	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;

	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

	      if (process.env.NODE_ENV !== 'production') {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }

	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },

	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },

	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedElement;

	    if (process.env.NODE_ENV !== 'production') {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }

	    return renderedElement;
	  },

	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedElement;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

	    return renderedElement;
	  },

	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },

	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },

	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },

	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },

	  // Stub
	  _instantiateReactComponent: null

	};

	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var React = __webpack_require__(10);

	var invariant = __webpack_require__(15);

	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,

	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};

	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var ReactPropTypeLocationNames = __webpack_require__(129);
	var ReactPropTypesSecret = __webpack_require__(117);

	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}

	var loggedTypeFailures = {};

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var componentStackInfo = '';

	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(33);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }

	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}

	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */

	/*eslint-disable no-self-compare */

	'use strict';

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}

	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }

	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }

	  return true;
	}

	module.exports = shallowEqual;

/***/ },
/* 131 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */

	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }

	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}

	module.exports = shouldUpdateReactComponent;

/***/ },
/* 132 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyComponentFactory;

	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};

	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};

	ReactEmptyComponent.injection = ReactEmptyComponentInjection;

	module.exports = ReactEmptyComponent;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);

	var invariant = __webpack_require__(15);

	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;

	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};

	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}

	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}

	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}

	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};

	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 134 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var nextDebugID = 1;

	function getNextDebugID() {
	  return nextDebugID++;
	}

	module.exports = getNextDebugID;

/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */

	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });

	  return '$' + escapedString;
	}

	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}

	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};

	module.exports = KeyEscapeUtils;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(137);

	var getIteratorFn = __webpack_require__(138);
	var invariant = __webpack_require__(15);
	var KeyEscapeUtils = __webpack_require__(135);
	var warning = __webpack_require__(18);

	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';

	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var didWarnAboutMaps = false;

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 137 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.

	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/* global Symbol */

	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var KeyEscapeUtils = __webpack_require__(135);
	var traverseAllChildren = __webpack_require__(136);
	var warning = __webpack_require__(18);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}

	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(33);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}

	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};

	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}

	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var PooledClass = __webpack_require__(57);
	var Transaction = __webpack_require__(75);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactServerUpdateQueue = __webpack_require__(141);

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];

	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}

	var noopCallbackQueue = {
	  enqueue: function () {}
	};

	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },

	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},

	  checkpoint: function () {},

	  rollback: function () {}
	};

	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

	PooledClass.addPoolingTo(ReactServerRenderingTransaction);

	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ReactUpdateQueue = __webpack_require__(142);

	var warning = __webpack_require__(18);

	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}

	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */

	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);

	    this.transaction = transaction;
	  }

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */


	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };

	  return ReactServerUpdateQueue;
	}();

	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactUpdates = __webpack_require__(63);

	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}

	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}

	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }

	  return internalInstance;
	}

	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }

	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },

	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingForceUpdate = true;

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }

	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

	    if (!internalInstance) {
	      return;
	    }

	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);

	    enqueueUpdate(internalInstance);
	  },

	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },

	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }

	};

	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var emptyFunction = __webpack_require__(19);
	var warning = __webpack_require__(18);

	var validateDOMNesting = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.

	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);

	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

	  var emptyAncestorInfo = {
	    current: null,

	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,

	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };

	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };

	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }

	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }

	    ancestorInfo.current = info;

	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }

	    return ancestorInfo;
	  };

	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }

	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;

	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }

	    return true;
	  };

	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':

	      case 'pre':
	      case 'listing':

	      case 'table':

	      case 'hr':

	      case 'xmp':

	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;

	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;

	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;

	      case 'button':
	        return ancestorInfo.buttonTagInScope;

	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;

	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }

	    return null;
	  };

	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }

	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };

	  var didWarn = {};

	  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;

	    if (childText != null) {
	      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }

	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;

	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;

	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);

	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;

	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }

	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;

	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }

	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };

	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}

	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var DOMLazyTree = __webpack_require__(88);
	var ReactDOMComponentTree = __webpack_require__(41);

	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});

	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var invariant = __webpack_require__(15);

	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }

	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }

	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }

	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}

	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}

	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

	  return inst._hostParent;
	}

	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}

	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}

	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);

	var DOMChildrenOperations = __webpack_require__(87);
	var DOMLazyTree = __webpack_require__(88);
	var ReactDOMComponentTree = __webpack_require__(41);

	var escapeTextContentForBrowser = __webpack_require__(93);
	var invariant = __webpack_require__(15);
	var validateDOMNesting = __webpack_require__(143);

	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;

	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};

	_assign(ReactDOMTextComponent.prototype, {

	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }

	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);

	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }

	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },

	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },

	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },

	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }

	});

	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var ReactUpdates = __webpack_require__(63);
	var Transaction = __webpack_require__(75);

	var emptyFunction = __webpack_require__(19);

	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};

	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};

	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}

	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});

	var transaction = new ReactDefaultBatchingStrategyTransaction();

	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,

	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};

	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var EventListener = __webpack_require__(149);
	var ExecutionEnvironment = __webpack_require__(55);
	var PooledClass = __webpack_require__(57);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);

	var getEventTarget = __webpack_require__(76);
	var getUnboundedScrollPosition = __webpack_require__(150);

	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}

	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);

	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}

	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}

	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,

	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },

	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },

	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },

	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },

	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }

	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};

	module.exports = ReactEventListener;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */

	var emptyFunction = __webpack_require__(19);

	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },

	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },

	  registerDefault: function registerDefault() {}
	};

	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	'use strict';

	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */

	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}

	module.exports = getUnboundedScrollPosition;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(43);
	var EventPluginHub = __webpack_require__(49);
	var EventPluginUtils = __webpack_require__(51);
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactEmptyComponent = __webpack_require__(132);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactHostComponent = __webpack_require__(133);
	var ReactUpdates = __webpack_require__(63);

	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};

	module.exports = ReactInjection;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(11);

	var CallbackQueue = __webpack_require__(64);
	var PooledClass = __webpack_require__(57);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactInputSelection = __webpack_require__(153);
	var ReactInstrumentation = __webpack_require__(69);
	var Transaction = __webpack_require__(75);
	var ReactUpdateQueue = __webpack_require__(142);

	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};

	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },

	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};

	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },

	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}

	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },

	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },

	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },

	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};

	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

	PooledClass.addPoolingTo(ReactReconcileTransaction);

	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMSelection = __webpack_require__(154);

	var containsNode = __webpack_require__(156);
	var focusNode = __webpack_require__(101);
	var getActiveElement = __webpack_require__(159);

	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}

	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {

	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },

	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },

	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },

	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;

	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }

	    return selection || { start: 0, end: 0 };
	  },

	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }

	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};

	module.exports = ReactInputSelection;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(55);

	var getNodeForCharacterOffset = __webpack_require__(155);
	var getTextContentAccessor = __webpack_require__(58);

	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}

	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;

	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);

	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;

	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}

	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();

	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }

	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;

	  var currentRange = selection.getRangeAt(0);

	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }

	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;

	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;

	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}

	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;

	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }

	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}

	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }

	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }

	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);

	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();

	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}

	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};

	module.exports = ReactDOMSelection;

/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */

	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}

	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}

	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;

	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;

	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }

	      nodeStart = nodeEnd;
	    }

	    node = getLeafNode(getSiblingNode(node));
	  }
	}

	module.exports = getNodeForCharacterOffset;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	var isTextNode = __webpack_require__(157);

	/*eslint-disable no-bitwise */

	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}

	module.exports = containsNode;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var isNode = __webpack_require__(158);

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}

	module.exports = isTextNode;

/***/ },
/* 158 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}

	module.exports = isNode;

/***/ },
/* 159 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	/* eslint-disable fb-www/typeof-undefined */

	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}

	module.exports = getActiveElement;

/***/ },
/* 160 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};

	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};

	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};

	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});

	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInputSelection = __webpack_require__(153);
	var SyntheticEvent = __webpack_require__(60);

	var getActiveElement = __webpack_require__(159);
	var isTextInputElement = __webpack_require__(78);
	var shallowEqual = __webpack_require__(130);

	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};

	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;

	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;

	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}

	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }

	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;

	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;

	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

	    return syntheticEvent;
	  }

	  return null;
	}

	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {

	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }

	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;

	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);

	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }

	    return null;
	  },

	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};

	module.exports = SelectEventPlugin;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var EventListener = __webpack_require__(149);
	var EventPropagators = __webpack_require__(48);
	var ReactDOMComponentTree = __webpack_require__(41);
	var SyntheticAnimationEvent = __webpack_require__(163);
	var SyntheticClipboardEvent = __webpack_require__(164);
	var SyntheticEvent = __webpack_require__(60);
	var SyntheticFocusEvent = __webpack_require__(165);
	var SyntheticKeyboardEvent = __webpack_require__(166);
	var SyntheticMouseEvent = __webpack_require__(81);
	var SyntheticDragEvent = __webpack_require__(169);
	var SyntheticTouchEvent = __webpack_require__(170);
	var SyntheticTransitionEvent = __webpack_require__(171);
	var SyntheticUIEvent = __webpack_require__(82);
	var SyntheticWheelEvent = __webpack_require__(172);

	var emptyFunction = __webpack_require__(19);
	var getEventCharCode = __webpack_require__(167);
	var invariant = __webpack_require__(15);

	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;

	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});

	var onClickListeners = {};

	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}

	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}

	function shouldPreventMouseEvent(inst) {
	  if (inst) {
	    var disabled = inst._currentElement && inst._currentElement.props.disabled;

	    if (disabled) {
	      return isInteractive(inst._tag);
	    }
	  }

	  return false;
	}

	var SimpleEventPlugin = {

	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	        // Disabled elements should not respond to mouse events
	        if (shouldPreventMouseEvent(targetInst)) {
	          return null;
	        }
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },

	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },

	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }

	};

	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(60);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

	module.exports = SyntheticAnimationEvent;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(60);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

	module.exports = SyntheticClipboardEvent;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(82);

	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

	module.exports = SyntheticFocusEvent;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(82);

	var getEventCharCode = __webpack_require__(167);
	var getEventKey = __webpack_require__(168);
	var getEventModifierState = __webpack_require__(84);

	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.

	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.

	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */

	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;

	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;

	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }

	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }

	  return 0;
	}

	module.exports = getEventCharCode;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var getEventCharCode = __webpack_require__(167);

	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};

	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};

	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.

	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }

	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);

	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}

	module.exports = getEventKey;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticMouseEvent = __webpack_require__(81);

	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

	module.exports = SyntheticDragEvent;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(82);

	var getEventModifierState = __webpack_require__(84);

	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

	module.exports = SyntheticTouchEvent;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(60);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

	module.exports = SyntheticTransitionEvent;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticMouseEvent = __webpack_require__(81);

	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,

	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

	module.exports = SyntheticWheelEvent;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var DOMLazyTree = __webpack_require__(88);
	var DOMProperty = __webpack_require__(43);
	var React = __webpack_require__(10);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMContainerInfo = __webpack_require__(174);
	var ReactDOMFeatureFlags = __webpack_require__(175);
	var ReactFeatureFlags = __webpack_require__(65);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactMarkupChecksum = __webpack_require__(176);
	var ReactReconciler = __webpack_require__(66);
	var ReactUpdateQueue = __webpack_require__(142);
	var ReactUpdates = __webpack_require__(63);

	var emptyObject = __webpack_require__(27);
	var instantiateReactComponent = __webpack_require__(125);
	var invariant = __webpack_require__(15);
	var setInnerHTML = __webpack_require__(90);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var warning = __webpack_require__(18);

	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	var instancesByReactRootID = {};

	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}

	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }

	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}

	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}

	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }

	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );

	  if (markerName) {
	    console.timeEnd(markerName);
	  }

	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}

	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}

	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }

	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }

	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}

	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}

	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}

	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}

	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}

	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}

	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}

	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;

	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {

	  TopLevelWrapper: TopLevelWrapper,

	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,

	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },

	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });

	    return prevComponent;
	  },

	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);

	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.

	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;

	    return componentInstance;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },

	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

	    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }

	    var prevComponent = getTopLevelWrapperInContainer(container);

	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }

	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }

	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },

	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }

	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);

	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }

	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },

	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }

	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }

	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};

	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var validateDOMNesting = __webpack_require__(143);

	var DOC_NODE_TYPE = 9;

	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}

	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 175 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};

	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var adler32 = __webpack_require__(177);

	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;

	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',

	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);

	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },

	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};

	module.exports = ReactMarkupChecksum;

/***/ },
/* 177 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var MOD = 65521;

	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}

	module.exports = adler32;

/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	module.exports = '15.4.0';

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(42);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstanceMap = __webpack_require__(123);

	var getHostComponentFromComposite = __webpack_require__(180);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);

	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }

	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }

	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}

	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactNodeTypes = __webpack_require__(127);

	function getHostComponentFromComposite(inst) {
	  var type;

	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }

	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}

	module.exports = getHostComponentFromComposite;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactMount = __webpack_require__(173);

	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(43);
	var EventPluginRegistry = __webpack_require__(50);
	var ReactComponentTreeHook = __webpack_require__(33);

	var warning = __webpack_require__(18);

	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,

	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};

	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();

	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}

	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }

	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');

	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};

	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}

	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};

	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactComponentTreeHook = __webpack_require__(33);

	var warning = __webpack_require__(18);

	var didWarnValueNull = false;

	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

	    didWarnValueNull = true;
	  }
	}

	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};

	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(43);
	var ReactComponentTreeHook = __webpack_require__(33);

	var warning = __webpack_require__(18);

	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

	function validateProperty(tagName, name, debugID) {
	  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	    return true;
	  }

	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      warnedProperties[name] = true;
	      return true;
	    }
	  }

	  return true;
	}

	function warnInvalidARIAProps(debugID, element) {
	  var invalidProps = [];

	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }

	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');

	  if (invalidProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (invalidProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}

	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }

	  warnInvalidARIAProps(debugID, element);
	}

	var ReactDOMInvalidARIAHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  }
	};

	module.exports = ReactDOMInvalidARIAHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var App = function (_Component) {
	    _inherits(App, _Component);

	    function App(props) {
	        _classCallCheck(this, App);

	        var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

	        _this.watchID = 0;
	        _this.state = {
	            userPosition: null
	        };
	        return _this;
	    }

	    _createClass(App, [{
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	            var _this2 = this;

	            var state = this.props.state;

	            // Success handler

	            var success = function success(p) {
	                var userPosition = {
	                    lat: p.coords.latitude,
	                    lng: p.coords.longitude
	                };

	                state.userPosition = userPosition;
	                _this2.setState({ userPosition: userPosition });
	            };

	            // Error handler
	            var error = function error(e) {
	                return console.error(e);
	            };

	            if ('geolocation' in navigator) {
	                this.watchID = navigator.geolocation.watchPosition(success, error);

	                if (state.userPosition.hasOwnProperty('lat')) {
	                    this.setState({ userPosition: state.userPosition });
	                }
	            } else {
	                console.error('Geolocation not supported');
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            if ('geolocation' in navigator) {
	                navigator.geolocation.clearWatch(this.watchID);
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this3 = this;

	            var _props = this.props,
	                state = _props.state,
	                children = _props.children;


	            return _react2.default.createElement(
	                'div',
	                { className: 'app' },
	                _react.Children.map(children, function (c) {
	                    return (0, _react.cloneElement)(c, {
	                        state: state,
	                        userPosition: _this3.state.userPosition
	                    });
	                })
	            );
	        }
	    }]);

	    return App;
	}(_react.Component);

	exports.default = App;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _cache = __webpack_require__(187);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Guide = function Guide(_ref) {
	    var state = _ref.state;


	    var navigate = function navigate() {
	        (0, _cache.userStartedTour)();
	        state.navigate('/locations');
	    };

	    return _react2.default.createElement(
	        'div',
	        { className: 'guide' },
	        _react2.default.createElement(
	            'h1',
	            { className: 'title' },
	            'Finding Alberta'
	        ),
	        _react2.default.createElement(
	            'p',
	            { className: 'instructions' },
	            'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.'
	        ),
	        _react2.default.createElement(
	            'ol',
	            { className: 'instructions-list' },
	            _react2.default.createElement(
	                'li',
	                null,
	                'Choose a spot'
	            ),
	            _react2.default.createElement(
	                'li',
	                null,
	                'Find the house'
	            ),
	            _react2.default.createElement(
	                'li',
	                null,
	                'Push the AR-button'
	            ),
	            _react2.default.createElement(
	                'li',
	                null,
	                'Do something'
	            ),
	            _react2.default.createElement(
	                'li',
	                null,
	                'Enjoy the story'
	            ),
	            _react2.default.createElement(
	                'li',
	                null,
	                'Share with friends'
	            )
	        ),
	        _react2.default.createElement(
	            'button',
	            {
	                className: 'start',
	                type: 'button',
	                onClick: navigate },
	            'Let\'s go'
	        )
	    );
	};

	exports.default = Guide;

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.fetchLocationData = fetchLocationData;
	exports.fetchUserData = fetchUserData;
	exports.locationVisited = locationVisited;
	exports.setCurrentSound = setCurrentSound;
	exports.locationUnlocked = locationUnlocked;
	exports.userStartedTour = userStartedTour;

	__webpack_require__(188);

	var _utilities = __webpack_require__(189);

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	// TODO check for errors when parsing JSON
	// Store and fetch data from local storage
	// Based on wether a value was passed or not
	function cache(key, value) {
	    var data = localStorage.getItem('lva-cache');

	    if (typeof value === 'undefined') {
	        if (data) {
	            var json = JSON.parse(data);
	            return json.hasOwnProperty(key) ? json[key] : {};
	        }

	        return {};
	    }

	    if (data) {
	        var _json = JSON.parse(data);
	        _json[key] = value;
	        localStorage.setItem('lva-cache', JSON.stringify(_json));
	    } else {
	        var _json2 = _defineProperty({}, key, value);
	        localStorage.setItem('lva-cache', JSON.stringify(_json2));
	    }

	    return {};
	}

	// Fetch the location data from our API
	function fetchLocationData(callback) {
	    var cached = cache('locationData');

	    if (!cached.hasOwnProperty('locations')) {
	        fetch('https://api.livingarchives.org/locations').then(function (res) {
	            return res.json();
	        }).then(function (json) {
	            cache('locationData', json);
	            callback(json);
	        }).catch(function (err) {
	            return console.log(err);
	        });
	    } else {
	        callback(cached);
	    }
	}

	// Fetch user data from the cache, create a new one otherwise
	function fetchUserData(callback) {
	    var cached = cache('userData');

	    if (!cached.hasOwnProperty('id')) {
	        fetchLocationData(function (json) {
	            var userData = {
	                id: (0, _utilities.guid)(window),
	                hasStarted: false,
	                currentSound: {
	                    id: 0,
	                    position: null
	                },
	                locations: json.locations.reduce(function (a, n) {
	                    a['location_' + n.id] = {
	                        id: n.id,
	                        unlocked: false,
	                        visited: false,
	                        listened: false
	                    };
	                    return a;
	                }, {})
	            };

	            cache('userData', userData);
	            callback(userData);
	        });
	    } else {
	        callback(cached);
	    }
	}

	// TODO should we create a new object (copy) instead of mutating the current one?
	function locationVisited(id) {
	    var userData = cache('userData');

	    if (!userData.hasOwnProperty('id')) {
	        return false;
	    }

	    if (userData.hasOwnProperty('locations') && userData.locations.hasOwnProperty('location_' + id) && !userData.locations['location_' + id].visited) {
	        // Only update cache and send statistics if the location hasnt been visited 
	        userData.locations['location_' + id].visited = true;
	        cache('userData', userData);
	        (0, _utilities.sendStatistic)(userData.id, id, 'visited');
	    }
	}

	function setCurrentSound(id, position) {
	    var userData = cache('userData');

	    if (!userData.hasOwnProperty('id')) {
	        return false;
	    }

	    if (userData.hasOwnProperty('currentSound') && userData.hasOwnProperty('locations') && userData.locations.hasOwnProperty('location_' + id)) {

	        // Update current sound
	        userData.currentSound.id = id;
	        userData.currentSound.position = position;

	        if (!userData.locations['location_' + id].listened) {
	            // Only update cache and send statistics if the location-sound hasnt been listened to
	            userData.locations['location_' + id].listened = true;
	            (0, _utilities.sendStatistic)(userData.id, id, 'listened');
	        }

	        cache('userData', userData);
	    }
	}

	function locationUnlocked(id) {
	    var userData = cache('userData');

	    if (!userData.hasOwnProperty('id')) {
	        return false;
	    }

	    if (userData.hasOwnProperty('locations') && userData.locations.hasOwnProperty('location_' + id) && !userData.locations['location_' + id].unlocked) {
	        // Only update cache and send statistics if the location hasnt been unlocked
	        userData.locations['location_' + id].unlocked = true;
	        cache('userData', userData);
	        (0, _utilities.sendStatistic)(userData.id, id, 'unlocked');
	    }
	}

	function userStartedTour() {
	    var userData = cache('userData');

	    if (!userData.hasOwnProperty('id')) {
	        return false;
	    }

	    if (userData.hasOwnProperty('hasStarted') && !userData.hasStarted) {
	        userData.hasStarted = true;
	        cache('userData', userData);
	        (0, _utilities.sendStatistic)(userData.id, 0, 'started');
	    }
	}

/***/ },
/* 188 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';

	  if (self.fetch) {
	    return
	  }

	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }

	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]

	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }

	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }

	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }

	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }

	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }

	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }

	    return iterator
	  }

	  function Headers(headers) {
	    this.map = {}

	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)

	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }

	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var oldValue = this.map[name]
	    this.map[name] = oldValue ? oldValue+','+value : value
	  }

	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }

	  Headers.prototype.get = function(name) {
	    name = normalizeName(name)
	    return this.has(name) ? this.map[name] : null
	  }

	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }

	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value)
	  }

	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this)
	      }
	    }
	  }

	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }

	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }

	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }

	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }

	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }

	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }

	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }

	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }

	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)

	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }

	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }

	  function Body() {
	    this.bodyUsed = false

	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }

	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }

	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }

	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }

	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }

	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }

	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }

	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }

	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }

	    return this
	  }

	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }

	  function Request(input, options) {
	    options = options || {}
	    var body = options.body

	    if (typeof input === 'string') {
	      this.url = input
	    } else {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    }

	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null

	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }

	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }

	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }

	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split('\r\n').forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }

	  Body.call(Request.prototype)

	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }

	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }

	  Body.call(Response.prototype)

	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }

	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }

	  var redirectStatuses = [301, 302, 303, 307, 308]

	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }

	    return new Response(null, {status: status, headers: {location: url}})
	  }

	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response

	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()

	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }

	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }

	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }

	      xhr.open(request.method, request.url, true)

	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }

	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }

	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })

	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.formatSeconds = formatSeconds;
	exports.toFixed = toFixed;
	exports.generateHash = generateHash;
	exports.guid = guid;
	exports.setupLocation = setupLocation;
	exports.throttle = throttle;
	exports.humanReadableDistance = humanReadableDistance;
	exports.setupLocationData = setupLocationData;
	exports.setupUserData = setupUserData;
	exports.rad = rad;
	exports.calculateDistance = calculateDistance;
	exports.prepare = prepare;
	exports.sendStatistic = sendStatistic;

	__webpack_require__(188);

	var _three = __webpack_require__(5);

	var _argon = __webpack_require__(1);

	var _cache = __webpack_require__(187);

	// Format seconds to 0:00:00 format
	function formatSeconds(seconds) {
	    seconds = Number(seconds);

	    var h = Math.floor(seconds / 3600) | 0;
	    var m = Math.floor(seconds / 60) | 0;
	    var s = Math.floor(seconds % 60) | 0;

	    var hms = '';

	    if (h > 0) {
	        hms += '' + h + ':' + (m < 10 ? '0' : '');
	    }

	    hms += '' + m + ':' + (s < 10 ? '0' : '');
	    hms += '' + s;
	    return hms;
	}

	// Format floating points
	function toFixed(value) {
	    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    var p = Math.pow(10, precision);
	    return Math.round(value * p) / p;
	}

	function generateHash(s) {
	    var hash = 0;
	    var i = void 0;
	    var len = void 0;
	    var chr = void 0;

	    for (i = 0, len = s.length; i < len; i++) {
	        chr = s.charCodeAt(i);
	        hash = (hash << 5) - hash + chr;
	        hash |= 0;
	    }

	    return hash;
	}

	// Creates a GUID based on several different browser variables
	// It wont be compliant with RFC4122 but hopefully good enough
	function guid(window) {
	    var nav = window.navigator;
	    var screen = window.screen;
	    var s = [nav.mimeTypes.length, nav.userAgent.replace(/D+/g, ''), nav.plugins.length, screen.height || '', screen.width || '', screen.pixelDepth || ''].join('');

	    return generateHash(s);
	}

	// Setup a new location
	function setupLocation(meta, content) {
	    // THREE.js 3D objects and a Cesium entity - these represents the location/pose
	    var locationObject = new _three.Object3D();
	    var geoObject = new _three.Object3D();
	    var geoEntity = new _argon.Cesium.Entity({
	        name: meta.name,
	        orientation: _argon.Cesium.Quaternion.IDENTITY,
	        position: _argon.Cesium.Cartesian3.fromDegrees(meta.longitude, meta.latitude)
	    });

	    // We need to add a location object to the geo object
	    // to be able to calculate the distance between two objects
	    geoObject.add(locationObject);

	    return {
	        initialized: false,
	        meta: meta,
	        content: content,
	        geoEntity: geoEntity,
	        geoObject: geoObject,
	        locationObject: locationObject
	    };
	}

	// Limit amount of time between function calls to a function
	function throttle(fn, ms) {
	    var lastCall = 0;
	    return function () {
	        var now = Date.now();

	        if (lastCall + ms < now) {
	            lastCall = now;
	            return fn.apply(this, arguments);
	        }
	    };
	}

	// Format distance into a more readable format
	function humanReadableDistance(d) {
	    // Kilometer
	    if (d > 1000) {
	        var km = d / 1000;
	        return km.toFixed(1) + 'km';
	    }

	    // Meter
	    return Math.floor(d) + 'm';
	}

	// Fetch and setup location data for the cache from the API
	function setupLocationData(state, cb) {
	    (0, _cache.fetchLocationData)(function (json) {
	        state.locations = json.locations.map(function (location) {
	            //  filter out content based on location id
	            var content = json.content.filter(function (c) {
	                return c.id === location.id;
	            }).reduce(function (_, c) {
	                return c.html;
	            }, '');

	            return setupLocation(location, content);
	        });

	        cb && cb(json);
	    });
	}

	function setupUserData(state, cb) {
	    (0, _cache.fetchUserData)(function (userData) {
	        state.userData = userData;
	        cb && cb(userData);
	    });
	}

	// Calculate the rad of 'n'
	function rad(n) {
	    return n * Math.PI / 180;
	}

	// Returns the distance between to lat/lng points
	function calculateDistance(p1, p2) {
	    // Earth’s mean radius in meter
	    var R = 6378137;
	    var dLat = rad(p2.lat - p1.lat);
	    var dLong = rad(p2.lng - p1.lng);
	    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(rad(p1.lat)) * Math.cos(rad(p2.lat)) * Math.sin(dLong / 2) * Math.sin(dLong / 2);
	    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	    var d = R * c;
	    return d;
	}

	function prepare(method, body) {
	    return {
	        method: method,
	        headers: new Headers({ 'Content-type': 'application/json' }),
	        body: JSON.stringify(body)
	    };
	}

	function sendStatistic(guid, location, type) {
	    var url = 'https://api.livingarchives.org/statistics';
	    var data = { guid: guid, type: type, location: location };
	    var payload = prepare('POST', data);

	    // TODO what should we do with the response and error?
	    // TODO should a callback be invoked?
	    return fetch(url, payload).then(function (res) {
	        return console.log(res);
	    }).catch(function (e) {
	        return console.log(e);
	    });
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.locationsList = undefined;

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(39);

	var _app = __webpack_require__(185);

	var _app2 = _interopRequireDefault(_app);

	var _navigation = __webpack_require__(191);

	var _navigation2 = _interopRequireDefault(_navigation);

	var _locationsList = __webpack_require__(193);

	var _locationsList2 = _interopRequireDefault(_locationsList);

	var _utilities = __webpack_require__(189);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Before
	function before(state) {
	    return function (done) {
	        (0, _reactDom.unmountComponentAtNode)(state.reactMountNode);
	        state.argonMountNode.style.display = 'none';
	        state.documentRootNode.style.background = 'white';
	        // Setup location data then the user data
	        (0, _utilities.setupLocationData)(state, function () {
	            return (0, _utilities.setupUserData)(state, done);
	        });
	    };
	}

	// After
	function after() {
	    return function () {};
	}

	// Locations list route
	function route(state) {
	    return function () {
	        console.log('Locations list:', state);

	        var goToMap = function goToMap() {
	            return state.navigate('/map');
	        };
	        var mapIcon = function mapIcon() {
	            return _react2.default.createElement(
	                'button',
	                { type: 'button', className: 'switch-to-map', onClick: goToMap },
	                _react2.default.createElement('i', { className: 'icon ion-ios-location' })
	            );
	        };

	        (0, _reactDom.render)(_react2.default.createElement(
	            _app2.default,
	            { state: state },
	            _react2.default.createElement(_navigation2.default, {
	                backUrl: '/',
	                renderRight: mapIcon,
	                title: 'All locations' }),
	            _react2.default.createElement(_locationsList2.default, null)
	        ), state.reactMountNode);
	    };
	}

	// Export the route handlers
	var locationsList = exports.locationsList = {
	    urls: ['/locations'],
	    route: route,
	    hooks: function hooks(state) {
	        return { before: before(state), after: after(state) };
	    }
	};

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _distance = __webpack_require__(192);

	var _distance2 = _interopRequireDefault(_distance);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Navigation = function Navigation(props) {
	    var state = props.state,
	        title = props.title,
	        renderLeft = props.renderLeft,
	        renderRight = props.renderRight,
	        distance = props.distance,
	        location = props.location,
	        backUrl = props.backUrl,
	        userPosition = props.userPosition;


	    var goBack = function goBack() {
	        state.prevRoute = '';
	        state.navigate(backUrl || '');
	    };

	    var renderDistance = function renderDistance(d) {
	        return _react2.default.createElement(
	            'div',
	            { className: 'distance' },
	            d
	        );
	    };

	    var left = _react2.default.createElement('div', null);
	    var right = _react2.default.createElement('div', null);
	    var center = _react2.default.createElement(
	        'p',
	        null,
	        title || ''
	    );

	    if (renderLeft) {
	        left = renderLeft();
	    } else if (backUrl) {
	        left = _react2.default.createElement(
	            'div',
	            { onClick: goBack, className: 'back-button' },
	            _react2.default.createElement('i', { className: 'icon ion-ios-arrow-left' })
	        );
	    }

	    if (renderRight) {
	        right = renderRight();
	    } else if (distance) {
	        right = _react2.default.createElement(_distance2.default, {
	            userPosition: userPosition,
	            location: location,
	            render: renderDistance });
	    }

	    return _react2.default.createElement(
	        'div',
	        { className: 'navigation' },
	        _react2.default.createElement(
	            'div',
	            { className: 'left' },
	            left
	        ),
	        _react2.default.createElement(
	            'div',
	            { className: 'center' },
	            center
	        ),
	        _react2.default.createElement(
	            'div',
	            { className: 'right' },
	            right
	        )
	    );
	};

	exports.default = Navigation;

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _utilities = __webpack_require__(189);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Distance = function Distance(_ref) {
	    var location = _ref.location,
	        userPosition = _ref.userPosition,
	        render = _ref.render;

	    // Render a distance of 0 meters if no user position is available
	    if (userPosition === null) {
	        // const temp: Object = render(humanReadableDistance(0))
	        // return <div>{temp}</div>
	        return _react2.default.createElement(
	            'div',
	            { className: 'spinner' },
	            _react2.default.createElement('div', { className: 'bounce1' }),
	            _react2.default.createElement('div', { className: 'bounce2' }),
	            _react2.default.createElement('div', { className: 'bounce3' })
	        );
	    }

	    var locationCoords = {
	        lat: location.meta.latitude,
	        lng: location.meta.longitude
	    };

	    var distance = (0, _utilities.humanReadableDistance)((0, _utilities.calculateDistance)(locationCoords, userPosition));

	    var component = render(distance);

	    return _react2.default.createElement(
	        'div',
	        null,
	        component
	    );
	};

	exports.default = Distance;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _distance = __webpack_require__(192);

	var _distance2 = _interopRequireDefault(_distance);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var sortByPosition = function sortByPosition(a, b) {
	    return a.meta.position - b.meta.position;
	};
	var renderDistance = function renderDistance(d) {
	    return _react2.default.createElement(
	        'p',
	        { className: 'distance' },
	        d
	    );
	};

	var Location = function Location(_ref) {
	    var location = _ref.location,
	        navigate = _ref.navigate,
	        userData = _ref.userData,
	        userPosition = _ref.userPosition,
	        renderDistance = _ref.renderDistance;


	    var backgroundStyle = {
	        backgroundImage: 'url(/static/location_' + location.meta.id + '.png)',
	        backgroundPosition: 'center',
	        backgroundRepeat: 'no-repeat',
	        backgroundSize: '100%'
	    };

	    var locationCache = userData.locations['location_' + location.meta.id];
	    var unlocked = locationCache.visited && locationCache.unlocked;

	    var title = unlocked ? location.meta.name : 'Location ' + location.meta.position;

	    return _react2.default.createElement(
	        'div',
	        {
	            onClick: navigate(location.meta.id),
	            style: backgroundStyle,
	            className: 'locations-list-item-outer' },
	        _react2.default.createElement(
	            'div',
	            { className: 'locations-list-item' },
	            _react2.default.createElement(
	                'p',
	                { className: 'title' },
	                title
	            ),
	            _react2.default.createElement(
	                'p',
	                { className: 'adress' },
	                location.meta.adress
	            ),
	            _react2.default.createElement(
	                'div',
	                { className: 'bottom' },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'visited' },
	                    unlocked ? _react2.default.createElement('i', { className: 'ion-ios-checkmark' }) : ''
	                ),
	                _react2.default.createElement(_distance2.default, {
	                    userPosition: userPosition,
	                    location: location,
	                    render: renderDistance })
	            ),
	            _react2.default.createElement(
	                'div',
	                { className: 'arrow' },
	                _react2.default.createElement('i', { className: 'icon ion-ios-arrow-right' })
	            )
	        )
	    );
	};

	var LocationsList = function LocationsList(_ref2) {
	    var state = _ref2.state,
	        userPosition = _ref2.userPosition;


	    var navigate = function navigate(id) {
	        return function () {
	            return state.navigate('/locations/' + id + '/map');
	        };
	    };

	    var locationComponents = state.locations.sort(sortByPosition).map(function (location, i) {
	        return _react2.default.createElement(Location, {
	            key: i,
	            location: location,
	            navigate: navigate,
	            userData: state.userData,
	            userPosition: userPosition,
	            renderDistance: renderDistance });
	    });

	    return _react2.default.createElement(
	        'div',
	        { className: 'locations-list' },
	        locationComponents
	    );
	};

	exports.default = LocationsList;

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.locationsMap = undefined;

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(39);

	var _app = __webpack_require__(185);

	var _app2 = _interopRequireDefault(_app);

	var _navigation = __webpack_require__(191);

	var _navigation2 = _interopRequireDefault(_navigation);

	var _locationsMap = __webpack_require__(195);

	var _locationsMap2 = _interopRequireDefault(_locationsMap);

	var _utilities = __webpack_require__(189);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Before
	function before(state) {
	    return function (done) {
	        (0, _reactDom.unmountComponentAtNode)(state.reactMountNode);
	        state.argonMountNode.style.display = 'none';
	        state.documentRootNode.style.background = 'white';
	        // Setup location data then the user data
	        (0, _utilities.setupLocationData)(state, function () {
	            return (0, _utilities.setupUserData)(state, done);
	        });
	    };
	}

	// After
	function after() {
	    return function () {};
	}

	// Locations map route
	function route(state) {
	    return function () {
	        console.log('Locations Map:', state);

	        var goToList = function goToList() {
	            return state.navigate('/locations');
	        };
	        var listIcon = function listIcon() {
	            return _react2.default.createElement(
	                'button',
	                { type: 'button', className: 'switch-to-list', onClick: goToList },
	                _react2.default.createElement('i', { className: 'icon ion-ios-list-outline' })
	            );
	        };

	        (0, _reactDom.render)(_react2.default.createElement(
	            _app2.default,
	            { state: state },
	            _react2.default.createElement(_navigation2.default, {
	                backUrl: '/',
	                renderRight: listIcon,
	                title: 'All locations' }),
	            _react2.default.createElement(_locationsMap2.default, null)
	        ), state.reactMountNode);
	    };
	}

	// Export the route handlers
	var locationsMap = exports.locationsMap = {
	    urls: ['/map'],
	    route: route,
	    hooks: function hooks(state) {
	        return { before: before(state), after: after(state) };
	    }
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _mapStyle = __webpack_require__(196);

	var _reactGoogleMaps = __webpack_require__(197);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* global google */
	var renderMarker = function renderMarker(navigateToLocation) {
	    return function (location) {

	        var pos = {
	            lat: location.meta.latitude,
	            lng: location.meta.longitude
	        };

	        return _react2.default.createElement(_reactGoogleMaps.Marker, {
	            position: pos,
	            onClick: navigateToLocation(location.meta.id),
	            label: String(location.meta.position),
	            key: location.meta.name });
	    };
	};

	var Map = (0, _reactGoogleMaps.withGoogleMap)(function (_ref) {
	    var navigateToLocation = _ref.navigateToLocation,
	        locations = _ref.locations,
	        userPosition = _ref.userPosition;


	    var center = {
	        lat: 55.68177,
	        lng: 12.55855
	    };

	    var userMarkerOpts = {
	        clickable: false,
	        cursor: 'pointer',
	        draggable: false,
	        flat: true,
	        optimized: false,
	        position: {
	            lat: userPosition ? userPosition.lat : 0,
	            lng: userPosition ? userPosition.lng : 0,
	            enableHighAccuracy: true,
	            maximumAge: 1000
	        },
	        title: 'Current location',
	        zIndex: 2,
	        icon: {
	            url: '/static/gpsloc.png',
	            size: new google.maps.Size(34, 34),
	            scaledSize: new google.maps.Size(17, 17),
	            origin: new google.maps.Point(0, 0),
	            anchor: new google.maps.Point(8, 8)
	        },
	        key: 'User location'
	    };

	    return _react2.default.createElement(
	        _reactGoogleMaps.GoogleMap,
	        {
	            defaultZoom: 14,
	            defaultCenter: center,
	            defaultOptions: {
	                styles: _mapStyle.mapStyles,
	                mapTypeControl: false,
	                streetViewControl: false,
	                rotateControl: false,
	                fullscreenControl: false,
	                scaleControl: false
	            } },
	        _react2.default.createElement(_reactGoogleMaps.Marker, userMarkerOpts),
	        locations.map(renderMarker(navigateToLocation))
	    );
	});

	var LocationsMap = function LocationsMap(_ref2) {
	    var state = _ref2.state,
	        userPosition = _ref2.userPosition;
	    var locations = state.locations;


	    var navigateToLocation = function navigateToLocation(id) {
	        return function () {
	            state.prevRoute = '/map';
	            state.navigate('/locations/' + id + '/map');
	        };
	    };

	    var div = _react2.default.createElement('div', { style: { height: '100%' } });

	    return _react2.default.createElement(
	        'div',
	        { className: 'locations-map' },
	        _react2.default.createElement(Map, {
	            navigateToLocation: navigateToLocation,
	            userPosition: userPosition,
	            locations: locations,
	            containerElement: div,
	            mapElement: div })
	    );
	};

	exports.default = LocationsMap;

/***/ },
/* 196 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var mapStyles = exports.mapStyles = [{
	    'featureType': 'all',
	    'elementType': 'labels.text.fill',
	    'stylers': [{
	        'color': '#ffffff'
	    }]
	}, {
	    'featureType': 'all',
	    'elementType': 'labels.text.stroke',
	    'stylers': [{
	        'color': '#000000'
	    }, {
	        'lightness': 13
	    }]
	}, {
	    'featureType': 'administrative',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'color': '#000000'
	    }]
	}, {
	    'featureType': 'administrative',
	    'elementType': 'geometry.stroke',
	    'stylers': [{
	        'color': '#144b53'
	    }, {
	        'lightness': 14
	    }, {
	        'weight': 1.4
	    }]
	}, {
	    'featureType': 'landscape',
	    'elementType': 'all',
	    'stylers': [{
	        'color': '#08304b'
	    }]
	}, {
	    'featureType': 'poi',
	    'elementType': 'geometry',
	    'stylers': [{
	        'color': '#0c4152'
	    }, {
	        'lightness': 5
	    }]
	}, {
	    'featureType': 'road.highway',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'color': '#000000'
	    }]
	}, {
	    'featureType': 'road.highway',
	    'elementType': 'geometry.stroke',
	    'stylers': [{
	        'color': '#0b434f'
	    }, {
	        'lightness': 25
	    }]
	}, {
	    'featureType': 'road.arterial',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'color': '#000000'
	    }]
	}, {
	    'featureType': 'road.arterial',
	    'elementType': 'geometry.stroke',
	    'stylers': [{
	        'color': '#0b3d51'
	    }, {
	        'lightness': 16
	    }]
	}, {
	    'featureType': 'road.local',
	    'elementType': 'geometry',
	    'stylers': [{
	        'color': '#000000'
	    }]
	}, {
	    'featureType': 'transit',
	    'elementType': 'all',
	    'stylers': [{
	        'color': '#146474'
	    }]
	}, {
	    'featureType': 'water',
	    'elementType': 'all',
	    'stylers': [{
	        'color': '#021019'
	    }]
	}];

	var mapStylesBqParchment = exports.mapStylesBqParchment = [{
	    'featureType': 'administrative',
	    'elementType': 'labels.text.fill',
	    'stylers': [{
	        'color': '#444444'
	    }]
	}, {
	    'featureType': 'administrative.country',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'visibility': 'on'
	    }]
	}, {
	    'featureType': 'landscape',
	    'elementType': 'all',
	    'stylers': [{
	        'color': '#f2f2f2'
	    }]
	}, {
	    'featureType': 'landscape',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'color': '#ecddbb'
	    }]
	}, {
	    'featureType': 'landscape.natural',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'visibility': 'on'
	    }, {
	        'color': '#d9d8b2'
	    }]
	}, {
	    'featureType': 'landscape.natural.terrain',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'color': '#e1d0ad'
	    }]
	}, {
	    'featureType': 'poi',
	    'elementType': 'all',
	    'stylers': [{
	        'visibility': 'off'
	    }]
	}, {
	    'featureType': 'road',
	    'elementType': 'all',
	    'stylers': [{
	        'saturation': -100
	    }, {
	        'lightness': 45
	    }]
	}, {
	    'featureType': 'road',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'color': '#9f8e7a'
	    }]
	}, {
	    'featureType': 'road',
	    'elementType': 'labels.text.fill',
	    'stylers': [{
	        'color': '#7d7971'
	    }]
	}, {
	    'featureType': 'road',
	    'elementType': 'labels.text.stroke',
	    'stylers': [{
	        'color': '#f3e0c1'
	    }]
	}, {
	    'featureType': 'road.highway',
	    'elementType': 'all',
	    'stylers': [{
	        'visibility': 'simplified'
	    }]
	}, {
	    'featureType': 'road.arterial',
	    'elementType': 'labels.icon',
	    'stylers': [{
	        'visibility': 'off'
	    }]
	}, {
	    'featureType': 'road.local',
	    'elementType': 'geometry.stroke',
	    'stylers': [{
	        'color': '#d5c2a3'
	    }]
	}, {
	    'featureType': 'transit',
	    'elementType': 'all',
	    'stylers': [{
	        'visibility': 'off'
	    }]
	}, {
	    'featureType': 'water',
	    'elementType': 'all',
	    'stylers': [{
	        'color': '#46bcec'
	    }, {
	        'visibility': 'on'
	    }]
	}, {
	    'featureType': 'water',
	    'elementType': 'geometry.fill',
	    'stylers': [{
	        'color': '#a5d2c9'
	    }]
	}, {
	    'featureType': 'water',
	    'elementType': 'geometry.stroke',
	    'stylers': [{
	        'visibility': 'on'
	    }]
	}, {
	    'featureType': 'water',
	    'elementType': 'labels.text.fill',
	    'stylers': [{
	        'color': '#838383'
	    }]
	}, {
	    'featureType': 'water',
	    'elementType': 'labels.text.stroke',
	    'stylers': [{
	        'visibility': 'off'
	    }]
	}];

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _withGoogleMap = __webpack_require__(198);

	Object.defineProperty(exports, "withGoogleMap", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_withGoogleMap).default;
	  }
	});

	var _GoogleMap = __webpack_require__(291);

	Object.defineProperty(exports, "GoogleMap", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_GoogleMap).default;
	  }
	});

	var _Marker = __webpack_require__(490);

	Object.defineProperty(exports, "Marker", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Marker).default;
	  }
	});

	var _Rectangle = __webpack_require__(491);

	Object.defineProperty(exports, "Rectangle", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Rectangle).default;
	  }
	});

	var _Polyline = __webpack_require__(492);

	Object.defineProperty(exports, "Polyline", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Polyline).default;
	  }
	});

	var _Polygon = __webpack_require__(493);

	Object.defineProperty(exports, "Polygon", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Polygon).default;
	  }
	});

	var _Circle = __webpack_require__(494);

	Object.defineProperty(exports, "Circle", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Circle).default;
	  }
	});

	var _KmlLayer = __webpack_require__(495);

	Object.defineProperty(exports, "KmlLayer", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_KmlLayer).default;
	  }
	});

	var _DirectionsRenderer = __webpack_require__(496);

	Object.defineProperty(exports, "DirectionsRenderer", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DirectionsRenderer).default;
	  }
	});

	var _HeatmapLayer = __webpack_require__(497);

	Object.defineProperty(exports, "HeatmapLayer", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_HeatmapLayer).default;
	  }
	});

	var _InfoWindow = __webpack_require__(498);

	Object.defineProperty(exports, "InfoWindow", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_InfoWindow).default;
	  }
	});

	var _OverlayView = __webpack_require__(499);

	Object.defineProperty(exports, "OverlayView", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_OverlayView).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _objectWithoutProperties2 = __webpack_require__(199);

	var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _getPrototypeOf = __webpack_require__(219);

	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

	var _classCallCheck2 = __webpack_require__(230);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _createClass2 = __webpack_require__(231);

	var _createClass3 = _interopRequireDefault(_createClass2);

	var _possibleConstructorReturn2 = __webpack_require__(232);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(279);

	var _inherits3 = _interopRequireDefault(_inherits2);

	exports.default = withGoogleMap;

	var _warning = __webpack_require__(287);

	var _warning2 = _interopRequireDefault(_warning);

	var _invariant = __webpack_require__(288);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _reactDisplayName = __webpack_require__(289);

	var _reactDisplayName2 = _interopRequireDefault(_reactDisplayName);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function withGoogleMap(WrappedComponent) {
	  var _class, _temp2;

	  return _temp2 = _class = function (_Component) {
	    (0, _inherits3.default)(Container, _Component);

	    function Container() {
	      var _ref;

	      var _temp, _this, _ret;

	      (0, _classCallCheck3.default)(this, Container);

	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Container.__proto__ || (0, _getPrototypeOf2.default)(Container)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	        map: null
	      }, _this.handleComponentMount = _this.handleComponentMount.bind(_this), _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	    }

	    (0, _createClass3.default)(Container, [{
	      key: "getChildContext",
	      value: function getChildContext() {
	        return (0, _defineProperty3.default)({}, _constants.MAP, this.state.map);
	      }
	    }, {
	      key: "componentWillMount",
	      value: function componentWillMount() {
	        var _props = this.props;
	        var containerElement = _props.containerElement;
	        var mapElement = _props.mapElement;

	        (0, _invariant2.default)(!!containerElement && !!mapElement, "Required props containerElement or mapElement is missing. You need to provide both of them.\n The `google.maps.Map` instance will be initialized on mapElement and it's wrapped by containerElement.\nYou need to provide both of them since Google Map requires the DOM to have height when initialized.");
	      }
	    }, {
	      key: "handleComponentMount",
	      value: function handleComponentMount(node) {
	        if (this.state.map || node === null) {
	          return;
	        }
	        (0, _warning2.default)("undefined" !== typeof google, "Make sure you've put a <script> tag in your <head> element to load Google Maps JavaScript API v3.\n If you're looking for built-in support to load it for you, use the \"async/ScriptjsLoader\" instead.\n See https://github.com/tomchentw/react-google-maps/pull/168");
	        // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Map
	        var map = new google.maps.Map(node);
	        this.setState({ map: map });
	      }
	    }, {
	      key: "render",
	      value: function render() {
	        var _props2 = this.props;
	        var containerElement = _props2.containerElement;
	        var mapElement = _props2.mapElement;
	        var restProps = (0, _objectWithoutProperties3.default)(_props2, ["containerElement", "mapElement"]);
	        var map = this.state.map;


	        if (map) {
	          return _react2.default.cloneElement(containerElement, {}, _react2.default.cloneElement(mapElement, {
	            ref: this.handleComponentMount
	          }), _react2.default.createElement(
	            "div",
	            null,
	            _react2.default.createElement(WrappedComponent, restProps)
	          ));
	        } else {
	          return _react2.default.cloneElement(containerElement, {}, _react2.default.cloneElement(mapElement, {
	            ref: this.handleComponentMount
	          }), _react2.default.createElement("div", null));
	        }
	      }
	    }]);
	    return Container;
	  }(_react.Component), _class.displayName = "withGoogleMap(" + (0, _reactDisplayName2.default)(WrappedComponent) + ")", _class.propTypes = {
	    containerElement: _react.PropTypes.node.isRequired,
	    mapElement: _react.PropTypes.node.isRequired
	  }, _class.childContextTypes = (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object), _temp2;
	} /* global google */

/***/ },
/* 199 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports.default = function (obj, keys) {
	  var target = {};

	  for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;
	    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	    target[i] = obj[i];
	  }

	  return target;
	};

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(201);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(202), __esModule: true };

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(203);
	var $Object = __webpack_require__(206).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(204);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(214), 'Object', {defineProperty: __webpack_require__(210).f});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(205)
	  , core      = __webpack_require__(206)
	  , ctx       = __webpack_require__(207)
	  , hide      = __webpack_require__(209)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 205 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 206 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(208);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 208 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(210)
	  , createDesc = __webpack_require__(218);
	module.exports = __webpack_require__(214) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(211)
	  , IE8_DOM_DEFINE = __webpack_require__(213)
	  , toPrimitive    = __webpack_require__(217)
	  , dP             = Object.defineProperty;

	exports.f = __webpack_require__(214) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(212);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 212 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(214) && !__webpack_require__(215)(function(){
	  return Object.defineProperty(__webpack_require__(216)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(215)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 215 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(212)
	  , document = __webpack_require__(205).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(212);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 218 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(220), __esModule: true };

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(221);
	module.exports = __webpack_require__(206).Object.getPrototypeOf;

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(222)
	  , $getPrototypeOf = __webpack_require__(224);

	__webpack_require__(229)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(223);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 223 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(225)
	  , toObject    = __webpack_require__(222)
	  , IE_PROTO    = __webpack_require__(226)('IE_PROTO')
	  , ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 225 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(227)('keys')
	  , uid    = __webpack_require__(228);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(205)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 228 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(204)
	  , core    = __webpack_require__(206)
	  , fails   = __webpack_require__(215);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 230 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(201);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _typeof2 = __webpack_require__(233);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _iterator = __webpack_require__(234);

	var _iterator2 = _interopRequireDefault(_iterator);

	var _symbol = __webpack_require__(263);

	var _symbol2 = _interopRequireDefault(_symbol);

	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(235), __esModule: true };

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236);
	__webpack_require__(258);
	module.exports = __webpack_require__(262).f('iterator');

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(237)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(239)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(238)
	  , defined   = __webpack_require__(223);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 238 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(240)
	  , $export        = __webpack_require__(204)
	  , redefine       = __webpack_require__(241)
	  , hide           = __webpack_require__(209)
	  , has            = __webpack_require__(225)
	  , Iterators      = __webpack_require__(242)
	  , $iterCreate    = __webpack_require__(243)
	  , setToStringTag = __webpack_require__(256)
	  , getPrototypeOf = __webpack_require__(224)
	  , ITERATOR       = __webpack_require__(257)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 240 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(209);

/***/ },
/* 242 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(244)
	  , descriptor     = __webpack_require__(218)
	  , setToStringTag = __webpack_require__(256)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(209)(IteratorPrototype, __webpack_require__(257)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(211)
	  , dPs         = __webpack_require__(245)
	  , enumBugKeys = __webpack_require__(254)
	  , IE_PROTO    = __webpack_require__(226)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(216)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(255).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(210)
	  , anObject = __webpack_require__(211)
	  , getKeys  = __webpack_require__(246);

	module.exports = __webpack_require__(214) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(247)
	  , enumBugKeys = __webpack_require__(254);

	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(225)
	  , toIObject    = __webpack_require__(248)
	  , arrayIndexOf = __webpack_require__(251)(false)
	  , IE_PROTO     = __webpack_require__(226)('IE_PROTO');

	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(249)
	  , defined = __webpack_require__(223);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(250);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 250 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(248)
	  , toLength  = __webpack_require__(252)
	  , toIndex   = __webpack_require__(253);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(238)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(238)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 254 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(205).document && document.documentElement;

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(210).f
	  , has = __webpack_require__(225)
	  , TAG = __webpack_require__(257)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(227)('wks')
	  , uid        = __webpack_require__(228)
	  , Symbol     = __webpack_require__(205).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(259);
	var global        = __webpack_require__(205)
	  , hide          = __webpack_require__(209)
	  , Iterators     = __webpack_require__(242)
	  , TO_STRING_TAG = __webpack_require__(257)('toStringTag');

	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(260)
	  , step             = __webpack_require__(261)
	  , Iterators        = __webpack_require__(242)
	  , toIObject        = __webpack_require__(248);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(239)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 260 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 261 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(257);

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(264), __esModule: true };

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(265);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(278);
	module.exports = __webpack_require__(206).Symbol;

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(205)
	  , has            = __webpack_require__(225)
	  , DESCRIPTORS    = __webpack_require__(214)
	  , $export        = __webpack_require__(204)
	  , redefine       = __webpack_require__(241)
	  , META           = __webpack_require__(266).KEY
	  , $fails         = __webpack_require__(215)
	  , shared         = __webpack_require__(227)
	  , setToStringTag = __webpack_require__(256)
	  , uid            = __webpack_require__(228)
	  , wks            = __webpack_require__(257)
	  , wksExt         = __webpack_require__(262)
	  , wksDefine      = __webpack_require__(267)
	  , keyOf          = __webpack_require__(268)
	  , enumKeys       = __webpack_require__(269)
	  , isArray        = __webpack_require__(272)
	  , anObject       = __webpack_require__(211)
	  , toIObject      = __webpack_require__(248)
	  , toPrimitive    = __webpack_require__(217)
	  , createDesc     = __webpack_require__(218)
	  , _create        = __webpack_require__(244)
	  , gOPNExt        = __webpack_require__(273)
	  , $GOPD          = __webpack_require__(275)
	  , $DP            = __webpack_require__(210)
	  , $keys          = __webpack_require__(246)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(274).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(271).f  = $propertyIsEnumerable;
	  __webpack_require__(270).f = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(240)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(209)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(228)('meta')
	  , isObject = __webpack_require__(212)
	  , has      = __webpack_require__(225)
	  , setDesc  = __webpack_require__(210).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(215)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(205)
	  , core           = __webpack_require__(206)
	  , LIBRARY        = __webpack_require__(240)
	  , wksExt         = __webpack_require__(262)
	  , defineProperty = __webpack_require__(210).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(246)
	  , toIObject = __webpack_require__(248);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(246)
	  , gOPS    = __webpack_require__(270)
	  , pIE     = __webpack_require__(271);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 270 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 271 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(250);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(248)
	  , gOPN      = __webpack_require__(274).f
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(247)
	  , hiddenKeys = __webpack_require__(254).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(271)
	  , createDesc     = __webpack_require__(218)
	  , toIObject      = __webpack_require__(248)
	  , toPrimitive    = __webpack_require__(217)
	  , has            = __webpack_require__(225)
	  , IE8_DOM_DEFINE = __webpack_require__(213)
	  , gOPD           = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(214) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 276 */
/***/ function(module, exports) {

	

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(267)('asyncIterator');

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(267)('observable');

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _setPrototypeOf = __webpack_require__(280);

	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

	var _create = __webpack_require__(284);

	var _create2 = _interopRequireDefault(_create);

	var _typeof2 = __webpack_require__(233);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }

	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(281), __esModule: true };

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(282);
	module.exports = __webpack_require__(206).Object.setPrototypeOf;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(204);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(283).set});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(212)
	  , anObject = __webpack_require__(211);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(207)(Function.call, __webpack_require__(275).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(285), __esModule: true };

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(286);
	var $Object = __webpack_require__(206).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(204)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(244)});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }

	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}

	module.exports = warning;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 289 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var getDisplayName = function getDisplayName(Component) {
	  return Component.displayName || Component.name || (typeof Component === 'string' ? Component : 'Component');
	};

	exports.default = getDisplayName;

/***/ },
/* 290 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var MAP = exports.MAP = "__SECRET_MAP_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	// export const SKELETON = `__SECRET_SKELETON_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`;

	var MARKER = exports.MARKER = "__SECRET_MARKER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var RECTANGLE = exports.RECTANGLE = "__SECRET_RECTANGLE_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var POLYLINE = exports.POLYLINE = "__SECRET_POLYLINE_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var POLYGON = exports.POLYGON = "__SECRET_POLYGON_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var CIRCLE = exports.CIRCLE = "__SECRET_CIRCLE_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var KML_LAYER = exports.KML_LAYER = "__SECRET_KML_LAYER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var DIRECTIONS_RENDERER = exports.DIRECTIONS_RENDERER = "__SECRET_DIRECTIONS_RENDERER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var HEATMAP_LAYER = exports.HEATMAP_LAYER = "__SECRET_HEATMAP_LAYER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var ANCHOR = exports.ANCHOR = "__SECRET_ANCHOR_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var INFO_WINDOW = exports.INFO_WINDOW = "__SECRET_INFO_WINDOW_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var OVERLAY_VIEW = exports.OVERLAY_VIEW = "__SECRET_OVERLAY_VIEW_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var DRAWING_MANAGER = exports.DRAWING_MANAGER = "__SECRET_DRAWING_MANAGER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var SEARCH_BOX = exports.SEARCH_BOX = "__SECRET_SEARCH_BOX_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var MARKER_CLUSTERER = exports.MARKER_CLUSTERER = "__SECRET_MARKER_CLUSTERER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

	var INFO_BOX = exports.INFO_BOX = "__SECRET_INFO_BOX_DO_NOT_USE_OR_YOU_WILL_BE_FIRED";

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _toConsumableArray2 = __webpack_require__(297);

	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _invariant = __webpack_require__(288);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* global google */
	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Map
	  center: _react.PropTypes.object,

	  heading: _react.PropTypes.number,

	  mapTypeId: _react.PropTypes.any,

	  options: _react.PropTypes.object,

	  streetView: _react.PropTypes.any,

	  tilt: _react.PropTypes.number,

	  zoom: _react.PropTypes.number
	};

	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Map
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onBoundsChanged: "bounds_changed",

	  onCenterChanged: "center_changed",

	  onClick: "click",

	  onDblClick: "dblclick",

	  onDrag: "drag",

	  onDragEnd: "dragend",

	  onDragStart: "dragstart",

	  onHeadingChanged: "heading_changed",

	  onIdle: "idle",

	  onMapTypeIdChanged: "maptypeid_changed",

	  onMouseMove: "mousemove",

	  onMouseOut: "mouseout",

	  onMouseOver: "mouseover",

	  onProjectionChanged: "projection_changed",

	  onResize: "resize",

	  onRightClick: "rightclick",

	  onTilesLoaded: "tilesloaded",

	  onTiltChanged: "tilt_changed",

	  onZoomChanged: "zoom_changed"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Map
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getBounds: function getBounds(map) {
	    return map.getBounds();
	  },
	  getCenter: function getCenter(map) {
	    return map.getCenter();
	  },
	  getDiv: function getDiv(map) {
	    return map.getDiv();
	  },
	  getHeading: function getHeading(map) {
	    return map.getHeading();
	  },
	  getMapTypeId: function getMapTypeId(map) {
	    return map.getMapTypeId();
	  },
	  getProjection: function getProjection(map) {
	    return map.getProjection();
	  },
	  getStreetView: function getStreetView(map) {
	    return map.getStreetView();
	  },
	  getTilt: function getTilt(map) {
	    return map.getTilt();
	  },
	  getZoom: function getZoom(map) {
	    return map.getZoom();
	  },

	  // END - Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Map
	  //
	  // Public APIs - Use this carefully
	  // See discussion in https://github.com/tomchentw/react-google-maps/issues/62
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Map
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return !it.match(/^get/) && !it.match(/^set/) && !it.match(/Map$/); })
	  fitBounds: function fitBounds(map, args) {
	    return map.fitBounds.apply(map, (0, _toConsumableArray3.default)(args));
	  },
	  panBy: function panBy(map, args) {
	    return map.panBy.apply(map, (0, _toConsumableArray3.default)(args));
	  },
	  panTo: function panTo(map, args) {
	    return map.panTo.apply(map, (0, _toConsumableArray3.default)(args));
	  },
	  panToBounds: function panToBounds(map, args) {
	    return map.panToBounds.apply(map, (0, _toConsumableArray3.default)(args));
	  }
	};

	var controlledPropUpdaterMap = {
	  center: function center(map, _center) {
	    map.setCenter(_center);
	  },
	  heading: function heading(map, _heading) {
	    map.setHeading(_heading);
	  },
	  mapTypeId: function mapTypeId(map, _mapTypeId) {
	    map.setMapTypeId(_mapTypeId);
	  },
	  options: function options(map, _options) {
	    map.setOptions(_options);
	  },
	  streetView: function streetView(map, _streetView) {
	    map.setStreetView(_streetView);
	  },
	  tilt: function tilt(map, _tilt) {
	    map.setTilt(_tilt);
	  },
	  zoom: function zoom(map, _zoom) {
	    map.setZoom(_zoom);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.context[_constants.MAP];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "GoogleMap",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    var map = getInstanceFromComponent(this);

	    (0, _invariant2.default)(!!map, "Did you wrap <GoogleMap> component with withGoogleMap() HOC?");

	    map.setOptions((0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props));
	    return null;
	  },
	  render: function render() {
	    var children = this.props.children;


	    return _react2.default.createElement(
	      "div",
	      null,
	      children
	    );
	  }
	});

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _assign = __webpack_require__(293);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(294), __esModule: true };

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(295);
	module.exports = __webpack_require__(206).Object.assign;

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(204);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(296)});

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(246)
	  , gOPS     = __webpack_require__(270)
	  , pIE      = __webpack_require__(271)
	  , toObject = __webpack_require__(222)
	  , IObject  = __webpack_require__(249)
	  , $assign  = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(215)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _from = __webpack_require__(298);

	var _from2 = _interopRequireDefault(_from);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }

	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(299), __esModule: true };

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236);
	__webpack_require__(300);
	module.exports = __webpack_require__(206).Array.from;

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(207)
	  , $export        = __webpack_require__(204)
	  , toObject       = __webpack_require__(222)
	  , call           = __webpack_require__(301)
	  , isArrayIter    = __webpack_require__(302)
	  , toLength       = __webpack_require__(252)
	  , createProperty = __webpack_require__(303)
	  , getIterFn      = __webpack_require__(304);

	$export($export.S + $export.F * !__webpack_require__(306)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(211);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(242)
	  , ITERATOR   = __webpack_require__(257)('iterator')
	  , ArrayProto = Array.prototype;

	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(210)
	  , createDesc      = __webpack_require__(218);

	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(305)
	  , ITERATOR  = __webpack_require__(257)('iterator')
	  , Iterators = __webpack_require__(242);
	module.exports = __webpack_require__(206).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(250)
	  , TAG = __webpack_require__(257)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(257)('iterator')
	  , SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }

	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	var createFlow = __webpack_require__(308);

	/**
	 * This method is like `_.flow` except that it creates a function that
	 * invokes the given functions from right to left.
	 *
	 * @static
	 * @since 3.0.0
	 * @memberOf _
	 * @category Util
	 * @param {...(Function|Function[])} [funcs] The functions to invoke.
	 * @returns {Function} Returns the new composite function.
	 * @see _.flow
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var addSquare = _.flowRight([square, _.add]);
	 * addSquare(1, 2);
	 * // => 9
	 */
	var flowRight = createFlow(true);

	module.exports = flowRight;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	var LodashWrapper = __webpack_require__(309),
	    flatRest = __webpack_require__(313),
	    getData = __webpack_require__(343),
	    getFuncName = __webpack_require__(347),
	    isArray = __webpack_require__(327),
	    isLaziable = __webpack_require__(349);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_CURRY_FLAG = 8,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_ARY_FLAG = 128,
	    WRAP_REARG_FLAG = 256;

	/**
	 * Creates a `_.flow` or `_.flowRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new flow function.
	 */
	function createFlow(fromRight) {
	  return flatRest(function(funcs) {
	    var length = funcs.length,
	        index = length,
	        prereq = LodashWrapper.prototype.thru;

	    if (fromRight) {
	      funcs.reverse();
	    }
	    while (index--) {
	      var func = funcs[index];
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	        var wrapper = new LodashWrapper([], true);
	      }
	    }
	    index = wrapper ? index : length;
	    while (++index < length) {
	      func = funcs[index];

	      var funcName = getFuncName(func),
	          data = funcName == 'wrapper' ? getData(func) : undefined;

	      if (data && isLaziable(data[0]) &&
	            data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	            !data[4].length && data[9] == 1
	          ) {
	        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	      } else {
	        wrapper = (func.length == 1 && isLaziable(func))
	          ? wrapper[funcName]()
	          : wrapper.thru(func);
	      }
	    }
	    return function() {
	      var args = arguments,
	          value = args[0];

	      if (wrapper && args.length == 1 &&
	          isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	        return wrapper.plant(value).value();
	      }
	      var index = 0,
	          result = length ? funcs[index].apply(this, args) : value;

	      while (++index < length) {
	        result = funcs[index].call(this, result);
	      }
	      return result;
	    };
	  });
	}

	module.exports = createFlow;


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(310),
	    baseLodash = __webpack_require__(312);

	/**
	 * The base constructor for creating `lodash` wrapper objects.
	 *
	 * @private
	 * @param {*} value The value to wrap.
	 * @param {boolean} [chainAll] Enable explicit method chain sequences.
	 */
	function LodashWrapper(value, chainAll) {
	  this.__wrapped__ = value;
	  this.__actions__ = [];
	  this.__chain__ = !!chainAll;
	  this.__index__ = 0;
	  this.__values__ = undefined;
	}

	LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	LodashWrapper.prototype.constructor = LodashWrapper;

	module.exports = LodashWrapper;


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(311);

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	module.exports = baseCreate;


/***/ },
/* 311 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ },
/* 312 */
/***/ function(module, exports) {

	/**
	 * The function whose prototype chain sequence wrappers inherit from.
	 *
	 * @private
	 */
	function baseLodash() {
	  // No operation performed.
	}

	module.exports = baseLodash;


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var flatten = __webpack_require__(314),
	    overRest = __webpack_require__(328),
	    setToString = __webpack_require__(330);

	/**
	 * A specialized version of `baseRest` which flattens the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @returns {Function} Returns the new function.
	 */
	function flatRest(func) {
	  return setToString(overRest(func, undefined, flatten), func + '');
	}

	module.exports = flatRest;


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(315);

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	module.exports = flatten;


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(316),
	    isFlattenable = __webpack_require__(317);

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	module.exports = baseFlatten;


/***/ },
/* 316 */
/***/ function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(318),
	    isArguments = __webpack_require__(321),
	    isArray = __webpack_require__(327);

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	module.exports = isFlattenable;


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(319);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(320);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ },
/* 320 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(322),
	    isObjectLike = __webpack_require__(326);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(323),
	    isObjectLike = __webpack_require__(326);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(318),
	    getRawTag = __webpack_require__(324),
	    objectToString = __webpack_require__(325);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  value = Object(value);
	  return (symToStringTag && symToStringTag in value)
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(318);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ },
/* 325 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ },
/* 326 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 327 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(329);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ },
/* 329 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(331),
	    shortOut = __webpack_require__(342);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(332),
	    defineProperty = __webpack_require__(333),
	    identity = __webpack_require__(341);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ },
/* 332 */
/***/ function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(334);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(335),
	    getValue = __webpack_require__(340);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(336),
	    isMasked = __webpack_require__(337),
	    isObject = __webpack_require__(311),
	    toSource = __webpack_require__(339);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(323),
	    isObject = __webpack_require__(311);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(338);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(319);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ },
/* 339 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ },
/* 340 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ },
/* 341 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ },
/* 342 */
/***/ function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	var metaMap = __webpack_require__(344),
	    noop = __webpack_require__(346);

	/**
	 * Gets metadata for `func`.
	 *
	 * @private
	 * @param {Function} func The function to query.
	 * @returns {*} Returns the metadata for `func`.
	 */
	var getData = !metaMap ? noop : function(func) {
	  return metaMap.get(func);
	};

	module.exports = getData;


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	var WeakMap = __webpack_require__(345);

	/** Used to store function metadata. */
	var metaMap = WeakMap && new WeakMap;

	module.exports = metaMap;


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(334),
	    root = __webpack_require__(319);

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	module.exports = WeakMap;


/***/ },
/* 346 */
/***/ function(module, exports) {

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	module.exports = noop;


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	var realNames = __webpack_require__(348);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the name of `func`.
	 *
	 * @private
	 * @param {Function} func The function to query.
	 * @returns {string} Returns the function name.
	 */
	function getFuncName(func) {
	  var result = (func.name + ''),
	      array = realNames[result],
	      length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	  while (length--) {
	    var data = array[length],
	        otherFunc = data.func;
	    if (otherFunc == null || otherFunc == func) {
	      return data.name;
	    }
	  }
	  return result;
	}

	module.exports = getFuncName;


/***/ },
/* 348 */
/***/ function(module, exports) {

	/** Used to lookup unminified function names. */
	var realNames = {};

	module.exports = realNames;


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var LazyWrapper = __webpack_require__(350),
	    getData = __webpack_require__(343),
	    getFuncName = __webpack_require__(347),
	    lodash = __webpack_require__(351);

	/**
	 * Checks if `func` has a lazy counterpart.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	 *  else `false`.
	 */
	function isLaziable(func) {
	  var funcName = getFuncName(func),
	      other = lodash[funcName];

	  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	    return false;
	  }
	  if (func === other) {
	    return true;
	  }
	  var data = getData(other);
	  return !!data && func === data[0];
	}

	module.exports = isLaziable;


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(310),
	    baseLodash = __webpack_require__(312);

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH = 4294967295;

	/**
	 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	 *
	 * @private
	 * @constructor
	 * @param {*} value The value to wrap.
	 */
	function LazyWrapper(value) {
	  this.__wrapped__ = value;
	  this.__actions__ = [];
	  this.__dir__ = 1;
	  this.__filtered__ = false;
	  this.__iteratees__ = [];
	  this.__takeCount__ = MAX_ARRAY_LENGTH;
	  this.__views__ = [];
	}

	// Ensure `LazyWrapper` is an instance of `baseLodash`.
	LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	LazyWrapper.prototype.constructor = LazyWrapper;

	module.exports = LazyWrapper;


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var LazyWrapper = __webpack_require__(350),
	    LodashWrapper = __webpack_require__(309),
	    baseLodash = __webpack_require__(312),
	    isArray = __webpack_require__(327),
	    isObjectLike = __webpack_require__(326),
	    wrapperClone = __webpack_require__(352);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates a `lodash` object which wraps `value` to enable implicit method
	 * chain sequences. Methods that operate on and return arrays, collections,
	 * and functions can be chained together. Methods that retrieve a single value
	 * or may return a primitive value will automatically end the chain sequence
	 * and return the unwrapped value. Otherwise, the value must be unwrapped
	 * with `_#value`.
	 *
	 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	 * enabled using `_.chain`.
	 *
	 * The execution of chained methods is lazy, that is, it's deferred until
	 * `_#value` is implicitly or explicitly called.
	 *
	 * Lazy evaluation allows several methods to support shortcut fusion.
	 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	 * the creation of intermediate arrays and can greatly reduce the number of
	 * iteratee executions. Sections of a chain sequence qualify for shortcut
	 * fusion if the section is applied to an array of at least `200` elements
	 * and any iteratees accept only one argument. The heuristic for whether a
	 * section qualifies for shortcut fusion is subject to change.
	 *
	 * Chaining is supported in custom builds as long as the `_#value` method is
	 * directly or indirectly included in the build.
	 *
	 * In addition to lodash methods, wrappers have `Array` and `String` methods.
	 *
	 * The wrapper `Array` methods are:
	 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	 *
	 * The wrapper `String` methods are:
	 * `replace` and `split`
	 *
	 * The wrapper methods that support shortcut fusion are:
	 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	 *
	 * The chainable wrapper methods are:
	 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	 * `zipObject`, `zipObjectDeep`, and `zipWith`
	 *
	 * The wrapper methods that are **not** chainable by default are:
	 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	 * `upperFirst`, `value`, and `words`
	 *
	 * @name _
	 * @constructor
	 * @category Seq
	 * @param {*} value The value to wrap in a `lodash` instance.
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var wrapped = _([1, 2, 3]);
	 *
	 * // Returns an unwrapped value.
	 * wrapped.reduce(_.add);
	 * // => 6
	 *
	 * // Returns a wrapped value.
	 * var squares = wrapped.map(square);
	 *
	 * _.isArray(squares);
	 * // => false
	 *
	 * _.isArray(squares.value());
	 * // => true
	 */
	function lodash(value) {
	  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	    if (value instanceof LodashWrapper) {
	      return value;
	    }
	    if (hasOwnProperty.call(value, '__wrapped__')) {
	      return wrapperClone(value);
	    }
	  }
	  return new LodashWrapper(value);
	}

	// Ensure wrappers are instances of `baseLodash`.
	lodash.prototype = baseLodash.prototype;
	lodash.prototype.constructor = lodash;

	module.exports = lodash;


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var LazyWrapper = __webpack_require__(350),
	    LodashWrapper = __webpack_require__(309),
	    copyArray = __webpack_require__(353);

	/**
	 * Creates a clone of `wrapper`.
	 *
	 * @private
	 * @param {Object} wrapper The wrapper to clone.
	 * @returns {Object} Returns the cloned wrapper.
	 */
	function wrapperClone(wrapper) {
	  if (wrapper instanceof LazyWrapper) {
	    return wrapper.clone();
	  }
	  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	  result.__actions__ = copyArray(wrapper.__actions__);
	  result.__index__  = wrapper.__index__;
	  result.__values__ = wrapper.__values__;
	  return result;
	}

	module.exports = wrapperClone;


/***/ },
/* 353 */
/***/ function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	module.exports = copyArray;


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _curry2 = __webpack_require__(355);

	var _curry3 = _interopRequireDefault(_curry2);

	var _noop2 = __webpack_require__(346);

	var _noop3 = _interopRequireDefault(_noop2);

	var _forEach2 = __webpack_require__(387);

	var _forEach3 = _interopRequireDefault(_forEach2);

	var _bind2 = __webpack_require__(410);

	var _bind3 = _interopRequireDefault(_bind2);

	var _has2 = __webpack_require__(412);

	var _has3 = _interopRequireDefault(_has2);

	var _reduce2 = __webpack_require__(448);

	var _reduce3 = _interopRequireDefault(_reduce2);

	var _identity2 = __webpack_require__(341);

	var _identity3 = _interopRequireDefault(_identity2);

	var _mapKeys2 = __webpack_require__(488);

	var _mapKeys3 = _interopRequireDefault(_mapKeys2);

	exports.addDefaultPrefixToPropTypes = addDefaultPrefixToPropTypes;
	exports.collectUncontrolledAndControlledProps = collectUncontrolledAndControlledProps;
	exports.default = enhanceElement;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* global google */
	function addDefaultPrefixToPropTypes(propTypes /*: Object*/) {
	  return (0, _mapKeys3.default)(propTypes, function (value, key) {
	    return "default" + key.substr(0, 1).toUpperCase() + key.substr(1);
	  });
	}

	function removeDefaultPrefix(defaultKey) {
	  // default = 7
	  var key = defaultKey.substr(7);
	  return "" + key.substr(0, 1).toLowerCase() + key.substr(1);
	}

	function collectProps(propTypes /*: Object*/, props /*: Object*/) {
	  var keyTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _identity3.default;

	  return (0, _reduce3.default)(propTypes, function (acc, value, key) {
	    if ((0, _has3.default)(props, key)) {
	      var nextKey = keyTransform(key);
	      // eslint-disable-next-line no-param-reassign
	      acc[nextKey] = props[key];
	    }
	    return acc;
	  }, {});
	}

	function collectUncontrolledAndControlledProps(defaultUncontrolledPropTypes /*: Object*/, controlledPropTypes /*: Object*/, props /*: Object*/) {
	  return (0, _extends3.default)({}, collectProps(defaultUncontrolledPropTypes, props, removeDefaultPrefix), collectProps(controlledPropTypes, props));
	}

	function registerGoogleEventsFromReactProps(instance /*: Object*/, props /*: Object*/, eventMap /*: Object*/) {
	  var registered = (0, _reduce3.default)(eventMap, function (acc, googleEventName, onEventName) {
	    if ((0, _has3.default)(props, onEventName)) {
	      acc.push(google.maps.event.addListener(instance, googleEventName, props[onEventName]));
	    }
	    return acc;
	  }, []);

	  return (0, _bind3.default)(_forEach3.default, null, registered, function (event) {
	    return google.maps.event.removeListener(event);
	  });
	}

	function registerEventsFromComponent(component, getInstanceFromComponent, eventMap) {
	  var instance = getInstanceFromComponent(component);
	  // eslint-disable-next-line no-param-reassign
	  component._unregisterEvents = registerGoogleEventsFromReactProps(instance, component.props, eventMap);
	}

	function unregisterEventsFromComponent(component, getInstanceFromComponent) {
	  // eslint-disable-next-line no-param-reassign
	  component._unregisterEvents();
	  // eslint-disable-next-line no-param-reassign
	  component._unregisterEvents = _noop3.default;
	}

	var enhanceWithPropTypes = (0, _curry3.default)(function (getInstanceFromComponent, controlledPropUpdaterMap, componentSpec) {
	  var _componentSpec$compon = componentSpec.componentDidUpdate;

	  var _componentDidUpdate = _componentSpec$compon === undefined ? _noop3.default : _componentSpec$compon;

	  return (0, _extends3.default)({}, componentSpec, {
	    componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	      var _this = this;

	      (0, _forEach3.default)(controlledPropUpdaterMap, function (fn, key) {
	        var nextValue = _this.props[key];
	        if (nextValue !== prevProps[key]) {
	          fn(getInstanceFromComponent(_this), nextValue, _this);
	        }
	      });
	      _componentDidUpdate.call(this, prevProps, prevState);
	    }
	  });
	});

	var enhanceWithEventMap = (0, _curry3.default)(function (getInstanceFromComponent, eventMap, componentSpec) {
	  var _componentSpec$compon2 = componentSpec.componentDidMount;

	  var _componentDidMount = _componentSpec$compon2 === undefined ? _noop3.default : _componentSpec$compon2;

	  var _componentSpec$compon3 = componentSpec.componentDidUpdate;

	  var _componentDidUpdate2 = _componentSpec$compon3 === undefined ? _noop3.default : _componentSpec$compon3;

	  var _componentSpec$compon4 = componentSpec.componentWillUnmount;

	  var _componentWillUnmount = _componentSpec$compon4 === undefined ? _noop3.default : _componentSpec$compon4;

	  return (0, _extends3.default)({}, componentSpec, {

	    _unregisterEvents: _noop3.default,

	    componentDidMount: function componentDidMount() {
	      _componentDidMount.call(this);
	      registerEventsFromComponent(this, getInstanceFromComponent, eventMap);
	    },
	    componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	      unregisterEventsFromComponent(this, getInstanceFromComponent);
	      _componentDidUpdate2.call(this, prevProps, prevState);
	      registerEventsFromComponent(this, getInstanceFromComponent, eventMap);
	    },
	    componentWillUnmount: function componentWillUnmount() {
	      unregisterEventsFromComponent(this, getInstanceFromComponent);
	      _componentWillUnmount.call(this);
	    }
	  });
	});

	var enhanceWithPublicMethod = (0, _curry3.default)(function (getInstanceFromComponent, publicMethodMap, componentSpec) {
	  return (0, _reduce3.default)(publicMethodMap, function (acc, fn, publicMethodName) {
	    // eslint-disable-next-line no-param-reassign
	    acc[publicMethodName] = function publicMethod() {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return fn(getInstanceFromComponent(this), args, /* Use with caution */this);
	    };
	    return acc;
	  }, (0, _extends3.default)({}, componentSpec));
	});

	function enhanceElement(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap) {
	  return (0, _flowRight3.default)(enhanceWithPublicMethod(getInstanceFromComponent, publicMethodMap), enhanceWithEventMap(getInstanceFromComponent, eventMap), enhanceWithPropTypes(getInstanceFromComponent, controlledPropUpdaterMap));
	}

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var createWrap = __webpack_require__(356);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_CURRY_FLAG = 8;

	/**
	 * Creates a function that accepts arguments of `func` and either invokes
	 * `func` returning its result, if at least `arity` number of arguments have
	 * been provided, or returns a function that accepts the remaining `func`
	 * arguments, and so on. The arity of `func` may be specified if `func.length`
	 * is not sufficient.
	 *
	 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	 * may be used as a placeholder for provided arguments.
	 *
	 * **Note:** This method doesn't set the "length" property of curried functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Function
	 * @param {Function} func The function to curry.
	 * @param {number} [arity=func.length] The arity of `func`.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the new curried function.
	 * @example
	 *
	 * var abc = function(a, b, c) {
	 *   return [a, b, c];
	 * };
	 *
	 * var curried = _.curry(abc);
	 *
	 * curried(1)(2)(3);
	 * // => [1, 2, 3]
	 *
	 * curried(1, 2)(3);
	 * // => [1, 2, 3]
	 *
	 * curried(1, 2, 3);
	 * // => [1, 2, 3]
	 *
	 * // Curried with placeholders.
	 * curried(1)(_, 3)(2);
	 * // => [1, 2, 3]
	 */
	function curry(func, arity, guard) {
	  arity = guard ? undefined : arity;
	  var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	  result.placeholder = curry.placeholder;
	  return result;
	}

	// Assign default placeholders.
	curry.placeholder = {};

	module.exports = curry;


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetData = __webpack_require__(357),
	    createBind = __webpack_require__(358),
	    createCurry = __webpack_require__(360),
	    createHybrid = __webpack_require__(361),
	    createPartial = __webpack_require__(381),
	    getData = __webpack_require__(343),
	    mergeData = __webpack_require__(382),
	    setData = __webpack_require__(366),
	    setWrapToString = __webpack_require__(367),
	    toInteger = __webpack_require__(383);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_CURRY_RIGHT_FLAG = 16,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_PARTIAL_RIGHT_FLAG = 64;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates a function that either curries or invokes `func` with optional
	 * `this` binding and partially applied arguments.
	 *
	 * @private
	 * @param {Function|string} func The function or method name to wrap.
	 * @param {number} bitmask The bitmask flags.
	 *    1 - `_.bind`
	 *    2 - `_.bindKey`
	 *    4 - `_.curry` or `_.curryRight` of a bound function
	 *    8 - `_.curry`
	 *   16 - `_.curryRight`
	 *   32 - `_.partial`
	 *   64 - `_.partialRight`
	 *  128 - `_.rearg`
	 *  256 - `_.ary`
	 *  512 - `_.flip`
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to be partially applied.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	  if (!isBindKey && typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var length = partials ? partials.length : 0;
	  if (!length) {
	    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	    partials = holders = undefined;
	  }
	  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	  arity = arity === undefined ? arity : toInteger(arity);
	  length -= holders ? holders.length : 0;

	  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	    var partialsRight = partials,
	        holdersRight = holders;

	    partials = holders = undefined;
	  }
	  var data = isBindKey ? undefined : getData(func);

	  var newData = [
	    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	    argPos, ary, arity
	  ];

	  if (data) {
	    mergeData(newData, data);
	  }
	  func = newData[0];
	  bitmask = newData[1];
	  thisArg = newData[2];
	  partials = newData[3];
	  holders = newData[4];
	  arity = newData[9] = newData[9] == null
	    ? (isBindKey ? 0 : func.length)
	    : nativeMax(newData[9] - length, 0);

	  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	  }
	  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	    var result = createBind(func, bitmask, thisArg);
	  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	    result = createCurry(func, bitmask, arity);
	  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	    result = createPartial(func, bitmask, thisArg, partials);
	  } else {
	    result = createHybrid.apply(undefined, newData);
	  }
	  var setter = data ? baseSetData : setData;
	  return setWrapToString(setter(result, newData), func, bitmask);
	}

	module.exports = createWrap;


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(341),
	    metaMap = __webpack_require__(344);

	/**
	 * The base implementation of `setData` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetData = !metaMap ? identity : function(func, data) {
	  metaMap.set(func, data);
	  return func;
	};

	module.exports = baseSetData;


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	var createCtor = __webpack_require__(359),
	    root = __webpack_require__(319);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the optional `this`
	 * binding of `thisArg`.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createBind(func, bitmask, thisArg) {
	  var isBind = bitmask & WRAP_BIND_FLAG,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	    return fn.apply(isBind ? thisArg : this, arguments);
	  }
	  return wrapper;
	}

	module.exports = createBind;


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(310),
	    isObject = __webpack_require__(311);

	/**
	 * Creates a function that produces an instance of `Ctor` regardless of
	 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	 *
	 * @private
	 * @param {Function} Ctor The constructor to wrap.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCtor(Ctor) {
	  return function() {
	    // Use a `switch` statement to work with class constructors. See
	    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	    // for more details.
	    var args = arguments;
	    switch (args.length) {
	      case 0: return new Ctor;
	      case 1: return new Ctor(args[0]);
	      case 2: return new Ctor(args[0], args[1]);
	      case 3: return new Ctor(args[0], args[1], args[2]);
	      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	    }
	    var thisBinding = baseCreate(Ctor.prototype),
	        result = Ctor.apply(thisBinding, args);

	    // Mimic the constructor's `return` behavior.
	    // See https://es5.github.io/#x13.2.2 for more details.
	    return isObject(result) ? result : thisBinding;
	  };
	}

	module.exports = createCtor;


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(329),
	    createCtor = __webpack_require__(359),
	    createHybrid = __webpack_require__(361),
	    createRecurry = __webpack_require__(365),
	    getHolder = __webpack_require__(377),
	    replaceHolders = __webpack_require__(380),
	    root = __webpack_require__(319);

	/**
	 * Creates a function that wraps `func` to enable currying.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {number} arity The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCurry(func, bitmask, arity) {
	  var Ctor = createCtor(func);

	  function wrapper() {
	    var length = arguments.length,
	        args = Array(length),
	        index = length,
	        placeholder = getHolder(wrapper);

	    while (index--) {
	      args[index] = arguments[index];
	    }
	    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	      ? []
	      : replaceHolders(args, placeholder);

	    length -= holders.length;
	    if (length < arity) {
	      return createRecurry(
	        func, bitmask, createHybrid, wrapper.placeholder, undefined,
	        args, holders, undefined, undefined, arity - length);
	    }
	    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	    return apply(fn, this, args);
	  }
	  return wrapper;
	}

	module.exports = createCurry;


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	var composeArgs = __webpack_require__(362),
	    composeArgsRight = __webpack_require__(363),
	    countHolders = __webpack_require__(364),
	    createCtor = __webpack_require__(359),
	    createRecurry = __webpack_require__(365),
	    getHolder = __webpack_require__(377),
	    reorder = __webpack_require__(378),
	    replaceHolders = __webpack_require__(380),
	    root = __webpack_require__(319);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_CURRY_RIGHT_FLAG = 16,
	    WRAP_ARY_FLAG = 128,
	    WRAP_FLIP_FLAG = 512;

	/**
	 * Creates a function that wraps `func` to invoke it with optional `this`
	 * binding of `thisArg`, partial application, and currying.
	 *
	 * @private
	 * @param {Function|string} func The function or method name to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to prepend to those provided to
	 *  the new function.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [partialsRight] The arguments to append to those provided
	 *  to the new function.
	 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	  var isAry = bitmask & WRAP_ARY_FLAG,
	      isBind = bitmask & WRAP_BIND_FLAG,
	      isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	      isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	      isFlip = bitmask & WRAP_FLIP_FLAG,
	      Ctor = isBindKey ? undefined : createCtor(func);

	  function wrapper() {
	    var length = arguments.length,
	        args = Array(length),
	        index = length;

	    while (index--) {
	      args[index] = arguments[index];
	    }
	    if (isCurried) {
	      var placeholder = getHolder(wrapper),
	          holdersCount = countHolders(args, placeholder);
	    }
	    if (partials) {
	      args = composeArgs(args, partials, holders, isCurried);
	    }
	    if (partialsRight) {
	      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	    }
	    length -= holdersCount;
	    if (isCurried && length < arity) {
	      var newHolders = replaceHolders(args, placeholder);
	      return createRecurry(
	        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	        args, newHolders, argPos, ary, arity - length
	      );
	    }
	    var thisBinding = isBind ? thisArg : this,
	        fn = isBindKey ? thisBinding[func] : func;

	    length = args.length;
	    if (argPos) {
	      args = reorder(args, argPos);
	    } else if (isFlip && length > 1) {
	      args.reverse();
	    }
	    if (isAry && ary < length) {
	      args.length = ary;
	    }
	    if (this && this !== root && this instanceof wrapper) {
	      fn = Ctor || createCtor(fn);
	    }
	    return fn.apply(thisBinding, args);
	  }
	  return wrapper;
	}

	module.exports = createHybrid;


/***/ },
/* 362 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates an array that is the composition of partially applied arguments,
	 * placeholders, and provided arguments into a single array of arguments.
	 *
	 * @private
	 * @param {Array} args The provided arguments.
	 * @param {Array} partials The arguments to prepend to those provided.
	 * @param {Array} holders The `partials` placeholder indexes.
	 * @params {boolean} [isCurried] Specify composing for a curried function.
	 * @returns {Array} Returns the new array of composed arguments.
	 */
	function composeArgs(args, partials, holders, isCurried) {
	  var argsIndex = -1,
	      argsLength = args.length,
	      holdersLength = holders.length,
	      leftIndex = -1,
	      leftLength = partials.length,
	      rangeLength = nativeMax(argsLength - holdersLength, 0),
	      result = Array(leftLength + rangeLength),
	      isUncurried = !isCurried;

	  while (++leftIndex < leftLength) {
	    result[leftIndex] = partials[leftIndex];
	  }
	  while (++argsIndex < holdersLength) {
	    if (isUncurried || argsIndex < argsLength) {
	      result[holders[argsIndex]] = args[argsIndex];
	    }
	  }
	  while (rangeLength--) {
	    result[leftIndex++] = args[argsIndex++];
	  }
	  return result;
	}

	module.exports = composeArgs;


/***/ },
/* 363 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This function is like `composeArgs` except that the arguments composition
	 * is tailored for `_.partialRight`.
	 *
	 * @private
	 * @param {Array} args The provided arguments.
	 * @param {Array} partials The arguments to append to those provided.
	 * @param {Array} holders The `partials` placeholder indexes.
	 * @params {boolean} [isCurried] Specify composing for a curried function.
	 * @returns {Array} Returns the new array of composed arguments.
	 */
	function composeArgsRight(args, partials, holders, isCurried) {
	  var argsIndex = -1,
	      argsLength = args.length,
	      holdersIndex = -1,
	      holdersLength = holders.length,
	      rightIndex = -1,
	      rightLength = partials.length,
	      rangeLength = nativeMax(argsLength - holdersLength, 0),
	      result = Array(rangeLength + rightLength),
	      isUncurried = !isCurried;

	  while (++argsIndex < rangeLength) {
	    result[argsIndex] = args[argsIndex];
	  }
	  var offset = argsIndex;
	  while (++rightIndex < rightLength) {
	    result[offset + rightIndex] = partials[rightIndex];
	  }
	  while (++holdersIndex < holdersLength) {
	    if (isUncurried || argsIndex < argsLength) {
	      result[offset + holders[holdersIndex]] = args[argsIndex++];
	    }
	  }
	  return result;
	}

	module.exports = composeArgsRight;


/***/ },
/* 364 */
/***/ function(module, exports) {

	/**
	 * Gets the number of `placeholder` occurrences in `array`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} placeholder The placeholder to search for.
	 * @returns {number} Returns the placeholder count.
	 */
	function countHolders(array, placeholder) {
	  var length = array.length,
	      result = 0;

	  while (length--) {
	    if (array[length] === placeholder) {
	      ++result;
	    }
	  }
	  return result;
	}

	module.exports = countHolders;


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var isLaziable = __webpack_require__(349),
	    setData = __webpack_require__(366),
	    setWrapToString = __webpack_require__(367);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_BOUND_FLAG = 4,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_PARTIAL_RIGHT_FLAG = 64;

	/**
	 * Creates a function that wraps `func` to continue currying.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {Function} wrapFunc The function to create the `func` wrapper.
	 * @param {*} placeholder The placeholder value.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to prepend to those provided to
	 *  the new function.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	  var isCurry = bitmask & WRAP_CURRY_FLAG,
	      newHolders = isCurry ? holders : undefined,
	      newHoldersRight = isCurry ? undefined : holders,
	      newPartials = isCurry ? partials : undefined,
	      newPartialsRight = isCurry ? undefined : partials;

	  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

	  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	  }
	  var newData = [
	    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	    newHoldersRight, argPos, ary, arity
	  ];

	  var result = wrapFunc.apply(undefined, newData);
	  if (isLaziable(func)) {
	    setData(result, newData);
	  }
	  result.placeholder = placeholder;
	  return setWrapToString(result, func, bitmask);
	}

	module.exports = createRecurry;


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetData = __webpack_require__(357),
	    shortOut = __webpack_require__(342);

	/**
	 * Sets metadata for `func`.
	 *
	 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	 * period of time, it will trip its breaker and transition to an identity
	 * function to avoid garbage collection pauses in V8. See
	 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	 * for more details.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var setData = shortOut(baseSetData);

	module.exports = setData;


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	var getWrapDetails = __webpack_require__(368),
	    insertWrapDetails = __webpack_require__(369),
	    setToString = __webpack_require__(330),
	    updateWrapDetails = __webpack_require__(370);

	/**
	 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	 * with wrapper details in a comment at the top of the source body.
	 *
	 * @private
	 * @param {Function} wrapper The function to modify.
	 * @param {Function} reference The reference function.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @returns {Function} Returns `wrapper`.
	 */
	function setWrapToString(wrapper, reference, bitmask) {
	  var source = (reference + '');
	  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	}

	module.exports = setWrapToString;


/***/ },
/* 368 */
/***/ function(module, exports) {

	/** Used to match wrap detail comments. */
	var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	    reSplitDetails = /,? & /;

	/**
	 * Extracts wrapper details from the `source` body comment.
	 *
	 * @private
	 * @param {string} source The source to inspect.
	 * @returns {Array} Returns the wrapper details.
	 */
	function getWrapDetails(source) {
	  var match = source.match(reWrapDetails);
	  return match ? match[1].split(reSplitDetails) : [];
	}

	module.exports = getWrapDetails;


/***/ },
/* 369 */
/***/ function(module, exports) {

	/** Used to match wrap detail comments. */
	var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

	/**
	 * Inserts wrapper `details` in a comment at the top of the `source` body.
	 *
	 * @private
	 * @param {string} source The source to modify.
	 * @returns {Array} details The details to insert.
	 * @returns {string} Returns the modified source.
	 */
	function insertWrapDetails(source, details) {
	  var length = details.length;
	  if (!length) {
	    return source;
	  }
	  var lastIndex = length - 1;
	  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	  details = details.join(length > 2 ? ', ' : ' ');
	  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	}

	module.exports = insertWrapDetails;


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var arrayEach = __webpack_require__(371),
	    arrayIncludes = __webpack_require__(372);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_CURRY_RIGHT_FLAG = 16,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_PARTIAL_RIGHT_FLAG = 64,
	    WRAP_ARY_FLAG = 128,
	    WRAP_REARG_FLAG = 256,
	    WRAP_FLIP_FLAG = 512;

	/** Used to associate wrap methods with their bit flags. */
	var wrapFlags = [
	  ['ary', WRAP_ARY_FLAG],
	  ['bind', WRAP_BIND_FLAG],
	  ['bindKey', WRAP_BIND_KEY_FLAG],
	  ['curry', WRAP_CURRY_FLAG],
	  ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	  ['flip', WRAP_FLIP_FLAG],
	  ['partial', WRAP_PARTIAL_FLAG],
	  ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	  ['rearg', WRAP_REARG_FLAG]
	];

	/**
	 * Updates wrapper `details` based on `bitmask` flags.
	 *
	 * @private
	 * @returns {Array} details The details to modify.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @returns {Array} Returns `details`.
	 */
	function updateWrapDetails(details, bitmask) {
	  arrayEach(wrapFlags, function(pair) {
	    var value = '_.' + pair[0];
	    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	      details.push(value);
	    }
	  });
	  return details.sort();
	}

	module.exports = updateWrapDetails;


/***/ },
/* 371 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	module.exports = arrayEach;


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(373);

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	module.exports = arrayIncludes;


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(374),
	    baseIsNaN = __webpack_require__(375),
	    strictIndexOf = __webpack_require__(376);

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	module.exports = baseIndexOf;


/***/ },
/* 374 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = baseFindIndex;


/***/ },
/* 375 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	module.exports = baseIsNaN;


/***/ },
/* 376 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = strictIndexOf;


/***/ },
/* 377 */
/***/ function(module, exports) {

	/**
	 * Gets the argument placeholder value for `func`.
	 *
	 * @private
	 * @param {Function} func The function to inspect.
	 * @returns {*} Returns the placeholder value.
	 */
	function getHolder(func) {
	  var object = func;
	  return object.placeholder;
	}

	module.exports = getHolder;


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	var copyArray = __webpack_require__(353),
	    isIndex = __webpack_require__(379);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Reorder `array` according to the specified indexes where the element at
	 * the first index is assigned as the first element, the element at
	 * the second index is assigned as the second element, and so on.
	 *
	 * @private
	 * @param {Array} array The array to reorder.
	 * @param {Array} indexes The arranged array indexes.
	 * @returns {Array} Returns `array`.
	 */
	function reorder(array, indexes) {
	  var arrLength = array.length,
	      length = nativeMin(indexes.length, arrLength),
	      oldArray = copyArray(array);

	  while (length--) {
	    var index = indexes[length];
	    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	  }
	  return array;
	}

	module.exports = reorder;


/***/ },
/* 379 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ },
/* 380 */
/***/ function(module, exports) {

	/** Used as the internal argument placeholder. */
	var PLACEHOLDER = '__lodash_placeholder__';

	/**
	 * Replaces all `placeholder` elements in `array` with an internal placeholder
	 * and returns an array of their indexes.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {*} placeholder The placeholder to replace.
	 * @returns {Array} Returns the new array of placeholder indexes.
	 */
	function replaceHolders(array, placeholder) {
	  var index = -1,
	      length = array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (value === placeholder || value === PLACEHOLDER) {
	      array[index] = PLACEHOLDER;
	      result[resIndex++] = index;
	    }
	  }
	  return result;
	}

	module.exports = replaceHolders;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(329),
	    createCtor = __webpack_require__(359),
	    root = __webpack_require__(319);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the `this` binding
	 * of `thisArg` and `partials` prepended to the arguments it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} partials The arguments to prepend to those provided to
	 *  the new function.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createPartial(func, bitmask, thisArg, partials) {
	  var isBind = bitmask & WRAP_BIND_FLAG,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var argsIndex = -1,
	        argsLength = arguments.length,
	        leftIndex = -1,
	        leftLength = partials.length,
	        args = Array(leftLength + argsLength),
	        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	    while (++leftIndex < leftLength) {
	      args[leftIndex] = partials[leftIndex];
	    }
	    while (argsLength--) {
	      args[leftIndex++] = arguments[++argsIndex];
	    }
	    return apply(fn, isBind ? thisArg : this, args);
	  }
	  return wrapper;
	}

	module.exports = createPartial;


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	var composeArgs = __webpack_require__(362),
	    composeArgsRight = __webpack_require__(363),
	    replaceHolders = __webpack_require__(380);

	/** Used as the internal argument placeholder. */
	var PLACEHOLDER = '__lodash_placeholder__';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_BOUND_FLAG = 4,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_ARY_FLAG = 128,
	    WRAP_REARG_FLAG = 256;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Merges the function metadata of `source` into `data`.
	 *
	 * Merging metadata reduces the number of wrappers used to invoke a function.
	 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	 * may be applied regardless of execution order. Methods like `_.ary` and
	 * `_.rearg` modify function arguments, making the order in which they are
	 * executed important, preventing the merging of metadata. However, we make
	 * an exception for a safe combined case where curried functions have `_.ary`
	 * and or `_.rearg` applied.
	 *
	 * @private
	 * @param {Array} data The destination metadata.
	 * @param {Array} source The source metadata.
	 * @returns {Array} Returns `data`.
	 */
	function mergeData(data, source) {
	  var bitmask = data[1],
	      srcBitmask = source[1],
	      newBitmask = bitmask | srcBitmask,
	      isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

	  var isCombo =
	    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	    ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

	  // Exit early if metadata can't be merged.
	  if (!(isCommon || isCombo)) {
	    return data;
	  }
	  // Use source `thisArg` if available.
	  if (srcBitmask & WRAP_BIND_FLAG) {
	    data[2] = source[2];
	    // Set when currying a bound function.
	    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	  }
	  // Compose partial arguments.
	  var value = source[3];
	  if (value) {
	    var partials = data[3];
	    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	  }
	  // Compose partial right arguments.
	  value = source[5];
	  if (value) {
	    partials = data[5];
	    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	  }
	  // Use source `argPos` if available.
	  value = source[7];
	  if (value) {
	    data[7] = value;
	  }
	  // Use source `ary` if it's smaller.
	  if (srcBitmask & WRAP_ARY_FLAG) {
	    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	  }
	  // Use source `arity` if one is not provided.
	  if (data[9] == null) {
	    data[9] = source[9];
	  }
	  // Use source `func` and merge bitmasks.
	  data[0] = source[0];
	  data[1] = newBitmask;

	  return data;
	}

	module.exports = mergeData;


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	var toFinite = __webpack_require__(384);

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	module.exports = toInteger;


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(385);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	module.exports = toFinite;


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(311),
	    isSymbol = __webpack_require__(386);

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = toNumber;


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(323),
	    isObjectLike = __webpack_require__(326);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var arrayEach = __webpack_require__(371),
	    baseEach = __webpack_require__(388),
	    castFunction = __webpack_require__(409),
	    isArray = __webpack_require__(327);

	/**
	 * Iterates over elements of `collection` and invokes `iteratee` for each element.
	 * The iteratee is invoked with three arguments: (value, index|key, collection).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length"
	 * property are iterated like arrays. To avoid this behavior use `_.forIn`
	 * or `_.forOwn` for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @alias each
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 * @see _.forEachRight
	 * @example
	 *
	 * _.forEach([1, 2], function(value) {
	 *   console.log(value);
	 * });
	 * // => Logs `1` then `2`.
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	 */
	function forEach(collection, iteratee) {
	  var func = isArray(collection) ? arrayEach : baseEach;
	  return func(collection, castFunction(iteratee));
	}

	module.exports = forEach;


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(389),
	    createBaseEach = __webpack_require__(408);

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	module.exports = baseEach;


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(390),
	    keys = __webpack_require__(392);

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	module.exports = baseForOwn;


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(391);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ },
/* 391 */
/***/ function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(393),
	    baseKeys = __webpack_require__(403),
	    isArrayLike = __webpack_require__(407);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = keys;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(394),
	    isArguments = __webpack_require__(321),
	    isArray = __webpack_require__(327),
	    isBuffer = __webpack_require__(395),
	    isIndex = __webpack_require__(379),
	    isTypedArray = __webpack_require__(398);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ },
/* 394 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(319),
	    stubFalse = __webpack_require__(397);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(396)(module)))

/***/ },
/* 396 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 397 */
/***/ function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(399),
	    baseUnary = __webpack_require__(401),
	    nodeUtil = __webpack_require__(402);

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	module.exports = isTypedArray;


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(323),
	    isLength = __webpack_require__(400),
	    isObjectLike = __webpack_require__(326);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	module.exports = baseIsTypedArray;


/***/ },
/* 400 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 401 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(320);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(396)(module)))

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(404),
	    nativeKeys = __webpack_require__(405);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeys;


/***/ },
/* 404 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(406);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ },
/* 406 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(336),
	    isLength = __webpack_require__(400);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(407);

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	module.exports = createBaseEach;


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(341);

	/**
	 * Casts `value` to `identity` if it's not a function.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Function} Returns cast function.
	 */
	function castFunction(value) {
	  return typeof value == 'function' ? value : identity;
	}

	module.exports = castFunction;


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(411),
	    createWrap = __webpack_require__(356),
	    getHolder = __webpack_require__(377),
	    replaceHolders = __webpack_require__(380);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_PARTIAL_FLAG = 32;

	/**
	 * Creates a function that invokes `func` with the `this` binding of `thisArg`
	 * and `partials` prepended to the arguments it receives.
	 *
	 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	 * may be used as a placeholder for partially applied arguments.
	 *
	 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	 * property of bound functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to bind.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {...*} [partials] The arguments to be partially applied.
	 * @returns {Function} Returns the new bound function.
	 * @example
	 *
	 * function greet(greeting, punctuation) {
	 *   return greeting + ' ' + this.user + punctuation;
	 * }
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * var bound = _.bind(greet, object, 'hi');
	 * bound('!');
	 * // => 'hi fred!'
	 *
	 * // Bound with placeholders.
	 * var bound = _.bind(greet, object, _, '!');
	 * bound('hi');
	 * // => 'hi fred!'
	 */
	var bind = baseRest(function(func, thisArg, partials) {
	  var bitmask = WRAP_BIND_FLAG;
	  if (partials.length) {
	    var holders = replaceHolders(partials, getHolder(bind));
	    bitmask |= WRAP_PARTIAL_FLAG;
	  }
	  return createWrap(func, bitmask, thisArg, partials, holders);
	});

	// Assign default placeholders.
	bind.placeholder = {};

	module.exports = bind;


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(341),
	    overRest = __webpack_require__(328),
	    setToString = __webpack_require__(330);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	var baseHas = __webpack_require__(413),
	    hasPath = __webpack_require__(414);

	/**
	 * Checks if `path` is a direct property of `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = { 'a': { 'b': 2 } };
	 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.has(object, 'a');
	 * // => true
	 *
	 * _.has(object, 'a.b');
	 * // => true
	 *
	 * _.has(object, ['a', 'b']);
	 * // => true
	 *
	 * _.has(other, 'a');
	 * // => false
	 */
	function has(object, path) {
	  return object != null && hasPath(object, path, baseHas);
	}

	module.exports = has;


/***/ },
/* 413 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.has` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHas(object, key) {
	  return object != null && hasOwnProperty.call(object, key);
	}

	module.exports = baseHas;


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(415),
	    isArguments = __webpack_require__(321),
	    isArray = __webpack_require__(327),
	    isIndex = __webpack_require__(379),
	    isLength = __webpack_require__(400),
	    toKey = __webpack_require__(447);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(327),
	    isKey = __webpack_require__(416),
	    stringToPath = __webpack_require__(417),
	    toString = __webpack_require__(444);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	module.exports = castPath;


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(327),
	    isSymbol = __webpack_require__(386);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(418);

	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(419);

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	module.exports = memoizeCapped;


/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(420);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(421),
	    mapCacheDelete = __webpack_require__(438),
	    mapCacheGet = __webpack_require__(441),
	    mapCacheHas = __webpack_require__(442),
	    mapCacheSet = __webpack_require__(443);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(422),
	    ListCache = __webpack_require__(429),
	    Map = __webpack_require__(437);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(423),
	    hashDelete = __webpack_require__(425),
	    hashGet = __webpack_require__(426),
	    hashHas = __webpack_require__(427),
	    hashSet = __webpack_require__(428);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(424);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(334);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ },
/* 425 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(424);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(424);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(424);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(430),
	    listCacheDelete = __webpack_require__(431),
	    listCacheGet = __webpack_require__(434),
	    listCacheHas = __webpack_require__(435),
	    listCacheSet = __webpack_require__(436);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ },
/* 430 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(432);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(433);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ },
/* 433 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(432);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(432);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(432);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(334),
	    root = __webpack_require__(319);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(439);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(440);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ },
/* 440 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(439);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(439);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(439);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(445);

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	module.exports = toString;


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(318),
	    arrayMap = __webpack_require__(446),
	    isArray = __webpack_require__(327),
	    isSymbol = __webpack_require__(386);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = baseToString;


/***/ },
/* 446 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(386);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toKey;


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	var arrayReduce = __webpack_require__(449),
	    baseEach = __webpack_require__(388),
	    baseIteratee = __webpack_require__(450),
	    baseReduce = __webpack_require__(487),
	    isArray = __webpack_require__(327);

	/**
	 * Reduces `collection` to a value which is the accumulated result of running
	 * each element in `collection` thru `iteratee`, where each successive
	 * invocation is supplied the return value of the previous. If `accumulator`
	 * is not given, the first element of `collection` is used as the initial
	 * value. The iteratee is invoked with four arguments:
	 * (accumulator, value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.reduce`, `_.reduceRight`, and `_.transform`.
	 *
	 * The guarded methods are:
	 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	 * and `sortBy`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @returns {*} Returns the accumulated value.
	 * @see _.reduceRight
	 * @example
	 *
	 * _.reduce([1, 2], function(sum, n) {
	 *   return sum + n;
	 * }, 0);
	 * // => 3
	 *
	 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	 *   (result[value] || (result[value] = [])).push(key);
	 *   return result;
	 * }, {});
	 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	 */
	function reduce(collection, iteratee, accumulator) {
	  var func = isArray(collection) ? arrayReduce : baseReduce,
	      initAccum = arguments.length < 3;

	  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	}

	module.exports = reduce;


/***/ },
/* 449 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.reduce` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initAccum] Specify using the first element of `array` as
	 *  the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  if (initAccum && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	module.exports = arrayReduce;


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(451),
	    baseMatchesProperty = __webpack_require__(479),
	    identity = __webpack_require__(341),
	    isArray = __webpack_require__(327),
	    property = __webpack_require__(484);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(452),
	    getMatchData = __webpack_require__(476),
	    matchesStrictComparable = __webpack_require__(478);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(453),
	    baseIsEqual = __webpack_require__(459);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(429),
	    stackClear = __webpack_require__(454),
	    stackDelete = __webpack_require__(455),
	    stackGet = __webpack_require__(456),
	    stackHas = __webpack_require__(457),
	    stackSet = __webpack_require__(458);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(429);

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	module.exports = stackClear;


/***/ },
/* 455 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	module.exports = stackDelete;


/***/ },
/* 456 */
/***/ function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	module.exports = stackGet;


/***/ },
/* 457 */
/***/ function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	module.exports = stackHas;


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(429),
	    Map = __webpack_require__(437),
	    MapCache = __webpack_require__(420);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	module.exports = stackSet;


/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(460),
	    isObject = __webpack_require__(311),
	    isObjectLike = __webpack_require__(326);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	module.exports = baseIsEqual;


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(453),
	    equalArrays = __webpack_require__(461),
	    equalByTag = __webpack_require__(467),
	    equalObjects = __webpack_require__(471),
	    getTag = __webpack_require__(472),
	    isArray = __webpack_require__(327),
	    isBuffer = __webpack_require__(395),
	    isTypedArray = __webpack_require__(398);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(462),
	    arraySome = __webpack_require__(465),
	    cacheHas = __webpack_require__(466);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(420),
	    setCacheAdd = __webpack_require__(463),
	    setCacheHas = __webpack_require__(464);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ },
/* 463 */
/***/ function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ },
/* 464 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ },
/* 465 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ },
/* 466 */
/***/ function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(318),
	    Uint8Array = __webpack_require__(468),
	    eq = __webpack_require__(433),
	    equalArrays = __webpack_require__(461),
	    mapToArray = __webpack_require__(469),
	    setToArray = __webpack_require__(470);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(319);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ },
/* 469 */
/***/ function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	module.exports = mapToArray;


/***/ },
/* 470 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(392);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(473),
	    Map = __webpack_require__(437),
	    Promise = __webpack_require__(474),
	    Set = __webpack_require__(475),
	    WeakMap = __webpack_require__(345),
	    baseGetTag = __webpack_require__(323),
	    toSource = __webpack_require__(339);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	module.exports = getTag;


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(334),
	    root = __webpack_require__(319);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	module.exports = DataView;


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(334),
	    root = __webpack_require__(319);

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	module.exports = Promise;


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(334),
	    root = __webpack_require__(319);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(477),
	    keys = __webpack_require__(392);

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	module.exports = getMatchData;


/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(311);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	module.exports = isStrictComparable;


/***/ },
/* 478 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	module.exports = matchesStrictComparable;


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(459),
	    get = __webpack_require__(480),
	    hasIn = __webpack_require__(482),
	    isKey = __webpack_require__(416),
	    isStrictComparable = __webpack_require__(477),
	    matchesStrictComparable = __webpack_require__(478),
	    toKey = __webpack_require__(447);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(481);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(415),
	    toKey = __webpack_require__(447);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(483),
	    hasPath = __webpack_require__(414);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ },
/* 483 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	module.exports = baseHasIn;


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(485),
	    basePropertyDeep = __webpack_require__(486),
	    isKey = __webpack_require__(416),
	    toKey = __webpack_require__(447);

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = property;


/***/ },
/* 485 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(481);

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	module.exports = basePropertyDeep;


/***/ },
/* 487 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.reduce` and `_.reduceRight`, without support
	 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} accumulator The initial value.
	 * @param {boolean} initAccum Specify using the first or last element of
	 *  `collection` as the initial value.
	 * @param {Function} eachFunc The function to iterate over `collection`.
	 * @returns {*} Returns the accumulated value.
	 */
	function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	  eachFunc(collection, function(value, index, collection) {
	    accumulator = initAccum
	      ? (initAccum = false, value)
	      : iteratee(accumulator, value, index, collection);
	  });
	  return accumulator;
	}

	module.exports = baseReduce;


/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(489),
	    baseForOwn = __webpack_require__(389),
	    baseIteratee = __webpack_require__(450);

	/**
	 * The opposite of `_.mapValues`; this method creates an object with the
	 * same values as `object` and keys generated by running each own enumerable
	 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	 * with three arguments: (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.8.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapValues
	 * @example
	 *
	 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   return key + value;
	 * });
	 * // => { 'a1': 1, 'b2': 2 }
	 */
	function mapKeys(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee(iteratee, 3);

	  baseForOwn(object, function(value, key, object) {
	    baseAssignValue(result, iteratee(value, key, object), value);
	  });
	  return result;
	}

	module.exports = mapKeys;


/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(333);

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _contextTypes; /* global google */


	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Marker
	  animation: _react.PropTypes.any,

	  attribution: _react.PropTypes.any,

	  clickable: _react.PropTypes.bool,

	  cursor: _react.PropTypes.string,

	  draggable: _react.PropTypes.bool,

	  icon: _react.PropTypes.any,

	  label: _react.PropTypes.any,

	  opacity: _react.PropTypes.number,

	  options: _react.PropTypes.object,

	  place: _react.PropTypes.any,

	  position: _react.PropTypes.any,

	  shape: _react.PropTypes.any,

	  title: _react.PropTypes.string,

	  visible: _react.PropTypes.bool,

	  zIndex: _react.PropTypes.number
	};

	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Marker
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onAnimationChanged: "animation_changed",

	  onClick: "click",

	  onClickableChanged: "clickable_changed",

	  onCursorChanged: "cursor_changed",

	  onDblClick: "dblclick",

	  onDrag: "drag",

	  onDragEnd: "dragend",

	  onDraggableChanged: "draggable_changed",

	  onDragStart: "dragstart",

	  onFlatChanged: "flat_changed",

	  onIconChanged: "icon_changed",

	  onMouseDown: "mousedown",

	  onMouseOut: "mouseout",

	  onMouseOver: "mouseover",

	  onMouseUp: "mouseup",

	  onPositionChanged: "position_changed",

	  onRightClick: "rightclick",

	  onShapeChanged: "shape_changed",

	  onTitleChanged: "title_changed",

	  onVisibleChanged: "visible_changed",

	  onZindexChanged: "zindex_changed"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Marker
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getAnimation: function getAnimation(marker) {
	    return marker.getAnimation();
	  },
	  getAttribution: function getAttribution(marker) {
	    return marker.getAttribution();
	  },
	  getClickable: function getClickable(marker) {
	    return marker.getClickable();
	  },
	  getCursor: function getCursor(marker) {
	    return marker.getCursor();
	  },
	  getDraggable: function getDraggable(marker) {
	    return marker.getDraggable();
	  },
	  getIcon: function getIcon(marker) {
	    return marker.getIcon();
	  },
	  getLabel: function getLabel(marker) {
	    return marker.getLabel();
	  },
	  getOpacity: function getOpacity(marker) {
	    return marker.getOpacity();
	  },
	  getPlace: function getPlace(marker) {
	    return marker.getPlace();
	  },
	  getPosition: function getPosition(marker) {
	    return marker.getPosition();
	  },
	  getShape: function getShape(marker) {
	    return marker.getShape();
	  },
	  getTitle: function getTitle(marker) {
	    return marker.getTitle();
	  },
	  getVisible: function getVisible(marker) {
	    return marker.getVisible();
	  },
	  getZIndex: function getZIndex(marker) {
	    return marker.getZIndex();
	  }
	};

	var controlledPropUpdaterMap = {
	  animation: function animation(marker, _animation) {
	    marker.setAnimation(_animation);
	  },
	  attribution: function attribution(marker, _attribution) {
	    marker.setAttribution(_attribution);
	  },
	  clickable: function clickable(marker, _clickable) {
	    marker.setClickable(_clickable);
	  },
	  cursor: function cursor(marker, _cursor) {
	    marker.setCursor(_cursor);
	  },
	  draggable: function draggable(marker, _draggable) {
	    marker.setDraggable(_draggable);
	  },
	  icon: function icon(marker, _icon) {
	    marker.setIcon(_icon);
	  },
	  label: function label(marker, _label) {
	    marker.setLabel(_label);
	  },
	  opacity: function opacity(marker, _opacity) {
	    marker.setOpacity(_opacity);
	  },
	  options: function options(marker, _options) {
	    marker.setOptions(_options);
	  },
	  place: function place(marker, _place) {
	    marker.setPlace(_place);
	  },
	  position: function position(marker, _position) {
	    marker.setPosition(_position);
	  },
	  shape: function shape(marker, _shape) {
	    marker.setShape(_shape);
	  },
	  title: function title(marker, _title) {
	    marker.setTitle(_title);
	  },
	  visible: function visible(marker, _visible) {
	    marker.setVisible(_visible);
	  },
	  zIndex: function zIndex(marker, _zIndex) {
	    marker.setZIndex(_zIndex);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.MARKER];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "Marker",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (_contextTypes = {}, (0, _defineProperty3.default)(_contextTypes, _constants.MAP, _react.PropTypes.object), (0, _defineProperty3.default)(_contextTypes, _constants.MARKER_CLUSTERER, _react.PropTypes.object), _contextTypes),

	  childContextTypes: (0, _defineProperty3.default)({}, _constants.ANCHOR, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Marker
	    var marker = new google.maps.Marker((0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props));
	    var markerClusterer = this.context[_constants.MARKER_CLUSTERER];
	    if (markerClusterer) {
	      markerClusterer.addMarker(marker);
	    } else {
	      marker.setMap(this.context[_constants.MAP]);
	    }
	    return (0, _defineProperty3.default)({}, _constants.MARKER, marker);
	  },
	  getChildContext: function getChildContext() {
	    return (0, _defineProperty3.default)({}, _constants.ANCHOR, this.context[_constants.ANCHOR] || getInstanceFromComponent(this));
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var marker = getInstanceFromComponent(this);
	    if (marker) {
	      var markerClusterer = this.context[_constants.MARKER_CLUSTERER];
	      if (markerClusterer) {
	        markerClusterer.removeMarker(marker);
	      }
	      marker.setMap(null);
	    }
	  },
	  render: function render() {
	    var children = this.props.children;


	    return _react2.default.createElement(
	      "div",
	      null,
	      children
	    );
	  }
	});

/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Rectangle
	  bounds: _react.PropTypes.any,
	  draggable: _react.PropTypes.bool,
	  editable: _react.PropTypes.bool,
	  options: _react.PropTypes.object,
	  visible: _react.PropTypes.bool
	}; /* global google */


	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Rectangle
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onBoundsChanged: "bounds_changed",

	  onClick: "click",

	  onDblClick: "dblclick",

	  onDrag: "drag",

	  onDragEnd: "dragend",

	  onDragStart: "dragstart",

	  onMouseDown: "mousedown",

	  onMouseMove: "mousemove",

	  onMouseOut: "mouseout",

	  onMouseOver: "mouseover",

	  onMouseUp: "mouseup",

	  onRightClick: "rightclick"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Rectangle
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getBounds: function getBounds(rectangle) {
	    return rectangle.getBounds();
	  },
	  getDraggable: function getDraggable(rectangle) {
	    return rectangle.getDraggable();
	  },
	  getEditable: function getEditable(rectangle) {
	    return rectangle.getEditable();
	  },
	  getVisible: function getVisible(rectangle) {
	    return rectangle.getVisible();
	  }
	};

	var controlledPropUpdaterMap = {
	  bounds: function bounds(rectangle, _bounds) {
	    rectangle.setBounds(_bounds);
	  },
	  draggable: function draggable(rectangle, _draggable) {
	    rectangle.setDraggable(_draggable);
	  },
	  editable: function editable(rectangle, _editable) {
	    rectangle.setEditable(_editable);
	  },
	  options: function options(rectangle, _options) {
	    rectangle.setOptions(_options);
	  },
	  visible: function visible(rectangle, _visible) {
	    rectangle.setVisible(_visible);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.RECTANGLE];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "Rectangle",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Rectangle
	    var rectangle = new google.maps.Rectangle((0, _extends3.default)({
	      map: this.context[_constants.MAP]
	    }, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props)));
	    return (0, _defineProperty3.default)({}, _constants.RECTANGLE, rectangle);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var rectangle = getInstanceFromComponent(this);
	    if (rectangle) {
	      rectangle.setMap(null);
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polyline
	  draggable: _react.PropTypes.bool,
	  editable: _react.PropTypes.bool,
	  options: _react.PropTypes.object,
	  path: _react.PropTypes.any,
	  visible: _react.PropTypes.bool
	}; /* global google */


	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polyline
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onClick: "click",

	  onDblClick: "dblclick",

	  onDrag: "drag",

	  onDragEnd: "dragend",

	  onDragStart: "dragstart",

	  onMouseDown: "mousedown",

	  onMouseMove: "mousemove",

	  onMouseOut: "mouseout",

	  onMouseOver: "mouseover",

	  onMouseUp: "mouseup",

	  onRightClick: "rightclick"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polyline
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getDraggable: function getDraggable(polyline) {
	    return polyline.getDraggable();
	  },
	  getEditable: function getEditable(polyline) {
	    return polyline.getEditable();
	  },
	  getPath: function getPath(polyline) {
	    return polyline.getPath();
	  },
	  getVisible: function getVisible(polyline) {
	    return polyline.getVisible();
	  }
	};

	var controlledPropUpdaterMap = {
	  draggable: function draggable(polyline, _draggable) {
	    polyline.setDraggable(_draggable);
	  },
	  editable: function editable(polyline, _editable) {
	    polyline.setEditable(_editable);
	  },
	  options: function options(polyline, _options) {
	    polyline.setOptions(_options);
	  },
	  path: function path(polyline, _path) {
	    polyline.setPath(_path);
	  },
	  visible: function visible(polyline, _visible) {
	    polyline.setVisible(_visible);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.POLYLINE];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "Polyline",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polyline
	    var polyline = new google.maps.Polyline((0, _extends3.default)({
	      map: this.context[_constants.MAP]
	    }, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props)));
	    return (0, _defineProperty3.default)({}, _constants.POLYLINE, polyline);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var polyline = getInstanceFromComponent(this);
	    if (polyline) {
	      polyline.setMap(null);
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polygon
	  draggable: _react.PropTypes.bool,
	  editable: _react.PropTypes.bool,
	  options: _react.PropTypes.object,
	  path: _react.PropTypes.any,
	  paths: _react.PropTypes.any,
	  visible: _react.PropTypes.bool
	}; /* global google */


	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polygon
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onClick: "click",

	  onDblClick: "dblclick",

	  onDrag: "drag",

	  onDragEnd: "dragend",

	  onDragStart: "dragstart",

	  onMouseDown: "mousedown",

	  onMouseMove: "mousemove",

	  onMouseOut: "mouseout",

	  onMouseOver: "mouseover",

	  onMouseUp: "mouseup",

	  onRightClick: "rightclick"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polygon
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getDraggable: function getDraggable(polygon) {
	    return polygon.getDraggable();
	  },
	  getEditable: function getEditable(polygon) {
	    return polygon.getEditable();
	  },
	  getPath: function getPath(polygon) {
	    return polygon.getPath();
	  },
	  getPaths: function getPaths(polygon) {
	    return polygon.getPaths();
	  },
	  getVisible: function getVisible(polygon) {
	    return polygon.getVisible();
	  }
	};

	var controlledPropUpdaterMap = {
	  draggable: function draggable(polygon, _draggable) {
	    polygon.setDraggable(_draggable);
	  },
	  editable: function editable(polygon, _editable) {
	    polygon.setEditable(_editable);
	  },
	  options: function options(polygon, _options) {
	    polygon.setOptions(_options);
	  },
	  path: function path(polygon, _path) {
	    polygon.setPath(_path);
	  },
	  paths: function paths(polygon, _paths) {
	    polygon.setPaths(_paths);
	  },
	  visible: function visible(polygon, _visible) {
	    polygon.setVisible(_visible);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.POLYGON];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "Polygon",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polygon
	    var polygon = new google.maps.Polygon((0, _extends3.default)({
	      map: this.context[_constants.MAP]
	    }, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props)));
	    return (0, _defineProperty3.default)({}, _constants.POLYGON, polygon);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var polygon = getInstanceFromComponent(this);
	    if (polygon) {
	      polygon.setMap(null);
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Circle
	  center: _react.PropTypes.any,
	  draggable: _react.PropTypes.bool,
	  editable: _react.PropTypes.bool,
	  options: _react.PropTypes.object,
	  radius: _react.PropTypes.number,
	  visible: _react.PropTypes.bool
	}; /* global google */


	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Circle
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onCenterChanged: "center_changed",

	  onClick: "click",

	  onDblClick: "dblclick",

	  onDrag: "drag",

	  onDragEnd: "dragend",

	  onDragStart: "dragstart",

	  onMouseDown: "mousedown",

	  onMouseMove: "mousemove",

	  onMouseOut: "mouseout",

	  onMouseOver: "mouseover",

	  onMouseUp: "mouseup",

	  onRadiusChanged: "radius_changed",

	  onRightClick: "rightclick"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Circle
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getBounds: function getBounds(circle) {
	    return circle.getBounds();
	  },
	  getCenter: function getCenter(circle) {
	    return circle.getCenter();
	  },
	  getDraggable: function getDraggable(circle) {
	    return circle.getDraggable();
	  },
	  getEditable: function getEditable(circle) {
	    return circle.getEditable();
	  },
	  getMap: function getMap(circle) {
	    return circle.getMap();
	  },
	  getRadius: function getRadius(circle) {
	    return circle.getRadius();
	  },
	  getVisible: function getVisible(circle) {
	    return circle.getVisible();
	  }
	};

	var controlledPropUpdaterMap = {
	  center: function center(circle, _center) {
	    circle.setCenter(_center);
	  },
	  draggable: function draggable(circle, _draggable) {
	    circle.setDraggable(_draggable);
	  },
	  editable: function editable(circle, _editable) {
	    circle.setEditable(_editable);
	  },
	  options: function options(circle, _options) {
	    circle.setOptions(_options);
	  },
	  radius: function radius(circle, _radius) {
	    circle.setRadius(_radius);
	  },
	  visible: function visible(circle, _visible) {
	    circle.setVisible(_visible);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.CIRCLE];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "Circle",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#Circle
	    var circle = new google.maps.Circle((0, _extends3.default)({
	      map: this.context[_constants.MAP]
	    }, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props)));
	    return (0, _defineProperty3.default)({}, _constants.CIRCLE, circle);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var circle = getInstanceFromComponent(this);
	    if (circle) {
	      circle.setMap(null);
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#KmlLayer
	  defaultViewport: _react.PropTypes.any,
	  metadata: _react.PropTypes.any,
	  status: _react.PropTypes.any,
	  url: _react.PropTypes.string,
	  zIndex: _react.PropTypes.number
	}; /* global google */


	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#KmlLayer
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onClick: "click",

	  onDefaultViewportChanged: "defaultviewport_changed",

	  onStatusChanged: "status_changed"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#KmlLayer
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getDefaultViewport: function getDefaultViewport(kmlLayer) {
	    return kmlLayer.getDefaultViewport();
	  },
	  getMetadata: function getMetadata(kmlLayer) {
	    return kmlLayer.getMetadata();
	  },
	  getStatus: function getStatus(kmlLayer) {
	    return kmlLayer.getStatus();
	  },
	  getUrl: function getUrl(kmlLayer) {
	    return kmlLayer.getUrl();
	  },
	  getZIndex: function getZIndex(kmlLayer) {
	    return kmlLayer.getZIndex();
	  }
	};

	var controlledPropUpdaterMap = {
	  defaultViewport: function defaultViewport(kmlLayer, _defaultViewport) {
	    kmlLayer.setDefaultViewport(_defaultViewport);
	  },
	  metadata: function metadata(kmlLayer, _metadata) {
	    kmlLayer.setMetadata(_metadata);
	  },
	  status: function status(kmlLayer, _status) {
	    kmlLayer.setStatus(_status);
	  },
	  url: function url(kmlLayer, _url) {
	    kmlLayer.setUrl(_url);
	  },
	  zIndex: function zIndex(kmlLayer, _zIndex) {
	    kmlLayer.setZIndex(_zIndex);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.KML_LAYER];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "KmlLayer",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#KmlLayer
	    var kmlLayer = new google.maps.KmlLayer((0, _extends3.default)({
	      map: this.context[_constants.MAP]
	    }, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props)));
	    return (0, _defineProperty3.default)({}, _constants.KML_LAYER, kmlLayer);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var kmlLayer = getInstanceFromComponent(this);
	    if (kmlLayer) {
	      kmlLayer.setMap(null);
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#DirectionsRenderer
	  directions: _react.PropTypes.any,
	  options: _react.PropTypes.object,
	  panel: _react.PropTypes.object,
	  routeIndex: _react.PropTypes.number
	}; /* global google */


	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#DirectionsRenderer
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onDirectionsChanged: "directions_changed"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#DirectionsRenderer
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getDirections: function getDirections(directionsRenderer) {
	    return directionsRenderer.getDirections();
	  },
	  getPanel: function getPanel(directionsRenderer) {
	    return directionsRenderer.getPanel();
	  },
	  getRouteIndex: function getRouteIndex(directionsRenderer) {
	    return directionsRenderer.getRouteIndex();
	  }
	};

	var controlledPropUpdaterMap = {
	  directions: function directions(directionsRenderer, _directions) {
	    directionsRenderer.setDirections(_directions);
	  },
	  options: function options(directionsRenderer, _options) {
	    directionsRenderer.setOptions(_options);
	  },
	  panel: function panel(directionsRenderer, _panel) {
	    directionsRenderer.setPanel(_panel);
	  },
	  routeIndex: function routeIndex(directionsRenderer, _routeIndex) {
	    directionsRenderer.setRouteIndex(_routeIndex);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.DIRECTIONS_RENDERER];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "DirectionsRenderer",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#DirectionsRenderer
	    var directionsRenderer = new google.maps.DirectionsRenderer((0, _extends3.default)({
	      map: this.context[_constants.MAP]
	    }, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props)));
	    return (0, _defineProperty3.default)({}, _constants.DIRECTIONS_RENDERER, directionsRenderer);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var directionsRenderer = getInstanceFromComponent(this);
	    if (directionsRenderer) {
	      directionsRenderer.setMap(null);
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#HeatmapLayer
	  data: _react.PropTypes.any,
	  options: _react.PropTypes.object
	}; /* global google */


	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#HeatmapLayer
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onZoomChanged: "zoom_changed"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#HeatmapLayer
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  // END - Public APIs
	};

	var controlledPropUpdaterMap = {
	  data: function data(heatmapLayer, _data) {
	    heatmapLayer.setData(_data);
	  },
	  options: function options(heatmapLayer, _options) {
	    heatmapLayer.setOptions(_options);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.HEATMAP_LAYER];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "HeatmapLayer",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#HeatmapLayer
	    var heatmapLayer = new google.maps.HeatmapLayer((0, _extends3.default)({
	      map: this.context[_constants.MAP]
	    }, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props)));
	    return (0, _defineProperty3.default)({}, _constants.HEATMAP_LAYER, heatmapLayer);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var heatmapLayer = getInstanceFromComponent(this);
	    if (heatmapLayer) {
	      heatmapLayer.setMap(null);
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _contextTypes; /* global google */


	var _invariant = __webpack_require__(288);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(39);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#InfoWindow
	  children: _react.PropTypes.element,
	  options: _react.PropTypes.object,
	  position: _react.PropTypes.any,
	  zIndex: _react.PropTypes.number
	};

	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#InfoWindow
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  onCloseClick: "closeclick",

	  onContentChanged: "content_changed",

	  onDomReady: "domready",

	  onPositionChanged: "position_changed",

	  onZIndexChanged: "zindex_changed"
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#InfoWindow
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getPosition: function getPosition(infoWindow) {
	    return infoWindow.getPosition();
	  },
	  getZIndex: function getZIndex(infoWindow) {
	    return infoWindow.getZIndex();
	  }
	};

	var controlledPropUpdaterMap = {
	  children: function children(infoWindow, _children, component) {
	    (0, _reactDom.unstable_renderSubtreeIntoContainer)(component, _react.Children.only(_children), infoWindow.getContent());
	  },
	  options: function options(infoWindow, _options) {
	    infoWindow.setOptions(_options);
	  },
	  position: function position(infoWindow, _position) {
	    infoWindow.setPosition(_position);
	  },
	  zIndex: function zIndex(infoWindow, _zIndex) {
	    infoWindow.setZIndex(_zIndex);
	  }
	};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.INFO_WINDOW];
	}

	function openInfoWindow(context, infoWindow) {
	  var map = context[_constants.MAP];
	  var anchor = context[_constants.ANCHOR];
	  if (anchor) {
	    infoWindow.open(map, anchor);
	  } else if (infoWindow.getPosition()) {
	    infoWindow.open(map);
	  } else {
	    (0, _invariant2.default)(false, "You must provide either an anchor (typically a <Marker>) or a position for <InfoWindow>.");
	  }
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "InfoWindow",

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes),

	  contextTypes: (_contextTypes = {}, (0, _defineProperty3.default)(_contextTypes, _constants.MAP, _react.PropTypes.object), (0, _defineProperty3.default)(_contextTypes, _constants.ANCHOR, _react.PropTypes.object), _contextTypes),

	  getInitialState: function getInitialState() {
	    var map = this.context[_constants.MAP];
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#InfoWindow
	    var infoWindow = new google.maps.InfoWindow((0, _extends3.default)({
	      map: map
	    }, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props), {
	      // Override props of ReactElement type
	      content: document.createElement("div"),
	      children: undefined
	    }));
	    openInfoWindow(this.context, infoWindow);
	    return (0, _defineProperty3.default)({}, _constants.INFO_WINDOW, infoWindow);
	  },
	  componentDidMount: function componentDidMount() {
	    var infoWindow = getInstanceFromComponent(this);
	    controlledPropUpdaterMap.children(infoWindow, this.props.children, this);
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps, nextContext) {
	    var anchorChanged = this.context[_constants.ANCHOR] !== nextContext[_constants.ANCHOR];
	    if (anchorChanged) {
	      var infoWindow = getInstanceFromComponent(this);
	      openInfoWindow(nextContext, infoWindow);
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var infoWindow = getInstanceFromComponent(this);
	    if (infoWindow) {
	      (0, _reactDom.unmountComponentAtNode)(infoWindow.getContent());
	      infoWindow.setMap(null);
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _defineProperty2 = __webpack_require__(200);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _delay2 = __webpack_require__(500);

	var _delay3 = _interopRequireDefault(_delay2);

	var _flowRight2 = __webpack_require__(307);

	var _flowRight3 = _interopRequireDefault(_flowRight2);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _constants = __webpack_require__(290);

	var _enhanceElement = __webpack_require__(354);

	var _enhanceElement2 = _interopRequireDefault(_enhanceElement);

	var _OverlayViewHelper = __webpack_require__(502);

	var helpers = _interopRequireWildcard(_OverlayViewHelper);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* global google */
	var controlledPropTypes = {
	  // NOTICE!!!!!!
	  //
	  // Only expose those with getters & setters in the table as controlled props.
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code", function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^set/) && !it.match(/^setMap/); })
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#OverlayView
	  mapPaneName: _react.PropTypes.string,
	  position: _react.PropTypes.object,
	  bounds: _react.PropTypes.object
	};

	var defaultUncontrolledPropTypes = (0, _enhanceElement.addDefaultPrefixToPropTypes)(controlledPropTypes);

	var eventMap = {
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#OverlayView
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	};

	var publicMethodMap = {
	  // Public APIs
	  //
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#OverlayView
	  //
	  // [].map.call($0.querySelectorAll("tr>td>code"), function(it){ return it.textContent; })
	  //    .filter(function(it){ return it.match(/^get/) && !it.match(/Map$/); })
	  getPanes: function getPanes(overlayView) {
	    return overlayView.getPanes();
	  },
	  getProjection: function getProjection(overlayView) {
	    return overlayView.getProjection();
	  }
	};

	var controlledPropUpdaterMap = {};

	function getInstanceFromComponent(component) {
	  return component.state[_constants.OVERLAY_VIEW];
	}

	exports.default = (0, _flowRight3.default)(_react2.default.createClass, (0, _enhanceElement2.default)(getInstanceFromComponent, publicMethodMap, eventMap, controlledPropUpdaterMap))({
	  displayName: "OverlayView",

	  statics: {
	    FLOAT_PANE: "floatPane",
	    MAP_PANE: "mapPane",
	    MARKER_LAYER: "markerLayer",
	    OVERLAY_LAYER: "overlayLayer",
	    OVERLAY_MOUSE_TARGET: "overlayMouseTarget"
	  },

	  propTypes: (0, _extends3.default)({}, controlledPropTypes, defaultUncontrolledPropTypes, {
	    children: _react.PropTypes.node.isRequired,
	    getPixelPositionOffset: _react.PropTypes.func
	  }),

	  contextTypes: (0, _defineProperty3.default)({}, _constants.MAP, _react.PropTypes.object),

	  getInitialState: function getInitialState() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#OverlayView
	    var overlayView = new google.maps.OverlayView();
	    // You must implement three methods: onAdd(), draw(), and onRemove().
	    overlayView.onAdd = this.onAdd;
	    overlayView.draw = this.draw;
	    overlayView.onRemove = this.onRemove;
	    // You must call setMap() with a valid Map object to trigger the call to
	    // the onAdd() method and setMap(null) in order to trigger the onRemove() method.
	    overlayView.setMap(this.context[_constants.MAP]);
	    return (0, _defineProperty3.default)({}, _constants.OVERLAY_VIEW, overlayView);
	  },
	  onAdd: function onAdd() {
	    this._containerElement = helpers.createContainerElement();
	  },
	  draw: function draw() {
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#OverlayView
	    var overlayView = getInstanceFromComponent(this);
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapPanes
	    var mapPanes = overlayView.getPanes();
	    // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapCanvasProjection
	    var mapCanvasProjection = overlayView.getProjection();
	    //
	    var props = (0, _extends3.default)({}, (0, _enhanceElement.collectUncontrolledAndControlledProps)(defaultUncontrolledPropTypes, controlledPropTypes, this.props), {
	      children: this.props.children,
	      getPixelPositionOffset: this.props.getPixelPositionOffset
	    });
	    helpers.mountContainerElementToPane(mapPanes, this._containerElement, props);
	    helpers.renderChildToContainerElement(mapCanvasProjection, this._containerElement, props);
	  },
	  onRemove: function onRemove() {
	    helpers.unmountAndDestroyContainerElement(this._containerElement);
	    this._containerElement = null;
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    (0, _delay3.default)(this.draw);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var overlayView = getInstanceFromComponent(this);
	    if (overlayView) {
	      overlayView.setMap(null);
	      // You must implement three methods: onAdd(), draw(), and onRemove().
	      overlayView.onAdd = null;
	      overlayView.draw = null;
	      overlayView.onRemove = null;
	    }
	  },
	  render: function render() {
	    return false;
	  }
	});

/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	var baseDelay = __webpack_require__(501),
	    baseRest = __webpack_require__(411),
	    toNumber = __webpack_require__(385);

	/**
	 * Invokes `func` after `wait` milliseconds. Any additional arguments are
	 * provided to `func` when it's invoked.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to delay.
	 * @param {number} wait The number of milliseconds to delay invocation.
	 * @param {...*} [args] The arguments to invoke `func` with.
	 * @returns {number} Returns the timer id.
	 * @example
	 *
	 * _.delay(function(text) {
	 *   console.log(text);
	 * }, 1000, 'later');
	 * // => Logs 'later' after one second.
	 */
	var delay = baseRest(function(func, wait, args) {
	  return baseDelay(func, toNumber(wait) || 0, args);
	});

	module.exports = delay;


/***/ },
/* 501 */
/***/ function(module, exports) {

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * The base implementation of `_.delay` and `_.defer` which accepts `args`
	 * to provide to `func`.
	 *
	 * @private
	 * @param {Function} func The function to delay.
	 * @param {number} wait The number of milliseconds to delay invocation.
	 * @param {Array} args The arguments to provide to `func`.
	 * @returns {number|Object} Returns the timer id or timeout object.
	 */
	function baseDelay(func, wait, args) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  return setTimeout(function() { func.apply(undefined, args); }, wait);
	}

	module.exports = baseDelay;


/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends2 = __webpack_require__(292);

	var _extends3 = _interopRequireDefault(_extends2);

	var _assign2 = __webpack_require__(503);

	var _assign3 = _interopRequireDefault(_assign2);

	var _isFunction2 = __webpack_require__(336);

	var _isFunction3 = _interopRequireDefault(_isFunction2);

	exports.createContainerElement = createContainerElement;
	exports.mountContainerElementToPane = mountContainerElementToPane;
	exports.renderChildToContainerElement = renderChildToContainerElement;
	exports.unmountAndDestroyContainerElement = unmountAndDestroyContainerElement;

	var _invariant = __webpack_require__(288);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _react = __webpack_require__(9);

	var _reactDom = __webpack_require__(39);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createContainerElement() {
	  var containerElement = document.createElement("div");
	  containerElement.style.position = "absolute";
	  return containerElement;
	} /* global google */
	function mountContainerElementToPane(mapPanes, containerElement, props) {
	  var mapPaneName = props.mapPaneName;

	  (0, _invariant2.default)(!!mapPaneName, "OverlayView requires either props.mapPaneName or props.defaultMapPaneName but got %s", mapPaneName);
	  // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapPanes
	  mapPanes[mapPaneName].appendChild(containerElement);
	}

	function getOffsetOverride(containerElement, props) {
	  var getPixelPositionOffset = props.getPixelPositionOffset;
	  //
	  // Allows the component to control the visual position of the OverlayView
	  // relative to the LatLng pixel position.
	  //

	  if ((0, _isFunction3.default)(getPixelPositionOffset)) {
	    return getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight);
	  } else {
	    return {};
	  }
	}

	function createLatLng(inst, Type) {
	  return new Type(inst.lat, inst.lng);
	}

	function createLatLngBounds(inst, Type) {
	  return new Type(new google.maps.LatLng(inst.ne.lat, inst.ne.lng), new google.maps.LatLng(inst.sw.lat, inst.sw.lng));
	}

	function ensureOfType(inst, type, factory) {
	  if (inst instanceof type) {
	    return inst;
	  } else {
	    return factory(inst, type);
	  }
	}

	function getLayoutStylesByBounds(mapCanvasProjection, offset, bounds) {
	  var ne = mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());
	  var sw = mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());
	  return {
	    left: sw.x + offset.x + "px",
	    top: ne.y + offset.y + "px",
	    width: ne.x - sw.x - offset.x + "px",
	    height: sw.y - ne.y - offset.y + "px"
	  };
	}

	function getLayoutStylesByPosition(mapCanvasProjection, offset, position) {
	  var _mapCanvasProjection$ = mapCanvasProjection.fromLatLngToDivPixel(position);

	  var x = _mapCanvasProjection$.x;
	  var y = _mapCanvasProjection$.y;

	  return {
	    left: x + offset.x + "px",
	    top: y + offset.y + "px"
	  };
	}

	function getLayoutStyles(mapCanvasProjection, offset, props) {
	  if (props.bounds) {
	    var bounds = ensureOfType(props.bounds, google.maps.LatLngBounds, createLatLngBounds);
	    return getLayoutStylesByBounds(mapCanvasProjection, offset, bounds);
	  } else {
	    var position = ensureOfType(props.position, google.maps.LatLng, createLatLng);
	    return getLayoutStylesByPosition(mapCanvasProjection, offset, position);
	  }
	}

	function renderChildToContainerElement(mapCanvasProjection, containerElement, props) {
	  var child = _react.Children.only(props.children);
	  (0, _reactDom.render)(child, containerElement, function () {
	    var offset = (0, _extends3.default)({
	      x: 0,
	      y: 0
	    }, getOffsetOverride(containerElement, props));
	    var layoutStyles = getLayoutStyles(mapCanvasProjection, offset, props);
	    (0, _assign3.default)(containerElement.style, layoutStyles);
	  });
	}

	function unmountAndDestroyContainerElement(containerElement) {
	  containerElement.parentNode.removeChild(containerElement);
	  (0, _reactDom.unmountComponentAtNode)(containerElement);
	}

/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(504),
	    copyObject = __webpack_require__(505),
	    createAssigner = __webpack_require__(506),
	    isArrayLike = __webpack_require__(407),
	    isPrototype = __webpack_require__(404),
	    keys = __webpack_require__(392);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns own enumerable string keyed properties of source objects to the
	 * destination object. Source objects are applied from left to right.
	 * Subsequent sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object` and is loosely based on
	 * [`Object.assign`](https://mdn.io/Object/assign).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.10.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.assignIn
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * function Bar() {
	 *   this.c = 3;
	 * }
	 *
	 * Foo.prototype.b = 2;
	 * Bar.prototype.d = 4;
	 *
	 * _.assign({ 'a': 0 }, new Foo, new Bar);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var assign = createAssigner(function(object, source) {
	  if (isPrototype(source) || isArrayLike(source)) {
	    copyObject(source, keys(source), object);
	    return;
	  }
	  for (var key in source) {
	    if (hasOwnProperty.call(source, key)) {
	      assignValue(object, key, source[key]);
	    }
	  }
	});

	module.exports = assign;


/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(489),
	    eq = __webpack_require__(433);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(504),
	    baseAssignValue = __webpack_require__(489);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(411),
	    isIterateeCall = __webpack_require__(507);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(433),
	    isArrayLike = __webpack_require__(407),
	    isIndex = __webpack_require__(379),
	    isObject = __webpack_require__(311);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.location = undefined;

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(39);

	var _app = __webpack_require__(185);

	var _app2 = _interopRequireDefault(_app);

	var _navigation = __webpack_require__(191);

	var _navigation2 = _interopRequireDefault(_navigation);

	var _location = __webpack_require__(509);

	var _location2 = _interopRequireDefault(_location);

	var _errorView = __webpack_require__(515);

	var _errorView2 = _interopRequireDefault(_errorView);

	var _utilities = __webpack_require__(189);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Before
	function before(state) {
	    return function (done) {
	        (0, _reactDom.unmountComponentAtNode)(state.reactMountNode);
	        state.argonMountNode.style.display = 'none';
	        state.documentRootNode.style.background = 'white';
	        // Setup location data then the user data
	        (0, _utilities.setupLocationData)(state, function () {
	            return (0, _utilities.setupUserData)(state, done);
	        });
	    };
	}

	// After


	function after() {
	    return function () {};
	}

	// Location route
	function route(state) {
	    return function (params) {
	        console.log('Location:', state, params);

	        var id = params.id;

	        // NOTE: weak equality check due to strings

	        var location = state.locations.filter(function (loc) {
	            return loc.meta.id == id;
	        }).reduce(function (_, l) {
	            return l;
	        }, {});

	        // TODO check if we didnt find a location?
	        if (!location.hasOwnProperty('meta')) {
	            return (0, _reactDom.render)(_react2.default.createElement(
	                _app2.default,
	                { state: state },
	                _react2.default.createElement(_navigation2.default, {
	                    backUrl: '/locations',
	                    title: 'Unknown location' }),
	                _react2.default.createElement(_errorView2.default, { msg: 'The location doesnt exist' })
	            ), state.reactMountNode);
	        }

	        var hasVisitedLocation = state.userData.locations['location_' + location.meta.id].visited;
	        var hasUnlockedLocation = state.userData.locations['location_' + location.meta.id].unlocked;

	        if (!hasVisitedLocation || !hasUnlockedLocation) {
	            return (0, _reactDom.render)(_react2.default.createElement(
	                _app2.default,
	                { state: state },
	                _react2.default.createElement(_navigation2.default, {
	                    title: 'Location ' + id,
	                    backUrl: '/locations/' + id + '/camera' }),
	                _react2.default.createElement(_errorView2.default, { msg: 'You need to visit and unlock the location!' })
	            ), state.reactMountNode);
	        }

	        (0, _reactDom.render)(_react2.default.createElement(
	            _app2.default,
	            { state: state },
	            _react2.default.createElement(_navigation2.default, {
	                title: 'Location ' + id,
	                backUrl: '/locations/' + id + '/camera' }),
	            _react2.default.createElement(_location2.default, {
	                location: location })
	        ), state.reactMountNode);
	    };
	}

	// Export the route handlers
	var location = exports.location = {
	    urls: ['/locations/:id', '/locations/:id/story', '/locations/:id/*'],
	    route: route,
	    hooks: function hooks(state) {
	        return { before: before(state), after: after(state) };
	    }
	};

/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _audioPlayer = __webpack_require__(510);

	var _audioPlayer2 = _interopRequireDefault(_audioPlayer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Location = function Location(_ref) {
	    var state = _ref.state,
	        location = _ref.location;


	    var navigateToList = function navigateToList() {
	        return state.navigate('/locations');
	    };

	    return _react2.default.createElement(
	        'div',
	        { className: 'location' },
	        _react2.default.createElement(_audioPlayer2.default, { src: 'example.mp3', title: 'Title', locationID: location.meta.id }),
	        _react2.default.createElement('div', { dangerouslySetInnerHTML: { __html: location.content } }),
	        _react2.default.createElement(
	            'button',
	            {
	                className: 'location-navigate-to-list',
	                onClick: navigateToList,
	                type: 'button' },
	            'Go back to the locations'
	        )
	    );
	};

	exports.default = Location;

/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _reactRangeslider = __webpack_require__(511);

	var _reactRangeslider2 = _interopRequireDefault(_reactRangeslider);

	var _utilities = __webpack_require__(189);

	var _cache = __webpack_require__(187);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var AudioPlayer = function (_Component) {
	    _inherits(AudioPlayer, _Component);

	    function AudioPlayer(props, context) {
	        _classCallCheck(this, AudioPlayer);

	        var _this = _possibleConstructorReturn(this, (AudioPlayer.__proto__ || Object.getPrototypeOf(AudioPlayer)).call(this, props, context));

	        _this.audio = new Audio('/static/' + _this.props.src);

	        _this.state = {
	            isPlaying: false,
	            isMuted: false,
	            elapsedTime: 0
	        };

	        return _this;
	    }

	    _createClass(AudioPlayer, [{
	        key: 'play',
	        value: function play() {
	            this.audio.play();
	        }
	    }, {
	        key: 'pause',
	        value: function pause() {
	            this.audio.pause();
	        }
	    }, {
	        key: 'mute',
	        value: function mute() {
	            this.audio.muted = true;
	        }
	    }, {
	        key: 'unmute',
	        value: function unmute() {
	            this.audio.muted = false;
	        }
	    }, {
	        key: 'handleMuteUnmuteClick',
	        value: function handleMuteUnmuteClick() {
	            var isMuted = this.state.isMuted;

	            if (isMuted) {
	                this.unmute();
	            } else {
	                this.mute();
	            }

	            this.setState({
	                isMuted: !isMuted
	            });
	        }
	    }, {
	        key: 'handlePlayPauseClick',
	        value: function handlePlayPauseClick() {
	            var isPlaying = this.state.isPlaying;

	            if (isPlaying) {
	                this.pause();
	            } else {
	                this.play();
	            }

	            (0, _cache.setCurrentSound)(this.props.locationID, this.state.elapsedTime);

	            this.setState({
	                isPlaying: !isPlaying
	            });
	        }
	    }, {
	        key: 'handleSongPlaying',
	        value: function handleSongPlaying(elapsedTime) {
	            this.setState({
	                elapsedTime: elapsedTime
	            });

	            this.audio.currentTime = elapsedTime;
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this2 = this;

	            this.timerID = setInterval(function () {
	                return _this2.tick();
	            }, 1000);
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            clearInterval(this.timerID);
	        }
	    }, {
	        key: 'tick',
	        value: function tick() {
	            this.setState({
	                elapsedTime: this.audio.currentTime
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            // yer own
	            var audio = this.audio;

	            // props
	            var title = this.props.title;

	            // state

	            var _state = this.state,
	                isPlaying = _state.isPlaying,
	                isMuted = _state.isMuted,
	                elapsedTime = _state.elapsedTime;

	            // formatted to look nice

	            var currentTime = (0, _utilities.formatSeconds)(elapsedTime);
	            var total = (0, _utilities.formatSeconds)(audio.duration);

	            return _react2.default.createElement(
	                'div',
	                { className: 'audio-player' },
	                _react2.default.createElement(
	                    'p',
	                    null,
	                    title
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'audio-player-controls' },
	                    _react2.default.createElement(
	                        'button',
	                        { onClick: this.handlePlayPauseClick.bind(this), className: 'play-pause' },
	                        _react2.default.createElement('i', { className: isPlaying ? 'icon ion-ios-pause' : 'icon ion-ios-play' })
	                    ),
	                    _react2.default.createElement(
	                        'p',
	                        null,
	                        currentTime,
	                        ' / ',
	                        total
	                    ),
	                    _react2.default.createElement(_reactRangeslider2.default, {
	                        value: elapsedTime,
	                        max: audio.duration,
	                        orientation: 'horizontal',
	                        onChange: this.handleSongPlaying.bind(this)
	                    }),
	                    _react2.default.createElement(
	                        'button',
	                        { onClick: this.handleMuteUnmuteClick.bind(this), className: 'mute-unmute' },
	                        _react2.default.createElement('i', { className: isMuted ? 'icon ion-ios-volume-low' : 'icon ion-ios-volume-high' })
	                    )
	                )
	            );
	        }
	    }]);

	    return AudioPlayer;
	}(_react.Component);

	exports.default = AudioPlayer;

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Rangeslider = __webpack_require__(512);

	var _Rangeslider2 = _interopRequireDefault(_Rangeslider);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _Rangeslider2.default;

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _classnames = __webpack_require__(513);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _utils = __webpack_require__(514);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-debugger: "warn" */


	/**
	 * Predefined constants
	 * @type {Object}
	 */
	var constants = {
	  orientation: {
	    horizontal: {
	      dimension: 'width',
	      direction: 'left',
	      coordinate: 'x'
	    },
	    vertical: {
	      dimension: 'height',
	      direction: 'top',
	      coordinate: 'y'
	    }
	  }
	};

	var Slider = function (_Component) {
	  _inherits(Slider, _Component);

	  function Slider(props, context) {
	    _classCallCheck(this, Slider);

	    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, props, context));

	    _this.handleNoop = function (e) {
	      e.stopPropagation();
	      e.preventDefault();
	    };

	    _this.handleUpdate = function () {
	      var orientation = _this.props.orientation;

	      var dimension = (0, _utils.capitalize)(constants.orientation[orientation].dimension);
	      var sliderPos = _this.slider['offset' + dimension];
	      var handlePos = _this.handle['offset' + dimension];
	      _this.setState({
	        limit: sliderPos - handlePos,
	        grab: handlePos / 2
	      });
	    };

	    _this.handleStart = function () {
	      document.addEventListener('mousemove', _this.handleDrag);
	      document.addEventListener('mouseup', _this.handleEnd);
	    };

	    _this.handleDrag = function (e) {
	      _this.handleNoop(e);
	      var onChange = _this.props.onChange;

	      if (!onChange) return;

	      var value = _this.position(e);
	      onChange && onChange(value);
	    };

	    _this.handleEnd = function () {
	      document.removeEventListener('mousemove', _this.handleDrag);
	      document.removeEventListener('mouseup', _this.handleEnd);
	    };

	    _this.getPositionFromValue = function (value) {
	      var limit = _this.state.limit;
	      var _this$props = _this.props;
	      var min = _this$props.min;
	      var max = _this$props.max;

	      var diffMaxMin = max - min;
	      var diffValMin = value - min;
	      var percentage = diffValMin / diffMaxMin;
	      var pos = Math.round(percentage * limit);

	      return pos;
	    };

	    _this.getValueFromPosition = function (pos) {
	      var value = null;
	      var limit = _this.state.limit;
	      var _this$props2 = _this.props;
	      var orientation = _this$props2.orientation;
	      var min = _this$props2.min;
	      var max = _this$props2.max;
	      var step = _this$props2.step;

	      var percentage = (0, _utils.clamp)(pos, 0, limit) / (limit || 1);
	      var baseVal = step * Math.round(percentage * (max - min) / step);

	      if (orientation === 'horizontal') {
	        value = baseVal + min;
	      } else {
	        value = max - baseVal;
	      }

	      if (value >= max) value = max;
	      if (value <= min) value = min;

	      return value;
	    };

	    _this.position = function (e) {
	      var grab = _this.state.grab;
	      var orientation = _this.props.orientation;

	      var node = _this.slider;
	      var coordinateStyle = constants.orientation[orientation].coordinate;
	      var directionStyle = constants.orientation[orientation].direction;
	      var clientCoordinateStyle = 'client' + (0, _utils.capitalize)(coordinateStyle);
	      var coordinate = !e.touches ? e[clientCoordinateStyle] : e.touches[0][clientCoordinateStyle];
	      var direction = node.getBoundingClientRect()[directionStyle];

	      var pos = coordinate - direction - grab;
	      var value = _this.getValueFromPosition(pos);

	      return value;
	    };

	    _this.coordinates = function (pos) {
	      var fillPos = null;
	      var _this$state = _this.state;
	      var limit = _this$state.limit;
	      var grab = _this$state.grab;
	      var orientation = _this.props.orientation;

	      var value = _this.getValueFromPosition(pos);
	      var handlePos = _this.getPositionFromValue(value);
	      var sumHandleposGrab = orientation === 'horizontal' ? handlePos + grab : handlePos;

	      if (orientation === 'horizontal') {
	        fillPos = sumHandleposGrab;
	      } else {
	        fillPos = limit - sumHandleposGrab;
	      }

	      return {
	        fill: fillPos,
	        handle: handlePos
	      };
	    };

	    _this.state = {
	      limit: 0,
	      grab: 0
	    };
	    return _this;
	  }

	  _createClass(Slider, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      window.addEventListener('resize', this.handleUpdate);
	      this.handleUpdate();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      window.removeEventListener('resize', this.handleUpdate);
	    }

	    /**
	     * Prevent default event and bubbling
	     * @param  {Object} e - Event object
	     * @return {void}
	     */


	    /**
	     * Update slider state on change
	     * @return {void}
	     */


	    /**
	     * Attach event listeners to mousemove/mouseup events
	     * @return {void}
	     */


	    /**
	     * Handle drag/mousemove event
	     * @param  {Object} e - Event object
	     * @return {void}
	     */


	    /**
	     * Detach event listeners to mousemove/mouseup events
	     * @return {void}
	     */


	    /**
	     * Calculate position of slider based on its value
	     * @param  {number} value - Current value of slider
	     * @return {position} pos - Calculated position of slider based on value
	     */


	    /**
	     * Translate position of slider to slider value
	     * @param  {number} pos - Current position/coordinates of slider
	     * @return {number} value - Slider value
	     */


	    /**
	     * Calculate position of slider based on value
	     * @param  {Object} e - Event object
	     * @return {number} value - Slider value
	     */


	    /**
	     * Grab coordinates of slider
	     * @param  {Object} pos - Position object
	     * @return {Object} - Slider fill/handle coordinates
	     */

	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var _props = this.props;
	      var value = _props.value;
	      var orientation = _props.orientation;
	      var className = _props.className;

	      var dimension = constants.orientation[orientation].dimension;
	      var direction = constants.orientation[orientation].direction;
	      var position = this.getPositionFromValue(value);
	      var coords = this.coordinates(position);
	      var fillStyle = _defineProperty({}, dimension, coords.fill + 'px');
	      var handleStyle = _defineProperty({}, direction, coords.handle + 'px');

	      return _react2.default.createElement(
	        'div',
	        {
	          ref: function ref(s) {
	            _this2.slider = s;
	          },
	          className: (0, _classnames2.default)('rangeslider', 'rangeslider-' + orientation, className),
	          onMouseDown: this.handleDrag,
	          onTouchStart: this.handleDrag,
	          onTouchEnd: this.handleNoop
	        },
	        _react2.default.createElement('div', {
	          className: 'rangeslider__fill',
	          style: fillStyle
	        }),
	        _react2.default.createElement('div', {
	          ref: function ref(sh) {
	            _this2.handle = sh;
	          },
	          className: 'rangeslider__handle',
	          onMouseDown: this.handleStart,
	          onTouchEnd: this.handleNoop,
	          onTouchMove: this.handleDrag,
	          style: handleStyle
	        })
	      );
	    }
	  }]);

	  return Slider;
	}(_react.Component);

	Slider.propTypes = {
	  min: _react.PropTypes.number,
	  max: _react.PropTypes.number,
	  step: _react.PropTypes.number,
	  value: _react.PropTypes.number,
	  orientation: _react.PropTypes.string,
	  onChange: _react.PropTypes.func,
	  className: _react.PropTypes.string
	};
	Slider.defaultProps = {
	  min: 0,
	  max: 100,
	  step: 1,
	  value: 0,
	  orientation: 'horizontal'
	};
	exports.default = Slider;

/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 514 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.capitalize = capitalize;
	exports.clamp = clamp;
	/**
	 * Capitalize first letter of string
	 * @private
	 * @param  {string} - String
	 * @return {string} - String with first letter capitalized
	 */
	function capitalize(str) {
	  return str.charAt(0).toUpperCase() + str.substr(1);
	}

	/**
	 * Clamp position between a range
	 * @param  {number} - Value to be clamped
	 * @param  {number} - Minimum value in range
	 * @param  {number} - Maximum value in range
	 * @return {number} - Clamped value
	 */
	function clamp(value, min, max) {
	  return Math.min(Math.max(value, min), max);
	}

/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ErrorView = function ErrorView(_ref) {
	    var msg = _ref.msg;

	    return _react2.default.createElement(
	        'p',
	        null,
	        msg
	    );
	};

	exports.default = ErrorView;

/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.locationMap = undefined;

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(39);

	var _utilities = __webpack_require__(189);

	var _app = __webpack_require__(185);

	var _app2 = _interopRequireDefault(_app);

	var _navigation = __webpack_require__(191);

	var _navigation2 = _interopRequireDefault(_navigation);

	var _locationMap = __webpack_require__(517);

	var _locationMap2 = _interopRequireDefault(_locationMap);

	var _errorView = __webpack_require__(515);

	var _errorView2 = _interopRequireDefault(_errorView);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Before
	function before(state) {
	    return function (done) {
	        (0, _reactDom.unmountComponentAtNode)(state.reactMountNode);
	        state.argonMountNode.style.display = 'none';
	        state.documentRootNode.style.background = 'white';
	        // Setup location data then the user data
	        (0, _utilities.setupLocationData)(state, function () {
	            return (0, _utilities.setupUserData)(state, done);
	        });
	    };
	}

	// After


	function after() {
	    return function () {};
	}

	// Location map route
	function route(state) {
	    return function (params) {
	        console.log('Location map:', state);

	        var id = params.id;

	        // NOTE: weak equality check due to strings

	        var location = state.locations.filter(function (loc) {
	            return loc.meta.id == id;
	        }).reduce(function (_, l) {
	            return l;
	        }, {});

	        if (!location.hasOwnProperty('meta')) {
	            return (0, _reactDom.render)(_react2.default.createElement(
	                _app2.default,
	                { state: state },
	                _react2.default.createElement(_navigation2.default, {
	                    backUrl: '/locations',
	                    title: 'Unknown location' }),
	                _react2.default.createElement(_errorView2.default, { msg: 'The location doesnt exist' })
	            ), state.reactMountNode);
	        }

	        (0, _reactDom.render)(_react2.default.createElement(
	            _app2.default,
	            { state: state },
	            _react2.default.createElement(_navigation2.default, {
	                backUrl: state.prevRoute || '/locations',
	                distance: true,
	                location: location,
	                title: 'Location map' }),
	            _react2.default.createElement(_locationMap2.default, {
	                location: location })
	        ), state.reactMountNode);
	    };
	}

	// Export the route handlers
	var locationMap = exports.locationMap = {
	    urls: ['/locations/:id/map'],
	    route: route,
	    hooks: function hooks(state) {
	        return { before: before(state), after: after(state) };
	    }
	};

/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _mapStyle = __webpack_require__(196);

	var _reactGoogleMaps = __webpack_require__(197);

	var _utilities = __webpack_require__(189);

	var _cache = __webpack_require__(187);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	/* global google */


	var Map = (0, _reactGoogleMaps.withGoogleMap)(function (_ref) {
	    var location = _ref.location,
	        userPosition = _ref.userPosition;

	    var center = {
	        lat: location.meta.latitude,
	        lng: location.meta.longitude
	    };

	    var userMarkerOpts = {
	        clickable: false,
	        cursor: 'pointer',
	        draggable: false,
	        flat: true,
	        optimized: false,
	        position: {
	            lat: userPosition ? userPosition.lat : 0,
	            lng: userPosition ? userPosition.lng : 0,
	            enableHighAccuracy: true,
	            maximumAge: 1000
	        },
	        title: 'Current location',
	        zIndex: 2,
	        icon: {
	            url: '/static/gpsloc.png',
	            size: new google.maps.Size(42, 42),
	            scaledSize: new google.maps.Size(21, 21),
	            origin: new google.maps.Point(0, 0),
	            anchor: new google.maps.Point(8, 8)
	        },
	        key: 'User location'
	    };

	    return _react2.default.createElement(
	        _reactGoogleMaps.GoogleMap,
	        {
	            defaultZoom: 15,
	            defaultCenter: center,
	            defaultOptions: {
	                styles: _mapStyle.mapStyles,
	                mapTypeControl: false,
	                streetViewControl: false,
	                rotateControl: false,
	                fullscreenControl: false,
	                scaleControl: false
	            } },
	        _react2.default.createElement(_reactGoogleMaps.Marker, userMarkerOpts),
	        _react2.default.createElement(_reactGoogleMaps.Circle, {
	            center: center,
	            radius: 80,
	            options: {
	                fillColor: 'red',
	                fillOpacity: 0.2,
	                strokeColor: 'red',
	                strokeOpacity: 0.5,
	                strokeWidth: 1
	            } }),
	        _react2.default.createElement(_reactGoogleMaps.Marker, {
	            position: center,
	            label: String(location.meta.id),
	            key: location.meta.name })
	    );
	});

	var LocationMap = function (_Component) {
	    _inherits(LocationMap, _Component);

	    function LocationMap() {
	        _classCallCheck(this, LocationMap);

	        return _possibleConstructorReturn(this, (LocationMap.__proto__ || Object.getPrototypeOf(LocationMap)).apply(this, arguments));
	    }

	    _createClass(LocationMap, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                state = _props.state,
	                location = _props.location,
	                userPosition = _props.userPosition;


	            var handleClick = function handleClick() {
	                (0, _cache.locationVisited)(location.meta.id);
	                state.navigate('/locations/' + location.meta.id + '/camera');
	            };

	            var div = _react2.default.createElement('div', { style: { height: '100%' } });

	            var hasVisitedLocation = state.userData.locations['location_' + location.meta.id].visited;

	            var activeButton = _react2.default.createElement(
	                'button',
	                {
	                    className: 'location-map-button',
	                    onClick: handleClick,
	                    type: 'button' },
	                'Go to AR mode'
	            );

	            var disabledButton = _react2.default.createElement(
	                'button',
	                {
	                    className: 'location-map-button disabled',
	                    type: 'button' },
	                'Go to AR mode'
	            );

	            if (userPosition === null) {
	                return _react2.default.createElement(
	                    'div',
	                    { className: 'location-map' },
	                    _react2.default.createElement(Map, {
	                        location: location,
	                        containerElement: div,
	                        mapElement: div }),
	                    disabledButton
	                );
	            }

	            var distance = (0, _utilities.calculateDistance)(userPosition, {
	                lat: location.meta.latitude,
	                lng: location.meta.longitude
	            });

	            // TODO fix distance
	            return _react2.default.createElement(
	                'div',
	                { className: 'location-map' },
	                _react2.default.createElement(Map, {
	                    location: location,
	                    userPosition: userPosition,
	                    containerElement: div,
	                    mapElement: div }),
	                hasVisitedLocation ? activeButton : distance < 100000 ? activeButton : disabledButton
	            );
	        }
	    }]);

	    return LocationMap;
	}(_react.Component);

	exports.default = LocationMap;

/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.locationCamera = undefined;

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(39);

	var _app = __webpack_require__(185);

	var _app2 = _interopRequireDefault(_app);

	var _navigation = __webpack_require__(191);

	var _navigation2 = _interopRequireDefault(_navigation);

	var _locationCamera = __webpack_require__(519);

	var _locationCamera2 = _interopRequireDefault(_locationCamera);

	var _errorView = __webpack_require__(515);

	var _errorView2 = _interopRequireDefault(_errorView);

	var _utilities = __webpack_require__(189);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Before
	function before(state) {
	    return function (done) {
	        (0, _reactDom.unmountComponentAtNode)(state.reactMountNode);
	        state.documentRootNode.style.background = 'transparent';
	        // Setup location data then the user data
	        (0, _utilities.setupLocationData)(state, function () {
	            return (0, _utilities.setupUserData)(state, done);
	        });
	    };
	}

	// After


	function after() {
	    return function () {};
	}

	// Location camera route
	function route(state) {
	    return function (params) {
	        console.log('Location camera', state, params);

	        var id = params.id;

	        // NOTE: weak equality check due to strings

	        var location = state.locations.filter(function (loc) {
	            return loc.meta.id == id;
	        }).reduce(function (_, l) {
	            return l;
	        }, {});

	        if (!location.hasOwnProperty('meta')) {
	            return (0, _reactDom.render)(_react2.default.createElement(
	                _app2.default,
	                { state: state },
	                _react2.default.createElement(_navigation2.default, {
	                    backUrl: '/locations',
	                    title: 'Unknown location' }),
	                _react2.default.createElement(_errorView2.default, { msg: 'The location doesnt exist' })
	            ), state.reactMountNode);
	        }

	        var hasVisitedLocation = state.userData.locations['location_' + location.meta.id].visited;

	        if (!hasVisitedLocation) {
	            return (0, _reactDom.render)(_react2.default.createElement(
	                _app2.default,
	                { state: state },
	                _react2.default.createElement(_navigation2.default, {
	                    backUrl: '/locations/' + id + '/map',
	                    distance: true,
	                    location: location,
	                    title: 'Location ' + location.meta.position }),
	                _react2.default.createElement(_errorView2.default, { msg: 'You need to visit the location first!' })
	            ), state.reactMountNode);
	        }

	        (0, _reactDom.render)(_react2.default.createElement(
	            _app2.default,
	            { state: state },
	            _react2.default.createElement(_navigation2.default, {
	                backUrl: '/locations/' + id + '/map',
	                distance: true,
	                location: location,
	                title: 'Location ' + location.meta.position }),
	            _react2.default.createElement(_locationCamera2.default, {
	                location: location })
	        ), state.reactMountNode);
	    };
	}

	// Export the route handlers
	var locationCamera = exports.locationCamera = {
	    urls: ['/locations/:id/camera'],
	    route: route,
	    hooks: function hooks(state) {
	        return { before: before(state), after: after(state) };
	    }
	};

/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(9);

	var _react2 = _interopRequireDefault(_react);

	var _cache = __webpack_require__(187);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// TODO should only be able to unlock if the user has "scanned" the object

	var LocationCamera = function (_Component) {
	    _inherits(LocationCamera, _Component);

	    function LocationCamera(props) {
	        _classCallCheck(this, LocationCamera);

	        return _possibleConstructorReturn(this, (LocationCamera.__proto__ || Object.getPrototypeOf(LocationCamera)).call(this, props));
	    }

	    _createClass(LocationCamera, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                state = _props.state,
	                location = _props.location;


	            var handleClick = function handleClick() {
	                (0, _cache.locationUnlocked)(location.meta.id);
	                state.navigate('/locations/' + location.meta.id + '/story');
	            };

	            // const hasUnlockedLocation: bool = state.userData.locations[`location_${location.meta.id}`].unlocked
	            // TODO fix later
	            var hasUnlockedLocation = true;

	            var activeButton = _react2.default.createElement(
	                'button',
	                {
	                    className: 'location-camera-button',
	                    onClick: handleClick,
	                    type: 'button' },
	                'Unlock the story'
	            );

	            var disabledButton = _react2.default.createElement(
	                'button',
	                {
	                    className: 'location-camera-button disabled',
	                    type: 'button' },
	                'Find the circle'
	            );

	            return _react2.default.createElement(
	                'div',
	                { className: 'location-camera' },
	                hasUnlockedLocation ? activeButton : disabledButton
	            );
	        }
	    }]);

	    return LocationCamera;
	}(_react.Component);

	exports.default = LocationCamera;

/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.CSS3DArgonRenderer = exports.CSS3DSprite = exports.CSS3DObject = exports.CSS3DArgonHUD = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	/**
	* @author mrdoob / http://mrdoob.com/
	* @author blairmacintyre / http://blairmacintyre.me/
	*
	* Usage:
	* ======
	* 
	* import {
	*     CSS3DArgonHUD,
	*     CSS3DArgonRenderer,
	*     CSS3DObject,
	*     CSS3DSprite
	* } from './path/to/CSS3DArgon'
	*
	**/

	var _three = __webpack_require__(5);

	var THREE = _interopRequireWildcard(_three);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CSS3DArgonHUD = exports.CSS3DArgonHUD = function () {
	    function CSS3DArgonHUD() {
	        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        _classCallCheck(this, CSS3DArgonHUD);

	        this.viewWidth = [];
	        this.viewHeight = [];

	        this.domElement = props.domElement || document.createElement('div');
	        this.domElement.style.pointerEvents = props.pointerEvents || 'auto';

	        this.hudElements = [];

	        this.hudElements[0] = this.createHudElement();
	        this.domElement.appendChild(this.hudElements[0]);

	        this.hudElements[1] = this.createHudElement();
	        this.domElement.appendChild(this.hudElements[1]);
	    }

	    _createClass(CSS3DArgonHUD, [{
	        key: 'createHudElement',
	        value: function createHudElement() {
	            var div = document.createElement('div');
	            // Starts off as hidden
	            div.style.display = 'none';
	            div.style.position = 'absolute';
	            div.style.overflow = 'hidden';
	            return div;
	        }
	    }, {
	        key: 'appendChild',
	        value: function appendChild(firstElement, secondElement) {
	            secondElement = secondElement || firstElement.cloneNode(true);
	            this.hudElements[0].appendChild(firstElement);
	            this.hudElements[1].appendChild(secondElement);
	        }
	    }, {
	        key: 'setViewport',
	        value: function setViewport(x, y, width, height, side) {
	            this.hudElements[side].style.display = 'inline-block';
	            this.hudElements[side].style.top = y + 'px';
	            this.hudElements[side].style.left = x + 'px';
	            this.hudElements[side].style.width = width + 'px';
	            this.hudElements[side].style.height = height + 'px';

	            this.viewWidth[side] = width;
	            this.viewHeight[side] = height;
	        }
	    }, {
	        key: 'showViewport',
	        value: function showViewport(side) {
	            this.hudElements[side].style.display = 'inline-block';
	        }
	    }, {
	        key: 'hideViewport',
	        value: function hideViewport(side) {
	            this.hudElements[side].style.display = 'none';
	        }
	    }, {
	        key: 'setSize',
	        value: function setSize(width, height) {
	            // Size of overall DOM
	            this.domElement.style.width = width + 'px';
	            this.domElement.style.height = height + 'px';
	            // NOTE: Do not reset the subviews
	            // Default viewports for left and right eyes
	            this.hudElements[0].style.display = 'none';
	            this.hudElements[1].style.display = 'none';
	        }
	    }, {
	        key: 'render',
	        value: function render(side) {
	            this.hudElements[side].style.display = 'inline-block';
	        }
	    }]);

	    return CSS3DArgonHUD;
	}();

	var CSS3DObject = exports.CSS3DObject = function (_THREE$Object3D) {
	    _inherits(CSS3DObject, _THREE$Object3D);

	    function CSS3DObject(element) {
	        _classCallCheck(this, CSS3DObject);

	        var _this = _possibleConstructorReturn(this, (CSS3DObject.__proto__ || Object.getPrototypeOf(CSS3DObject)).call(this));

	        _this.elements = [];

	        if (Array.isArray(element)) {
	            _this.elements = element.map(function (e) {
	                return e;
	            });
	        } else {
	            _this.elements[0] = element;
	            _this.elements[1] = element.cloneNode(true);
	        }

	        _this.elements.forEach(function (el) {
	            return el.style.position = 'absolute';
	        });

	        _this.addEventListener('removed', function (e) {
	            _this.elements.filter(function (el) {
	                return el.parentNode !== null;
	            }).forEach(function (el) {
	                // remove node
	                el.parentNode.removeChild(el);
	                // remove all children 
	                for (var i = 0; i < el.children.length; i++) {
	                    el.children[i].dispatchEvent(e);
	                }
	            });
	        });
	        return _this;
	    }

	    return CSS3DObject;
	}(THREE.Object3D);

	var CSS3DSprite = exports.CSS3DSprite = function (_CSS3DObject) {
	    _inherits(CSS3DSprite, _CSS3DObject);

	    function CSS3DSprite(element) {
	        _classCallCheck(this, CSS3DSprite);

	        return _possibleConstructorReturn(this, (CSS3DSprite.__proto__ || Object.getPrototypeOf(CSS3DSprite)).call(this, element));
	    }

	    return CSS3DSprite;
	}(CSS3DObject);

	// based on CSS3DStereoRenderer in threejs.org github repo


	var CSS3DArgonRenderer = exports.CSS3DArgonRenderer = function () {
	    function CSS3DArgonRenderer() {
	        _classCallCheck(this, CSS3DArgonRenderer);

	        // NOTE not used?
	        // this.cameras = []
	        this.width = 0;
	        this.height = 0;
	        this.viewWidth = [];
	        this.viewHeight = [];

	        this.tempMatrix = new THREE.Matrix4();
	        this.tempMatrix2 = new THREE.Matrix4();

	        this.cache = {
	            camera: {
	                fov: [],
	                style: []
	            },
	            objects: []
	        };

	        this.domElement = document.createElement('div');
	        this.domElement.style.pointerEvents = 'auto';

	        this.domElements = [];
	        this.domElements[0] = this.createDOMElement(true);
	        this.domElements[1] = this.createDOMElement(true);

	        this.cameraElements = [];
	        this.cameraElements[0] = this.createDOMElement();
	        this.cameraElements[1] = this.createDOMElement();

	        this.domElement.appendChild(this.domElements[0]);
	        this.domElements[0].appendChild(this.cameraElements[0]);
	        this.domElement.appendChild(this.domElements[1]);
	        this.domElements[1].appendChild(this.cameraElements[1]);

	        this.oldProjection = new THREE.Matrix4();
	        this.oldFOV = 0;
	        this.eps = 0.0000001;
	        this.projInv = new THREE.Matrix4();
	    }

	    _createClass(CSS3DArgonRenderer, [{
	        key: 'createDOMElement',
	        value: function createDOMElement() {
	            var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	            var div = document.createElement('div');

	            if (hidden) {
	                div.style.display = 'none';
	                div.style.overflow = 'hidden';
	                div.style.position = 'absolute';
	                div.style.pointerEvents = 'auto';
	            }

	            // NOTE deprecated?
	            // div.style.WebkitTransformStyle = 'preserve-3d'
	            // div.style.MozTransformStyle = 'preserve-3d'
	            // div.style.oTransformStyle = 'preserve-3d'
	            div.style.transformStyle = 'preserve-3d';
	            return div;
	        }
	    }, {
	        key: 'setClearColor',
	        value: function setClearColor() {}
	    }, {
	        key: 'setViewport',
	        value: function setViewport(x, y, width, height) {
	            var side = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

	            this.domElements[side].style.display = 'inline-block';
	            this.domElements[side].style.top = y + 'px';
	            this.domElements[side].style.left = x + 'px';
	            this.domElements[side].style.width = width + 'px';
	            this.domElements[side].style.height = height + 'px';

	            this.cameraElements[side].style.width = width + 'px';
	            this.cameraElements[side].style.height = height + 'px';

	            this.viewWidth[side] = width;
	            this.viewHeight[side] = height;
	        }
	    }, {
	        key: 'showViewport',
	        value: function showViewport() {
	            var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	            this.domElements[side].style.display = 'inline-block';
	        }
	    }, {
	        key: 'hideViewport',
	        value: function hideViewport() {
	            var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	            this.domElements[side].style.display = 'none';
	        }
	    }, {
	        key: 'setSize',
	        value: function setSize(width, height) {
	            this.domElement.style.width = width + 'px';
	            this.domElement.style.height = height + 'px';

	            var w = width / 2;
	            var h = height;

	            // Do not reset the subviews
	            // Hide elements after setSize
	            this.domElements[0].style.display = 'none';
	            this.domElements[0].style.top = 0 + 'px';
	            this.domElements[0].style.left = 0 + 'px';
	            this.domElements[0].style.width = w + 'px';
	            this.domElements[0].style.height = h + 'px';

	            this.cameraElements[0].style.width = w + 'px';
	            this.cameraElements[0].style.height = h + 'px';

	            this.domElements[1].style.display = 'none';
	            this.domElements[1].style.top = 0 + 'px';
	            this.domElements[1].style.left = w + 'px';
	            this.domElements[1].style.width = w + 'px';
	            this.domElements[1].style.height = h + 'px';

	            this.cameraElements[1].style.width = w + 'px';
	            this.cameraElements[1].style.height = h + 'px';
	        }
	    }, {
	        key: 'toFixed',
	        value: function toFixed(value) {
	            var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	            var pow = Math.pow(10, precision);
	            return String(Math.round(value * pow) / pow);
	        }
	    }, {
	        key: 'epsilon',
	        value: function epsilon(value) {
	            return this.toFixed(value, 6);
	        }
	    }, {
	        key: 'getCameraCSSMatrix',
	        value: function getCameraCSSMatrix(m) {
	            var matrix = this.tempMatrix2;
	            matrix.copy(m);
	            matrix.multiplyScalar(100);

	            // We dont want the lower corner to be scaled, just the rest
	            matrix.elements[15] = m.elements[15];

	            var elements = matrix.elements;

	            var params = [this.epsilon(elements[0]), this.epsilon(-elements[1]), this.epsilon(elements[2]), this.epsilon(elements[3]), this.epsilon(elements[4]), this.epsilon(-elements[5]), this.epsilon(elements[6]), this.epsilon(elements[7]), this.epsilon(elements[8]), this.epsilon(-elements[9]), this.epsilon(elements[10]), this.epsilon(elements[11]), this.epsilon(elements[12]), this.epsilon(-elements[13]), this.epsilon(elements[14]), this.epsilon(elements[15])].join(',');

	            return 'matrix3d(' + params + ')';
	        }
	    }, {
	        key: 'getObjectCSSMatrix',
	        value: function getObjectCSSMatrix(m) {
	            var matrix = this.tempMatrix2;
	            matrix.copy(m);
	            matrix.multiplyScalar(100);

	            // We dont want the lower corner to be scaled, just the rest
	            matrix.elements[15] = m.elements[15];

	            var elements = matrix.elements;

	            var params = [this.epsilon(elements[0]), this.epsilon(elements[1]), this.epsilon(elements[2]), this.epsilon(elements[3]), this.epsilon(-elements[4]), this.epsilon(-elements[5]), this.epsilon(-elements[6]), this.epsilon(-elements[7]), this.epsilon(elements[8]), this.epsilon(elements[9]), this.epsilon(elements[10]), this.epsilon(elements[11]), this.epsilon(elements[12]), this.epsilon(elements[13]), this.epsilon(elements[14]), this.epsilon(elements[15])].join(',');

	            return 'translate3d(-50%, -50%, 0) matrix3d(' + params + ')';
	        }
	    }, {
	        key: 'renderObject',
	        value: function renderObject(object, camera, cameraElement, side, visible) {
	            visible = visible && object.visible;

	            if (object instanceof CSS3DObject) {
	                var element = object.elements[side];

	                if (visible === false) {
	                    element.style.display = 'none';
	                } else {
	                    element.style.display = 'inline-block';
	                }

	                var style = undefined;

	                if (object instanceof CSS3DSprite) {
	                    // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/
	                    var matrix = this.tempMatrix;
	                    matrix.copy(camera.matrixWorldInverse);
	                    matrix.transpose();
	                    matrix.copyPosition(object.matrixWorld);
	                    matrix.scale(object.scale);

	                    matrix.elements[3] = 0;
	                    matrix.elements[7] = 0;
	                    matrix.elements[11] = 0;
	                    matrix.elements[15] = 1;

	                    style = this.getObjectCSSMatrix(matrix);
	                } else {
	                    style = this.getObjectCSSMatrix(object.matrixWorld);
	                }

	                // NOTE deprecated?
	                // element.style.WebkitTransform = style
	                // element.style.MozTransform = style
	                // element.style.oTransform = style
	                element.style.transform = style;

	                if (element.parentNode !== cameraElement) {
	                    cameraElement.appendChild(element);
	                }
	            }

	            // we can't short circuit this, because we have to
	            // make sure we clear all the children of this 
	            // if (!object.visible) return
	            for (var i = 0, len = object.children.length; i < len; i++) {
	                this.renderObject(object.children[i], camera, cameraElement, side, visible);
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render(scene, camera, side) {
	            scene.updateMatrixWorld();

	            if (camera.parent === null) {
	                camera.updateMatrixWorld();
	            }

	            var fov = this.toFixed(0.5 / Math.tan(THREE.Math.degToRad(camera.fov * 0.5)) * this.viewHeight[side], 2);

	            this.fovStyle = fov;

	            if (this.cache.camera.fov[side] !== fov) {
	                // NOTE deprecated?
	                // this.domElements[side].style.WebkitPerspective = `${fov}px`
	                // this.domElements[side].style.MozPerspective = `${fov}px`
	                // this.domElements[side].style.oPerspective = `${fov}px`
	                this.domElements[side].style.perspective = fov + 'px';
	                this.cache.camera.fov[side] = fov;
	            }

	            this.domElements[side].style.display = 'inline-block';

	            camera.matrixWorldInverse.getInverse(camera.matrixWorld);

	            var style = 'translate3d(0, 0, ' + fov + 'px)\n            ' + this.getCameraCSSMatrix(camera.matrixWorldInverse) + '\n            translate3d(\n                ' + this.toFixed(this.viewWidth[side] / 2, 4) + 'px,\n                ' + this.toFixed(this.viewHeight[side] / 2, 4) + 'px, 0)';

	            if (this.cache.camera.style[side] !== style) {
	                // NOTE deprecated?
	                // this.cameraElements[side].style.WebkitTransform = style
	                // this.cameraElements[side].style.MozTransform = style
	                // this.cameraElements[side].style.oTransform = style
	                this.cameraElements[side].style.transform = style;
	                this.cache.camera.style[side] = style;
	            }

	            this.renderObject(scene, camera, this.cameraElements[side], side, scene.visible);
	        }
	    }, {
	        key: 'epsilonEquals',
	        value: function epsilonEquals(matrix) {
	            var te = this.oldProjection.elements;
	            var me = matrix.elements;

	            for (var i = 0; i < 16; i++) {
	                if (Math.abs(te[i] - me[i]) > this.eps) {
	                    this.oldProjection.copy(matrix);
	                    return false;
	                }
	            }

	            return true;
	        }
	    }, {
	        key: 'applyProjection',
	        value: function applyProjection(x, y, matrix) {
	            var e = matrix.elements;
	            // Any depth will do, just use the middle of the canonical depth space
	            var z = 0.5;
	            // For the perspective divide
	            var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
	            // Do the minimal math
	            var nx = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
	            var ny = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
	            var nz = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;

	            var len = Math.sqrt(nx * nx + ny * ny + nz * nz);
	            return [nx / len, ny / len, nz / len];
	        }
	    }, {
	        key: 'angleBetween',
	        value: function angleBetween(v1, v2) {
	            // v1 and v2 are normalized above
	            var dot = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
	            // Clamp, to handle numerical problems
	            var theta = Math.max(-1, Math.min(1, dot));

	            return Math.acos(theta);
	        }
	    }, {
	        key: 'updateCameraFOVFromProjection',
	        value: function updateCameraFOVFromProjection(camera) {
	            var projection = camera.projectionMatrix;

	            // If its different from what it was, update FOV
	            if (!this.epsilonEquals(projection)) {
	                // console.log(`get FOV: projection={${projection[0]}, ${projection[1]}, ...}`)
	                this.projInv.getInverse(camera.projectionMatrix);

	                var v1 = this.applyProjection(0, 1, this.projInv);
	                var v2 = this.applyProjection(0, -1, this.projInv);
	                // console.log(`get FOV: v1={${v1[0]}, ${v1[1]}, ${v1[2]}}`)
	                // console.log(`get FOV: v2={${v2[0]}, ${v2[1]}, ${v2[2]}}`)

	                this.oldFOV = this.angleBetween(v1, v2) * 180 / Math.PI;
	                camera.fov = this.oldFOV;
	            }
	        }
	    }]);

	    return CSS3DArgonRenderer;
	}();

/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.setupArgon = setupArgon;
	exports.getDistanceFromUser = getDistanceFromUser;
	exports.updateUserAndLocationPosition = updateUserAndLocationPosition;

	var _argon = __webpack_require__(1);

	var Argon = _interopRequireWildcard(_argon);

	var _utilities = __webpack_require__(189);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// Initialize stuff for argon
	function setupArgon(state) {
	    state.app.context.setDefaultReferenceFrame(state.app.context.localOriginEastUpSouth);
	    state.scene.add(state.camera);
	    state.scene.add(state.userLocation);

	    // set pixel ratio (ex "2" for retina screens etc)
	    state.renderer.setPixelRatio(window.devicePixelRatio);

	    // append renderers to our app view
	    state.app.view.element.appendChild(state.renderer.domElement);
	    state.app.view.element.appendChild(state.cssRenderer.domElement);
	    state.app.view.element.appendChild(state.hud.domElement);

	    return state;
	}

	// Calculate distance between two 3D objects (THREE)
	function getDistanceFromUser(user, location) {
	    var userPos = user.getWorldPosition();
	    var locationPos = location.locationObject.getWorldPosition();
	    var distance = userPos.distanceTo(locationPos);
	    return (0, _utilities.toFixed)(distance, 2);
	}

	// Handles the update of user and _one_ location position
	function updateUserAndLocationPosition(state, id, cb) {
	    var app = state.app,
	        scene = state.scene,
	        userLocation = state.userLocation,
	        locations = state.locations;


	    return function (frame) {
	        // Update user position
	        var userPose = app.context.getEntityPose(app.context.user);

	        if (!(userPose.poseStatus & Argon.PoseStatus.KNOWN)) {
	            return;
	        }

	        userLocation.position.copy(userPose.position);

	        // Update position for all locations
	        locations.filter(function (loc) {
	            return loc.meta.id == id;
	        }).forEach(function (location) {
	            // Initialize location for Argon as a reference frame
	            if (!location.initialized) {
	                if (Argon.convertEntityReferenceFrame(location.geoEntity, frame.time, Argon.Cesium.ReferenceFrame.FIXED)) {
	                    location.initialized = true;
	                    scene.add(location.geoObject);
	                }
	            }

	            // Update geo position
	            var locationPose = app.context.getEntityPose(location.geoEntity);
	            location.geoObject.position.copy(locationPose);
	            location.geoObject.quaternion.copy(locationPose);

	            cb(getDistanceFromUser(userLocation, location));
	        });
	    };
	}

/***/ }
/******/ ]);